// CodeMirror is the only global var we claim
window.CodeMirror = (function() {
  "use strict";

  // BROWSER SNIFFING

  // Crude, but necessary to handle a number of hard-to-feature-detect
  // bugs and behavior differences.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);

  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version) opera_version = Number(opera_version[1]);
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || (ie && !ie_lt9);

  // Optimize some code when these features are not used
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // CONSTRUCTOR

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
      options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);

    var docStart = typeof options.value == "string" ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {keyMaps: [],
                  overlays: [],
                  modeGen: 0,
                  overwrite: false, focused: false,
                  suppressEdits: false, pasteIncoming: false,
                  draggingText: false,
                  highlight: new Delayed()};

    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }
    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);
    else onBlur(this);

    operation(this, function() {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    })();
  }

  // DISPLAY CONSTRUCTOR

  function makeDisplay(place, docStart) {
    var d = {};

    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // if border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The actual fake scrollbars.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // DIVs containing the selection and the actual code
    d.lineDiv = elt("div", null, "CodeMirror-code");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    // Blinky cursor, and element used to ensure cursor fits at the end of a line
    d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
    // Used to measure text size
    d.measure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],
                         null, "position: relative; outline: none");
    // Moved around its parent to cover visible view
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the text, causes scrolling
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Provides scrolling
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    // Work around IE7 z-index bug
    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);

    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

    // Current visible range (may be bigger than the view window).
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling widget is added. As
    // an optimization, widget aligning is skipped when d is false.
    d.alignWidgets = false;
    // Flag that indicates whether we currently expect input to appear
    // (after some event like 'keypress' or 'input') and are polling
    // intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;

    // Tracks when resetInput has punted to just putting a short
    // string instead of the (large) selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    return d;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += " CodeMirror-wrap";
      cm.display.sizer.style.minWidth = "";
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
    cm.state.disableInput = map.disableInput;
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
  }

  function lineLength(doc, line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == "CodeMirror-linenumbers") {
        if (options.lineNumbers) found = true;
        else options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push("CodeMirror-linenumbers");
  }

  // SCROLLBARS

  // Re-synchronize the fake scrollbars with the actual size of the
  // content. Optionally force a scrollTop.
  function updateScrollbars(cm) {
    var d = cm.display, docHeight = cm.doc.height;
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);
    var needsV = scrollHeight > (d.scroller.clientHeight + 1);
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarV.firstChild.style.height =
        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";
    } else d.scrollbarV.style.display = "";
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";
    } else d.scrollbarH.style.display = "";
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
  }

  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == "number") top = viewPort;
    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};
  }

  // LINE NUMBERS

  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + "px";
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }

  // DISPLAY DRAWING

  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (!updateDisplayInner(cm, changes, visible)) break;
      updated = true;
      updateSelection(cm);
      updateScrollbars(cm);

      // Clip forced viewport to actual scrollable area
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,
                            typeof viewPort == "number" ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }

    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
    }
    return updated;
  }

  // Uses a set of changes plus the current scroll position to
  // determine which DOM updates have to be made, and makes the
  // updates.
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (changes.length == 0 &&
        visible.from > display.showingFrom && visible.to < display.showingTo)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      changes = [{from: doc.first, to: doc.first + doc.size}];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

    // Used to determine which lines need their line numbers updated
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }

    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
    }

    // Create a range of theoretically intact lines, and punch holes
    // in that using the change info.
    var intact = [{from: Math.max(display.showingFrom, doc.first),
                   to: Math.min(display.showingTo, end)}];
    if (intact[0].from >= intact[0].to) intact = [];
    else intact = computeIntact(intact, changes);
    // When merged lines are present, we might have to reduce the
    // intact ranges because changes in continued fragments of the
    // intact lines do require the lines to be redrawn.
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from) range.to = newTo;
          else { intact.splice(i--, 1); break; }
        }
      }

    // Clip off the parts that won't be visible
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from) range.from = from;
      if (range.to > to) range.to = to;
      if (range.from >= range.to) intact.splice(i--, 1);
      else intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function(a, b) {return a.from - b.from;});

    // Avoid crashing on IE's "unspecified error" when in iframes
    try {
      var focused = document.activeElement;
    } catch(e) {}
    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = "";
    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();

    var different = from != display.showingFrom || to != display.showingTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    // This is just a bogus formula that detects when the editor is
    // resized or the font size changes.
    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }
    display.showingFrom = from; display.showingTo = to;

    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
      if (ie_lt8) {
        var bot = node.offsetTop + node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = getRect(node);
        height = box.bottom - box.top;
      }
      var diff = node.lineObj.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(node.lineObj, height);
        var widgets = node.lineObj.widgets;
        if (widgets) for (var i = 0; i < widgets.length; ++i)
          widgets[i].height = widgets[i].node.offsetHeight;
      }
    }
    updateViewOffset(cm);

    return true;
  }

  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    // Position the mover div to align with the current virtual scroll position
    cm.display.mover.style.top = off + "px";
  }

  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({from: range.from + diff, to: range.to + diff});
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({from: range.from, to: change.from});
          if (change.to < range.to)
            intact2.push({from: change.to + diff, to: range.to + diff});
        }
      }
      intact = intact2;
    }
    return intact;
  }

  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function(line) {
      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0) updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {
          var w = line.widgets[i];
          if (w.showIfHidden) {
            var prev = cur.previousSibling;
            if (/pre/i.test(prev.nodeName)) {
              var wrap = elt("div", null, null, "position: relative");
              prev.parentNode.replaceChild(wrap, prev);
              wrap.appendChild(prev);
              prev = wrap;
            }
            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
            if (!w.handleMouseEvents) wnode.ignoreEvents = true;
            positionLineWidget(w, wnode, prev, dims);
          }
        }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        // This line is intact. Skip to the actual node. Update its
        // line number if needed.
        while (cur.lineObj != line) cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        // For lines with widgets, make an attempt to find and reuse
        // the existing element, so that widgets aren't needlessly
        // removed and re-inserted into the dom
        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }
        // This line needs to be generated.
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse) cur = rm(cur);
          cur = cur.nextSibling;
        }

        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur) cur = rm(cur);
  }

  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;

    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;

    // Lines with gutter elements, widgets or a background class need
    // to be wrapped again, and have the extra elements added to the
    // wrapper div

    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0, insertBefore = null;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0; i < line.widgets.length; ++i) {
            var widget = line.widgets[i];
            if (widget.node == n.firstChild) {
              if (!widget.above && !insertBefore) insertBefore = n;
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              break;
            }
          }
          if (i == line.widgets.length) { isOk = false; break; }
        }
      }
      reuse.insertBefore(lineElement, insertBefore);
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || "";
      }
    }
    if (!wrap) {
      wrap = elt("div", null, line.wrapClass, "position: relative");
      wrap.appendChild(lineElement);
    }
    // Kludge to make sure the styled element lies behind the selection (by z-index)
    if (line.bgClass)
      wrap.insertBefore(elt("div", null, line.bgClass + " CodeMirror-linebackground"), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                                         wrap.firstChild);
      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        wrap.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineNo),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + display.lineNumInnerWidth + "px"));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
        }
    }
    if (ie_lt8) wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, wrap, dims);
      if (widget.above)
        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
    return wrap;
  }

  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // SELECTION / CURSOR

  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = "none";
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = "none";

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";
    }
  }

  // No selection, plain cursor
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");
    display.cursor.style.left = pos.left + "px";
    display.cursor.style.top = pos.top + "px";
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    display.cursor.style.display = "";

    if (pos.other) {
      display.otherCursor.style.display = "";
      display.otherCursor.style.left = pos.other.left + "px";
      display.otherCursor.style.top = pos.other.top + "px";
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    } else { display.otherCursor.style.display = "none"; }
  }

  // Highlight selection
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = pl;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = clientWidth;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < pl + 1) left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(pl, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(pl, leftEnd.bottom, null, rightStart.top);
    }

    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = "";
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = "";
    display.blinker = setInterval(function() {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
    }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {
      if (doc.frontier >= cm.display.showingFrom) { // Visible
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;
          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function() {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
    return e.offsetLeft;
  }

  function measureChar(cm, line, ch, data, bias) {
    var dir = -1;
    data = data || measureLine(cm, line);

    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r) break;
      if (dir < 0 && pos == 0) dir = 1;
    }
    bias = pos > ch ? "left" : pos < ch ? "right" : bias;
    if (bias == "left" && r.leftSide) r = r.leftSide;
    else if (bias == "right" && r.rightSide) r = r.rightSide;
    return {left: pos < ch ? r.right : r.left,
            right: pos > ch ? r.left : r.right,
            top: r.top,
            bottom: r.bottom};
  }

  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&
          cm.display.scroller.clientWidth == memo.width &&
          memo.classes == line.textClass + "|" + line.bgClass + "|" + line.wrapClass)
        return memo;
    }
  }

  function clearCachedMeasurement(cm, line) {
    var exists = findCachedMeasurement(cm, line);
    if (exists) exists.text = exists.measure = exists.markedSpans = null;
  }

  function measureLine(cm, line) {
    // First look in the cache
    var cached = findCachedMeasurement(cm, line);
    if (cached) return cached.measure;

    // Failing that, recompute and store result in cache
    var measure = measureLineInner(cm, line);
    var cache = cm.display.measureLineCache;
    var memo = {text: line.text, width: cm.display.scroller.clientWidth,
                markedSpans: line.markedSpans, measure: measure,
                classes: line.textClass + "|" + line.bgClass + "|" + line.wrapClass};
    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;
    else cache.push(memo);
    return measure;
  }

  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);

    // IE does not cache element positions of inline elements between
    // calls to getBoundingClientRect. This makes the loop below,
    // which gathers the positions of all the characters on the line,
    // do an amount of layout work quadratic to the number of
    // characters. When line wrapping is off, we try to improve things
    // by first subdividing the line into a bunch of inline blocks, so
    // that IE can reuse most of the layout information from caches
    // for those blocks. This does interfere with line wrapping, so it
    // doesn't work when wrapping is on, but in that case the
    // situation is slightly better, since IE does cache line-wrapping
    // information and only recomputes per-line.
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt("div", null, null, "display: inline-block");
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }

    removeChildrenAndAdd(display.measure, pre);

    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    // Work around an IE7/8 bug where it will sometimes have randomly
    // replaced our pre with a clone at this point.
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);

    function measureRect(rect) {
      var top = rect.top - outer.top, bot = rect.bottom - outer.top;
      if (bot > maxBot) bot = maxBot;
      if (top < 0) top = 0;
      for (var i = vranges.length - 2; i >= 0; i -= 2) {
        var rtop = vranges[i], rbot = vranges[i+1];
        if (rtop > bot || rbot < top) continue;
        if (rtop <= top && rbot >= bot ||
            top <= rtop && bot >= rbot ||
            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {
          vranges[i] = Math.min(top, rtop);
          vranges[i+1] = Math.max(bot, rbot);
          break;
        }
      }
      if (i < 0) { i = vranges.length; vranges.push(top, bot); }
      return {left: rect.left - outer.left,
              right: rect.right - outer.left,
              top: i, bottom: null};
    }
    function finishRect(rect) {
      rect.bottom = vranges[rect.top+1];
      rect.top = vranges[rect.top];
    }

    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
      var node = cur, rect = null;
      // A widget might wrap, needs special care
      if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
        if (cur.firstChild.nodeType == 1) node = cur.firstChild;
        var rects = node.getClientRects();
        if (rects.length > 1) {
          rect = data[i] = measureRect(rects[0]);
          rect.rightSide = measureRect(rects[rects.length - 1]);
        }
      }
      if (!rect) rect = data[i] = measureRect(getRect(node));
      if (cur.measureRight) rect.right = getRect(cur.measureRight).left;
      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));
    }
    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
      finishRect(cur);
      if (cur.leftSide) finishRect(cur.leftSide);
      if (cur.rightSide) finishRect(cur.rightSide);
    }
    return data;
  }

  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {
      var sp = line.markedSpans[i];
      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;
    }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached) return measureChar(cm, line, line.text.length, cached.measure, "right").right;

    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }

  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(cm, lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Context may be "window", "page", "div", or "local"/null
  // Result is in "div" coords
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = getRect(cm.display.sizer);
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = getRect(cm.display.lineSpace);
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
  }

  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement) measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  function PosWithInfo(line, ch, outside, xRel) {
    var pos = new Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Coords must be lineSpace-local
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",
                            lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < 0 ? -1 : xDiff ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "x");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap changes in such a way that each
  // change won't have to update the cursor and display (which would
  // be awkward, slow, and error-prone), but instead updates are
  // batched and then all combined and executed at once.

  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      // An array of ranges of lines that have to be updated. See
      // updateDisplay.
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);

    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, "change", cm, op.textChanged);
    if (op.cursorActivity) signal(cm, "cursorActivity", cm);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm1, f) {
    return function() {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp) startOperation(cm);
      try { var result = f.apply(cm, arguments); }
      finally { if (withOp) endOperation(cm); }
      return result;
    };
  }
  function docOperation(f) {
    return function() {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp) startOperation(this.cm);
      try { result = f.apply(this, arguments); }
      finally { if (withOp) endOperation(this.cm); }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp) startOperation(cm);
    try { result = f(); }
    finally { if (withOp) endOperation(cm); }
    return result;
  }

  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({from: from, to: to, diff: lendiff});
  }

  // INPUT HANDLING

  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // prevInput is a hack to work with IME. If we reset the textarea
  // on every change, that breaks IME. So we look for changes
  // compared to the previous content instead. (Modern browsers have
  // events that indicate IME taking place, but these are not widely
  // supported or compatible enough yet to rely on.)
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to)) return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));

    var updateInput = cm.curOp.updateInput;
    var changeEvent = {from: from, to: to, text: splitLines(text.slice(same)),
                       origin: cm.state.pasteIncoming ? "paste" : "+input"};
    makeChange(cm.doc, changeEvent, "end");
    cm.curOp.updateInput = updateInput;
    signalLater(cm, "inputRead", cm, changeEvent);

    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }

  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = "";
      minimal = hasCopyEvent &&
        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_lt9) cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    var resizeTimer;
    function onResize() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
        clearCaches(cm);
        runInOp(cm, bind(regChange, cm));
      }, 100);
    }
    on(window, "resize", onResize);
    // Above handler holds on to the editor and its data structures.
    // Here we poll to unregister it when the editor is no longer in
    // the document, so that it can be garbage-collected.
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
      if (p) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, function(e) {
      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
      if (e.keyCode == 16) cm.doc.sel.shift = false;
    }));
    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e){
      if (eventInWidget(d, e)) return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = "";
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, "cut", prepareCopy);
    on(d.input, "copy", prepareCopy);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
        if (document.activeElement == d.input) d.input.blur();
        focusInput(cm);
    });
  }

  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||
          target == display.scrollbarV || target == display.scrollbarV.firstChild ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = getRect(display.lineSpace);
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }
    return coordsChar(cm, x - space.left, y - space.top);
  }

  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);

    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick) onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    // For button 1, if it was clicked inside the editor
    // (posFromMouse returning non-null), we have to adjust the
    // selection.
    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}

    if (!cm.state.focused) onFocus(cm);

    var now = +new Date, type = "single";
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = "triple";
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else { lastClick = {time: now, pos: start}; }

    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&
        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
      var dragEnd = operation(cm, function(e2) {
        if (webkit) display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, "mouseup", dragEnd);
        off(display.scroller, "drop", dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          extendSelection(cm.doc, start);
          focusInput(cm);
        }
      });
      // Let the drag handler handle this.
      if (webkit) display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop) display.scroller.dragDrop();
      on(document, "mouseup", dragEnd);
      on(display.scroller, "drop", dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

    var startstart = sel.from, startend = sel.to, lastPos = start;

    function doSelect(cur) {
      if (posEq(lastPos, cur)) return;
      lastPos = cur;

      if (type == "single") {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }

      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == "double") {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);
        else extendSelection(cm.doc, startstart, word.to);
      } else if (type == "triple") {
        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }

    var editorSize = getRect(display.wrapper);
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur) return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused) onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
    }

    var move = operation(cm, function(e) {
      if (!ie && !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  function clickInGutter(cm, e) {
    var display = cm.display;
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }

    if (mX >= Math.floor(getRect(display.gutters).right)) return false;
    e_preventDefault(e);
    if (!hasHandler(cm, "gutterClick")) return true;

    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom) return true;
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, "gutterClick", cm, line, gutter, e);
        break;
      }
    }
    return true;
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"}, "around");
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else {
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
          cm.replaceSelection(text, null, "paste");
          focusInput(cm);
          onFocus(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    var txt = cm.getSelection();
    e.dataTransfer.setData("Text", txt);

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera) img.parentNode.removeChild(img);
    }
  }

  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm, []);
    startWorker(cm, 100);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  function handleKeyBinding(cm, e) {
    // Handle auto keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused) onFocus(cm);
    if (ie && e.keyCode == 27) { e.returnValue = false; }
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var code = e.keyCode;
    // IE does strange things with escape.
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    // First give onKeyEvent option a chance to handle this.
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("");
    }
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars &&
        this.options.smartIndent && !isReadOnly(this) &&
        this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function() {indentLine(cm, cm.doc.sel.to.line, "smart");}), 75);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += " CodeMirror-focused";
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);
  }

  var detectingSelectAll;
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera) return; // Opera is difficult.
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" +
      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm, true);
    // Adds "Select all" to context menu in FF
    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var extval = display.input.value = " " + (posEq(sel.from, sel.to) ? "" : display.input.value);
        display.prevInput = " ";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_lt9) prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function(){
          if (display.prevInput == " " && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_lt9) prepareSelectAllHack();
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  // UPDATING

  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Make sure a position will be valid after the given change.
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos)) return clipPos(doc, pos);
    var diff = (change.text.length - 1) - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +
                       getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }

  // Hint can be null|"end"|"start"|"around"|{anchor,head}
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
      return {anchor: clipPostChange(doc, change, hint.anchor),
              head: clipPostChange(doc, change, hint.head)};

    if (hint == "start") return {anchor: change.from, head: change.from};

    var end = changeEnd(change);
    if (hint == "around") return {anchor: change.from, head: end};
    if (hint == "end") return {anchor: end, head: end};

    // hint is null, leave the selection alone as much as possible
    var adjustPos = function(pos) {
      if (posLess(pos, change.from)) return pos;
      if (!posLess(change.to, pos)) return end;

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};
  }

  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Replace the range from from to to by the strings in replacement.
  // change is a {from, to, text [, origin]} object
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});
      if (split.length)
        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }

  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history;
    var event = (type == "undo" ? hist.done : hist.undone).pop();
    if (!event) return;

    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
                anchorAfter: event.anchorBefore, headAfter: event.headBefore,
                generation: hist.generation};
    (type == "undo" ? hist.undone : hist.done).push(anti);
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        (type == "undo" ? hist.done : hist.undone).length = 0;
        return;
      }

      anti.changes.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null)
                    : {anchor: event.anchorBefore, head: event.headBefore};
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];

      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  function shiftDoc(doc, distance) {
    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}
    doc.first += distance;
    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);
  }

  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else updateDoc(doc, change, spans, selAfter);
  }

  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;

    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    regChange(cm, from.line, to.line + 1, lendiff);

    if (hasHandler(cm, "change")) {
      var changeObj = {from: from, to: to,
                       text: change.text,
                       removed: change.removed,
                       origin: change.origin};
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
        cur.next = changeObj;
      } else cm.curOp.textChanged = changeObj;
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);
  }

  // POSITION OBJECT

  function Pos(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  }
  CodeMirror.Pos = Pos;

  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}
  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}
  function copyPos(x) {return Pos(x.line, x.ch);}

  // SELECTION

  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}

  // If shift is held, this will move the selection anchor. Otherwise,
  // it'll set the whole selection.
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm) doc.cm.curOp.userSelChange = true;
  }

  function filterSelectionChange(doc, anchor, head) {
    var obj = {anchor: anchor, head: head};
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);
    return obj;
  }

  // Update the selection. Last two args are only used by
  // updateDoc, since they have to be expressed in the line
  // numbers before the update.
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }

    var sel = doc.sel;
    sel.goalColumn = null;
    // Skip over atomic spans.
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != "push");

    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

    sel.anchor = anchor; sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;

    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =
        doc.cm.curOp.cursorActivity = true;

    signalLater(doc, "cursorActivity", doc);
  }

  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
  }

  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find()[dir < 0 ? "from" : "to"];
            if (posEq(newPos, curPos)) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SCROLLING

  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
    if (!cm.state.focused) return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == "none";
      if (hidden) {
        display.cursor.style.display = "";
        display.cursor.style.left = coords.left + "px";
        display.cursor.style.top = (coords.top - display.viewOffset) + "px";
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden) display.cursor.style.display = "none";
    }
  }

  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,
                                scrollTop: top == null ? cm.doc.scrollTop : top};
  }

  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }

  // API UTILITIES

  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (how == null) how = "add";
    if (how == "smart") {
      if (!cm.doc.mode.indent) how = "prev";
      else var state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
  }

  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regChange(cm, no, no + 1);
    else return null;
    return line;
  }

  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur) ? "w"
          : !group ? null
          : /\s/.test(cur) ? null
          : "p";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }
        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};
  }

  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }

  // PROTOTYPE

  // The publicly visible API. Note that operation(null, f) means
  // 'wrap f in an operation, performed on its `this` parameter'

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: operation(null, function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: operation(null, function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function(how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              className: style || null, // Deprecated, use 'type' instead
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      if (ch == 0) return styles[2];
      for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else return styles[mid * 2 + 2];
      }
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      if (!helpers.hasOwnProperty(type)) return;
      var help = helpers[type], mode = this.getModeAt(pos);
      return mode[type] && help[mode[type]] ||
        mode.helperType && help[mode.helperType] ||
        help[mode.name];
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null) pos = sel.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +
        (end ? lineObj.height : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: operation(null, function(line, gutterID, value) {
      return changeLine(this, line, function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: operation(null, function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: operation(null, function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: operation(null, onKeyDown),

    execCommand: function(cmd) {return commands[cmd](this);},

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: operation(null, function(dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),

    deleteH: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");
      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
      this.curOp.userSelChange = true;
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, "div");
      if (sel.goalColumn != null) pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);

      if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += " CodeMirror-overwrite";
      else
        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
    },
    hasFocus: function() { return this.state.focused; },

    scrollTo: operation(null, function(x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: operation(null, function(pos, margin) {
      if (typeof pos == "number") pos = Pos(pos, 0);
      if (!margin) margin = 0;
      var coords = pos;

      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),

    setSize: function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },

    operation: function(f){return runInOp(this, f);},

    refresh: operation(null, function() {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),

    swapDoc: operation(null, function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  var optionHandlers = CodeMirror.optionHandlers = {};

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("onKeyEvent", null);
  option("onDragEvent", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {onBlur(cm); cm.display.input.blur();}
    else if (!val) resetInput(cm, true);
  });
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true);
  option("pollInterval", 100);
  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 500);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, function(cm){loadMode(cm); cm.refresh();}, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;

    return modeObj;
  };

  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {};
    helpers[type][name] = value;
  };

  // UTILITIES

  CodeMirror.isWordChar = isWordChar;

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;

  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},
    killLine: function(cm) {
      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
      if (!sel && cm.getLine(from.line).length == from.ch)
        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");
      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
    },
    deleteLine: function(cm) {
      var l = cm.getCursor().line;
      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
    },
    delLineLeft: function(cm) {
      var cur = cm.getCursor();
      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelection(lineStart(cm, cm.getCursor().line));
    },
    goLineStartSmart: function(cm) {
      var cur = cm.getCursor(), start = lineStart(cm, cur.line);
      var line = cm.getLineHandle(start.line);
      var order = getOrder(line);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
      } else cm.extendSelection(start);
    },
    goLineEnd: function(cm) {
      cm.extendSelection(lineEnd(cm, cm.getCursor().line));
    },
    goLineRight: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));
    },
    goLineLeft: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t", "end", "+input");},
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.replaceSelection("\t", "end", "+input");
    },
    transposeChars: function(cm) {
      var cur = cm.getCursor(), line = cm.getLine(cur.line);
      if (cur.ch > 0 && cur.ch < line.length - 1)
        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
    },
    newlineAndIndent: function(cm) {
      operation(cm, function() {
        cm.replaceSelection("\n", "end", "+input");
        cm.indentLine(cm.getCursor().line, null, true);
      })();
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = document.body;
      // doc.activeElement occasionally throws on IE
      try { hasFocus = document.activeElement; } catch(e) {}
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == 0;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function() {return countColumn(this.string, null, this.tabSize);},
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);}
  };
  CodeMirror.StringStream = StringStream;

  // TEXTMARKERS

  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  eventMixin(TextMarker);

  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null) max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm);
    }
    if (withOp) endOperation(cm);
    signalLater(this, "clear");
  };

  TextMarker.prototype.find = function() {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null) from = Pos(found, span.from);
        if (span.to != null) to = Pos(found, span.to);
      }
    }
    if (this.type == "bookmark") return from;
    return from && {from: from, to: to};
  };

  TextMarker.prototype.changed = function() {
    var pos = this.find(), cm = this.doc.cm;
    if (!pos || !cm) return;
    var line = getLine(this.doc, pos.from.line);
    clearCachedMeasurement(cm, line);
    if (pos.from.line >= cm.display.showingFrom && pos.from.line < cm.display.showingTo) {
      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {
        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);
        break;
      }
      runInOp(cm, function() { cm.curOp.selectionChanged = true; });
    }
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  function markText(doc, from, to, options, type) {
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type);
    if (type == "range" && !posLess(from, to)) return marker;
    if (options) copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;
    }
    if (marker.collapsed) sawCollapsedSpans = true;

    if (marker.addToHistory)
      addToHistory(doc, {from: from, to: to, origin: "markText"},
                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);

    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {from: null, to: null, marker: marker};
      size += line.text.length;
      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}
      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}
      if (marker.collapsed) {
        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);
        else updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error("Inserting collapsed marker overlapping an existing one");
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic) reCheckSelection(cm);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], "clear", function(){me.clear();});
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function() {
    return this.primary.find();
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function(doc) {
      if (widget) options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  // TEXTMARKER SPANS

  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || marker.type == "bookmark" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push({from: span.from,
                                to: endsAfter ? null : span.to,
                                marker: marker});
      }
    }
    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,
                                to: span.to == null ? null : span.to - endCh,
                                marker: marker});
      }
    }
    return nw;
  }

  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    if (sameLine && first) {
      // Make sure we didn't create any zero-length spans
      for (var i = 0; i < first.length; ++i)
        if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != "bookmark")
          first.splice(i--, 1);
      if (!first.length) first = null;
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
        var newParts = [j, 1];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({from: p.from, to: m.from});
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if ((sp.from == null || sp.from < ch) &&
          (sp.to == null || sp.to > ch) &&
          (!found || found.width < sp.marker.width))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }

  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }

  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.replacedWith) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // LINE WIDGETS

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);
  function widgetOperation(f) {
    return function() {
      var withOp = !this.cm.curOp;
      if (withOp) startOperation(this.cm);
      try {var result = f.apply(this, arguments);}
      finally {if (withOp) endOperation(this.cm);}
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function() {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) this.line.widgets = null;
    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function() {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Run the given mode's parser over a line, update the styles
  // array, which contains alternating fragments of text and CSS
  // classes.
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    if (curStart < stream.pos) f(stream.pos, curStyle);
  }

  function highlightLine(cm, line, state) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen];
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {st.push(end, style);});

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = cur ? cur + " " + style : style;
          }
        }
      });
    }

    return st;
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array.
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }

  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style) return null;
    return styleToClassCache[style] ||
      (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
  }

  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, empty = true;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(cm.doc, merged.find().from.line);

    var builder = {pre: elt("pre"), col: 0, pos: 0, display: !measure,
                   measure: null, measuredSomething: false, cm: cm};
    if (line.textClass) builder.pre.className = line.textClass;

    do {
      if (line.text) empty = false;
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      if (measure && line == realLine && !builder.measuredSomething) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.measuredSomething = true;
      }
      if (next) line = getLine(cm.doc, next.to.line);
    } while (next);

    if (measure && !builder.measuredSomething && !measure[0])
      measure[0] = builder.pre.appendChild(empty ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode("\u00a0"));

    var order;
    // Work around problem with the reported dimensions of single-char
    // direction spans on IE (issue #1129). See also the comment in
    // cursorCoords.
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to) --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),
                                               span.nextSibling);
      }
    }

    signal(cm, "renderLine", cm, realLine, builder.pre);
    return builder.pre;
  }

  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text) return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle);
      if (title) token.title = title;
      return builder.pre.appendChild(token);
    }
    builder.pre.appendChild(content);
  }

  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping(text, i)) {
        builder.pre.appendChild(elt("wbr"));
      }
      var old = builder.measure[builder.pos];
      var span = builder.measure[builder.pos] =
        buildToken(builder, ch, style,
                   start && startStyle, i == text.length - 1 && endStyle);
      if (old) span.leftSide = old.leftSide || old;
      // In IE single-space nodes wrap differently than spaces
      // embedded in larger text nodes, except when set to
      // white-space: normal (issue #1268).
      if (ie && wrapping && ch == " " && i && !/\s/.test(text.charAt(i - 1)) &&
          i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = "normal";
      builder.pos += ch.length;
    }
    if (text.length) builder.measuredSomething = true;
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle, title);
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.replacedWith;
    if (widget) {
      if (!builder.display) widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure) {
        if (size) {
          builder.measure[builder.pos] = widget;
        } else {
          var elt = builder.measure[builder.pos] = zeroWidthElement(builder.cm.display.measure);
          if (marker.type != "bookmark" || marker.insertLeft)
            builder.pre.insertBefore(elt, widget);
          else
            builder.pre.appendChild(elt);
        }
        builder.measuredSomething = true;
      }
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), styleToClass(styles[i+1]));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmark = m;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = styleToClass(styles[i++]);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // First adjust the line structure
    if (from.ch == 0 && to.ch == 0 && lastText == "") {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    collapse: function(lines) {
      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
    },
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
    },
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.history = makeHistory();
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    insert: function(at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"},
                 {head: top, anchor: top}, true);
    },
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},
    setLine: function(line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function(line) {
      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));
    },

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(this, line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var sel = this.sel, pos;
      if (start == null || start == "head") pos = sel.head;
      else if (start == "anchor") pos = sel.anchor;
      else if (start == "end" || start === false) pos = sel.to;
      else pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},

    setCursor: docOperation(function(line, ch, extend) {
      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
      if (extend) extendSelection(this, pos);
      else setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function(anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function(from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),

    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},
    replaceSelection: function(code, collapse, origin) {
      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");
    },
    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),
    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),

    setExtending: function(val) {this.sel.extend = val;},

    historySize: function() {
      var hist = this.history;
      return {undo: hist.done.length, redo: hist.undone.length};
    },
    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration();
    },
    changeGeneration: function() {
      this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = makeHistory(this.history.maxGeneration);
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  Doc.prototype.eachLine = Doc.prototype.iter;

  // The Doc methods that should be available on CodeMirror instances
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent) n.height += diff;
  }

  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }

  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function makeHistory(startGen) {
    return {
      // Arrays of history events. Doing something adds an event to
      // done and clears undo. Undoing moves events from done to
      // undone, redoing moves them in the other direction.
      done: [], undone: [], undoDepth: Infinity,
      // Used to track when changes can be merged into a single undo
      // event
      lastTime: 0, lastOp: null, lastOrigin: null,
      // Used by the isClean() method
      generation: startGen || 1, maxGeneration: startGen || 1
    };
  }

  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  function historyChangeFromChange(doc, change) {
    var from = { line: change.from.line, ch: change.from.ch };
    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur = lst(hist.done);

    if (cur &&
        (hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*"))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;
    } else {
      // Can not be merged, start a new event.
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation,
             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
             anchorAfter: selAfter.anchor, headAfter: selAfter.head};
      hist.done.push(cur);
      hist.generation = ++hist.maxGeneration;
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }

  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT OPERATORS

  function stopMethod() {e_stop(this);}
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop) event.stop = stopMethod;
    return event;
  }

  function e_preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e);
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;

  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  function Delayed() {this.id = null;}
  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
      else ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  function selectInput(node) {
    if (ios) { // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else {
      // Suppress mysterious IE10 errors
      try { node.select(); }
      catch(_e) {}
    }
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  function createObj(base, props) {
    function Obj() {}
    Obj.prototype = base;
    var inst = new Obj();
    if (props) copyObj(props, inst);
    return inst;
  }

  function copyObj(obj, target) {
    if (!target) target = {};
    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
    return target;
  }

  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i) a.push(undefined);
    return a;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") setTextContent(e, content);
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = "";
      e.appendChild(document.createTextNode(str));
    } else e.textContent = str;
  }

  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function(f) { getRect = f; };

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_lt9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  // For a reason I have yet to figure out, some browsers disallow
  // word wrapping between certain characters *only* if a new inline
  // element is started between them. This makes it hard to reliably
  // measure the position of things, since that requires inserting an
  // extra span. This terribly fragile set of tests matches the
  // character combinations that suffer from this phenomenon on the
  // various browsers.
  function spanAffectsWrapping() { return false; }
  if (gecko) // Only for "$'"
    spanAffectsWrapping = function(str, i) {
      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
    };
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = function(str, i) {
      return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
    };
  else if (webkit && !/Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent))
    spanAffectsWrapping = function(str, i) {
      if (i > 1 && str.charCodeAt(i - 1) == 45) {
        if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i))) return true;
        if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i))) return false;
      }
      return /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|…[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
    };

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};
  CodeMirror.splitLines = splitLines;

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == 'function';
  })();

  // KEY NAMING

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
                  186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
                  63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) { bidiOther = null; return i; }
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          bidiOther = found;
          return i;
        } else {
          bidiOther = i;
          return found;
        }
      }
    }
    bidiOther = null;
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
    return pos;
  }

  // This is somewhat involved. It is needed in order to move
  // 'visually' through bi-directional text -- i.e., pressing left
  // should make the cursor go left, even when in RTL text. The
  // tricky part is the 'jumps', where RTL and LTR text touch each
  // other. This often requires the cursor offset to move more than
  // one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
    function charType(code) {
      if (code <= 0xff) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);
      else if (0x700 <= code && code <= 0x8ac) return "r";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len - 1 && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len - 1 ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push({from: start, to: i, level: 0});
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, {from: nstart, to: j, level: 2});
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift({from: 0, to: m[0].length, level: 0});
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push({from: len - m[0].length, to: len, level: 0});
      }
      if (order[0].level != lst(order).level)
        order.push({from: len, to: len, level: order[0].level});

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "3.14.1";

  return CodeMirror;
})();
// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true, in which case
// the styles are combined.

// overlayParser is the old, deprecated name
CodeMirror.overlayMode = CodeMirror.overlayParser = function(base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);
      if (stream.eol()) state.basePos = state.overlayPos = 0;

      if (state.overlayCur == null) return state.baseCur;
      if (state.baseCur != null && combine) return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent && function(state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      if (base.blankLine) base.blankLine(state.base);
      if (overlay.blankLine) overlay.blankLine(state.overlay);
    }
  };
};
CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});
  var cssMode = CodeMirror.getMode(config, "css");

  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;
  scriptTypes.push({matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
                    mode: CodeMirror.getMode(config, "javascript")});
  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
    var conf = scriptTypesConf[i];
    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});
  }
  scriptTypes.push({matches: /./,
                    mode: CodeMirror.getMode(config, "text/plain")});

  function html(stream, state) {
    var tagName = state.htmlState.tagName;
    var style = htmlMode.token(stream, state.htmlState);
    if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
      // Script block: mode to change to depends on type attribute
      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
      scriptType = scriptType ? scriptType[1] : "";
      if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
      for (var i = 0; i < scriptTypes.length; ++i) {
        var tp = scriptTypes[i];
        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
          if (tp.mode) {
            state.token = script;
            state.localMode = tp.mode;
            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
          }
          break;
        }
      }
    } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
      state.token = css;
      state.localMode = cssMode;
      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
    }
    return style;
  }
  function maybeBackup(stream, pat, style) {
    var cur = stream.current();
    var close = cur.search(pat), m;
    if (close > -1) stream.backUp(cur.length - close);
    else if (m = cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur[0]);
    }
    return style;
  }
  function script(stream, state) {
    if (stream.match(/^<\/\s*script\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*script\s*>/,
                       state.localMode.token(stream, state.localState));
  }
  function css(stream, state) {
    if (stream.match(/^<\/\s*style\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*style\s*>/,
                       cssMode.token(stream, state.localState));
  }

  return {
    startState: function() {
      var state = htmlMode.startState();
      return {token: html, localMode: null, localState: null, htmlState: state};
    },

    copyState: function(state) {
      if (state.localState)
        var local = CodeMirror.copyState(state.localMode, state.localState);
      return {token: state.token, localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function(stream, state) {
      return state.token(stream, state);
    },

    indent: function(state, textAfter) {
      if (!state.localMode || /^\s*<\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    electricChars: "/{}:",

    innerMode: function(state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}, "xml", "javascript", "css");

CodeMirror.defineMIME("text/html", "htmlmixed");
CodeMirror.defineMode("clike", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);
      else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "brace"
  };
});

(function() {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
    "double static else struct entry switch extern typedef float union for unsigned " +
    "goto while enum void const signed volatile";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    for (;;) {
      if (stream.skipTo("\\")) {
        stream.next();
        if (stream.eol()) {
          state.tokenize = cppHook;
          break;
        }
      } else {
        stream.skipToEnd();
        state.tokenize = null;
        break;
      }
    }
    return "meta";
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  function mimes(ms, mode) {
    for (var i = 0; i < ms.length; ++i) CodeMirror.defineMIME(ms[i], mode);
  }

  mimes(["text/x-csrc", "text/x-c", "text/x-chdr"], {
    name: "clike",
    keywords: words(cKeywords),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook}
  });
  mimes(["text/x-c++src", "text/x-c++hdr"], {
    name: "clike",
    keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t"),
    blockKeywords: words("catch class do else finally for if struct switch try while"),
    atoms: words("true false null"),
    hooks: {"#": cppHook}
  });
  CodeMirror.defineMIME("text/x-java", {
    name: "clike",
    keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
    blockKeywords: words("catch class do else finally for if switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });
  CodeMirror.defineMIME("text/x-csharp", {
    name: "clike",
    keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
    blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
    builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object"  +
                    " sbyte float string ushort uint ulong"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream, state) {
        if (stream.eat('"')) {
          state.tokenize = tokenAtString;
          return tokenAtString(stream, state);
        }
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });
  CodeMirror.defineMIME("text/x-scala", {
    name: "clike",
    keywords: words(

      /* scala */
      "abstract case catch class def do else extends false final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
      "<% >: # @ " +

      /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble " +

      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"


    ),
    blockKeywords: words("catch class do else finally for forSome if match switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });
  mimes(["x-shader/x-vertex", "x-shader/x-fragment"], {
    name: "clike",
    keywords: words("float int bool void " +
                    "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                    "mat2 mat3 mat4 " +
                    "sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow" +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smootstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
    atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragColor gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
    hooks: {"#": cppHook}
  });
}());
CodeMirror.defineMode("yaml", function() {

  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];
  var keywordRegex = new RegExp("\\b(("+cons.join(")|(")+"))$", 'i');

  return {
    token: function(stream, state) {
      var ch = stream.peek();
      var esc = state.escaped;
      state.escaped = false;
      /* comments */
      if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
        stream.skipToEnd(); return "comment";
      }
      if (state.literal && stream.indentation() > state.keyCol) {
        stream.skipToEnd(); return "string";
      } else if (state.literal) { state.literal = false; }
      if (stream.sol()) {
        state.keyCol = 0;
        state.pair = false;
        state.pairStart = false;
        /* document start */
        if(stream.match(/---/)) { return "def"; }
        /* document end */
        if (stream.match(/\.\.\./)) { return "def"; }
        /* array list item */
        if (stream.match(/\s*-\s+/)) { return 'meta'; }
      }
      /* pairs (associative arrays) -> key */
      if (!state.pair && stream.match(/^\s*([a-z0-9\._-])+(?=\s*:)/i)) {
        state.pair = true;
        state.keyCol = stream.indentation();
        return "atom";
      }
      if (state.pair && stream.match(/^:\s*/)) { state.pairStart = true; return 'meta'; }

      /* inline pairs/lists */
      if (stream.match(/^(\{|\}|\[|\])/)) {
        if (ch == '{')
          state.inlinePairs++;
        else if (ch == '}')
          state.inlinePairs--;
        else if (ch == '[')
          state.inlineList++;
        else
          state.inlineList--;
        return 'meta';
      }

      /* list seperator */
      if (state.inlineList > 0 && !esc && ch == ',') {
        stream.next();
        return 'meta';
      }
      /* pairs seperator */
      if (state.inlinePairs > 0 && !esc && ch == ',') {
        state.keyCol = 0;
        state.pair = false;
        state.pairStart = false;
        stream.next();
        return 'meta';
      }

      /* start of value of a pair */
      if (state.pairStart) {
        /* block literals */
        if (stream.match(/^\s*(\||\>)\s*/)) { state.literal = true; return 'meta'; };
        /* references */
        if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) { return 'variable-2'; }
        /* numbers */
        if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) { return 'number'; }
        if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) { return 'number'; }
        /* keywords */
        if (stream.match(keywordRegex)) { return 'keyword'; }
      }

      /* nothing found, continue */
      state.pairStart = false;
      state.escaped = (ch == '\\');
      stream.next();
      return null;
    },
    startState: function() {
      return {
        pair: false,
        pairStart: false,
        keyCol: 0,
        inlinePairs: 0,
        inlineList: 0,
        literal: false,
        escaped: false
      };
    }
  };
});

CodeMirror.defineMIME("text/x-yaml", "yaml");
CodeMirror.defineMode("ruby", function(config) {
  function wordObj(words) {
    var o = {};
    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
    return o;
  }
  var keywords = wordObj([
    "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else",
    "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or",
    "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless",
    "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc",
    "caller", "lambda", "proc", "public", "protected", "private", "require", "load",
    "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"
  ]);
  var indentWords = wordObj(["def", "class", "case", "for", "while", "do", "module", "then",
                             "catch", "loop", "proc", "begin"]);
  var dedentWords = wordObj(["end", "until"]);
  var matching = {"[": "]", "{": "}", "(": ")"};
  var curPunc;

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    curPunc = null;
    if (stream.sol() && stream.match("=begin") && stream.eol()) {
      state.tokenize.push(readBlockComment);
      return "comment";
    }
    if (stream.eatSpace()) return null;
    var ch = stream.next(), m;
    if (ch == "`" || ch == "'" || ch == '"') {
      return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
    } else if (ch == "/" && !stream.eol() && stream.peek() != " ") {
      return chain(readQuoted(ch, "string-2", true), stream, state);
    } else if (ch == "%") {
      var style = "string", embed = false;
      if (stream.eat("s")) style = "atom";
      else if (stream.eat(/[WQ]/)) { style = "string"; embed = true; }
      else if (stream.eat(/[r]/)) { style = "string-2"; embed = true; }
      else if (stream.eat(/[wxq]/)) style = "string";
      var delim = stream.eat(/[^\w\s]/);
      if (!delim) return "operator";
      if (matching.propertyIsEnumerable(delim)) delim = matching[delim];
      return chain(readQuoted(delim, style, embed, true), stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "<" && (m = stream.match(/^<-?[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
      return chain(readHereDoc(m[1]), stream, state);
    } else if (ch == "0") {
      if (stream.eat("x")) stream.eatWhile(/[\da-fA-F]/);
      else if (stream.eat("b")) stream.eatWhile(/[01]/);
      else stream.eatWhile(/[0-7]/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
      return "number";
    } else if (ch == "?") {
      while (stream.match(/^\\[CM]-/)) {}
      if (stream.eat("\\")) stream.eatWhile(/\w/);
      else stream.next();
      return "string";
    } else if (ch == ":") {
      if (stream.eat("'")) return chain(readQuoted("'", "atom", false), stream, state);
      if (stream.eat('"')) return chain(readQuoted('"', "atom", true), stream, state);

      // :> :>> :< :<< are valid symbols
      if (stream.eat(/[\<\>]/)) {
        stream.eat(/[\<\>]/);
        return "atom";
      }

      // :+ :- :/ :* :| :& :! are valid symbols
      if (stream.eat(/[\+\-\*\/\&\|\:\!]/)) {
        return "atom";
      }

      // Symbols can't start by a digit
      if (stream.eat(/[a-zA-Z$@_]/)) {
        stream.eatWhile(/[\w]/);
        // Only one ? ! = is allowed and only as the last character
        stream.eat(/[\?\!\=]/);
        return "atom";
      }
      return "operator";
    } else if (ch == "@" && stream.match(/^@?[a-zA-Z_]/)) {
      stream.eat("@");
      stream.eatWhile(/[\w]/);
      return "variable-2";
    } else if (ch == "$") {
      if (stream.eat(/[a-zA-Z_]/)) {
        stream.eatWhile(/[\w]/);
      } else if (stream.eat(/\d/)) {
        stream.eat(/\d/);
      } else {
        stream.next(); // Must be a special global like $: or $!
      }
      return "variable-3";
    } else if (/[a-zA-Z_]/.test(ch)) {
      stream.eatWhile(/[\w]/);
      stream.eat(/[\?\!]/);
      if (stream.eat(":")) return "atom";
      return "ident";
    } else if (ch == "|" && (state.varList || state.lastTok == "{" || state.lastTok == "do")) {
      curPunc = "|";
      return null;
    } else if (/[\(\)\[\]{}\\;]/.test(ch)) {
      curPunc = ch;
      return null;
    } else if (ch == "-" && stream.eat(">")) {
      return "arrow";
    } else if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
      stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
      return "operator";
    } else {
      return null;
    }
  }

  function tokenBaseUntilBrace() {
    var depth = 1;
    return function(stream, state) {
      if (stream.peek() == "}") {
        depth--;
        if (depth == 0) {
          state.tokenize.pop();
          return state.tokenize[state.tokenize.length-1](stream, state);
        }
      } else if (stream.peek() == "{") {
        depth++;
      }
      return tokenBase(stream, state);
    };
  }
  function tokenBaseOnce() {
    var alreadyCalled = false;
    return function(stream, state) {
      if (alreadyCalled) {
        state.tokenize.pop();
        return state.tokenize[state.tokenize.length-1](stream, state);
      }
      alreadyCalled = true;
      return tokenBase(stream, state);
    };
  }
  function readQuoted(quote, style, embed, unescaped) {
    return function(stream, state) {
      var escaped = false, ch;

      if (state.context.type === 'read-quoted-paused') {
        state.context = state.context.prev;
        stream.eat("}");
      }

      while ((ch = stream.next()) != null) {
        if (ch == quote && (unescaped || !escaped)) {
          state.tokenize.pop();
          break;
        }
        if (embed && ch == "#" && !escaped) {
          if (stream.eat("{")) {
            if (quote == "}") {
              state.context = {prev: state.context, type: 'read-quoted-paused'};
            }
            state.tokenize.push(tokenBaseUntilBrace());
            break;
          } else if (/[@\$]/.test(stream.peek())) {
            state.tokenize.push(tokenBaseOnce());
            break;
          }
        }
        escaped = !escaped && ch == "\\";
      }
      return style;
    };
  }
  function readHereDoc(phrase) {
    return function(stream, state) {
      if (stream.match(phrase)) state.tokenize.pop();
      else stream.skipToEnd();
      return "string";
    };
  }
  function readBlockComment(stream, state) {
    if (stream.sol() && stream.match("=end") && stream.eol())
      state.tokenize.pop();
    stream.skipToEnd();
    return "comment";
  }

  return {
    startState: function() {
      return {tokenize: [tokenBase],
              indented: 0,
              context: {type: "top", indented: -config.indentUnit},
              continuedLine: false,
              lastTok: null,
              varList: false};
    },

    token: function(stream, state) {
      if (stream.sol()) state.indented = stream.indentation();
      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;
      if (style == "ident") {
        var word = stream.current();
        style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
          : /^[A-Z]/.test(word) ? "tag"
          : (state.lastTok == "def" || state.lastTok == "class" || state.varList) ? "def"
          : "variable";
        if (indentWords.propertyIsEnumerable(word)) kwtype = "indent";
        else if (dedentWords.propertyIsEnumerable(word)) kwtype = "dedent";
        else if ((word == "if" || word == "unless") && stream.column() == stream.indentation())
          kwtype = "indent";
      }
      if (curPunc || (style && style != "comment")) state.lastTok = word || curPunc || style;
      if (curPunc == "|") state.varList = !state.varList;

      if (kwtype == "indent" || /[\(\[\{]/.test(curPunc))
        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};
      else if ((kwtype == "dedent" || /[\)\]\}]/.test(curPunc)) && state.context.prev)
        state.context = state.context.prev;

      if (stream.eol())
        state.continuedLine = (curPunc == "\\" || style == "operator");
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize[state.tokenize.length-1] != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0);
      var ct = state.context;
      var closing = ct.type == matching[firstChar] ||
        ct.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
      return ct.indented + (closing ? 0 : config.indentUnit) +
        (state.continuedLine ? config.indentUnit : 0);
    },

    electricChars: "}de", // enD and rescuE
    lineComment: "#"
  };
});

CodeMirror.defineMIME("text/x-ruby", "ruby");

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlFound = CodeMirror.modes.hasOwnProperty("xml");
  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: "xml", htmlMode: true} : "text/plain");
  var aliases = {
    html: "htmlmixed",
    js: "javascript",
    json: "application/json",
    c: "text/x-csrc",
    "c++": "text/x-c++src",
    java: "text/x-java",
    csharp: "text/x-csharp",
    "c#": "text/x-csharp",
    scala: "text/x-scala"
  };

  var getMode = (function () {
    var i, modes = {}, mimes = {}, mime;

    var list = [];
    for (var m in CodeMirror.modes)
      if (CodeMirror.modes.propertyIsEnumerable(m)) list.push(m);
    for (i = 0; i < list.length; i++) {
      modes[list[i]] = list[i];
    }
    var mimesList = [];
    for (var m in CodeMirror.mimeModes)
      if (CodeMirror.mimeModes.propertyIsEnumerable(m))
        mimesList.push({mime: m, mode: CodeMirror.mimeModes[m]});
    for (i = 0; i < mimesList.length; i++) {
      mime = mimesList[i].mime;
      mimes[mime] = mimesList[i].mime;
    }

    for (var a in aliases) {
      if (aliases[a] in modes || aliases[a] in mimes)
        modes[a] = aliases[a];
    }

    return function (lang) {
      return modes[lang] ? CodeMirror.getMode(cmCfg, modes[lang]) : null;
    };
  }());

  // Should underscores in words open/close em/strong?
  if (modeCfg.underscoresBreakWords === undefined)
    modeCfg.underscoresBreakWords = true;

  // Turn on fenced code blocks? ("```" to start/end)
  if (modeCfg.fencedCodeBlocks === undefined) modeCfg.fencedCodeBlocks = false;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  var codeDepth = 0;

  var header   = 'header'
  ,   code     = 'comment'
  ,   quote1   = 'atom'
  ,   quote2   = 'number'
  ,   list1    = 'variable-2'
  ,   list2    = 'variable-3'
  ,   list3    = 'keyword'
  ,   hr       = 'hr'
  ,   image    = 'tag'
  ,   linkinline = 'link'
  ,   linkemail = 'link'
  ,   linktext = 'link'
  ,   linkhref = 'string'
  ,   em       = 'em'
  ,   strong   = 'strong';

  var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/
  ,   ulRE = /^[*\-+]\s+/
  ,   olRE = /^[0-9]+\.\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
  ,   headerRE = /^(?:\={1,}|-{1,})$/
  ,   textRE = /^[^!\[\]*_\\<>` "'(]+/;

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }


  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset state.quote
    state.quote = 0;
    if (!htmlFound && state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.thisLineHasContent = false;
    return null;
  }

  function blockNormal(stream, state) {

    var prevLineIsList = (state.list !== false);
    if (state.list !== false && state.indentationDiff >= 0) { // Continued list
      if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
        state.indentation -= state.indentationDiff;
      }
      state.list = null;
    } else if (state.list !== false && state.indentation > 0) {
      state.list = null;
      state.listDepth = Math.floor(state.indentation / 4);
    } else if (state.list !== false) { // No longer a list
      state.list = false;
      state.listDepth = 0;
    }

    if (state.indentationDiff >= 4) {
      state.indentation -= 4;
      stream.skipToEnd();
      return code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (stream.peek() === '#' || (state.prevLineHasContent && stream.match(headerRE)) ) {
      state.header = true;
    } else if (stream.eat('>')) {
      state.indentation++;
      state.quote = 1;
      stream.eatSpace();
      while (stream.eat('>')) {
        stream.eatSpace();
        state.quote++;
      }
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    } else if (stream.match(hrRE, true)) {
      return hr;
    } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, true) || stream.match(olRE, true))) {
      state.indentation += 4;
      state.list = true;
      state.listDepth++;
      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
    } else if (modeCfg.fencedCodeBlocks && stream.match(/^```([\w+#]*)/, true)) {
      // try switching mode
      state.localMode = getMode(RegExp.$1);
      if (state.localMode) state.localState = state.localMode.startState();
      switchBlock(stream, state, local);
      return code;
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (htmlFound && style === 'tag' && state.htmlState.type !== 'openTag' && !state.htmlState.context) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    if (state.md_inside && stream.current().indexOf(">")!=-1) {
      state.f = inlineNormal;
      state.block = blockNormal;
      state.htmlState.context = undefined;
    }
    return style;
  }

  function local(stream, state) {
    if (stream.sol() && stream.match(/^```/, true)) {
      state.localMode = state.localState = null;
      state.f = inlineNormal;
      state.block = blockNormal;
      return code;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return code;
    }
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.taskOpen) { return "meta"; }
    if (state.taskClosed) { return "property"; }

    if (state.strong) { styles.push(strong); }
    if (state.em) { styles.push(em); }

    if (state.linkText) { styles.push(linktext); }

    if (state.code) { styles.push(code); }

    if (state.header) { styles.push(header); }
    if (state.quote) { styles.push(state.quote % 2 ? quote1 : quote2); }
    if (state.list !== false) {
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod) {
        styles.push(list1);
      } else if (listMod === 1) {
        styles.push(list2);
      } else {
        styles.push(list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] !== "x";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    var ch = stream.next();

    if (ch === '\\') {
      stream.next();
      return getType(state);
    }

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return linkhref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var t = getType(state);
      var before = stream.pos;
      stream.eatWhile('`');
      var difference = 1 + stream.pos - before;
      if (!state.code) {
        codeDepth = difference;
        state.code = true;
        return getType(state);
      } else {
        if (difference === codeDepth) { // Must be exact
          state.code = false;
          return t;
        }
        return getType(state);
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      stream.match(/\[[^\]]*\]/);
      state.inline = state.f = linkHref;
      return image;
    }

    if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
      state.linkText = true;
      return getType(state);
    }

    if (ch === ']' && state.linkText) {
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkinline, '>'));
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkemail, '>'));
    }

    if (ch === '<' && stream.match(/^\w/, false)) {
      if (stream.string.indexOf(">")!=-1) {
        var atts = stream.string.substring(1,stream.string.indexOf(">"));
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
          state.md_inside = true;
        }
      }
      stream.backUp(1);
      return switchBlock(stream, state, htmlBlock);
    }

    if (ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    }

    var ignoreUnderscore = false;
    if (!modeCfg.underscoresBreakWords) {
      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
        var prevPos = stream.pos - 2;
        if (prevPos >= 0) {
          var prevCh = stream.string.charAt(prevPos);
          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
            ignoreUnderscore = true;
          }
        }
      }
    }
    var t = getType(state);
    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
      if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
        state.strong = false;
        return t;
      } else if (!state.strong && stream.eat(ch)) { // Add STRONG
        state.strong = ch;
        return getType(state);
      } else if (state.em === ch) { // Remove EM
        state.em = false;
        return t;
      } else if (!state.em) { // Add EM
        state.em = ch;
        return getType(state);
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      return switchInline(stream, state, inlineElement(linkhref, ch === '(' ? ')' : ']'));
    }
    return 'error';
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^[^\]]*\]:/, true)) {
      state.f = footnoteUrl;
      return linktext;
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return linkhref;
  }

  var savedInlineRE = [];
  function inlineRE(endChar) {
    if (!savedInlineRE[endChar]) {
      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
      endChar = (endChar+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      // Match any non-endChar, escaped character, as well as the closing
      // endChar.
      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
    }
    return savedInlineRE[endChar];
  }

  function inlineElement(type, endChar, next) {
    next = next || inlineNormal;
    return function(stream, state) {
      stream.match(inlineRE(endChar));
      state.inline = state.f = next;
      return type;
    };
  }

  return {
    startState: function() {
      return {
        f: blockNormal,

        prevLineHasContent: false,
        thisLineHasContent: false,

        block: blockNormal,
        htmlState: CodeMirror.startState(htmlMode),
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        linkText: false,
        linkTitle: false,
        em: false,
        strong: false,
        header: false,
        taskList: false,
        list: false,
        listDepth: 0,
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLineHasContent: s.prevLineHasContent,
        thisLineHasContent: s.thisLineHasContent,

        block: s.block,
        htmlState: CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        linkTitle: s.linkTitle,
        em: s.em,
        strong: s.strong,
        header: s.header,
        taskList: s.taskList,
        list: s.list,
        listDepth: s.listDepth,
        quote: s.quote,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (stream.match(/^\s*$/, true)) {
          state.prevLineHasContent = false;
          return blankLine(state);
        } else {
          state.prevLineHasContent = state.thisLineHasContent;
          state.thisLineHasContent = true;
        }

        // Reset state.header
        state.header = false;

        // Reset state.taskList
        state.taskList = false;

        // Reset state.code
        state.code = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        state.f = state.block;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
        var difference = Math.floor((indentation - state.indentation) / 4) * 4;
        if (difference > 4) difference = 4;
        var adjustedIndentation = state.indentation + difference;
        state.indentationDiff = adjustedIndentation - state.indentation;
        state.indentation = adjustedIndentation;
        if (indentation > 0) return null;
      }
      return state.f(stream, state);
    },

    blankLine: blankLine,

    getType: getType
  };

}, "xml");

CodeMirror.defineMIME("text/x-markdown", "markdown");
CodeMirror.defineMode("xml", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;

  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                      'track': true, 'wbr': true},
    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                       'th': true, 'tr': true},
    contextGrabbers: {
      'dd': {'dd': true, 'dt': true},
      'dt': {'dd': true, 'dt': true},
      'li': {'li': true},
      'option': {'option': true, 'optgroup': true},
      'optgroup': {'optgroup': true},
      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
      'rp': {'rp': true, 'rt': true},
      'rt': {'rp': true, 'rt': true},
      'tbody': {'tbody': true, 'tfoot': true},
      'td': {'td': true, 'th': true},
      'tfoot': {'tbody': true},
      'th': {'td': true, 'th': true},
      'thead': {'tbody': true, 'tfoot': true},
      'tr': {'tr': true}
    },
    doNotIndent: {"pre": true},
    allowUnquoted: true,
    allowMissing: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var tagName, type;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        var isClose = stream.eat("/");
        tagName = "";
        var c;
        while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;
        if (!tagName) return "error";
        type = isClose ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      return "error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=<>\"\']/);
      return "word";
    }
  }

  function inAttribute(quote) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  var curState, curStream, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }

  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);
    curState.context = {
      prev: curState.context,
      tagName: tagName,
      indent: curState.indented,
      startOfLine: startOfLine,
      noIndent: noIndent
    };
  }
  function popContext() {
    if (curState.context) curState.context = curState.context.prev;
  }

  function element(type) {
    if (type == "openTag") {
      curState.tagName = tagName;
      curState.tagStart = curStream.column();
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == "closeTag") {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }
      if (err) setStyle = "error";
      return cont(endclosetag(err));
    }
    return cont();
  }
  function endtag(startOfLine) {
    return function(type) {
      var tagName = curState.tagName;
      curState.tagName = curState.tagStart = null;
      if (type == "selfcloseTag" ||
          (type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase()))) {
        maybePopContext(tagName.toLowerCase());
        return cont();
      }
      if (type == "endTag") {
        maybePopContext(tagName.toLowerCase());
        pushContext(tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }
  function endclosetag(err) {
    return function(type) {
      if (err) setStyle = "error";
      if (type == "endTag") { popContext(); return cont(); }
      setStyle = "error";
      return cont(arguments.callee);
    };
  }
  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }

  function attributes(type) {
    if (type == "word") {setStyle = "attribute"; return cont(attribute, attributes);}
    if (type == "endTag" || type == "selfcloseTag") return pass();
    setStyle = "error";
    return cont(attributes);
  }
  function attribute(type) {
    if (type == "equals") return cont(attvalue, attributes);
    if (!Kludges.allowMissing) setStyle = "error";
    else if (type == "word") setStyle = "attribute";
    return (type == "endTag" || type == "selfcloseTag") ? pass() : cont();
  }
  function attvalue(type) {
    if (type == "string") return cont(attvaluemaybe);
    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return cont();}
    setStyle = "error";
    return (type == "endTag" || type == "selfCloseTag") ? pass() : cont();
  }
  function attvaluemaybe(type) {
    if (type == "string") return cont(attvaluemaybe);
    else return pass();
  }

  return {
    startState: function() {
      return {tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, tagStart: null, context: null};
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol()) {
        state.startOfLine = true;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;

      setStyle = type = tagName = null;
      var style = state.tokenize(stream, state);
      state.type = type;
      if ((style || type) && style != "comment") {
        curState = state; curStream = stream;
        while (true) {
          var comb = state.cc.pop() || element;
          if (comb(type || style)) break;
        }
      }
      state.startOfLine = false;
      return setStyle || style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      if ((state.tokenize != inTag && state.tokenize != inText) ||
          context && context.noIndent)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      if (state.tagName) return state.tagStart + indentUnit * multilineTagIndentFactor;
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      if (context && /^<\//.test(textAfter))
        context = context.prev;
      while (context && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricChars: "/",
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: parserConfig.htmlMode ? "html" : "xml",
    helperType: parserConfig.htmlMode ? "html" : "xml"
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
// TODO actually recognize syntax of TypeScript constructs

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this")
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "class": kw("class"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        "super": kw("super"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == "\\";
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'")
      return chain(stream, state, jsTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    }
    else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, jsTokenComment);
      }
      else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      }
      else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, "/");
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
    else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function jsTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret("string", "string");
    };
  }

  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    return function(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(arguments.callee);
    };
  }

  function statement(type) {
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                   poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), commasep(expressionNoComma, "]"), poplex, maybeop);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeop);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, maybeoperatorComma);
  }
  function maybeoperatorNoComma(type, value, me) {
    if (!me) me = maybeoperatorNoComma;
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expression);
      return cont(expression);
    }
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")", "call"), commasep(expressionNoComma, ")"), poplex, me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = type + " property";
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expressionNoComma);
  }
  function getterSetter(type) {
    if (type == ":") return cont(expression);
    if (type != "variable") return cont(expect(":"), expression);
    cx.marked = "property";
    return cont(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ":") return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
    return pass();
  }
  function vardef1(type, value) {
    if (type == "variable") {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expressionNoComma, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef1, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybein);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybein(_type, value) {
    if (value == "in") return cont(expression);
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in") return cont(expression);
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return isTS ? cont(maybetype) : cont();}
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (state.tokenize != jsTokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse || /^else\b/.test(textAfter)) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? 4 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMode("css", function(config) {
  return CodeMirror.getMode(config, "text/css");
});

CodeMirror.defineMode("css-base", function(config, parserConfig) {
  "use strict";

  var indentUnit = config.indentUnit,
      hooks = parserConfig.hooks || {},
      atMediaTypes = parserConfig.atMediaTypes || {},
      atMediaFeatures = parserConfig.atMediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = !!parserConfig.allowNested,
      type = null;

  function ret(style, tp) { type = tp; return style; }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      // result[0] is style and result[1] is type
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("def", stream.current());}
    else if (ch == "=") ret(null, "compare");
    else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    }
    else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    }
    else if (ch === "-") {
      if (/\d/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    }
    else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    }
    else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    }
    else if (ch == ":") {
      return ret("operator", ch);
    }
    else if (/[;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    }
    else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "variable");
    }
    else {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "variable");
    }
  }

  function tokenString(quote, nonInclusive) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) {
        if (nonInclusive) stream.backUp(1);
        state.tokenize = tokenBase;
      }
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\']/, false))
      state.tokenize = tokenString(")", true);
    else
      state.tokenize = tokenBase;
    return ret(null, "(");
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: [],
              lastToken: null};
    },

    token: function(stream, state) {

      // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
      //
      // rule** or **ruleset:
      // A selector + braces combo, or an at-rule.
      //
      // declaration block:
      // A sequence of declarations.
      //
      // declaration:
      // A property + colon + value combo.
      //
      // property value:
      // The entire value of a property.
      //
      // component value:
      // A single piece of a property value. Like the 5px in
      // text-shadow: 0 0 5px blue;. Can also refer to things that are
      // multiple terms, like the 1-4 terms that make up the background-size
      // portion of the background shorthand.
      //
      // term:
      // The basic unit of author-facing CSS, like a single number (5),
      // dimension (5px), string ("foo"), or function. Officially defined
      //  by the CSS 2.1 grammar (look for the 'term' production)
      //
      //
      // simple selector:
      // A single atomic selector, like a type selector, an attr selector, a
      // class selector, etc.
      //
      // compound selector:
      // One or more simple selectors without a combinator. div.example is
      // compound, div > .example is not.
      //
      // complex selector:
      // One or more compound selectors chained with combinators.
      //
      // combinator:
      // The parts of selectors that express relationships. There are four
      // currently - the space (descendant combinator), the greater-than
      // bracket (child combinator), the plus sign (next sibling combinator),
      // and the tilda (following sibling combinator).
      //
      // sequence of selectors:
      // One or more of the named type of selector chained with commas.

      state.tokenize = state.tokenize || tokenBase;
      if (state.tokenize == tokenBase && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (style && typeof style != "string") style = ret(style[0], style[1]);

      // Changing style returned based on context
      var context = state.stack[state.stack.length-1];
      if (style == "variable") {
        if (type == "variable-definition") state.stack.push("propertyValue");
        return state.lastToken = "variable-2";
      } else if (style == "property") {
        var word = stream.current().toLowerCase();
        if (context == "propertyValue") {
          if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else {
            style = "variable-2";
          }
        } else if (context == "rule") {
          if (!propertyKeywords.hasOwnProperty(word)) {
            style += " error";
          }
        } else if (context == "block") {
          // if a value is present in both property, value, or color, the order
          // of preference is property -> color -> value
          if (propertyKeywords.hasOwnProperty(word)) {
            style = "property";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else {
            style = "tag";
          }
        } else if (!context || context == "@media{") {
          style = "tag";
        } else if (context == "@media") {
          if (atMediaTypes[stream.current()]) {
            style = "attribute"; // Known attribute
          } else if (/^(only|not)$/.test(word)) {
            style = "keyword";
          } else if (word == "and") {
            style = "error"; // "and" is only allowed in @mediaType
          } else if (atMediaFeatures.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in @mediaType(
          } else {
            // Unknown, expecting keyword or attribute, assuming attribute
            style = "attribute error";
          }
        } else if (context == "@mediaType") {
          if (atMediaTypes.hasOwnProperty(word)) {
            style = "attribute";
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            // Unknown attribute or property, but expecting property (preceded
            // by "and"). Should be in parentheses
            style = "error";
          }
        } else if (context == "@mediaType(") {
          if (propertyKeywords.hasOwnProperty(word)) {
            // do nothing, remains "property"
          } else if (atMediaTypes.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in parentheses
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            style += " error";
          }
        } else if (context == "@import") {
          style = "tag";
        } else {
          style = "error";
        }
      } else if (style == "atom") {
        if(!context || context == "@media{" || context == "block") {
          style = "builtin";
        } else if (context == "propertyValue") {
          if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
            style += " error";
          }
        } else {
          style = "error";
        }
      } else if (context == "@media" && type == "{") {
        style = "error";
      }

      // Push/pop context stack
      if (type == "{") {
        if (context == "@media" || context == "@mediaType") {
          state.stack.pop();
          state.stack[state.stack.length-1] = "@media{";
        }
        else {
          var newContext = allowNested ? "block" : "rule";
          state.stack.push(newContext);
        }
      }
      else if (type == "}") {
        var lastState = state.stack[state.stack.length - 1];
        if (lastState == "interpolation") style = "operator";
        state.stack.pop();
        if (context == "propertyValue") state.stack.pop();
      }
      else if (type == "interpolation") state.stack.push("interpolation");
      else if (type == "@media") state.stack.push("@media");
      else if (type == "@import") state.stack.push("@import");
      else if (context == "@media" && /\b(keyword|attribute)\b/.test(style))
        state.stack.push("@mediaType");
      else if (context == "@mediaType" && stream.current() == ",") state.stack.pop();
      else if (context == "@mediaType" && type == "(") state.stack.push("@mediaType(");
      else if (context == "@mediaType(" && type == ")") state.stack.pop();
      else if (type == ":" && state.lastToken == "property") state.stack.push("propertyValue");
      else if (context == "propertyValue" && type == ";") state.stack.pop();
      else if (context == "@import" && type == ";") state.stack.pop();
      return state.lastToken = style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;
      if (/^\}/.test(textAfter))
        n -= state.stack[state.stack.length-1] == "propertyValue" ? 2 : 1;
      return state.baseIndent + n * indentUnit;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace"
  };
});

(function() {
  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var atMediaTypes = keySet([
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ]);

  var atMediaFeatures = keySet([
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ]);

  var propertyKeywords = keySet([
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-iteration-count",
    "animation-name", "animation-play-state", "animation-timing-function",
    "appearance", "azimuth", "backface-visibility", "background",
    "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "font", "font-feature-settings", "font-family",
    "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid-cell", "grid-column", "grid-column-align",
    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",
    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",
    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "rendering-intent",
    "resize", "rest", "rest-after", "rest-before", "richness", "right",
    "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-shadow",
    "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters", "color-profile",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"
  ]);

  var colorKeywords = keySet([
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ]);

  var valueKeywords = keySet([
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "background",
    "backwards", "baseline", "below", "bidi-override", "binary", "bengali",
    "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "overlay", "overline", "padding", "padding-box", "painted",
    "paused", "persian", "plus-darker", "plus-lighter", "pointer", "portrait",
    "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "relative",
    "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ]);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    hooks: {
      "<": function(stream, state) {
        function tokenSGMLComment(stream, state) {
          var dashes = 0, ch;
          while ((ch = stream.next()) != null) {
            if (dashes >= 2 && ch == ">") {
              state.tokenize = null;
              break;
            }
            dashes = (ch == "-") ? dashes + 1 : 0;
          }
          return ["comment", "comment"];
        }
        if (stream.eat("!")) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        }
      },
      "/": function(stream, state) {
        if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }
        return false;
      }
    },
    name: "css-base"
  });

  CodeMirror.defineMIME("text/x-scss", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    allowNested: true,
    hooks: {
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.peek() == ":") {
          return ["variable", "variable-definition"];
        }
        return ["variable", "variable"];
      },
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "#": function(stream) {
        if (stream.eat("{")) {
          return ["operator", "interpolation"];
        } else {
          stream.eatWhile(/[\w\\\-]/);
          return ["atom", "hash"];
        }
      }
    },
    name: "css-base"
  });
})();
CodeMirror.defineMode("gfm", function(config) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
    startState: function() {
      return {
        code: false,
        codeBlock: false,
        ateSpace: false
      };
    },
    copyState: function(s) {
      return {
        code: s.code,
        codeBlock: s.codeBlock,
        ateSpace: s.ateSpace
      };
    },
    token: function(stream, state) {
      // Hack to prevent formatting override inside code blocks (block and inline)
      if (state.codeBlock) {
        if (stream.match(/^```/)) {
          state.codeBlock = false;
          return null;
        }
        stream.skipToEnd();
        return null;
      }
      if (stream.sol()) {
        state.code = false;
      }
      if (stream.sol() && stream.match(/^```/)) {
        stream.skipToEnd();
        state.codeBlock = true;
        return null;
      }
      // If this block is changed, it may need to be updated in Markdown mode
      if (stream.peek() === '`') {
        stream.next();
        var before = stream.pos;
        stream.eatWhile('`');
        var difference = 1 + stream.pos - before;
        if (!state.code) {
          codeDepth = difference;
          state.code = true;
        } else {
          if (difference === codeDepth) { // Must be exact
            state.code = false;
          }
        }
        return null;
      } else if (state.code) {
        stream.next();
        return null;
      }
      // Check if space. If so, links can be formatted later on
      if (stream.eatSpace()) {
        state.ateSpace = true;
        return null;
      }
      if (stream.sol() || state.ateSpace) {
        state.ateSpace = false;
        if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
          // User/Project@SHA
          // User@SHA
          // SHA
          return "link";
        } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
          // User/Project#Num
          // User#Num
          // #Num
          return "link";
        }
      }
      if (stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i)) {
        // URLs
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
        return "link";
      }
      stream.next();
      return null;
    },
    blankLine: blankLine
  };
  CodeMirror.defineMIME("gfmBase", {
    name: "markdown",
    underscoresBreakWords: false,
    taskLists: true,
    fencedCodeBlocks: true
  });
  return CodeMirror.overlayMode(CodeMirror.getMode(config, "gfmBase"), gfmOverlay);
}, "markdown");
var Liquid = {

  author: 'M@ McCray <darthapo@gmail.com>',
  version: '1.2.1',

  readTemplateFile: function(path) {
    throw ("This liquid context does not allow includes.");
  },

  registerFilters: function(filters) {
    Liquid.Template.registerFilter(filters);
  },

  parse: function(src) {
    return Liquid.Template.parse(src);
  }

};

if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(obj) {
    for (var i=0; i<this.length; i++) {
      if (this[i] == obj) return i;
    }

    return -1;
  };
}

if (!Array.prototype.clear) {
  Array.prototype.clear = function() {
    this.length = 0;
  };
}

if (!Array.prototype.map) {
  Array.prototype.map = function(fun /*, thisp*/) {
    var len = this.length;
    if (typeof fun != "function")
      throw 'Array.map requires first argument to be a function';

    var res = new Array(len);
    var thisp = arguments[1];
    for (var i = 0; i < len; i++) {
      if (i in this)
        res[i] = fun.call(thisp, this[i], i, this);
    }

    return res;
  };
}

if (!Array.prototype.first) {
  Array.prototype.first = function() {
    return this[0];
  };
}

if (!Array.prototype.last) {
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
}

if (!Array.prototype.flatten) {
  Array.prototype.flatten = function() {
    var len = this.length;
    var arr = [];
    for (var i = 0; i < len; i++) {
      if (this[i] instanceof Array) {
        arr = arr.concat(this[i]);
      } else {
        arr.push(this[i]);
      }
    }

    return arr;
  };
}

if (!Array.prototype.each) {
  Array.prototype.each = function(fun /*, thisp*/) {
    var len = this.length;
    if (typeof fun != "function")
      throw 'Array.each requires first argument to be a function';

    var thisp = arguments[1];
    for (var i = 0; i < len; i++) {
      if (i in this)
        fun.call(thisp, this[i], i, this);
    }

    return null;
  };
}

if (!Array.prototype.include) {
  Array.prototype.include = function(arg) {
    var len = this.length;

    return this.indexOf(arg) >= 0;
    for (var i = 0; i < len; i++) {
      if (arg == this[i]) return true;
    }

    return false;
  };
}


if (!String.prototype.capitalize) {
  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  };
}

if (!String.prototype.strip) {
  String.prototype.strip = function() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '');
  };
}


Liquid.extensions = {};
Liquid.extensions.object = {};

Liquid.extensions.object.update = function(newObj) {
  for (var p in newObj) {
    this[p] = newObj[p];
  }

  return this;
};

Liquid.extensions.object.hasKey = function(arg) {
  return !!this[arg];
};

Liquid.extensions.object.hasValue = function(arg) {
  for (var p in this) {
    if (this[p] == arg) return true;
  }

  return false;
};

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;

  this.Class = function(){};

  Class.extend = function(prop) {
    var _super = this.prototype;

    initializing = true;
    var prototype = new this();
    initializing = false;

    for (var name in prop) {
      prototype[name] = typeof prop[name] == "function" &&
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;

            this._super = _super[name];

            var ret = fn.apply(this, arguments);
            this._super = tmp;

            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }

    function Class() {
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }

    Class.prototype = prototype;

    Class.prototype.constructor = Class;

    Class.extend = arguments.callee;

    return Class;
  };
})();

Liquid.Tag = Class.extend({

  init: function(tagName, markup, tokens) {
    this.tagName = tagName;
    this.markup = markup;
    this.nodelist = this.nodelist || [];
    this.parse(tokens);
  },

  parse: function(tokens) {
  },

  render: function(context) {
    return '';
  }

});
Liquid.Block = Liquid.Tag.extend({

  init: function(tagName, markup, tokens){
    this.blockName = tagName;
    this.blockDelimiter = "end"+ this.blockName;
    this._super(tagName, markup, tokens);
  },

  parse: function(tokens) {
    if (!this.nodelist) this.nodelist = [];
    this.nodelist.clear();

    var token = tokens.shift();
    tokens.push(''); // To ensure we don't lose the last token passed in...
    while(tokens.length) {

      if( /^\{\%/.test(token) ) { // It's a tag...
        var tagParts = token.match(/^\{\%\s*(\w+)\s*(.*)?\%\}$/);

        if(tagParts) {
          if( this.blockDelimiter == tagParts[1] ) {
            this.endTag();
            return;
          }
          if( tagParts[1] in Liquid.Template.tags ) {
            this.nodelist.push( new Liquid.Template.tags[tagParts[1]]( tagParts[1], tagParts[2], tokens ) );
          } else {
            this.unknownTag( tagParts[1], tagParts[2], tokens );
          }
        } else {
          throw ( "Tag '"+ token +"' was not properly terminated with: %}");
        }
      } else if(/^\{\{/.test(token)) { // It's a variable...
        this.nodelist.push( this.createVariable(token) );
      } else { //if(token != '') {
        this.nodelist.push( token );
      } // Ignores tokens that are empty
      token = tokens.shift(); // Assign the next token to loop again...
    }

    this.assertMissingDelimitation();
  },

  endTag: function() {},

  unknownTag: function(tag, params, tokens) {
    switch(tag) {
      case 'else': throw (this.blockName +" tag does not expect else tag"); break;
      case 'end':  throw ("'end' is not a valid delimiter for "+ this.blockName +" tags. use "+ this.blockDelimiter); break;
      default:     throw ("Unknown tag: "+ tag);
    }
  },

  createVariable: function(token) {
    var match = token.match(/^\{\{(.*)\}\}$/);
    if(match) { return new Liquid.Variable(match[1]); }
    else { throw ("Variable '"+ token +"' was not properly terminated with: }}"); }
  },

  render: function(context) {
    return this.renderAll(this.nodelist, context);
  },

  renderAll: function(list, context) {
    return (list || []).map(function(token, i){
      var output = '';
      try { // hmmm... feels a little heavy
        output = ( token['render'] ) ? token.render(context) : token;
      } catch(e) {
        output = context.handleError(e);
      }
      return output;
    });
  },

  assertMissingDelimitation: function(){
    throw (this.blockName +" tag was never closed");
  }
});
Liquid.Document = Liquid.Block.extend({

  init: function(tokens){
    this.blockDelimiter = []; // [], really?
    this.parse(tokens);
  },

  assertMissingDelimitation: function() {
  }
});
Liquid.Strainer = Class.extend({

  init: function(context) {
    this.context = context;
  },

  respondTo: function(methodName) {
    methodName = methodName.toString();
    if (methodName.match(/^__/)) return false;
    if (Liquid.Strainer.requiredMethods.include(methodName)) return false;
    return (methodName in this);
  }
});

Liquid.Strainer.filters = {};

Liquid.Strainer.globalFilter = function(filters) {
  for (var f in filters) {
    Liquid.Strainer.filters[f] = filters[f];
  }
}

Liquid.Strainer.requiredMethods = ['respondTo', 'context'];

Liquid.Strainer.create = function(context) {
  var strainer = new Liquid.Strainer(context);
  for (var f in Liquid.Strainer.filters) {
    strainer[f] = Liquid.Strainer.filters[f];
  }
  return strainer;
}
Liquid.Context = Class.extend({

  init: function(assigns, registers, rethrowErrors) {
    this.scopes = [ assigns ? assigns : {} ];
    this.registers = registers ? registers : {};
    this.errors = [];
    this.rethrowErrors = rethrowErrors;
    this.strainer = Liquid.Strainer.create(this);
  },

  get: function(varname) {
    return this.resolve(varname);
  },

  set: function(varname, value) {
    this.scopes[0][varname] = value;
  },

  hasKey: function(key) {
    return (this.resolve(key)) ? true : false;
  },

  push: function() {
    var scpObj = {};
    this.scopes.unshift(scpObj);
    return scpObj // Is this right?
  },

  merge: function(newScope) {
    return Liquid.extensions.object.update.call(this.scopes[0], newScope);
  },

  pop: function() {
    if(this.scopes.length == 1){ throw "Context stack error"; }
    return this.scopes.shift();
  },

  stack: function(lambda, bind) {
    var result = null;
    this.push();
    try {
      result = lambda.apply(bind ? bind : this.strainer);
    } finally {
      this.pop();
    }
    return result;
  },

  invoke: function(method, args) {
    if( this.strainer.respondTo(method) ) {
      var result = this.strainer[method].apply(this.strainer, args);
      return result;
    } else {
      return (args.length == 0) ? null : args[0]; // was: $pick
    }
  },

  resolve: function(key) {
    switch(key) {
      case null:
      case 'nil':
      case 'null':
      case '':
        return null;

      case 'true':
        return true;

      case 'false':
        return false;

      case 'blank':
      case 'empty':
        return '';

      default:
        if((/^'(.*)'$/).test(key))      // Single quoted strings
          { return key.replace(/^'(.*)'$/, '$1'); }

        else if((/^"(.*)"$/).test(key)) // Double quoted strings
          { return key.replace(/^"(.*)"$/, '$1'); }

        else if((/^(\d+)$/).test(key)) // Integer...
          { return parseInt( key.replace(/^(\d+)$/ , '$1') ); }

        else if((/^(\d[\d\.]+)$/).test(key)) // Float...
          { return parseFloat( key.replace(/^(\d[\d\.]+)$/, '$1') ); }

        else if((/^\((\S+)\.\.(\S+)\)$/).test(key)) {// Ranges
          var range = key.match(/^\((\S+)\.\.(\S+)\)$/),
              left  = parseInt(range[1]),
              right = parseInt(range[2]),
              arr   = [];
          if (isNaN(left) || isNaN(right)) {
            left = range[1].charCodeAt(0);
            right = range[2].charCodeAt(0);

            var limit = right-left+1;
            for (var i=0; i<limit; i++) arr.push(String.fromCharCode(i+left));
          } else { // okay to make array
            var limit = right-left+1;
            for (var i=0; i<limit; i++) arr.push(i+left);
          }
          return arr;
        } else {
          var result = this.variable(key);
          return result;
        }
    }
  },

  findVariable: function(key) {
    for (var i=0; i < this.scopes.length; i++) {
      var scope = this.scopes[i];
      if( scope && typeof(scope[key]) !== 'undefined' ) {
        var variable = scope[key];
        if(typeof(variable) == 'function'){
          variable = variable.apply(this);
          scope[key] = variable;
        }
        if(variable && typeof(variable) == 'object' && ('toLiquid' in variable)) {
          variable = variable.toLiquid();
        }
        if(variable && typeof(variable) == 'object' && ('setContext' in variable)){
          variable.setContext(self);
        }
        return variable;
      }
    };
    return null;
  },

  variable: function(markup) {
    if(typeof markup != 'string') {
      return null;
    }

    var parts       = markup.match( /\[[^\]]+\]|(?:[\w\-]\??)+/g ),
        firstPart   = parts.shift(),
        squareMatch = firstPart.match(/^\[(.*)\]$/);

    if(squareMatch)
      { firstPart = this.resolve( squareMatch[1] ); }

    var object = this.findVariable(firstPart),
        self = this;

    if(object) {
      parts.each(function(part){
        var squareMatch = part.match(/^\[(.*)\]$/);
        if(squareMatch) {
          var part = self.resolve( squareMatch[1] );
          if( typeof(object[part]) == 'function'){ object[part] = object[part].apply(this); }// Array?
          object = object[part];
          if(typeof(object) == 'object' && ('toLiquid' in object)){ object = object.toLiquid(); }
        } else {
          if( (typeof(object) == 'object' || typeof(object) == 'hash') && (part in object)) {
            var res = object[part];
            if( typeof(res) == 'function'){ res = object[part] = res.apply(self) ; }
            if( typeof(res) == 'object' && ('toLiquid' in res)){ object = res.toLiquid(); }
            else { object = res; }
          }
          else if( (/^\d+$/).test(part) ) {
            var pos = parseInt(part);
            if( typeof(object[pos]) == 'function') { object[pos] = object[pos].apply(self); }
            if(typeof(object[pos]) == 'object' && typeof(object[pos]) == 'object' && ('toLiquid' in object[pos])) { object = object[pos].toLiquid(); }
            else { object  = object[pos]; }
          }
          else if( object && typeof(object[part]) == 'function' && ['length', 'size', 'first', 'last'].include(part) ) {
            object = object[part].apply(part);
            if('toLiquid' in object){ object = object.toLiquid(); }
          }
          else {
            return object = null;
          }
          if(typeof(object) == 'object' && ('setContext' in object)){ object.setContext(self); }
        }
      });
    }
    return object;
  },

  addFilters: function(filters) {
    filters = filters.flatten();
    filters.each(function(f){
      if(typeof(f) != 'object'){ throw ("Expected object but got: "+ typeof(f)) }
      this.strainer.addMethods(f);
    });
  },

  handleError: function(err) {
    this.errors.push(err);
    if(this.rethrowErrors){ throw err; }
    return "Liquid error: " + (err.message ? err.message : (err.description ? err.description : err));
  }

});
Liquid.Template = Class.extend({

  init: function() {
    this.root = null;
    this.registers = {};
    this.assigns = {};
    this.errors = [];
    this.rethrowErrors = false;
  },

  parse: function(src) {
    this.root = new Liquid.Document( Liquid.Template.tokenize(src) );
    return this;
  },

  render: function() {
    if(!this.root){ return ''; }
    var args = {
      ctx: arguments[0],
      filters: arguments[1],
      registers: arguments[2]
    }
    var context = null;

    if(args.ctx instanceof Liquid.Context ) {
      context = args.ctx;
      this.assigns = context.assigns;
      this.registers = context.registers;
    } else {
      if(args.ctx){
        Liquid.extensions.object.update.call(this.assigns, args.ctx);
      }
      if(args.registers){
        Liquid.extensions.object.update.call(this.registers, args.registers);
      }
      context = new Liquid.Context(this.assigns, this.registers, this.rethrowErrors)
    }

    if(args.filters){ context.addFilters(arg.filters); }

    try {
      return this.root.render(context).join('');
    } finally {
      this.errors = context.errors;
    }
  },

  renderWithErrors: function() {
    var savedRethrowErrors = this.rethrowErrors;
    this.rethrowErrors = true;
    var res = this.render.apply(this, arguments);
    this.rethrowErrors = savedRethrowErrors;
    return res;
  }
});


Liquid.Template.tags = {};

Liquid.Template.registerTag = function(name, klass) {
  Liquid.Template.tags[ name ] = klass;
}

Liquid.Template.registerFilter = function(filters) {
  Liquid.Strainer.globalFilter(filters)
}

Liquid.Template.tokenize = function(src) {
  var tokens = src.split( /(\{\%.*?\%\}|\{\{.*?\}\}?)/ );
  if(tokens[0] == ''){ tokens.shift(); }
  return tokens;
}


Liquid.Template.parse =  function(src) {
  return (new Liquid.Template()).parse(src);
}
Liquid.Variable = Class.extend({

  init: function(markup) {
    this.markup = markup;
    this.name = null;
    this.filters = [];
    var self = this;
    var match = markup.match(/\s*("[^"]+"|'[^']+'|[^\s,|]+)/);
    if( match ) {
      this.name = match[1];
      var filterMatches = markup.match(/\|\s*(.*)/);
      if(filterMatches) {
        var filters = filterMatches[1].split(/\|/);
        filters.each(function(f){
          var matches = f.match(/\s*(\w+)/);
          if(matches) {
            var filterName = matches[1];
            var filterArgs = [];
            (f.match(/(?:[:|,]\s*)("[^"]+"|'[^']+'|[^\s,|]+)/g) || []).flatten().each(function(arg){
              var cleanupMatch = arg.match(/^[\s|:|,]*(.*?)[\s]*$/);
              if(cleanupMatch)
                { filterArgs.push( cleanupMatch[1] );}
            });
            self.filters.push( [filterName, filterArgs] );
          }
        });
      }
    }
  },

  render: function(context) {
    if(this.name == null){ return ''; }
    var output = context.get(this.name);
    this.filters.each(function(filter) {
      var filterName = filter[0],
          filterArgs = (filter[1] || []).map(function(arg){
            return context.get(arg);
          });
      filterArgs.unshift(output); // Push in input value into the first argument spot...
      output = context.invoke(filterName, filterArgs);
    });

    return output;
  }
});
Liquid.Condition = Class.extend({

  init: function(left, operator, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
    this.childRelation = null;
    this.childCondition = null;
    this.attachment = null;
  },

  evaluate: function(context) {
    context = context || new Liquid.Context();
    var result = this.interpretCondition(this.left, this.right, this.operator, context);
    switch(this.childRelation) {
      case 'or':
        return (result || this.childCondition.evaluate(context));
      case 'and':
        return (result && this.childCondition.evaluate(context));
      default:
        return result;
    }
  },

  or: function(condition) {
    this.childRelation = 'or';
    this.childCondition = condition;
  },

  and: function(condition) {
    this.childRelation = 'and';
    this.childCondition = condition;
  },

  attach: function(attachment) {
    this.attachment = attachment;
    return this.attachment;
  },

  isElse: false,

  interpretCondition: function(left, right, op, context) {
    if(!op)
      { return context.get(left); }

    left = context.get(left);
    right = context.get(right);
    op = Liquid.Condition.operators[op];
    if(!op)
      { throw ("Unknown operator "+ op); }

    var results = op(left, right);
    return results;
  },

  toString: function() {
    return "<Condition "+ this.left +" "+ this.operator +" "+ this.right +">";
  }

});

Liquid.Condition.operators = {
  '==': function(l,r) {  return (l == r); },
  '=':  function(l,r) { return (l == r); },
  '!=': function(l,r) { return (l != r); },
  '<>': function(l,r) { return (l != r); },
  '<':  function(l,r) { return (l < r); },
  '>':  function(l,r) { return (l > r); },
  '<=': function(l,r) { return (l <= r); },
  '>=': function(l,r) { return (l >= r); },

  'contains': function(l,r) { return l.match(r); },
  'hasKey':   function(l,r) { return Liquid.extensions.object.hasKey.call(l, r); },
  'hasValue': function(l,r) { return Liquid.extensions.object.hasValue.call(l, r); }
}

Liquid.ElseCondition = Liquid.Condition.extend({

  isElse: true,

  evaluate: function(context) {
    return true;
  },

  toString: function() {
    return "<ElseCondition>";
  }

});
Liquid.Drop = Class.extend({
  setContext: function(context) {
    this.context = context;
  },
  beforeMethod: function(method) {

  },
  invokeDrop: function(method) {
    var results = this.beforeMethod();
    if( !results && (method in this) )
      { results = this[method].apply(this); }
    return results;
  },
  hasKey: function(name) {
    return true;
  }
});
var hackObjectEach = function(fun /*, thisp*/) {
  if (typeof fun != "function")
    throw 'Object.each requires first argument to be a function';

  var i = 0;
  var thisp = arguments[1];
  for (var p in this) {
    var value = this[p], pair = [p, value];
    pair.key = p;
    pair.value = value;
    fun.call(thisp, pair, i, this);
    i++;
  }

  return null;
};

Liquid.Template.registerTag( 'assign', Liquid.Tag.extend({

  tagSyntax: /((?:\(?[\w\-\.\[\]]\)?)+)\s*=\s*((?:"[^"]+"|'[^']+'|[^\s,|]+)+)/,

  init: function(tagName, markup, tokens) {
    var parts = markup.match(this.tagSyntax)
    if( parts ) {
      this.to   = parts[1];
      this.from = parts[2];
    } else {
      throw ("Syntax error in 'assign' - Valid syntax: assign [var] = [source]");
    }
    this._super(tagName, markup, tokens)
  },
  render: function(context) {
    context.scopes.last()[this.to.toString()] = context.get(this.from);
    return '';
  }
}));

Liquid.Template.registerTag( 'cache', Liquid.Block.extend({
  tagSyntax: /(\w+)/,

  init: function(tagName, markup, tokens) {
    var parts = markup.match(this.tagSyntax)
    if( parts ) {
      this.to = parts[1];
    } else {
      throw ("Syntax error in 'cache' - Valid syntax: cache [var]");
    }
    this._super(tagName, markup, tokens);
  },
  render: function(context) {
    var output = this._super(context);
    context.scopes.last()[this.to] = [output].flatten().join('');
    return '';
  }
}));


Liquid.Template.registerTag( 'capture', Liquid.Block.extend({
  tagSyntax: /(\w+)/,

  init: function(tagName, markup, tokens) {
    var parts = markup.match(this.tagSyntax)
    if( parts ) {
      this.to = parts[1];
    } else {
      throw ("Syntax error in 'capture' - Valid syntax: capture [var]");
    }
    this._super(tagName, markup, tokens);
  },
  render: function(context) {
    var output = this._super(context);
    context.set( this.to, [output].flatten().join('') );
    return '';
  }
}));

Liquid.Template.registerTag( 'case', Liquid.Block.extend({

  tagSyntax     : /("[^"]+"|'[^']+'|[^\s,|]+)/,
  tagWhenSyntax : /("[^"]+"|'[^']+'|[^\s,|]+)(?:(?:\s+or\s+|\s*\,\s*)("[^"]+"|'[^']+'|[^\s,|]+.*))?/,

  init: function(tagName, markup, tokens) {
    this.blocks = [];
    this.nodelist = [];

    var parts = markup.match(this.tagSyntax)
    if( parts ) {
      this.left = parts[1];
    } else {
      throw ("Syntax error in 'case' - Valid syntax: case [condition]");
    }

    this._super(tagName, markup, tokens);
  },
  unknownTag: function(tag, markup, tokens) {
    switch(tag) {
      case 'when':
        this.recordWhenCondition(markup);
        break;
      case 'else':
        this.recordElseCondition(markup);
        break;
      default:
        this._super(tag, markup, tokens);
    }

  },
  render: function(context) {
    var self = this,
        output = [],
        execElseBlock = true;

    context.stack(function(){
      for (var i=0; i < self.blocks.length; i++) {
        var block = self.blocks[i];
        if( block.isElse  ) {
          if(execElseBlock == true){ output = [output, self.renderAll(block.attachment, context)].flatten(); }
          return output;
        } else if( block.evaluate(context) ) {
          execElseBlock = false;
          output = [output, self.renderAll(block.attachment, context)].flatten();
        }
      };
    });

    return output;
  },
  recordWhenCondition: function(markup) {
    while(markup) {
      var parts = markup.match(this.tagWhenSyntax);
      if(!parts) {
        throw ("Syntax error in tag 'case' - Valid when condition: {% when [condition] [or condition2...] %} ");
      }

      markup = parts[2];

      var block = new Liquid.Condition(this.left, '==', parts[1]);
      this.blocks.push( block );
      this.nodelist = block.attach([]);
    }
  },
  recordElseCondition: function(markup) {
    if( (markup || '').strip() != '') {
      throw ("Syntax error in tag 'case' - Valid else condition: {% else %} (no parameters) ")
    }
    var block = new Liquid.ElseCondition();
    this.blocks.push(block);
    this.nodelist = block.attach([]);
  }
}));

Liquid.Template.registerTag( 'comment', Liquid.Block.extend({
  render: function(context) {
    return '';
  }
}));

Liquid.Template.registerTag( 'cycle', Liquid.Tag.extend({

  tagSimpleSyntax: /"[^"]+"|'[^']+'|[^\s,|]+/,
  tagNamedSyntax:  /("[^"]+"|'[^']+'|[^\s,|]+)\s*\:\s*(.*)/,

  init: function(tag, markup, tokens) {
    var matches, variables;
    matches = markup.match(this.tagNamedSyntax);
    if(matches) {
      this.variables = this.variablesFromString(matches[2]);
      this.name = matches[1];
    } else {
      matches = markup.match(this.tagSimpleSyntax);
      if(matches) {
        this.variables = this.variablesFromString(markup);
        this.name = "'"+ this.variables.toString() +"'";
      } else {
        throw ("Syntax error in 'cycle' - Valid syntax: cycle [name :] var [, var2, var3 ...]");
      }
    }
    this._super(tag, markup, tokens);
  },

  render: function(context) {
    var self   = this,
        key    = context.get(self.name),
        output = '';

    if(!context.registers['cycle']) {
      context.registers['cycle'] = {};
    }

    if(!context.registers['cycle'][key]) {
      context.registers['cycle'][key] = 0;
    }

    context.stack(function(){
      var iter    = context.registers['cycle'][key],
          results = context.get( self.variables[iter] );
      iter += 1;
      if(iter == self.variables.length){ iter = 0; }
      context.registers['cycle'][key] = iter;
      output = results;
    });

    return output;
  },

  variablesFromString: function(markup) {
    return markup.split(',').map(function(varname){
      var match = varname.match(/\s*("[^"]+"|'[^']+'|[^\s,|]+)\s*/);
      return (match[1]) ? match[1] : null
    });
  }
}));

Liquid.Template.registerTag( 'for', Liquid.Block.extend({
  tagSyntax: /(\w+)\s+in\s+((?:\(?[\w\-\.\[\]]\)?)+)/,

  init: function(tag, markup, tokens) {
    var matches = markup.match(this.tagSyntax);
    if(matches) {
      this.variableName = matches[1];
      this.collectionName = matches[2];
      this.name = this.variableName +"-"+ this.collectionName;
      this.attributes = {};
      var attrmarkup = markup.replace(this.tagSyntax, '');
      var attMatchs = markup.match(/(\w*?)\s*\:\s*("[^"]+"|'[^']+'|[^\s,|]+)/g);
      if(attMatchs) {
        attMatchs.each(function(pair){
          pair = pair.split(":");
          this.attributes[pair[0].strip()] = pair[1].strip();
        }, this);
      }
    } else {
      throw ("Syntax error in 'for loop' - Valid syntax: for [item] in [collection]");
    }
    this._super(tag, markup, tokens);
  },

  render: function(context) {
    var self       = this,
        output     = [],
        collection = (context.get(this.collectionName) || []),
        range      = [0, collection.length];

    if(!context.registers['for']){ context.registers['for'] = {}; }

    if(this.attributes['limit'] || this.attributes['offset']) {
      var offset   = 0,
          limit    = 0,
          rangeEnd = 0,
          segment = null;

      if(this.attributes['offset'] == 'continue')
        { offset = context.registers['for'][this.name]; }
      else
        { offset = context.get( this.attributes['offset'] ) || 0; }

      limit = context.get( this.attributes['limit'] );

      rangeEnd = (limit) ? offset + limit + 1 : collection.length;
      range = [ offset, rangeEnd - 1 ];

      context.registers['for'][this.name] = rangeEnd;
    }

    segment = collection.slice(range[0], range[1]);
    if(!segment || segment.length == 0){ return ''; }

    context.stack(function(){
      var length = segment.length;

      segment.each(function(item, index){
        context.set( self.variableName, item );
        context.set( 'forloop', {
          name:   self.name,
          length: length,
          index:  (index + 1),
          index0: index,
          rindex: (length - index),
          rindex0:(length - index - 1),
          first:  (index == 0),
          last:   (index == (length - 1))
        });
        output.push( (self.renderAll(self.nodelist, context) || []).join('') );
      });
    });

    return [output].flatten().join('');
  }
}));

Liquid.Template.registerTag( 'if', Liquid.Block.extend({

  tagSyntax: /("[^"]+"|'[^']+'|[^\s,|]+)\s*([=!<>a-z_]+)?\s*("[^"]+"|'[^']+'|[^\s,|]+)?/,

  init: function(tag, markup, tokens) {
    this.nodelist = [];
    this.blocks = [];
    this.pushBlock('if', markup);
    this._super(tag, markup, tokens);
  },

  unknownTag: function(tag, markup, tokens) {
    if( ['elsif', 'else'].include(tag) ) {
      this.pushBlock(tag, markup);
    } else {
      this._super(tag, markup, tokens);
    }
  },

  render: function(context) {
    var self = this,
        output = '';
    context.stack(function(){
      for (var i=0; i < self.blocks.length; i++) {
        var block = self.blocks[i];
        if( block.evaluate(context) ) {
          output = self.renderAll(block.attachment, context);
          return;
        }
      };
    })
    return [output].flatten().join('');
  },

  pushBlock: function(tag, markup) {
    var block;
    if(tag == 'else') {
      block = new Liquid.ElseCondition();
    } else {
      var expressions = markup.split(/\b(and|or)\b/).reverse(),
          expMatches  = expressions.shift().match( this.tagSyntax );

      if(!expMatches){ throw ("Syntax Error in tag '"+ tag +"' - Valid syntax: "+ tag +" [expression]"); }

      var condition = new Liquid.Condition(expMatches[1], expMatches[2], expMatches[3]);

      while(expressions.length > 0) {
        var operator = expressions.shift(),
            expMatches  = expressions.shift().match( this.tagSyntax );
        if(!expMatches){ throw ("Syntax Error in tag '"+ tag +"' - Valid syntax: "+ tag +" [expression]"); }

        var newCondition = new Liquid.Condition(expMatches[1], expMatches[2], expMatches[3]);
        newCondition[operator](condition);
        condition = newCondition;
      }

      block = condition;
    }
    block.attach([]);
    this.blocks.push(block);
    this.nodelist = block.attachment;
  }
}));

Liquid.Template.registerTag( 'ifchanged', Liquid.Block.extend({

  render: function(context) {
    var self = this,
        output = '';
    context.stack(function(){
      var results = self.renderAll(self.nodelist, context).join('');
      if(results != context.registers['ifchanged']) {
        output = results;
        context.registers['ifchanged'] = output;
      }
    });
    return output;
  }
}));

Liquid.Template.registerTag( 'include', Liquid.Tag.extend({

  tagSyntax: /((?:"[^"]+"|'[^']+'|[^\s,|]+)+)(\s+(?:with|for)\s+((?:"[^"]+"|'[^']+'|[^\s,|]+)+))?/,

  init: function(tag, markup, tokens) {
    var matches = (markup || '').match(this.tagSyntax);
    if(matches) {
      this.templateName = matches[1];
      this.templateNameVar = this.templateName.substring(1, this.templateName.length - 1);
      this.variableName = matches[3];
      this.attributes = {};

      var attMatchs = markup.match(/(\w*?)\s*\:\s*("[^"]+"|'[^']+'|[^\s,|]+)/g);
      if(attMatchs) {
        attMatchs.each(function(pair){
          pair = pair.split(":");
          this.attributes[pair[0].strip()] = pair[1].strip();
        }, this);
      }
    } else {
      throw ("Error in tag 'include' - Valid syntax: include '[template]' (with|for) [object|collection]");
    }
    this._super(tag, markup, tokens);
  },

  render: function(context) {
    var self     = this,
        source   = Liquid.readTemplateFile( context.get(this.templateName) ),
        partial  = Liquid.parse(source),
        variable = context.get((this.variableName || this.templateNameVar)),
        output   = '';
    context.stack(function(){
      self.attributes.each = hackObjectEach;
      self.attributes.each(function(pair){
        context.set(pair.key, context.get(pair.value));
      })

      if(variable instanceof Array) {
        output = variable.map(function(variable){
          context.set( self.templateNameVar, variable );
          return partial.render(context);
        });
      } else {
        context.set(self.templateNameVar, variable);
        output = partial.render(context);
      }
    });
    output = [output].flatten().join('');
    return output
  }
}));

Liquid.Template.registerTag( 'unless', Liquid.Template.tags['if'].extend({

  render: function(context) {
    var self = this,
        output = '';
    context.stack(function(){
      var block = self.blocks[0];
      if( !block.evaluate(context) ) {
        output = self.renderAll(block.attachment, context);
        return;
      }
      for (var i=1; i < self.blocks.length; i++) {
        var block = self.blocks[i];
        if( block.evaluate(context) ) {
          output = self.renderAll(block.attachment, context);
          return;
        }
      };
    })
    return [output].flatten().join('');
  }
}));
Liquid.Template.registerFilter({

  size: function(iterable) {
    return (iterable['length']) ? iterable.length : 0;
  },

  downcase: function(input) {
    return input.toString().toLowerCase();
  },

  upcase: function(input) {
    return input.toString().toUpperCase();
  },

  capitalize: function(input) {
    return input.toString().capitalize();
  },

  escape: function(input) {
    input = input.toString();
    input = input.replace(/&/g, '&amp;');
    input = input.replace(/</g, '&lt;');
    input = input.replace(/>/g, '&gt;');
    input = input.replace(/"/g, '&quot;');
    return input;
  },

  h: function(input) {
    input = input.toString();
    input = input.replace(/&/g, '&amp;');
    input = input.replace(/</g, '&lt;');
    input = input.replace(/>/g, '&gt;');
    input = input.replace(/"/g, '&quot;');
    return input;
  },

  truncate: function(input, length, string) {
    if(!input || input == ''){ return ''; }
    length = length || 50;
    string = string || "...";

    var seg = input.slice(0, length);
    return (input.length > length ?
            input.slice(0, length) + string :
            input);
  },

  truncatewords: function(input, words, string) {
    if(!input || input == ''){ return ''; }
    words = parseInt(words || 15);
    string = string || '...';
    var wordlist = input.toString().split(" "),
        l = Math.max((words), 0);
    return (wordlist.length > l) ? wordlist.slice(0,l).join(' ') + string : input;
  },

  truncate_words: function(input, words, string) {
    if(!input || input == ''){ return ''; }
    words = parseInt(words || 15);
    string = string || '...';
    var wordlist = input.toString().split(" "),
        l = Math.max((words), 0);
    return (wordlist.length > l) ? wordlist.slice(0,l).join(' ') + string : input;
  },

  strip_html: function(input) {
    return input.toString().replace(/<.*?>/g, '');
  },

  strip_newlines: function(input) {
    return input.toString().replace(/\n/g, '')
  },

  join: function(input, separator) {
    separator = separator ||  ' ';
    return input.join(separator);
  },

  split: function(input, separator) {
    separator = separator ||  ' ';
    return input.split(separator);
  },

  sort: function(input) {
    return input.sort();
  },

  reverse: function(input) {
    return input.reverse();
  },

  replace: function(input, string, replacement) {
    replacement = replacement || '';
    return input.toString().replace(new RegExp(string, 'g'), replacement);
  },

  replace_first: function(input, string, replacement) {
    replacement = replacement || '';
    return input.toString().replace(new RegExp(string, ""), replacement);
  },

  newline_to_br: function(input) {
    return input.toString().replace(/\n/g, "<br/>\n");
  },

  date: function(input, format) {
    var date;
    if( input instanceof Date ){ date = input; }
    if(!(date instanceof Date) && input == 'now'){ date = new Date(); }
    if(!(date instanceof Date)){ date = new Date(input); }
    if(!(date instanceof Date)){ date = new Date(Date.parse(input));}
    if(!(date instanceof Date)){ return input; } // Punt
    return date.strftime(format);
  },

  first: function(input) {
    return input[0];
  },

  last: function(input) {
    input = input;
    return input[input.length -1];
  }
});


if(!(new Date()).strftime) {(function(){
Date.ext={};Date.ext.util={};Date.ext.util.xPad=function(x,pad,r){if(typeof (r)=="undefined"){r=10}for(;parseInt(x,10)<r&&r>1;r/=10){x=pad.toString()+x}return x.toString()};Date.prototype.locale="en-GB";if(document.getElementsByTagName("html")&&document.getElementsByTagName("html")[0].lang){Date.prototype.locale=document.getElementsByTagName("html")[0].lang}Date.ext.locales={};Date.ext.locales.en={a:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],A:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],b:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],B:["January","February","March","April","May","June","July","August","September","October","November","December"],c:"%a %d %b %Y %T %Z",p:["AM","PM"],P:["am","pm"],x:"%d/%m/%y",X:"%T"};Date.ext.locales["en-US"]=Date.ext.locales.en;Date.ext.locales["en-US"].c="%a %d %b %Y %r %Z";Date.ext.locales["en-US"].x="%D";Date.ext.locales["en-US"].X="%r";Date.ext.locales["en-GB"]=Date.ext.locales.en;Date.ext.locales["en-AU"]=Date.ext.locales["en-GB"];Date.ext.formats={a:function(d){return Date.ext.locales[d.locale].a[d.getDay()]},A:function(d){return Date.ext.locales[d.locale].A[d.getDay()]},b:function(d){return Date.ext.locales[d.locale].b[d.getMonth()]},B:function(d){return Date.ext.locales[d.locale].B[d.getMonth()]},c:"toLocaleString",C:function(d){return Date.ext.util.xPad(parseInt(d.getFullYear()/100,10),0)},d:["getDate","0"],e:["getDate"," "],g:function(d){return Date.ext.util.xPad(parseInt(Date.ext.util.G(d)/100,10),0)},G:function(d){var y=d.getFullYear();var V=parseInt(Date.ext.formats.V(d),10);var W=parseInt(Date.ext.formats.W(d),10);if(W>V){y++}else{if(W===0&&V>=52){y--}}return y},H:["getHours","0"],I:function(d){var I=d.getHours()%12;return Date.ext.util.xPad(I===0?12:I,0)},j:function(d){var ms=d-new Date(""+d.getFullYear()+"/1/1 GMT");ms+=d.getTimezoneOffset()*60000;var doy=parseInt(ms/60000/60/24,10)+1;return Date.ext.util.xPad(doy,0,100)},m:function(d){return Date.ext.util.xPad(d.getMonth()+1,0)},M:["getMinutes","0"],p:function(d){return Date.ext.locales[d.locale].p[d.getHours()>=12?1:0]},P:function(d){return Date.ext.locales[d.locale].P[d.getHours()>=12?1:0]},S:["getSeconds","0"],u:function(d){var dow=d.getDay();return dow===0?7:dow},U:function(d){var doy=parseInt(Date.ext.formats.j(d),10);var rdow=6-d.getDay();var woy=parseInt((doy+rdow)/7,10);return Date.ext.util.xPad(woy,0)},V:function(d){var woy=parseInt(Date.ext.formats.W(d),10);var dow1_1=(new Date(""+d.getFullYear()+"/1/1")).getDay();var idow=woy+(dow1_1>4||dow1_1<=1?0:1);if(idow==53&&(new Date(""+d.getFullYear()+"/12/31")).getDay()<4){idow=1}else{if(idow===0){idow=Date.ext.formats.V(new Date(""+(d.getFullYear()-1)+"/12/31"))}}return Date.ext.util.xPad(idow,0)},w:"getDay",W:function(d){var doy=parseInt(Date.ext.formats.j(d),10);var rdow=7-Date.ext.formats.u(d);var woy=parseInt((doy+rdow)/7,10);return Date.ext.util.xPad(woy,0,10)},y:function(d){return Date.ext.util.xPad(d.getFullYear()%100,0)},Y:"getFullYear",z:function(d){var o=d.getTimezoneOffset();var H=Date.ext.util.xPad(parseInt(Math.abs(o/60),10),0);var M=Date.ext.util.xPad(o%60,0);return(o>0?"-":"+")+H+M},Z:function(d){return d.toString().replace(/^.*\(([^)]+)\)$/,"$1")},"%":function(d){return"%"}};Date.ext.aggregates={c:"locale",D:"%m/%d/%y",h:"%b",n:"\n",r:"%I:%M:%S %p",R:"%H:%M",t:"\t",T:"%H:%M:%S",x:"locale",X:"locale"};Date.ext.aggregates.z=Date.ext.formats.z(new Date());Date.ext.aggregates.Z=Date.ext.formats.Z(new Date());Date.ext.unsupported={};Date.prototype.strftime=function(fmt){if(!(this.locale in Date.ext.locales)){if(this.locale.replace(/-[a-zA-Z]+$/,"") in Date.ext.locales){this.locale=this.locale.replace(/-[a-zA-Z]+$/,"")}else{this.locale="en-GB"}}var d=this;while(fmt.match(/%[cDhnrRtTxXzZ]/)){fmt=fmt.replace(/%([cDhnrRtTxXzZ])/g,function(m0,m1){var f=Date.ext.aggregates[m1];return(f=="locale"?Date.ext.locales[d.locale][m1]:f)})}var str=fmt.replace(/%([aAbBCdegGHIjmMpPSuUVwWyY%])/g,function(m0,m1){var f=Date.ext.formats[m1];if(typeof (f)=="string"){return d[f]()}else{if(typeof (f)=="function"){return f.call(d,d)}else{if(typeof (f)=="object"&&typeof (f[0])=="string"){return Date.ext.util.xPad(d[f[0]](),f[1])}else{return m1}}}});d=null;return str};
})();}
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
var split;

split = split || function (undef) {

    var nativeSplit = String.prototype.split,
        compliantExecNpcg = /()??/.exec("")[1] === undef, // NPCG: nonparticipating capturing group
        self;

    self = function (str, separator, limit) {
        if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
            return nativeSplit.call(str, separator, limit);
        }
        var output = [],
            flags = (separator.ignoreCase ? "i" : "") +
                    (separator.multiline  ? "m" : "") +
                    (separator.extended   ? "x" : "") + // Proposed for ES6
                    (separator.sticky     ? "y" : ""), // Firefox 3+
            lastLastIndex = 0,
            separator = new RegExp(separator.source, flags + "g"),
            separator2, match, lastIndex, lastLength;
        str += ""; // Type-convert
        if (!compliantExecNpcg) {
            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
        }
        /* Values for `limit`, per the spec:
         * If undefined: 4294967295 // Math.pow(2, 32) - 1
         * If 0, Infinity, or NaN: 0
         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
         * If negative number: 4294967296 - Math.floor(Math.abs(limit))
         * If other: Type-convert, then use the above rules
         */
        limit = limit === undef ?
            -1 >>> 0 : // Math.pow(2, 32) - 1
            limit >>> 0; // ToUint32(limit)
        while (match = separator.exec(str)) {
            lastIndex = match.index + match[0].length;
            if (lastIndex > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));
                if (!compliantExecNpcg && match.length > 1) {
                    match[0].replace(separator2, function () {
                        for (var i = 1; i < arguments.length - 2; i++) {
                            if (arguments[i] === undef) {
                                match[i] = undef;
                            }
                        }
                    });
                }
                if (match.length > 1 && match.index < str.length) {
                    Array.prototype.push.apply(output, match.slice(1));
                }
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= limit) {
                    break;
                }
            }
            if (separator.lastIndex === match.index) {
                separator.lastIndex++; // Avoid an infinite loop
            }
        }
        if (lastLastIndex === str.length) {
            if (lastLength || !separator.test("")) {
                output.push("");
            }
        } else {
            output.push(str.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
    };

    String.prototype.split = function (separator, limit) {
        return self(this, separator, limit);
    };

    return self;

}();
;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
module.exports = {"login":"Authorize on GitHub","docheader":{"editing":"Editing","error":"Error","preview":"Previewing"},"navigation":{"newFile":"New File","edit":"Edit","preview":"Preview","settings":"Settings","meta":"Meta Data","save":"Save","login":"Authorize with GitHub","about":"About","develop":"Developers","logout":"Logout","language":"Language"},"toolbar":{"heading":"Heading","subHeading":"Sub Heading","link":"Insert Link","image":"Insert Image","bold":"Bold","italic":"Italic","blockquote":"Blockquote","list":"List","numberedlist":"Numbered List","help":"Help"},"heading":{"explore":"Explore Projects"},"actions":{"unsaved":"You have unsaved Changes. Are you sure you want to leave?","draft":{"toPost":"Draft to Post","toPostInfo":"Convert this draft into a published post"},"publishing":{"publish":"Publish","publishInfo":"This post will be published the next time you save","published":"Published","unpublish":"Unpublish","unpublished":"Unpublished","unpublishInfo":"This post will be unpublished the next time you save"},"change":{"noChange":"No Changes","submit":"Changes to Submit","save":"Changes to Save"},"delete":{"title":"Delete","warn":"Are you sure you want to delete this file?","error":"Error during deletion. Please wait 30 seconds and try again."},"upload":{"uploading":"Uploading {file}","uploaded":"Uploaded {file}"},"save":{"title":"Save","saved":"Saved","saving":"Saving","patch":"Submitting Request","fileNameError":"Needs a Filename","submission":"Request Submitted","metaError":"Error! Metadata not Found","fileNameExists":"A filename with this path already exists"},"error":"Error. Try again in 30 Seconds","restore":{"restoring":"Restoring","restored":"Restored"},"commits":{"created":"Created {filename}","updated":"Updated {filename}","deleted":"Deleted {filename}","toDraft":"Created draft of {filename}","fromDraft":"Created post from a draft of {filename}"}},"loading":{"repos":"Loading Profile","repo":"Loading Project","file":"Loading File","preview":"Previewing File","creating":"Creating new post"},"modal":{"errorHeading":"Error","confirm":"Got it"},"main":{"start":{"content":"Prose is a content editor for GitHub designed for managing websites.","learn":"Learn more"},"repos":{"filter":"Filter Projects","repo":"View Project","site":"View Site","sharedFrom":"Shared from an account","forkedFrom":"Forked from another project"},"repo":{"filter":"Filter Files","edit":"Edit","delete":"Delete this File"},"new":{"body":"## A New Post\n\nEnter text in [Markdown](http://daringfireball.net/projects/markdown/). Use the toolbar above, or click the **?** button for formatting help.\n"},"file":{"noTitle":"Untitled","metaTitle":"Review your changes:","rawMeta":"Raw Metadata","metaDescription":"Additions are highlighted in green. Deletions are crossed out.","back":"Done","createMeta":"Create New"},"upgrade":{"content":"Prose requires features not available to your browser","download":"Download a Modern Browser"}},"notification":{"loginDescription":"Please login with your GitHub account to access that project.","create":"Create it","home":"Back to Main Page","back":"Go Back","githubStatus":"Status on GitHub ({status})","error":{"label":"Error","github":"Error while loading data from GitHub. This might be a temporary issue. Please try again later.","exists":"This file does not exist","notFound":"Page not Found"}},"sidebar":{"repos":{"groups":"Groups"},"repo":{"branch":"Switch Branch","drafts":"View Drafts","history":{"label":"Most Recent History","actions":{"restore":"Restore?"}},"create":"Create New File"},"save":{"label":"Describe your Changes","cancel":"Cancel","save":"Commit","submit":"Submit Change Request"},"settings":{"title":"Options","fileInputLabel":"File Path","delete":"Delete This File","translate":"Translate to","draft":"Create Draft"}},"dialogs":{"link":{"title":"Insert Link","insertLocal":"Insert a Local Link","insert":"Insert","hrefPlaceholder":"Link URL","textPlaceholder":"Link Name","titlePlaceholder":"Title (optional)","insertPlaceholder":"Insert a local link"},"media":{"title":"Insert Image","back":"Back","hrefPlaceholder":"Image URL","altPlaceholder":"Alt text (optional)","description":"Upload images by Dragging &amp; Dropping or </br>\n{input} <a>selecting one</a>\n","help":"Images uploaded are added to the current directory or one specified in the Image URL path above.","helpMedia":"Images uploaded are added to the 'Choose Existing' directory or one specified in the Image URL field.","choose":"Choose Existing"},"help":{"blockElements":{"title":"Block Elements","content":{"paragraphs":{"title":"Paragraphs &amp; Breaks","content":"<p>To create a paragraph, simply create a block of text that is separated by one or more blank lines. Blocks of text separated by one or more blank lines will be parsed as paragraphs.</p><p>If you want to create a line break, end a line with two or more spaces, then hit Return/Enter.</p>\n"},"headers":{"title":"Headers","content":"<p>Markdown supports two header formats. The wiki editor uses the &ldquo;atx&rsquo;-style headers. Simply prefix your header text with the number of <code>#</code> characters to specify heading depth. For example: <code># Header 1</code>, <code>## Header 2</code> and <code>### Header 3</code> will be progressively smaller headers. You may end your headers with any number of hashes.</p>\n"},"blockquotes":{"title":"Blockquotes","content":"<p>Markdown creates blockquotes email-style by prefixing each line with the <code>&gt;</code>. This looks best if you decide to hard-wrap text and prefix each line with a <code>&gt;</code> character, but Markdown supports just putting <code>&gt;</code> before your paragraph.</p>\n"},"lists":{"title":"Lists","content":"<p>Markdown supports both ordered and unordered lists. To create an ordered list, simply prefix each line with a number (any number will do &mdash; this is why the editor only uses one number.) To create an unordered list, you can prefix each line with <code>*</code>, <code>+</code> or <code>-</code>.</p> List items can contain multiple paragraphs, however each paragraph must be indented by at least 4 spaces or a tab.\n"},"codeBlocks":{"title":"Code Blocks","content":"<p>Markdown wraps code blocks in pre-formatted tags to preserve indentation in your code blocks. To create a code block, indent the entire block by at least 4 spaces or one tab. Markdown will strip the extra indentation you&rsquo;ve added to the code block.</p>\n"},"horizontalRules":{"title":"Horizontal Rules","content":"<p>Horizontal rules are created by placing three or more hyphens, asterisks or underscores on a line by themselves. Spaces are allowed between the hyphens, asterisks or underscores.</p>\n"}}},"spanElements":{"title":"Span Elements","content":{"links":{"title":"Links","content":"<p>Markdown has two types of links: <strong>inline</strong> and <strong>reference</strong>. For both types of links, the text you want to display to the user is placed in square brackets. For example, if you want your link to display the text &ldquo;GitHub&rdquo;, you write <code>[GitHub]</code>.</p><p>To create an inline link, create a set of parentheses immediately after the brackets and write your URL within the parentheses. (e.g., <code>[GitHub](http://github.com/)</code>). Relative paths are allowed in inline links.</p><p>To create a reference link, use two sets of square brackets. <code>[my internal link][internal-ref]</code> will link to the internal reference <code>internal-ref</code>.</p>\n"},"emphasis":{"title":"Emphasis","content":"<p>Asterisks (<code>*</code>) and underscores (<code>_</code>) are treated as emphasis and are wrapped with an <code>&lt;em&gt;</code> tag, which usually displays as italics in most browsers. Double asterisks (<code>**</code>) or double underscores (<code>__</code>) are treated as bold using the <code>&lt;strong&gt;</code> tag. To create italic or bold text, simply wrap your words in single/double asterisks/underscores. For example, <code>**My double emphasis text**</code> becomes <strong>My double emphasis text</strong>, and <code>*My single emphasis text*</code> becomes <em>My single emphasis text</em>.</p>\n"},"code":{"title":"Code","content":"<p>To create inline spans of code, simply wrap the code in backticks (<code>`</code>). Markdown will turn <code>`myFunction`</code> into <code>myFunction</code>.</p>\n"},"images":{"title":"Images","content":"<p>Markdown image syntax looks a lot like the syntax for links; it is essentially the same syntax preceded by an exclamation point (<code>!</code>). For example, if you want to link to an image at <code>http://github.com/unicorn.png</code> with the alternate text <code>My Unicorn</code>, you would write <code>![My Unicorn](http://github.com/unicorn.png)</code>.</p>\n"}}},"miscellaneous":{"title":"Miscellaneous","content":{"automaticLinks":{"title":"Automatic Links","content":"<p>If you want to create a link that displays the actual URL, Markdown allows you to quickly wrap the URL in <code>&lt;</code> and <code>&gt;</code> to do so. For example, the link <a href=\"javascript:void(0);\">http://github.com/</a> is easily produced by writing <code>&lt;http://github.com/&gt;</code>.</p>\n"},"escaping":{"title":"Escaping","content":"<p>If you want to use a special Markdown character in your document (such as displaying literal asterisks), you can escape the character with the backslash (<code>\\\\</code>). Markdown will ignore the character directly after a backslash.</p>\n"}}}}},"chooselanguage":{"title":"Choose a Language","description":"Prose is a translated application. If you don't see your language in the list, there are spelling errors, or translations are missing, consider <a href='https://www.transifex.com/projects/p/prose'>contributing translations to the project</a>.\n"},"about":{"content":"# About\nProse provides a beatifully simple content authoring environment for\n[CMS-free websites](http://developmentseed.org/blog/2012/07/27/build-cms-free-websites/).\nIt's a web-based interface for managing content on\n[GitHub](http://github.com). Use it to create, edit, and delete files,\nand save your changes directly to GitHub. Host your website on\n[GitHub Pages](http://pages.github.com) for free, or set up your own\n[GitHub webhook server](http://developmentseed.org/blog/2013/05/01/introducing-jekyll-hook/).\n\nProse has advanced support for [Jekyll](http://jekyllrb.com/) sites and\n[markdown content](http://daringfireball.net/projects/markdown/).\nProse detects markdown posts in Jekyll sites and provides syntax\nhighlighting, a formatting toolbar, and draft previews in the site's\nfull layout.\n\nDevelopers can configure Jekyll sites to take advantage of these and\nmany more features that customize the content editing experience.\n\n## Configuring\n\nProse can be configured per repository with additional metadata in a\nJekyll site's `_config.yml` file or a separate `prose.yml` file. We offer\nProse.io as a hosted service for the latest version, or you can download\nthe source code and host it on your own. For for developer documentation,\nsee [the wiki page on GitHub](https://github.com/prose/prose/wiki).\n\n## Developing\n\nProse is an open source project. We encourage you to contribute and\nhelp us improve this application or adapt it to your needs. For\ninstructions on developing Prose, see the\n[Prose contributing guidelines](https://github.com/prose/prose/blob/gh-pages/CONTRIBUTING.md).\n\n## Getting Help\n\nWe do not offer support for Prose at this time, however if you are a\ncontent editor using Prose, you should contact the developer who gave\nyou access to it. To report technical problems with Prose, please\n[file an issue on GitHub](https://github.com/prose/prose/issues).\n\n## Credits\n\nProse is developed and maintained by\n[Development Seed](http://developmentseed.org), a creative data\nvisualization and mapping team based in Washington, DC.\n"}};
},{}],2:[function(require,module,exports){
// Automatically Generated

module.exports = [{"name":"Chinese","code":"zh"},{"name":"Dutch","code":"nl"},{"name":"English","code":"en"},{"name":"French","code":"fr"},{"name":"German","code":"de"},{"name":"Hebrew (Israel)","code":"he-IL"},{"name":"Italian","code":"it"},{"name":"Portuguese (Brazil)","code":"pt-BR"},{"name":"Romanian","code":"ro"},{"name":"Russian","code":"ru"},{"name":"Spanish","code":"es"},{"name":"Swedish","code":"sv"},{"name":"Vietnamese","code":"vi"}];
},{}],3:[function(require,module,exports){
function tryParse(obj) {
  try {
    return JSON.parse(obj);
  } catch(e) {}

  return obj;
}

function tryStringify(obj) {
  if (typeof obj !== 'object' || !JSON.stringify) return obj;
  return JSON.stringify(obj);
}

var cookie = {};

cookie.set = function(name, value, expires, path, domain) {
  var pair = escape(name) + '=' + escape(tryStringify(value));

  if (!!expires) {
    if (expires.constructor === Number) pair += ';max-age=' + expires;
    else if (expires.constructor === String) pair += ';expires=' + expires;
    else if (expires.constructor === Date)  pair += ';expires=' + expires.toUTCString();
  }

  pair += ';path=' + ((!!path) ? path : '/');
  if(!!domain) pair += ';domain=' + domain;

  document.cookie = pair;
  return cookie;
};

cookie.setObject = function(object, expire, path, domain) {
  for(var key in object) cookie.set(key, object[key], expires, path, domain);
  return cookie;
};

cookie.get = function(name) {
  var obj = cookie.getObject();
  return obj[name];
};

cookie.getObject = function() {
  var pairs = document.cookie.split(/;\s?/i);
  var object = {};
  var pair;

  for (var i in pairs) {
    if (typeof pairs[i] === 'string') {
      pair = pairs[i].split('=');
      if (pair.length <= 1) continue;
      object[unescape(pair[0])] = tryParse(unescape(pair[1]));
    }
  }

  return object;
};

cookie.unset = function(name) {
  var date = new Date(0);
  document.cookie = name + '=; expires=' + date.toUTCString();
  return cookie;
};

cookie.clear = function() {
  var obj = cookie.getObject();
  for(var key in obj) cookie.unset(key);
  return object;
};

module.exports = cookie;

},{}],4:[function(require,module,exports){
var cookie = require('./cookie');
var oauth = require('../oauth.json');

module.exports = {
  api: oauth.api || 'https://api.github.com',
  apiStatus: oauth.status || 'https://status.github.com/api/status.json',
  site: oauth.site || 'https://github.com',
  id: oauth.clientId,
  url: oauth.gatekeeperUrl,
  username: cookie.get('username'),
  auth: 'oauth'
};

},{"../oauth.json":5,"./cookie":3}],6:[function(require,module,exports){
(function(){var LOCALES = require('../translations/locales');
var en = require('../dist/en.js');

// Set locale as global variable
window.locale.en = en;
window.locale.current('en');
window.app = {};

var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var Router = require('./router');
var User = require('./models/user');
var NotificationView = require('./views/notification');
var config = require('./config');
var cookie = require('./cookie');
var auth = require('./config');
var status = require('./status');

// Set up translations
var setLanguage = (cookie.get('lang')) ? true : false;

// Check if the browsers language is supported
if (setLanguage) app.locale = cookie.get('lang');

if (app.locale && app.locale !== 'en') {
  $.getJSON('./translations/locales/' + app.locale + '.json', function(result) {
    window.locale[app.locale] = result;
    window.locale.current(app.locale);
  });
}

var user = new User();

user.authenticate({
  success: function() {
    if ('withCredentials' in new XMLHttpRequest()) {
      // Set OAuth header for all CORS requests
      $.ajaxSetup({
        headers: {
          'Authorization': config.auth === 'oauth' ?
            'token ' + cookie.get('oauth-token') :
            'Basic ' + Base64.encode(config.username + ':' + config.password)
        }
      });

      // Set an 'authenticated' class to #prose
      $('#prose').addClass('authenticated');

      // Set User model id and login from cookies
      var id = cookie.get('id');
      if (id) user.set('id', id);

      var login = cookie.get('login');
      if (login) user.set('login', login);

      user.fetch({
        success: function(model, res, options) {
          // Set authenticated user id and login cookies
          cookie.set('id', user.get('id'));
          cookie.set('login', user.get('login'));

          // Initialize router
          window.router = new Router({ user: model });

          // Start responding to routes
          Backbone.history.start();
        },
        error: function(model, res, options) {
          var apiStatus = status.githubApi(function(res) {

            var error = new NotificationView({
              'message': t('notification.error.github'),
              'options': [
                {
                  'title': t('notification.back'),
                  'link': '/'
                },
                {
                  'title': t('notification.githubStatus', {
                    status: res.status
                  }),
                  'link': '//status.github.com',
                  'className': res.status
                }
              ]
            });

            $('#prose').html(error.render().el);
          });
        }
      });
    } else {
      var upgrade = new NotificationView({
        'message': t('main.upgrade.content'),
        'options': [{
          'title': t('main.upgrade.download'),
          'link': 'https://www.google.com/intl/en/chrome/browser'
        }]
      });

      $('#prose').html(upgrade.render().el);
    }
  },
  error: function() {
    // Initialize router
    window.router = new Router();

    // Start responding to routes
    Backbone.history.start();
  }
});

})()
},{"../dist/en.js":1,"../translations/locales":2,"./models/user":7,"./router":8,"./views/notification":9,"./config":4,"./cookie":3,"./status":10,"jquery-browserify":11,"backbone":12,"underscore":13}],5:[function(require,module,exports){
module.exports={
  "api": "https://api.github.com",
  "site": "https://github.com",
  "clientId": "da429541964e3302c62f",
  "gatekeeperUrl": "https://edb-prose-gatekeeper.herokuapp.com"
}
 
},{}],11:[function(require,module,exports){
(function(){// Uses Node, AMD or browser globals to create a module.

// If you want something that will work in other stricter CommonJS environments,
// or if you need to create a circular dependency, see commonJsStrict.js

// Defines a module "returnExports" that depends another module called "b".
// Note that the name of the module is implied by the file name. It is best
// if the file name and the exported global have matching names.

// If the 'b' module also uses this type of boilerplate, then
// in the browser, it will create a global .b that is used below.

// If you do not want to support the browser global path, then you
// can remove the `root` use and the passing `this` as the first arg to
// the top function.

(function (root, factory) {
    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else {
        // Browser globals
        root.returnExports = factory();
    }
}(this, function () {/*!
 * jQuery JavaScript Library v1.8.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Thu Aug 30 2012 17:17:22 GMT-0400 (Eastern Daylight Time)
 */
return (function( window, undefined ) {
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === "complete" ) {
			// we're here because readyState === "complete" in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context && context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.8.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			"slice", core_slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" && ( !options.unique || !self.has( arg ) ) ) {
								list.push( arg );
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return typeof obj === "object" ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

	// Preliminary tests
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	input.setAttribute( "checked", "checked" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement("div");
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				// Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery.removeData( elem, type + "queue", true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			removes = ( value || "" ).split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {

					className = (" " + elem.className + " ").replace( rclass, " " );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c < cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(" " + removes[ c ] + " ") > -1 ) {
							className = className.replace( " " + removes[ c ] + " " , " " );
						}
					}
					elem.className = value ? jQuery.trim( className ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i < attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.value = value + "" );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, "events", true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = jQuery( sel, this ).index( cur ) >= 0;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8 –
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "_submit_attached", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "_change_attached", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2012 jQuery Foundation and other contributors
 *  Released under the MIT license
 *  http://sizzlejs.com/
 */
(function( window, undefined ) {

var dirruns,
	cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	document = window.document,
	docElem = document.documentElement,
	done = 0,
	slice = [].slice,
	push = [].push,

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value || true;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) > Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			return (cache[ key ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

	// For matchExpr.POS and matchExpr.needsContext
	pos = ":(nth|eq|gt|lt|first|last|even|odd)(?:\\(((?:-\\d)?\\d*)\\)|)(?=[^-]|$)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|nth|last|first)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"POS": new RegExp( pos, "ig" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem, results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector, context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function isXML( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var attr,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( Expr.attrHandle[ name ] ) {
		return Expr.attrHandle[ name ]( elem );
	}
	if ( assertAttributes || xml ) {
		return elem.getAttribute( name );
	}
	attr = elem.getAttributeNode( name );
	return attr ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			attr.specified ? attr.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	order: new RegExp( "ID|TAG" +
		(assertUsableName ? "|NAME" : "") +
		(assertUsableClassName ? "|CLASS" : "")
	),

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		},

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		"NAME": function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		"CLASS": function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr.CHILD
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match, context, xml ) {
			var unquoted, excess;
			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, context, xml, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ expando ][ className ];
			if ( !pattern ) {
				pattern = classCache( className, new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)") );
			}
			return function( elem ) {
				return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
			};
		},

		"ATTR": function( name, operator, check ) {
			if ( !operator ) {
				return function( elem ) {
					return Sizzle.attr( elem, name ) != null;
				};
			}

			return function( elem ) {
				var result = Sizzle.attr( elem, name ),
					value = result + "";

				if ( result == null ) {
					return operator === "!=";
				}

				switch ( operator ) {
					case "=":
						return value === check;
					case "!=":
						return value !== check;
					case "^=":
						return check && value.indexOf( check ) === 0;
					case "*=":
						return check && value.indexOf( check ) > -1;
					case "$=":
						return check && value.substr( value.length - check.length ) === check;
					case "~=":
						return ( " " + value + " " ).indexOf( check ) > -1;
					case "|=":
						return value === check || value.substr( 0, check.length + 1 ) === check + "-";
				}
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				var doneName = done++;

				return function( elem ) {
					var parent, diff,
						count = 0,
						node = elem;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.sizset) ) {
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.sizset = ++count;
								if ( node === elem ) {
									break;
								}
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.sizset - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument, context, xml ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.pseudos[ pseudo.toLowerCase() ];

			if ( !fn ) {
				Sizzle.error( "unsupported pseudo: " + pseudo );
			}

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( !fn[ expando ] ) {
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return function( elem ) {
						return fn( elem, 0, args );
					};
				}
				return fn;
			}

			return fn( argument, context, xml );
		}
	},

	pseudos: {
		"not": markFunction(function( selector, context, xml ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var matcher = compile( selector.replace( rtrim, "$1" ), context, xml );
			return function( elem ) {
				return !matcher( elem );
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputPseudo("radio"),
		"checkbox": createInputPseudo("checkbox"),
		"file": createInputPseudo("file"),
		"password": createInputPseudo("password"),
		"image": createInputPseudo("image"),

		"submit": createButtonPseudo("submit"),
		"reset": createButtonPseudo("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},

	setFilters: {
		"first": function( elements, argument, not ) {
			return not ? elements.slice( 1 ) : [ elements[0] ];
		},

		"last": function( elements, argument, not ) {
			var elem = elements.pop();
			return not ? elements : [ elem ];
		},

		"even": function( elements, argument, not ) {
			var results = [],
				i = not ? 1 : 0,
				len = elements.length;
			for ( ; i < len; i = i + 2 ) {
				results.push( elements[i] );
			}
			return results;
		},

		"odd": function( elements, argument, not ) {
			var results = [],
				i = not ? 0 : 1,
				len = elements.length;
			for ( ; i < len; i = i + 2 ) {
				results.push( elements[i] );
			}
			return results;
		},

		"lt": function( elements, argument, not ) {
			return not ? elements.slice( +argument ) : elements.slice( 0, +argument );
		},

		"gt": function( elements, argument, not ) {
			return not ? elements.slice( 0, +argument + 1 ) : elements.slice( +argument + 1 );
		},

		"eq": function( elements, argument, not ) {
			var elem = elements.splice( +argument, 1 );
			return not ? elements : elem;
		}
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		i = 1;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				results.splice( i--, 1 );
			}
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, context, xml, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, group, i,
		preFilters, filters,
		checkContext = !xml && context !== document,
		// Token cache should maintain spaces
		key = ( checkContext ? "<s>" : "" ) + selector.replace( rtrim, "$1<s>" ),
		cached = tokenCache[ expando ][ key ];

	if ( cached ) {
		return parseOnly ? 0 : slice.call( cached, 0 );
	}

	soFar = selector;
	groups = [];
	i = 0;
	preFilters = Expr.preFilter;
	filters = Expr.filter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				soFar = soFar.slice( match[0].length );
				tokens.selector = group;
			}
			groups.push( tokens = [] );
			group = "";

			// Need to make sure we're within a narrower context if necessary
			// Adding a descendant combinator will generate what is needed
			if ( checkContext ) {
				soFar = " " + soFar;
			}
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			group += match[0];
			soFar = soFar.slice( match[0].length );

			// Cast descendant combinators to space
			matched = tokens.push({
				part: match.pop().replace( rtrim, " " ),
				string: match[0],
				captures: match
			});
		}

		// Filters
		for ( type in filters ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				( match = preFilters[ type ](match, context, xml) )) ) {

				group += match[0];
				soFar = soFar.slice( match[0].length );
				matched = tokens.push({
					part: type,
					string: match.shift(),
					captures: match
				});
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Attach the full group as a selector
	if ( group ) {
		tokens.selector = group;
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			slice.call( tokenCache(key, groups), 0 );
}

function addCombinator( matcher, combinator, context, xml ) {
	var dir = combinator.dir,
		doneName = done++;

	if ( !matcher ) {
		// If there is no matcher to check, check against the context
		matcher = function( elem ) {
			return elem === context;
		};
	}
	return combinator.first ?
		function( elem ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 ) {
					return matcher( elem ) && elem;
				}
			}
		} :
		xml ?
			function( elem ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 ) {
						if ( matcher( elem ) ) {
							return elem;
						}
					}
				}
			} :
			function( elem ) {
				var cache,
					dirkey = doneName + "." + dirruns,
					cachedkey = dirkey + "." + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			};
}

function addMatcher( higher, deeper ) {
	return higher ?
		function( elem ) {
			var result = deeper( elem );
			return result && higher( result === true ? elem : result );
		} :
		deeper;
}

// ["TAG", ">", "ID", " ", "CLASS"]
function matcherFromTokens( tokens, context, xml ) {
	var token, matcher,
		i = 0;

	for ( ; (token = tokens[i]); i++ ) {
		if ( Expr.relative[ token.part ] ) {
			matcher = addCombinator( matcher, Expr.relative[ token.part ], context, xml );
		} else {
			matcher = addMatcher( matcher, Expr.filter[ token.part ].apply(null, token.captures.concat( context, xml )) );
		}
	}

	return matcher;
}

function matcherFromGroupMatchers( matchers ) {
	return function( elem ) {
		var matcher,
			j = 0;
		for ( ; (matcher = matchers[j]); j++ ) {
			if ( matcher(elem) ) {
				return true;
			}
		}
		return false;
	};
}

compile = Sizzle.compile = function( selector, context, xml ) {
	var group, i, len,
		cached = compilerCache[ expando ][ selector ];

	// Return a cached group function if already generated (context dependent)
	if ( cached && cached.context === context ) {
		return cached;
	}

	// Generate a function of recursive functions that can be used to check each element
	group = tokenize( selector, context, xml );
	for ( i = 0, len = group.length; i < len; i++ ) {
		group[i] = matcherFromTokens(group[i], context, xml);
	}

	// Cache the compiled function
	cached = compilerCache( selector, matcherFromGroupMatchers(group) );
	cached.context = context;
	cached.runs = cached.dirruns = 0;
	return cached;
};

function multipleContexts( selector, contexts, results, seed ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results, seed );
	}
}

function handlePOSGroup( selector, posfilter, argument, contexts, seed, not ) {
	var results,
		fn = Expr.setFilters[ posfilter.toLowerCase() ];

	if ( !fn ) {
		Sizzle.error( posfilter );
	}

	if ( selector || !(results = seed) ) {
		multipleContexts( selector || "*", contexts, (results = []), seed );
	}

	return results.length > 0 ? fn( results, argument, not ) : [];
}

function handlePOS( groups, context, results, seed ) {
	var group, part, j, groupLen, token, selector,
		anchor, elements, match, matched,
		lastIndex, currentContexts, not,
		i = 0,
		len = groups.length,
		rpos = matchExpr["POS"],
		// This is generated here in case matchExpr["POS"] is extended
		rposgroups = new RegExp( "^" + rpos.source + "(?!" + whitespace + ")", "i" ),
		// This is for making sure non-participating
		// matching groups are represented cross-browser (IE6-8)
		setUndefined = function() {
			var i = 1,
				len = arguments.length - 2;
			for ( ; i < len; i++ ) {
				if ( arguments[i] === undefined ) {
					match[i] = undefined;
				}
			}
		};

	for ( ; i < len; i++ ) {
		group = groups[i];
		part = "";
		elements = seed;
		for ( j = 0, groupLen = group.length; j < groupLen; j++ ) {
			token = group[j];
			selector = token.string;
			if ( token.part === "PSEUDO" ) {
				// Reset regex index to 0
				rpos.exec("");
				anchor = 0;
				while ( (match = rpos.exec( selector )) ) {
					matched = true;
					lastIndex = rpos.lastIndex = match.index + match[0].length;
					if ( lastIndex > anchor ) {
						part += selector.slice( anchor, match.index );
						anchor = lastIndex;
						currentContexts = [ context ];

						if ( rcombinators.test(part) ) {
							if ( elements ) {
								currentContexts = elements;
							}
							elements = seed;
						}

						if ( (not = rendsWithNot.test( part )) ) {
							part = part.slice( 0, -5 ).replace( rcombinators, "$&*" );
							anchor++;
						}

						if ( match.length > 1 ) {
							match[0].replace( rposgroups, setUndefined );
						}
						elements = handlePOSGroup( part, match[1], match[2], currentContexts, elements, not );
					}
					part = "";
				}

			}

			if ( !matched ) {
				part += selector;
			}
			matched = false;
		}

		if ( part ) {
			if ( rcombinators.test(part) ) {
				multipleContexts( part, elements || [ context ], results, seed );
			} else {
				Sizzle( part, context, results, seed ? seed.concat(elements) : elements );
			}
		} else {
			push.apply( results, elements );
		}
	}

	// Do not sort if this is a single filter
	return len === 1 ? results : Sizzle.uniqueSort( results );
}

function select( selector, context, results, seed, xml ) {
	// Remove excessive whitespace
	selector = selector.replace( rtrim, "$1" );
	var elements, matcher, cached, elem,
		i, tokens, token, lastToken, findContext, type,
		match = tokenize( selector, context, xml ),
		contextNodeType = context.nodeType;

	// POS handling
	if ( matchExpr["POS"].test(selector) ) {
		return handlePOS( match, context, results, seed );
	}

	if ( seed ) {
		elements = slice.call( seed, 0 );

	// To maintain document order, only narrow the
	// set if there is one group
	} else if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		if ( (tokens = slice.call( match[0], 0 )).length > 2 &&
				(token = tokens[0]).part === "ID" &&
				contextNodeType === 9 && !xml &&
				Expr.relative[ tokens[1].part ] ) {

			context = Expr.find["ID"]( token.captures[0].replace( rbackslash, "" ), context, xml )[0];
			if ( !context ) {
				return results;
			}

			selector = selector.slice( tokens.shift().string.length );
		}

		findContext = ( (match = rsibling.exec( tokens[0].string )) && !match.index && context.parentNode ) || context;

		// Reduce the set if possible
		lastToken = "";
		for ( i = tokens.length - 1; i >= 0; i-- ) {
			token = tokens[i];
			type = token.part;
			lastToken = token.string + lastToken;
			if ( Expr.relative[ type ] ) {
				break;
			}
			if ( Expr.order.test(type) ) {
				elements = Expr.find[ type ]( token.captures[0].replace( rbackslash, "" ), findContext, xml );
				if ( elements == null ) {
					continue;
				} else {
					selector = selector.slice( 0, selector.length - lastToken.length ) +
						lastToken.replace( matchExpr[ type ], "" );

					if ( !selector ) {
						push.apply( results, slice.call(elements, 0) );
					}

					break;
				}
			}
		}
	}

	// Only loop over the given elements once
	if ( selector ) {
		matcher = compile( selector, context, xml );
		dirruns = matcher.dirruns++;
		if ( elements == null ) {
			elements = Expr.find["TAG"]( "*", (rsibling.test( selector ) && context.parentNode) || context );
		}

		for ( i = 0; (elem = elements[i]); i++ ) {
			cachedruns = matcher.runs++;
			if ( matcher(elem) ) {
				results.push( elem );
			}
		}
	}

	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
			rbuggyQSA = [],
			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [":active"],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'/>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				if ( context.nodeType === 9 ) {
					try {
						push.apply( results, slice.call(context.querySelectorAll( selector ), 0) );
						return results;
					} catch(qsaError) {}
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var groups, i, len,
						old = context.getAttribute("id"),
						nid = old || expando,
						newContext = rsibling.test( selector ) && context.parentNode || context;

					if ( old ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}

					groups = tokenize(selector, context, xml);
					// Trailing space is unnecessary
					// There is always a context check
					nid = "[id='" + nid + "']";
					for ( i = 0, len = groups.length; i < len; i++ ) {
						groups[i] = nid + groups[i].selector;
					}
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							groups.join(",")
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( matchExpr["PSEUDO"].source, matchExpr["POS"].source, "!=" );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

// Deprecated
Expr.setFilters["nth"] = Expr.setFilters["eq"];

// Back-compat
Expr.filters = Expr.pseudos;

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( "", "find", selector );

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: "GET",
								dataType: "script",
								async: false,
								global: false,
								"throws": true
							});
						} else {
							jQuery.error("no ajax");
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === "object" ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType && context[0] || context;
	context = context.ownerDocument || context;

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit && fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

		if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i < l; i++ ) {
				elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === "undefined" ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement("div");
					safe.appendChild( div );

					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						hasBody = rtbody.test(elem);
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
					jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
	elemdisplay = {},

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, "olddisplay" );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && elem.style.display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, "display" );

			if ( !values[ index ] && display !== "none" ) {
				jQuery._data( elem, "olddisplay", display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === "boolean";

		if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			ret = computed[ name ];
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox
		)
	) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
		display = elem.css("display");
	elem.remove();

	// If the simple way fails,
	// get element's real default display by attaching it to a temp iframe
	if ( display === "none" || display === "" ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement("iframe"), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit & Firefox won't allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write("<!doctype html><html><body>");
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, "display" );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
				style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "marginRight" );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var // Document location
	ajaxLocation,
	// Document location segments
	ajaxLocParts,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery("<div>")

				// inject the contents of the document in, removing the scripts
				// to avoid any 'Permission Denied' errors in IE
				.append( responseText.replace( rscript, "" ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader("Etag");
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test( url ),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test( data );

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, "$1" + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, "$1" + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit, prevScale,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						prevScale = scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

						// Update scale, tolerating zeroes from tween.cur()
						scale = tween.cur() / target;

					// Stop looping if we've hit the mark or scale is unchanged
					} while ( scale !== 1 && scale !== prevScale );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				percent = 1 - ( remaining / animation.duration || 0 ),
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, "fxshow", true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ||
			// special check for .toggle( handler, handler, ... )
			( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var box, docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, top, left,
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure we're not dealing with a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return { top: 0, left: 0 };
	}

	box = elem.getBoundingClientRect();
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	top  = box.top  + scrollTop  - clientTop;
	left = box.left + scrollLeft - clientLeft;

	return { top: top, left: left };
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

return jQuery;

})( window ); }));

})()
},{}],14:[function(require,module,exports){
module.exports = {"app":"<% if (locale.current() === 'he-IL') { %>\r\n  <link rel='stylesheet' href='./style-rtl.css'>\r\n<% } %>\r\n\r\n<div id='loader' class='loader'></div>\r\n<div id='drawer' class='sidebar' <% if (locale.current() === 'he-IL') { %>dir='rtl'<% } %>></div>\r\n<nav id='navigation'></nav>\r\n<div id='main' <% if (locale.current() === 'he-IL') { %>dir='rtl'<% } %>></div>\r\n\r\n<div class='prose-menu dropdown-menu' <% if (locale.current() === 'he-IL') { %>dir='rtl'<% } %>>\r\n  <div class='inner clearfix'>\r\n    <a href='#' class='icon branding dropdown-hover' data-link=true>Prose</a>\r\n    <ul class='dropdown clearfix'>\r\n      <li><a href='#'>Prose</a></li>\r\n      <li><a class='about' href='./#about'><%= t('navigation.about') %></a></li>\r\n      <li><a class='help' href='https://github.com/prose/prose'><%= t('navigation.develop') %></a></li>\r\n      <li><a href='./#chooselanguage'><%= t('navigation.language') %></a></li>\r\n      <li class='divider authenticated'></li>\r\n      <li class='authenticated'>\r\n        <a href='#' class='logout'><%= t('navigation.logout') %></a>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n","breadcrumb":"<span class='slash'>/</span>\r\n<a class='path' href='#<%= trail %>/<%= url %>'><%= name %></a>\r\n","chooselanguage":"<h1><%= t('chooselanguage.title') %></h1>\r\n<ul class='fat-list round'>\r\n  <% _(chooseLanguage.languages).each(function(l) { %>\r\n    <li>\r\n    <a href='#' data-code='<%= l.code %>' class='language<% if (l.code === chooseLanguage.active) { %> active<% } %>'>\r\n        <% if (l.code === chooseLanguage.active) { %><span class='ico checkmark fr'></span><% } %>\r\n        <%= l.name %>\r\n        <small>(<%= l.code %>)</small>\r\n      </a>\r\n    </li>\r\n  <% }); %>\r\n</ul>\r\n<p><%= t('chooselanguage.description') %></p>\r\n","dialogs":{"help":"<%\r\n  function formattedClass(str) {\r\n    return str.toLowerCase().replace(/\\s/g, '-').replace('&amp;', '');\r\n  };\r\n%>\r\n\r\n<div class='col col25'>\r\n  <ul class='main-menu'>\r\n    <% _(help).each(function(mainMenu, i) { %>\r\n      <li><a href='#' class='<% if (i === 0) { %>active <% } %>' data-id='<%= formattedClass(mainMenu.menuName) %>'><%= mainMenu.menuName %></a></li>\r\n    <% }); %>\r\n  </ul>\r\n</div>\r\n\r\n<div class='col col25'>\r\n  <% _(help).each(function(mainMenu, index) { %>\r\n  <ul class='sub-menu <%= formattedClass(mainMenu.menuName) %> <% if (index === 0) { %>active<% } %>' data-id='<%= formattedClass(mainMenu.menuName) %>'>\r\n      <% _(mainMenu.content).each(function(subMenu, i) { %>\r\n        <li><a href='#' data-id='<%= formattedClass(subMenu.menuName) %>' class='<% if (index === 0 && i === 0) { %> active<% } %>'><%= subMenu.menuName %></a></li>\r\n      <% }); %>\r\n    </ul>\r\n  <% }); %>\r\n</div>\r\n\r\n<div class='col col-last prose small'>\r\n  <% _(help).each(function(mainMenu, index) { %>\r\n    <% _(mainMenu.content).each(function(d, i) { %>\r\n    <div class='help-content inner help-<%= formattedClass(d.menuName) %><% if (index === 0 && i === 0) { %> active<% } %>'>\r\n      <%= d.data %>\r\n    </div>\r\n    <% }); %>\r\n  <% }); %>\r\n</div>\r\n","link":"<div class='inner'>\r\n  <label><%= t('dialogs.link.title') %></label>\r\n  <input type='text' name='href' placeholder=\"<%= t('dialogs.link.hrefPlaceholder') %>\" />\r\n  <input type='text' name='text' placeholder=\"<%= t('dialogs.link.textPlaceholder') %>\" />\r\n  <input type='text' name='title' placeholder=\"<%= t('dialogs.link.titlePlaceholder') %>\" />\r\n\r\n  <% if (relativeLinks) { %>\r\n    <div class='collapsible'>\r\n      <select data-placeholder=\"<%= t('dialogs.link.insertPlaceholder') %>\" class='chzn-select'>\r\n        <option value></option>\r\n        <% _(relativeLinks).each(function(link) { %>\r\n        <option value='<%= link.href %>,<%= link.text %>'><%= link.text %></option>\r\n        <% }); %>\r\n      </select>\r\n    </div>\r\n  <% } %>\r\n\r\n  <a href='#' class='button round insert' data-type='link'><%= t('dialogs.link.insert') %></a>\r\n</div>\r\n","media":"<div class='inner clearfix'>\r\n\r\n  <div <% if (assetsDirectory) { %>class='col fl'<% } %>>\r\n    <label><%= t('dialogs.media.title') %></label>\r\n\r\n    <% if (writable) { %>\r\n      <div class='contain clearfix'>\r\n        <span class='ico picture-add fl'></span>\r\n        <%= description %>\r\n      </div>\r\n    <% } %>\r\n\r\n    <input type='text' name='url' placeholder=\"<%= t('dialogs.media.hrefPlaceholder')%>\" />\r\n    <input type='text' name='alt' placeholder=\"<%= t('dialogs.media.altPlaceholder')%>\" />\r\n    <a href='#' class='button round insert' data-type='media'><%= t('dialogs.link.insert') %></a>\r\n      <% if (!assetsDirectory) { %>\r\n        <small class='caption deemphasize'><%= t('dialogs.media.help') %></small>\r\n      <% } %>\r\n  </div>\r\n\r\n  <% if (assetsDirectory) { %>\r\n    <div class='col col-last fl media-listing'>\r\n      <label><%= t('dialogs.media.choose') %></label>\r\n      <ul id='media'></ul>\r\n      <small class='caption deemphasize'><%= t('dialogs.media.helpMedia') %></small>\r\n    </div>\r\n  <% } %>\r\n</div>\r\n","mediadirectory":"<% if (type === 'tree') { %>\r\n  <li class='directory'>\r\n    <span class='mask'></span>\r\n    <a class='clearfix item' href='<%= path %>'>\r\n      <span class='ico fl small inline folder'></span>\r\n      <%= name %>\r\n    </a>\r\n  </li>\r\n<% } else { %>\r\n  <li class='asset'>\r\n    <span class='mask'></span>\r\n    <a class='clearfix item' href='<%= path %>' title='<%= path %>'>\r\n      <% if (isMedia) { %>\r\n        <span class='ico fl small inline media'></span>\r\n      <% } else { %>\r\n        <span class='ico fl small inline document'></span>\r\n      <% } %>\r\n      <%= name %>\r\n    </a>\r\n  </li>\r\n<% } %>\r\n"},"drawer":"<div id='orgs'></div>\r\n<div id='branches'></div>\r\n<div id='history'></div>\r\n<div id='drafts'></div>\r\n<div id='save'></div>\r\n<div id='settings'></div>\r\n","file":"<header id='heading' class='heading limiter clearfix'></header>\r\n<div id='modal'></div>\r\n\r\n<div id='post' class='post limiter'>\r\n  <div class='editor views<% if (file.markdown) { %> markdown<% } else if (file.edb) { %> edb<% } %>'>\r\n    <div id='diff' class='view prose diff'>\r\n      <h2><%= t('main.file.metaTitle') %><br />\r\n        <span class='deemphasize small'><%= t('main.file.metaDescription') %></span>\r\n      </h2>\r\n      <div class='diff-content inner'></div>\r\n    </div>\r\n    <div id='meta' class='view round meta'></div>\r\n    <div id='edit' class='view active edit'>\r\n      <div class='topbar-wrapper'>\r\n        <div class='topbar'>\r\n          <div id='toolbar' class='containment toolbar round'></div>\r\n        </div>\r\n      </div>\r\n      <div id='drop' class='drop-mask'></div>\r\n      <div id='code' class='code round inner'></div>\r\n    </div>\r\n    <div id='preview' class='view preview prose'></div>\r\n  </div>\r\n</div>\r\n","files":"<% if (data.path && data.path !== data.rooturl) { %>\r\n  <div class='breadcrumb'>\r\n    <a class='branch' href='#<%= data.url %>'>..</a>\r\n    <% _.each(data.parts, function(part) { %>\r\n      <% if (part.name !== data.rooturl) { %>\r\n        <span class='slash'>/</span>\r\n        <a class='path' href='#<%= [data.url, part.url].join(\"/\") %>'><%= part.name %></a>\r\n      <% } %>\r\n    <% }); %>\r\n  </div>\r\n<% } %>\r\n\r\n<ul class='listing'></ul>\r\n","header":"<% if (data.alterable) { %>\r\n  <div class='round avatar'>\r\n    <%= data.avatar %>\r\n  </div>\r\n  <div class='fl details'>\r\n    <h4 class='parent-trail'><a href='#<%= data.user %>'><%= data.user %></a> / <a href='#<%= data.user %>/<%= data.repo.name %>'><%= data.repo.name %></a><% if (data.isPrivate) { %><span class='ico small inline private' title='Private Project'></span><% } %></h4>\r\n    <!-- if (isNew() && !translate) placeholder, not value -->\r\n    <input type='text' class='headerinput' data-mode='<%= data.mode %>' <% print((data.placeholder ? 'placeholder=' : 'value=') + '\"' + data.input + '\"') %>>\r\n    <div class='mask'></div>\r\n  </div>\r\n<% } else { %>\r\n  <div class='avatar round'><%= data.avatar %></div>\r\n  <div class='fl details'>\r\n    <h4><a class='user' href='#<%= data.user %>'><%= data.user %></a></h4>\r\n    <h2><a class='repo' href='#<%= data.path %>'><%= data.title %></a></h2>\r\n  </div>\r\n<% } %>\r\n","li":{"file":"<% if (file.binary) { %>\r\n  <div class='listing-icon icon round <%= file.extension %> <% if (file.media) { %>media<% } %>'></div>\r\n<% } else { %>\r\n  <a href='#<%= file.repo.owner.login %>/<%= file.repo.name %>/edit/<%= file.branch %>/<%= file.path %>' class='listing-icon'>\r\n    <span class='icon round <%= file.extension %> <% if (file.markdown) { %> md<% } %> <% if (file.media) { %> media<% } %>'></span>\r\n  </a>\r\n<% } %>\r\n\r\n<div class='details'>\r\n  <div class='actions fr clearfix'>\r\n    <% if (!file.binary) { %>\r\n      <a class='clearfix'\r\n        title=\"<%= t('main.repo.edit') %>\"\r\n        href='#<%= file.repo.owner.login %>/<%= file.repo.name %>/edit/<%= file.branch %>/<%= file.path %>'>\r\n        <%= t('main.repo.edit') %>\r\n      </a>\r\n    <% } %>\r\n    <% if (file.writable) { %>\r\n      <a\r\n        class='delete'\r\n        title=\"<%= t('main.repo.delete') %>\"\r\n        href='#'>\r\n        <span class='ico rubbish small'></span>\r\n      </a>\r\n    <% } %>\r\n  </div>\r\n  <% if (file.binary) { %>\r\n    <h3 class='title' title='<%= file.name %>'><%= file.name %></h3>\r\n  <% } else { %>\r\n    <h3 class='title' title='<%= file.name %>'><a class='clearfix'href='#<%= file.repo.owner.login %>/<%= file.repo.name %>/edit/<%= file.branch %>/<%= file.path %>'><%= file.name %></a></h3>\r\n  <% } %>\r\n  <span class='deemphasize'><%= file.jailpath %></span>\r\n</div>\r\n","folder":"<a href='#<%= folder.repo.owner.login %>/<%= folder.repo.name %>/tree/<%= folder.branch %>/<%= folder.path %>' class='listing-icon'>\r\n  <span class='icon round folder'></span>\r\n</a>\r\n\r\n<span class='details'>\r\n  <h3 class='title' title='<%= folder.name %>'>\r\n    <a href='#<%= folder.repo.owner.login %>/<%= folder.repo.name %>/tree/<%= folder.branch %>/<%= folder.path %>'>\r\n      <%= folder.name %>\r\n    </a>\r\n  </h3>\r\n  <span class='deemphasize'><%= folder.jailpath %></span>\r\n</span>\r\n","repo":"<a\r\n  class='listing-icon'\r\n  data-user='<%= repo.owner.login %>'\r\n  data-repo='<%= repo.name %>'\r\n  href='#<%= repo.owner.login %>/<%= repo.name %>'>\r\n  <% if ((repo.owner.login !== repo.login) && repo.private) { %>\r\n    <span class='icon round repo owner private' title=\"<%= t('main.repos.sharedFrom') %> (<%= repo.owner.login %>)\"></span>\r\n  <% } else if (repo.owner.login !== repo.login) { %>\r\n    <span class='icon round repo owner' title=\"<%= t('main.repos.sharedFrom') %> (<%= repo.owner.login %>)\"></span>\r\n  <% } else if (repo.fork && repo.private) { %>\r\n    <span class='icon round repo private fork' title=\"<%= t('main.repos.forkedFrom') %>\"></span>\r\n  <% } else if (repo.fork) { %>\r\n    <span class='icon round repo fork' title=\"<%= t('main.repos.forkedFrom') %>\"></span>\r\n  <% } else if (repo.private) { %>\r\n    <span class='icon round repo private'></span>\r\n  <% } else { %>\r\n    <span class='icon round repo'></span>\r\n  <% } %>\r\n</a>\r\n\r\n<div class='details'>\r\n  <div class='actions fr clearfix'>\r\n    <a\r\n      data-user='<%= repo.owner.login %>'\r\n      data-repo='<%= repo.name %>'\r\n      href='#<%= repo.owner.login %>/<%= repo.name %>'>\r\n      <%= t('main.repos.repo') %>\r\n    </a>\r\n    <% if (repo.homepage) { %>\r\n      <a href='<%= repo.homepage %>'><%= t('main.repos.site') %></a>\r\n    <% } %>\r\n  </div>\r\n  <a\r\n    data-user='<%= repo.owner.login %>'\r\n    data-repo='<%= repo.name %>'\r\n    href='#<%= repo.owner.login %>/<%= repo.name %>'>\r\n    <h3<% if (!repo.description) { %> class='title'<% } %>><%= repo.name %></h3>\r\n    <span class='deemphasize'><%= repo.description %></span>\r\n  </a>\r\n</div>\r\n"},"loading":"<div class='loading round clearfix'>\r\n  <div class='loading-icon'></div>\r\n  <span class=\"message\"></span>\r\n</div>\r\n","meta":{"button":"<div class='form-item'>\r\n  <label for='<%= meta.name %>'><%= meta.label %></label>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n  <fieldset>\r\n    <button class='metafield round <%= meta.name %>' type='button' name='<%= meta.name %>' value='<%= meta.value %>' data-on='<%= meta.on %>' data-off='<%= meta.off %>'>\r\n      <% print(value ? meta.on : meta.off); %>\r\n    </button>\r\n  </fieldset>\r\n</div>\r\n","checkbox":"<div class='form-item'>\r\n  <fieldset>\r\n    <input class='metafield' type='checkbox' name='<%= meta.name %>' value='<%= meta.value %>'<% print(meta.checked ? 'checked' : '') %> />\r\n    <label class='aside' for='<%= meta.name %>'><%= meta.label %></label>\r\n  </fieldset>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n</div>\r\n","multiselect":"<div class='form-item'>\r\n  <label for='<%= meta.name %>'><%= meta.label %></label>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n\r\n  <fieldset>\r\n    <select id='<%= meta.name %>' name='<%= meta.name %>' data-placeholder='<%= meta.placeholder %>' multiple class='metafield chzn-select'>\r\n      <% _(meta.options).each(function(o) { %>\r\n        <% if (!o.lang || o.lang === meta.lang) { %>\r\n          <% if (o.name) { %>\r\n           <option value='<%= o.value %>'><%= o.name %></option>\r\n          <% } else if (o.value) { %>\r\n           <option value='<%= o.value %>'><%= o.value %></option>\r\n          <% } else { %>\r\n           <option value='<%= o %>'><%= o %></option>\r\n          <% } %>\r\n        <% } %>\r\n      <% }); %>\r\n    </select>\r\n  </fieldset>\r\n\r\n  <% if (meta.alterable) { %>\r\n    <div class='create'>\r\n      <input type='text' class='inline' data-select='<%= meta.name %>' />\r\n      <a href='#' class='round create-select inline button' data-select='<%= meta.name %>' title=\"<%= t('main.file.createMeta') %>\"><%= t('main.file.createMeta') %></a>\r\n    </div>\r\n  <% } %>\r\n</div>\r\n","raw":"<div class='form-item'>\r\n  <label for='raw'><%= t('main.file.rawMeta') %></label>\r\n  <% if (meta.help) { %><small><%= meta.help %></small><% } %>\r\n  <fieldset>\r\n    <div name='raw' id='raw' class='metafield inner'></div>\r\n  </fieldset>\r\n</div>\r\n","select":"<div class='form-item'>\r\n  <label for='<%= meta.name %>'><%= meta.label %></label>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n\r\n  <fieldset>\r\n    <select name='<%= meta.name %>' data-placeholder='<%= meta.placeholder %>' class='metafield chzn-select'>\r\n      <% _(meta.options).each(function(o) { %>\r\n        <% if (!o.lang || o.lang === meta.lang) { %>\r\n          <% if (o.name) { %>\r\n           <option value='<%= o.value %>'><%= o.name %></option>\r\n          <% } else if (o.value) { %>\r\n           <option value='<%= o.value %>'><%= o.value %></option>\r\n          <% } else { %>\r\n           <option value='<%= o %>'><%= o %></option>\r\n          <% } %>\r\n        <% } %>\r\n      <% }); %>\r\n    </select>\r\n  </fieldset>\r\n</div>\r\n","text":"<div class='form-item'>\r\n  <label for='<%= meta.name %>'><%= meta.label %></label>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n  <fieldset>\r\n    <input class='metafield' type='text' name='<%= meta.name %>' value='<%= meta.value %>' data-type='<%= meta.type %>' placeholder='<%= meta.placeholder %>' />\r\n  </fieldset>\r\n</div>\r\n","textarea":"<div class='form-item yaml-block'>\r\n  <label for='<%= meta.name %>'><%= meta.label %></label>\r\n  <% if (meta.help) { %><small class='deemphasize'><%= meta.help %></small><% } %>\r\n  <fieldset>\r\n    <textarea class='metafield' id='<%= meta.id %>' type='text' name='<%= meta.name %>' data-type='<%= meta.type %>' placeholder='<%= meta.placeholder %>'><%= meta.value %></textarea>\r\n  </fieldset>\r\n</div>\r\n"},"metadata":"<div class='form'></div>\r\n<a href='#' class='button round finish'><%= t('main.file.back') %></a>\r\n","modal":"<div class='modal-content round'>\r\n  <div class='modal-heading inner'>\r\n    <%= t('modal.errorHeading') %>\r\n  </div>\r\n  <div class='prose inner'>\r\n    <p><%= modal.message %></p>\r\n  </div>\r\n  <div class='modal-footer inner'>\r\n    <a href='#' class='button round got-it'><%= t('modal.confirm') %></a>\r\n  </div>\r\n</div>\r\n","nav":"<ul class='mobile nav clearfix'>\r\n  <li>\r\n    <a href='#' class='toggle ico menu round'></a>\r\n  </li>\r\n</ul>\r\n\r\n<ul class='file nav clearfix'>\r\n  <li>\r\n    <a href='#' title=\"<%= t('navigation.edit') %>\" class='ico round pencil edit' data-state='edit'>\r\n      <span class='popup round arrow-right'><%= t('navigation.edit') %></span>\r\n    </a>\r\n  </li>\r\n\r\n  <li>\r\n    <a href='#' title=\"<%= t('navigation.preview') %>\" class='ico round eye blob preview' data-state='blob'>\r\n      <span class='popup round arrow-right'><%= t('navigation.preview') %></span>\r\n    </a>\r\n  </li>\r\n\r\n  <li>\r\n    <a href='#' title=\"<%= t('navigation.meta') %>\" class='ico round metadata meta' data-state='meta'>\r\n      <span class='popup round arrow-right'><%= t('navigation.meta') %></span>\r\n    </a>\r\n  </li>\r\n\r\n  <li>\r\n    <a href='#' title=\"<%= t('navigation.settings') %>\" class='ico round sprocket settings' data-state='settings' data-drawer=true>\r\n      <span class='popup round arrow-right'><%= t('navigation.settings') %></span>\r\n    </a>\r\n  </li>\r\n\r\n  <li>\r\n    <a href='#' title=\"<%= t('navigation.save') %>\" class='ico round save' data-state='save'>\r\n      <div class='status'></div>\r\n      <span class='popup round arrow-right'>\r\n        <%= t('navigation.save') %>\r\n      </span>\r\n    </a>\r\n  </li>\r\n</ul>\r\n\r\n<ul class='auth nav clearfix'>\r\n  <li>\r\n    <a class='ico round switch login' href='<%= data.login %>' title=\"<%= t('login') %>\">\r\n      <span class='popup round arrow-right'><%= t('login') %></span>\r\n    </a>\r\n  </li>\r\n</ul>\r\n","notification":"<div class='notify'>\r\n  <h2 class='icon landing error'>Prose</h2>\r\n  <div class='inner'>\r\n    <p><%= data.message %></p>\r\n    <p class='error'><%= data.error %></p>\r\n\r\n    <% _(data.options).each(function(options) { %>\r\n    <div>\r\n      <a class='button round <% if(options.className) { %><%= options.className %><% } %>' href='<%= options.link %>'><%= options.title %></a>\r\n    </div>\r\n    <% }); %>\r\n  </div>\r\n</div>\r\n","profile":"<header id='heading' class='heading limiter clearfix'></header>\r\n\r\n<div id='content' class='application content limiter'>\r\n  <div class='topbar'>\r\n    <div id='search' class='content-search round'></div>\r\n  </div>\r\n  <ul id='repos' class='projects listing'></ul>\r\n</div>\r\n","repo":"<header id='heading' class='heading limiter clearfix'></header>\r\n\r\n<div id='content' class='application content limiter'>\r\n  <div class='topbar clearfix'>\r\n    <!-- if repo and authenticated -->\r\n    <!-- #user/repo/new/branch/path -->\r\n    <div id='search' class='fl content-search round'></div>\r\n    <a href='#' class='fl button round new new-file' data-state='new'>\r\n      <%= t('navigation.newFile') %>\r\n    </a>\r\n  </div>\r\n\r\n  <div id='files'></div>\r\n</div>\r\n","search":"<span class='ico search'></span>\r\n<input type='text' id='filter' placeholder=\"<%= search.placeholder %>\" />\r\n","sidebar":{"branches":"<div class='inner'>\r\n  <h2 class='label'><%= t('sidebar.repo.branch') %></h2>\r\n  <select class='chzn-select'></select>\r\n</div>\r\n","drafts":"<a class='button round' href='#<%= link %>'><%= t('sidebar.repo.drafts') %></a>\r\n","label":"<div class='inner'>\r\n  <h2 class='label inner'><%= label %></h2>\r\n</div>\r\n","li":{"commit":"<a class='<%= data.status %>' href='#<%= [data.repo.owner.login, data.repo.name, data.mode, data.branch, data.path].join(\"/\") %>'>\r\n  <span class='ico small inline <%= data.status %>'></span>\r\n  <span class='message'><%= data.file.filename %></span>\r\n</a>\r\n"},"orgs":"<div class='inner'>\r\n  <h2 class='label'><%= t('sidebar.repos.groups') %></h2>\r\n</div>\r\n<ul class='listing'>\r\n  <li>\r\n    <a href='#<%= orgs.login.user %>' title='<%= orgs.login.user %>' data-id='<%= orgs.login.id %>'>\r\n      <%= orgs.login.user %>\r\n    </a>\r\n  </li>\r\n  <% orgs.orgs.each(function(org) {  %>\r\n  <li>\r\n    <a href='#<%= org.login %>' title='<%= org.login %>' data-id='<%= org.id %>'>\r\n      <%= org.login %>\r\n    </a>\r\n  </li>\r\n  <% }); %>\r\n</ul>\r\n","save":"<div class='inner'>\r\n  <h2 class='label'><%= t('sidebar.save.label') %></h2>\r\n</div>\r\n<div class='inner authoring'>\r\n  <div class='commit'>\r\n    <textarea class='commit-message' placeholder></textarea>\r\n    <a class='ico small cancel round' title=\"<%= t('sidebar.save.cancel') %>\" href='#' data-action='cancel'>\r\n      <span class='popup round arrow-bottom'><%= t('sidebar.save.cancel') %></span>\r\n    </a>\r\n  </div>\r\n  <a class='confirm button round' href='#' data-action='confirm'><%= writable %></a>\r\n</div>\r\n","settings":"<div class='inner'>\r\n  <h2 class='label'><%= t('sidebar.settings.title') %></h2>\r\n</div>\r\n<div class='inner authoring'>\r\n  <% if (/^_posts/.test(settings.path)) { %>\r\n    <a class='draft button round' href='#' data-action='draft'><%= t('sidebar.settings.draft') %></a>\r\n  <% } %>\r\n  \r\n  <% if (settings.languages && settings.lang !== 'yaml') { %>\r\n    <% _.each(settings.languages, function(l) { %>\r\n      <% if (l.value && (settings.metadata && (settings.metadata.lang !== l.value))) { %>\r\n        <a class='translate round button' href='#<%= l.value %>' data-action='translate'><%= t('sidebar.settings.translate') + ' ' + l.name %></a>\r\n      <% } %>\r\n    <% }); %>\r\n  <% } %>\r\n\r\n  <!-- if !isNew() and is writable -->\r\n  <a class='delete button round' href='#' data-action='destroy'><%= t('sidebar.settings.delete') %></a>\r\n</div>\r\n\r\n<% if (settings.fileInput) { %>\r\n  <div class='inner'>\r\n    <h2 class='label'><%= t('sidebar.settings.fileInputLabel') %></h2>\r\n    <input type='text' class='filepath' placeholder='<%= settings.path %>' value='<%= settings.path %>'>\r\n  </div>\r\n<% } %>\r\n"},"start":"<div class='round splash'>\r\n  <h2 class='icon landing'>Prose</h2>\r\n  <div class='inner'>\r\n    <p><%= t('main.start.content') %></p>\r\n    <p><a href='#about'><%= t('main.start.learn') %></a></p>\r\n    <a class='round button' href='<%= auth.site %>/login/oauth/authorize?client_id=<%= auth.id %>&scope=repo'><%= t('login') %></a>\r\n  </div>\r\n</div>\r\n","toolbar":"<% if (toolbar.draft) { %>\r\n  <a href='#' class='draft-to-post round contain'>\r\n    <%= t('actions.draft.toPost') %><span class='ico small checkmark'></span>\r\n    <span class='popup round arrow-top'><%= t('actions.draft.toPostInfo') %></span>\r\n  </a>\r\n<% } else { %>\r\n  <% if (toolbar.metadata && toolbar.metadata.published) { %>\r\n    <a href='#' class='publish-flag published round contain' data-state='true'>\r\n      <%= t('actions.publishing.published') %><span class='ico small checkmark'></span>\r\n    </a>\r\n  <% } else if (toolbar.metadata && !toolbar.metadata.published) { %>\r\n    <a href='#' class='publish-flag round contain' data-state='false'>\r\n      <%= t('actions.publishing.unpublished') %><span class='ico small checkmark'></span>\r\n    </a>\r\n  <% } %>\r\n<% } %>\r\n\r\n<% if (toolbar.markdown) { %>\r\n<div class='options clearfix'>\r\n  <ul class='group round clearfix'>\r\n    <li><a href='#' title=\"<%= t('toolbar.heading') %>\" data-key='heading' data-snippet='<% print(\"##\\n\\n\") %>'>h2</a></li>\r\n    <li><a href='#' title=\"<%= t('toolbar.subHeading') %>\" data-key='sub-heading' data-snippet='<% print(\"###\\n\\n\") %>'>h3</a></li>\r\n  </ul>\r\n  <ul class='group round clearfix'>\r\n    <li>\r\n      <a title=\"<%= t('toolbar.link') %>\" href='#' data-key='link' data-snippet=false data-dialog=true>\r\n        <span class='ico small link'></span>\r\n      </a>\r\n    </li>\r\n    <li>\r\n      <a title=\"<%= t('toolbar.image') %>\" href='#' data-key='media' data-snippet=false data-dialog=true>\r\n        <span class='ico small picture'></span>\r\n      </a>\r\n    </li>\r\n  </ul>\r\n  <ul class='group round clearfix'>\r\n    <li><a href='#' title=\"<%= t('toolbar.bold') %>\" data-key='bold' data-snippet='****'>B</a></li>\r\n    <li>\r\n      <a data-key='italic' href='#' title=\"<%= t('toolbar.italic') %>\" data-snippet='__'>\r\n        <span class='ico small italic'></span>\r\n      </a>\r\n    </li>\r\n  </ul>\r\n  <ul class='group round clearfix'>\r\n    <li>\r\n      <a title=\"<%= t('toolbar.blockquote') %>\"  href='#' data-key='quote' data-snippet='<% print(\"> We loved with a love that was more than love\\n\\n\"); %>'>\r\n        <span class='ico small quote'></span>\r\n      </a>\r\n    </li>\r\n    <li>\r\n      <a href='#' title=\"<%= t('toolbar.list') %>\" data-key='list' data-snippet='<% print(\"- item\\n- item\\n- item\\n\\n\"); %>'>\r\n        <span class='ico small list'></span>\r\n      </a>\r\n    </li>\r\n    <li>\r\n      <a href='#' title=\"<%= t('toolbar.numberedlist') %>\" data-key='numbered-list' data-snippet='<% print(\"1. item\\n2. item\\n3. item\\n\\n\"); %>'>\r\n        <span class='ico small numbered-list'></span>\r\n      </a>\r\n    </li>\r\n  </ul>\r\n  <ul class='group round clearfix'>\r\n    <li>\r\n    <a class='round' title=\"<%= t('toolbar.help') %>\" href='#' data-key='help' data-snippet=false data-dialog=true>\r\n        <span class='ico small question'></span>\r\n      </a>\r\n    </li>\r\n  </ul>\r\n</div>\r\n<% } %>\r\n<div id='dialog'></div>\r\n"};
},{}],13:[function(require,module,exports){
(function(){//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

})()
},{}],8:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');

var User = require('./models/user');
var Users = require('./collections/users');
var Orgs = require('./collections/orgs');

var Repo = require('./models/repo');
var File = require('./models/file');

var AppView = require('./views/app');
var NotificationView = require('./views/notification');
var StartView = require('./views/start');
var ProfileView = require('./views/profile');
var SearchView = require('./views/search');
var ReposView = require('./views/repos');
var RepoView = require('./views/repo');
var FileView = require('./views/file');
var DocumentationView = require('./views/documentation');
var ChooseLanguageView = require('./views/chooselanguage');

var templates = require('../dist/templates');
var util = require('./util');

module.exports = Backbone.Router.extend({

  routes: {
    'about(/)': 'about',
    'chooselanguage(/)': 'chooseLanguage',
    ':user(/)': 'profile',
    ':user/:repo(/)': 'repo',
    ':user/:repo/*path(/)': 'path',
    '*default': 'start'
  },

  initialize: function(options) {
    options = _.clone(options) || {};

    this.users = new Users();

    if (options.user) {
      this.user = options.user;
      this.users.add(this.user);
    }

    // Load up the main layout
    this.app = new AppView({
      el: '#prose',
      model: {},
      user: this.user
    });

    this.app.render();
  },

  chooseLanguage: function() {
    if (this.view) this.view.remove();

    this.app.loader.start(t('loading.file'));
    this.app.nav.mode('');

    this.view = new ChooseLanguageView();
    this.app.$el.find('#main').html(this.view.render().el);

    this.app.loader.done();
  },

  about: function() {
    if (this.view) this.view.remove();

    this.app.loader.start(t('loading.file'));
    this.app.nav.mode('');

    this.view = new DocumentationView();
    this.app.$el.find('#main').html(this.view.render().el);

    this.app.loader.done();
  },

  // #example-user
  // #example-organization
  profile: function(login) {
    if (this.view) this.view.remove();

    this.app.loader.start(t('loading.repos'));
    this.app.nav.mode('repos');

    util.documentTitle(login);

    var user = this.users.findWhere({ login: login });
    if (_.isUndefined(user)) {
      user = new User({ login: login });
      this.users.add(user);
    }

    var search = new SearchView({
      model: user.repos,
      mode: 'repos'
    });

    var repos = new ReposView({
      model: user.repos,
      search: search
    });

    var content = new ProfileView({
      auth: this.user,
      search: search,
      sidebar: this.app.sidebar,
      repos: repos,
      router: this,
      user: user
    });

    user.fetch({
      success: (function(model, res, options) {
        this.view = content;
        this.app.$el.find('#main').html(this.view.render().el);

        model.repos.fetch({
          success: repos.render,
          error: (function(model, xhr, options) {
            this.error(xhr);
          }).bind(this),
          complete: this.app.loader.done
        });
      }).bind(this),
      error: (function(model, xhr, options) {
        this.error(xhr);
      }).bind(this)
    });
  },

  // #example-user/example-repo
  // #example-user/example-repo/tree/example-branch/example-path
  repo: function(login, repoName, branch, path) {
    if (this.view instanceof RepoView &&
      this.view.model.get('owner').login === login &&
      this.view.model.get('name') === repoName &&
      (this.view.branch === branch ||
        (_.isUndefined(branch) &&
        this.view.branch === this.view.model.get('default_branch'))
      )) {
      this.view.files.path = path || '';
      return this.view.files.render();
    } else if (this.view) this.view.remove();

    this.app.loader.start(t('loading.repo'));
    this.app.nav.mode('repo');

    var title = repoName;
    if (branch) title = repoName + ': /' + path + ' at ' + branch;
    util.documentTitle(title);

    var user = this.users.findWhere({ login: login });
    if (_.isUndefined(user)) {
      user = new User({ login: login });
      this.users.add(user);
    }

    var repo = user.repos.findWhere({ name: repoName });
    if (_.isUndefined(repo)) {
      repo = new Repo({
        name: repoName,
        owner: {
          login: login
        }
      });
      user.repos.add(repo);
    }

    repo.fetch({
      success: (function(model, res, options) {
        var content = new RepoView({
          app: this.app,
          branch: branch,
          model: repo,
          nav: this.app.nav,
          path: path,
          router: this,
          sidebar: this.app.sidebar
        });

        this.view = content;
        this.app.$el.find('#main').html(this.view.render().el);
      }).bind(this),
      error: (function(model, xhr, options) {
        this.error(xhr);
      }).bind(this),
      complete: this.app.loader.done
    });
  },

  path: function(login, repoName, path) {
    var url = util.extractURL(path);

    switch(url.mode) {
      case 'tree':
        this.repo(login, repoName, url.branch, url.path);
        break;
      case 'new':
      case 'blob':
      case 'edit':
      case 'preview':
        this.post(login, repoName, url.mode, url.branch, url.path);
        break;
      default:
        throw url.mode;
    }
  },

  post: function(login, repoName, mode, branch, path) {
    if (this.view) this.view.remove();

    this.app.nav.mode('file');

    switch(mode) {
      case 'new':
        this.app.loader.start(t('loading.creating'));
        break;
      case 'edit':
        this.app.loader.start(t('loading.file'));
        break;
      case 'preview':
        this.app.loader.start(t('loading.preview'));
        break;
    }

    var user = this.users.findWhere({ login: login });
    if (_.isUndefined(user)) {
      user = new User({ login: login });
      this.users.add(user);
    }

    var repo = user.repos.findWhere({ name: repoName });
    if (_.isUndefined(repo)) {
      repo = new Repo({
        name: repoName,
        owner: {
          login: login
        }
      });
      user.repos.add(repo);
    }

    var file = {
      app: this.app,
      branch: branch,
      branches: repo.branches,
      mode: mode,
      nav: this.app.nav,
      name: util.extractFilename(path)[1],
      path: path,
      repo: repo,
      router: this,
      sidebar: this.app.sidebar
    };

    // TODO: defer this success function until both user and repo have been fetched
    // in paralell rather than in series
    user.fetch({
      success: (function(model, res, options) {
        repo.fetch({
          success: (function(model, res, options) {
            this.view = new FileView(file);
            this.app.$el.find('#main').html(this.view.el);
          }).bind(this),
          error: (function(model, xhr, options) {
            this.error(xhr);
          }).bind(this),
          complete: this.app.loader.done
        });
      }).bind(this),
      error: (function(model, xhr, options) {
        this.error(xhr);
      }).bind(this)
    });
  },

  preview: function(login, repoName, mode, branch, path) {
    if (this.view) this.view.remove();

    this.app.loader.start(t('loading.preview'));

    var user = this.users.findWhere({ login: login });
    if (_.isUndefined(user)) {
      user = new User({ login: login });
      this.users.add(user);
    }

    var repo = user.repos.findWhere({ name: repoName });
    if (_.isUndefined(repo)) {
      repo = new Repo({
        name: repoName,
        owner: {
          login: login
        }
      });
      user.repos.add(repo);
    }

    var file = {
      branch: branch,
      branches: repo.branches,
      mode: mode,
      nav: this.app.nav,
      name: util.extractFilename(path)[1],
      path: path,
      repo: repo,
      router: this,
      sidebar: this.app.sidebar
    };

    repo.fetch({
      success: (function(model, res, options) {
        // TODO: should this still pass through File view?
        this.view = new Preview(file);
        this.app.$el.find('#main').html(this.view.el);
      }).bind(this),
      error: (function(model, xhr, options) {
        this.error(xhr);
      }).bind(this),
      complete: this.app.loader.done
    });
  },

  start: function() {
    if (this.view) this.view.remove();

    // If user has authenticated
    if (this.user) {
      router.navigate(this.user.get('login'), {
        trigger: true,
        replace: true
      });
    } else {
      this.app.nav.mode('start');
      this.view = new StartView();
      this.app.$el.find('#main').html(this.view.render().el);
    }
  },

  notify: function(message, error, options) {
    if (this.view) this.view.remove();

    this.view = new NotificationView({
      'message': message,
      'error': error,
      'options': options
    });

    this.app.$el.find('#main').html(this.view.render().el);
    this.app.loader.stop();
  },

  error: function(xhr) {
    var message = [
      xhr.status,
      xhr.statusText
    ].join(' ');

    var error = JSON.parse(xhr.responseText).message;

    var options = [
      {
        'title': t('notification.home'),
        'link': '/'
      }
    ];

    this.notify(message, error, options);
  }
});

},{"./models/user":7,"./collections/users":15,"./collections/orgs":16,"./models/repo":17,"./models/file":18,"./views/app":19,"./views/notification":9,"./views/start":20,"./views/profile":21,"./views/search":22,"./views/repos":23,"./views/repo":24,"./views/file":25,"./views/documentation":26,"./views/chooselanguage":27,"../dist/templates":14,"./util":28,"jquery-browserify":11,"underscore":13,"backbone":12}],10:[function(require,module,exports){
var config = require('./config'); 
var $ = require('jquery-browserify'); 

module.exports = {
  githubApi: function(cb) {
    $.ajax({
      type: 'GET',
      url: config.apiStatus + '?callback=?',
      dataType: 'jsonp',
      success: function(res) {
        return cb(res);
      }
    });
  }
}

},{"./config":4,"jquery-browserify":11}],29:[function(require,module,exports){
(function(){/* We can add other JSONForm format definitions by using this syntax:
 * exports.bla = { ... };
 * Then, in another file we import this file and reference one of the format
 * specifications:
 * var jsonformformat = require('./jsonformformat.js');
 * var blaformat = jsonformformat.bla;
 *
 * The ordering of the fields are either determined by first the form and second by the schema.
 *
 *
 */
 
module.exports.prod = {
  "schema": {
  
	  /* Basic */
      "name": {
        "type": "string",
        "title": "Name *",
        "required": true
      },
      "specification": {
        "type": "string",
        "title": "Specification"
      },
      "synonyms": {
        "type": "string",
        "title": "Synonyms"
      },
      "name-english": {
        "type": "string",
        "title": "English Name"
      },
      "name-french": {
        "type": "string",
        "title": "French Name"
      },    
      "co2-value": {
        "type": "number",
        "title": "CO2-Value [kg CO2&Auml;q/kg] (*)",
		"description": "You can leave the CO2-value empty if this is a linked product."
      },      
      "id": {
        "type": "integer",
        "title": "ID *",
		/*"readonly": "readonly",*/
        "required": true
      },
	  "nutrition-id": {
	    "type": "string",
		"title": "Nutrition Data *"
	  },
	  "group-id": {
	    "type": "string",
		"title": "Product Group",
		"enum": Object.keys(ID_PROD).sort()
	  },
      "linked-id": {
        "type": "string",
        "title": "Linked with",
		"enum": Object.keys(ID_PROD).sort()
      },       
	  
	  /* Advanced */
      "tags": {
        "type": "string",
        "title": "Tags *",
        "required": true
      },
      "alternatives": {
        "type": "string",
        "title": "Alternatives"
      },
      "standard-origin": {
        "type": "string",
        "title": "Standard Origin"
      },
	  "origins": {
	    "type": "string",
		"title": "Possible origins"
	  },
      "production-names": {
        "type": "string",
        "title": "Production methods"
      },
      "production-values": {
        "type": "string",
        "title": "Production method parameters"
      },
      "production-methods": {
	    "type": "array",
		"title": "Production Methods",
		"items": {
		  "type": "string",
		  "title": "Production Method",
		  "enum": Object.keys(ID_PROC).sort()
		}
	  },
      "processing-names": {
        "type": "string",
        "title": "Degrees of processing"
      },
      "processing-values": {
        "type": "string",
        "title": "Degrees of processing parameters"
      },
      "processing-methods": {
	    "type": "array",
		"title": "Processing Methods",
		"items": {
		  "type": "string",
		  "title": "Processing Method",
		  "enum": Object.keys(ID_PROC).sort()
		}
	  },
      "conservation-names": {
        "type": "string",
        "title": "Preservation methods"
      },
      "conservation-values": {
        "type": "string",
        "title": "Preservation method parameters"
      },
      "preservation-methods": {
	    "type": "array",
		"title": "Preservation Methods",
		"items": {
		  "type": "string",
		  "title": "Preservation Method",
		  "enum": Object.keys(ID_PROC).sort()
		}
	  },	  
      "packaging-names": {
        "type": "string",
        "title": "Packaging"
      },
      "packaging-values": {
        "type": "string",
        "title": "Packaging parameters"
      },
      "packaging-methods": {
	    "type": "array",
		"title": "Packaging Methods",
		"items": {
		  "type": "string",
		  "title": "Packaging Method",
		  "enum": Object.keys(ID_PROC).sort()
		}
	  },	
      "season-begin": {
        "type": "string",
        "title": "Start of local season"
      },
      "season-end": {
        "type": "string",
        "title": "End of local season"
      },
      "combined-product": {
        "type": "boolean",
        "title": "Is a combined product"
      },
      "density": {
          "type": "number",
          "title": "Density [g/ml]"
      },
      "unit-weight": {
          "type": "number",
          "title": "Unit weight [g/piece]"
      },
      "quantity-comments": {
          "type": "textarea",
          "title": "Comments of density & unit weight"
      },
      "quantity-references": {
          "type": "textarea",
          "title": "References of density & unit weight"
      },
      "consistency": {
          "type": "string",
          "title": "Texture"
      },
      
      /* Documentation */
      "co2-calculation": {
        "type": "textarea",
        "title": "CO2 calculation path for basic CO2-value"
      },
      "calculation-process-documentation": {
        "type": "textarea",
        "title": "Calculation process documentation",
		"description": "Description of data used for CO2-calculation and important product traits"
      },	  
      "info-text": {
        "type": "string",
        "title": "Info text for cook"
      },
      "references": {
        "type": "textarea",
        "title": "References for basic CO2-value"
      }, 
	  "other-references": {
	    "type": "textarea",
	    "title": "Other references (not used)"
	  },
      "comments": {
        "type": "string",
        "title": "Comment"
      },
	  "co2-calculation-parameters": {
	    "type": "textarea",
		"title": "CO2 calculation path for different product parameters"
	  },
	  "references-parameters": {
	    "type": "string",
		"title": "References for product parameter calculation"
	  },
     "data-quality": {
        "type": "string",
        "title": "Data quality estimation"
      },      
      "author": {
        "type": "string",
        "title": "Last analyst initials"
      },	  
	  "delete": {
        "type": "boolean",
        "title": "To delete"
      }
    },
    
    "form": [
      {
        "type": "fieldset",
        "title": "Basic",
        "expandable": false,
        "items": [
          {
            "key": "name",
            "htmlClass": "h1 title heading",
            "formHtmlClass": "h1 title heading"
          },
          "specification",
          "synonyms",
          "name-english",
          "name-french",
          "co2-value",
		  {
		    "key": "id",
			"readonly": "readonly"
		  },
		  "nutrition-id",
		  {
		    "key": "group-id",
			"titleMap": ID_PROD
		  },
          {
		    "key": "linked-id",
			"titleMap": ID_PROD/*,
			"prepend":"<a onclick=\"window.open(\'http://edb.eaternity.ch/prose/#eaternity-agent/Eaternity-Datenbank/edit/gh-pages/_data/prods/\' + ID_PROD_FILE[document.getElementsByName(\'linked-id\')[0].value] + \'.json\', \'_blank\');\">Open</a>"*/
          },
        ]
      },
	  
      {
        "type": "fieldset",
        "title": "Advanced [+]",
        "expandable": true,
        "items": [
          "tags",
          "alternatives",
          "standard-origin",
          "origins",
          "production-names",
          "production-values",
          {
            "type": "fieldset",
			"title": "Production Methods [+]",
			"expandable": true,
			"items": [
              {
		        "key": "production-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC
		      }			
			]
		  },
/*
          {
            "type": "fieldset",
			"title": "Production Methods Standard [+]",
			"expandable": true,
			"items": [
              {
		        "key": "production-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC_STANDARD
		      }			
			]
		  },
		  {
            "type": "fieldset",
			"title": "Production Methods Non-Standard [+]",
			"expandable": true,
			"items": [
              {
		        "key": "production-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC_NON_STANDARD
		      }			
			]
		  },
*/
          "processing-names",
          "processing-values",
          {
            "type": "fieldset",
			"title": "Processing Methods [+]",
			"expandable": true,
			"items": [
              {
		        "key": "processing-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC
		      }			
			]
		  },
          "conservation-names",
          "conservation-values",
          {
            "type": "fieldset",
			"title": "Preservation Methods [+]",
			"expandable": true,
			"items": [
              {
		        "key": "preservation-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC
		      }			
			]
		  },
          "packaging-names",
          "packaging-values",
          {
            "type": "fieldset",
			"title": "Packaging Methods [+]",
			"expandable": true,
			"items": [
              {
		        "key": "packaging-methods",
			    "type": "checkboxes",
			    "titleMap": ID_PROC
		      }			
			]
		  },
          "season-begin",
		  "season-end",
		  "combined-product",
          "density",
          "unit-weight",
          "quantity-comments",
          "quantity-references",
		  "consistency"
        ]
      },
      {
        "type": "fieldset",
        "title": "Documentation [+]",
        "expandable": true,
        "items": [
          "co2-calculation",
          "calculation-process-documentation",
          "info-text",
          "references",
          "other-references",
          "comments",
          "co2-calculation-parameters",
          "data-quality",
          "author",
          "delete"
        ]
      }  

	  /*,
	  // Hidden submit button
	  {
		"type": "submit",
		"title": "Hidden Button!",
		"htmlClass": "hide"
	  }*/
    ],
    
    // This will be injected when an edb file is loaded. It will contain the file's values.
    "value": null,
	
	// Not really necessary to set as default is true anyway
	"validate": true,
    
    "onSubmitValid": function(values) {
      // Nothing to do
    }
	
	/*
    "onSubmit": function(errors, values) {
      // Nothing to do
    }*/
};


module.exports.nutr = {

  "schema": {
    "id": {
      "type": "string",
      "title": "ID *",
      "required": true
    },
    "name": {
      "type": "string",
      "title": "Name *",
      "required": true
    },
    "country": {
      "type": "string",
      "title": "Country"
    },
	"comment": {
	  "type": "string",
	  "title": "Comment"
	},
    "nutr-vals": {
      "type": "array",
      "items": {
        "type": "object",
        "title": "Nutritional Value",
        "properties": {
          "component-id": {
            "type": "string",
            "title": "Component Id *"/*,
            "required": "true"*/
          },
          "value": {
            "type": "number",
            "title": "Value *"/*,
            "required": "true"*/
          },
          "unit": {
            "type": "string",
            "title": "Unit *"/*,
            "required": "true"*/
          }		  
        }
      }
    }
  },
  
  "form": [
    {
      "type": "fieldset",
      "title": "Basic",
      "expandable": false,
      "items": [
	    {
          "key": "name",
		  "htmlClass": "h1 title heading",
		  "formHtmlClass": "h1 title heading"
		},		  
		  
	    "id",
        "country",
		{
		  "key": "comment",
		  "type": "textarea"
		},
		{
		  "type": "fieldset",
		  "title": "Nutritional Values [+]",
		  "expandable": true,
		  "items": [
			{
			  "type": "array",
			  "items": {
				"type": "section",
				"items": [
				  {
					"type": "fieldset",
					"expandable": false,
					"items": [
					  {
					    "key": "nutr-vals[].component-id",
						"htmlClass": "h3 title heading",
						"formHtmlClass": "h3 title heading"
					  },
					  "nutr-vals[].value",
					  "nutr-vals[].unit"
					 ]
				  }
				]
			  }
			}		  
		  ]
		}
        /*{
          "type": "tabarray",
          "items": {
            "type": "section",
			"legend": "{{value}}",
            "items": [
			  {
			    "key": "nutr-vals[]",
			    "valueInLegend": "true"
			  }		
            ]
          }
        }*//*,
		// Hidden submit button
		{
		  "type": "submit",
		  "title": "Hidden Button!",
		  "htmlClass": "hide"
		}*/
	  ]
    }
  ],
  
  "value": null,
  
  // Not really necessary to set as default is true anyway
  "validate": true,
  
  /*
  "onSubmit": function(values) {
    //alert("onSubmit was called!");
	// Nothing to do
  }
  */

  "onSubmitValid": function(values) {
    //alert("onSubmitValid was called!");
	// Nothing to do
  }


};


module.exports.proc = {
  "schema": {
  
    "name": {
      "type": "string",
      "title": "Name *",
      "required": true
    },
    "id": {
      "type": "integer",
      "title": "ID *",
      "required": true
    },
	"description": {
	  "type": "textarea",
	  "title": "Description"
	},
    "co2-value": {
      "type": "number",
      "title": "CO2-Value [kg CO2&Auml;q/kg] *",
	  "required": true
    },	
	"parameter-name": {
	  "type": "string",
	  "title": "Parameter Name"
	},
    "references": {
      "type": "textarea",
      "title": "References"
    },
    "documentation": {
      "type": "textarea",
      "title": "Documentation"
    },	
    "is-standard-process-value": {
      "type": "boolean",
      "title": "Is Standard Process Value?"
    },
    "comment": {
      "type": "textarea",
      "title": "Comment"
    }	
  },
  
  "form": {
  
        "type": "fieldset",
        "title": "Basic",
        "expandable": false,
        "items": [
          {
            "key": "name",
            "htmlClass": "h1 title heading",
            "formHtmlClass": "h1 title heading"
          },
		  {
		    "key": "id",
			"readonly": "readonly"
		  },
          "description",
		  "co2-value",
		  "parameter-name",
		  "references",
		  "documentation",
		  "is-standard-process-value",
		  "comment"
		]
  },
  
  "value": null,
  
  "validate": true,
  
  "onSubmitValid": function(values) {
    //alert("onSubmitValid was called!");
    // Nothing to do
  }
};

// Add other JSONForm format definitions
// exports.ntr = { "schema": { ... }, "form": [ ... ], "value": null, "onSubmitValid": ... };
})()
},{}],30:[function(require,module,exports){
module.exports = function() {
  Liquid.readTemplateFile = (function(path) {
    var file = this.collection.findWhere({ path: '_includes/' + path });
    if (file) {
      return file.getContentSync().responseText;
    } else {
      throw ("File Not Found:" + path);
    }
  }).bind(this);

  // This is the include tag from Jekyll see: http://git.io/PsVGwg
  Liquid.Template.registerTag( 'include', Liquid.Tag.extend({

    paramSyntax: /([\w-]+)\s*=\s*(?:"([^"\\]*(?:\\.[^"\\]*)*)"|'([^'\\]*(?:\\.[^'\\]*)*)'|([\w\.-]+))/,

    init: function(tag, markup, tokens) {
      var fileParamMatches = (markup || '').strip().split(/\s+(.+)?/);
      if (fileParamMatches) {
        this.templateName = fileParamMatches[0];
        this.rawParams = fileParamMatches[1];
      } else {
        throw ("Error in tag 'include " + markup + "' - Valid syntax: {% include file.ext param='value' param2='value' %}");
      }
      this._super(tag, markup, tokens);
    },

    render: function(context) {
      var resolvedName = this.retrieve_variable(this.templateName, context) || this.templateName;
      var targetTemplate = Liquid.readTemplateFile(resolvedName);
      var partial = Liquid.parse(targetTemplate);

      // Load context with parameters
      var params = this.parseParams(this.rawParams, context);
      context.set('include', params);

      var output = partial.render(context);
      output = [output].flatten().join('');
      return output;
    },

    // Test for the possibility of {{variable}} and check the context
    retrieve_variable: function(possiblePath, context) {
      var match = possiblePath.match(/\{\{([\w\-\.]+)\}\}/);
      if (match) {
        var variable = context.get(match[1]);
        if (variable) {
          return variable;
        } else {
          throw ("No variable " + match[1] + "was found in include tag");
        }
      }
    },

    parseParams: function(rawParams, context) {
      var params = {};
      var markup = rawParams || '';
      var match;
      while ((match = markup.match(this.paramSyntax))) {
        // Cut off current parameter
        markup = markup.substr(match[0].length);

        var value;
        if (match[2]) {
          value = match[2].replace(/\\"/g, '"');
        } else if (match[3]) {
          value = match[3].replace(/\\'/g, "'");
        } else if (match[4]) {
          value = context.get(match[4]); // Its a variable most likely
         }
        params[match[1]] = value;
      }
      return params;
    }
  }));


  Liquid.Block.prototype.renderAll = function(list, context) {
    return (list || []).map(function(token, i){
      var output = '';
      try { // hmmm... feels a little heavy
        output = ( token['render'] ) ? token.render(context) : token;
      } catch(e) {
        console.log(context.handleError(e));
      }
      return output;
    });
  };

  Liquid.Template.registerTag( 'highlight', Liquid.Block.extend({
    tagSyntax: /(\w+)/,

    init: function(tagName, markup, tokens) {
      var parts = markup.match(this.tagSyntax);
      if( parts ) {
        this.to = parts[1];
      } else {
        throw ("Syntax error in 'highlight' - Valid syntax: hightlight [language]");
      }
      this._super(tagName, markup, tokens);
    },
    render: function(context) {
      var output = this._super(context);
      return '<pre>' + output[0] + '</pre>';
    }
  }));

  // Unless tag wasn't properly returning output
  Liquid.Template.registerTag( 'unless', Liquid.Template.tags['if'].extend({

    render: function(context) {
      var self = this,
          output = '';
      context.stack(function(){
        var block = self.blocks[0];
        if( !block.evaluate(context) ) {
          output = self.renderAll(block.attachment, context);
          return;
        }
        for (var i=1; i < self.blocks.length; i++) {
          var block = self.blocks[i];
          if( block.evaluate(context) ) {
            output = self.renderAll(block.attachment, context);
            return;
          }
        };
      });
      return [output].flatten().join('');
    }
  }));

  Liquid.Block.prototype.unknownTag = function(tag, params, tokens) {
    switch(tag) {
      case 'else': console.log(this.blockName +" tag does not expect else tag"); break;
      case 'end':  console.log("'end' is not a valid delimiter for "+ this.blockName +" tags. use "+ this.blockDelimiter); break;
      default:     console.log("Unknown tag: "+ tag);
    }
  };

  // Contains should work with strings or arrays
  Liquid.Condition.operators.contains = function(l,r) {
    if (typeof l === 'object') {
      return l.include(r);
    } else {
      return (l.indexOf(r) !== -1);
    }
  }

  // Don't use regex for replace functions. Messes up '.'
  Liquid.Template.registerFilter({
    replace: function(input, string, replacement) {
      replacement = replacement || '';
      return input.toString().split(string).join(replacement);
    },

    replace_first: function(input, string, replacement) {
      replacement = replacement || '';
      return input.toString().replace(string, replacement);
    }
  });
}

},{}],31:[function(require,module,exports){
module.exports = {
  dragEnter: function(e) {
    $(e.currentTarget).addClass('drag-over');
    e.stopPropagation();
    e.preventDefault();
    return false;
  },

  dragOver: function(e) {
    e.originalEvent.dataTransfer.dropEffect = 'copy';
    e.stopPropagation();
    e.preventDefault();
    return false;
  },

  dragLeave: function($el, e) {
    $el.removeClass('drag-over');
    e.stopPropagation();
    e.preventDefault();
    return false;
  },

  dragDrop: function($el, cb) {
    $el.on('dragenter', (function(e) {
      this.dragEnter(e);
    }).bind(this))
    .on('dragover', this.dragOver);

    $el.find('#drop').on('dragleave', (function(e) {
      this.dragLeave($el, e);
    }).bind(this))
    .on('drop', (function(e) {
      this.drop(e, cb);
    }).bind(this));
  },

  fileSelect: function(e, cb) {
    var files = e.target.files;
    this.compileResult(files, cb);
  },

  drop: function(e, cb) {
    e.preventDefault();
    $(e.currentTarget).removeClass('drag-over');

    e = e.originalEvent
    var files = e.dataTransfer.files;
    this.compileResult(files, cb);
  },

  compileResult: function(files, cb) {
    for (var i = 0, f; f = files[i]; i++) {
      // TODO: add size validation, warn > 50MB, reject > 100MB
      // https://help.github.com/articles/working-with-large-files

      // Only upload images
      // TODO: remove this filter, allow uploading any binary file?
      if (/image/.test(f.type)) {
        var reader = new FileReader();

        reader.onload = (function(currentFile) {
          return function(e) {
            cb(e, currentFile, e.target.result);
          };
        })(f);

        reader.readAsBinaryString(f);
      }
    };
  }
}

},{}],9:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../dist/templates');
var util = require('../util');

module.exports = Backbone.View.extend({
  id: 'notification',

  className: 'notification round',

  template: templates.notification,

  events: {
    'click .create': 'createPost'
  },

  initialize: function(options) {
    options = _.clone(options) || {};
    _.bindAll(this);

    this.message = options.message;
    this.error = options.error;
    this.options = options.options;
  },

  render: function() {
    util.documentTitle(t('docheader.error'));

    var data = {
      message: this.message,
      error: this.error,
      options: this.options
    }

    this.$el.html(_.template(this.template, data, {
      variable: 'data'
    }));

    return this;
  },

  createPost: function (e) {
    var hash = window.location.hash.split('/');
    hash[2] = 'new';

    var path = hash[hash.length - 1].split('?');
    hash[hash.length - 1] = path[0] + '?file=' + path[0];

    // append query string
    if (path.length > 1) {
      hash[hash.length - 1]  += '&' + path[1];
    }

    router.navigate(_(hash).compact().join('/'), { trigger: true });
    return false;
  }
});

},{"../../dist/templates":14,"../util":28,"backbone":12,"jquery-browserify":11,"underscore":13}],7:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');

var Backbone = require('backbone');
var Repos = require('../collections/repos');
var Orgs = require('../collections/orgs');

// TODO Pass Notification view here if something goes wrong?
var NotificationView = require('../views/notification');

var auth = require('../config');
var cookie = require('../cookie');
var templates = require('../../dist/templates');

module.exports = Backbone.Model.extend({
  initialize: function(attributes, options) {
    this.repos = new Repos([], { user: this });
    this.orgs = new Orgs([], { user: this });
  },

  authenticate: function(options) {
    var match;

    if (cookie.get('oauth-token')) {
      if (_.isFunction(options.success)) options.success();
    } else {
      match = window.location.href.match(/\?code=([a-z0-9]*)/);

      if (match) {
        var ajax = $.ajax(auth.url + '/authenticate/' + match[1], {
          success: function(data) {
            cookie.set('oauth-token', data.token);

            var regex = new RegExp("(?:\\/)?\\?code=" + match[1]);
            window.location.href = window.location.href.replace(regex, '');

            if (_.isFunction(options.success)) options.success();
          }
        });
      } else {
        if (_.isFunction(options.error)) options.error();
      }
    }
  },

  url: function() {
    var id = cookie.get('id');
    var token = cookie.get('oauth-token');

    // Return '/user' if authenticated but no user id cookie has been set yet
    // or if this model's id matches authenticated user id
    return auth.api + ((token && _.isUndefined(id)) || (id && this.get('id') === id) ?
      '/user' : '/users/' + this.get('login'));
  }
});

},{"../collections/repos":32,"../collections/orgs":16,"../views/notification":9,"../config":4,"../cookie":3,"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],12:[function(require,module,exports){
(function(){//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);

})()
},{"underscore":13}],28:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var templates = require('../dist/templates');
var chrono = require('chrono');

module.exports = {

  // Cleans up a string for use in urls
  stringToUrl: function(string) {
    // Change non-alphanumeric characters to dashes, trim excess dashes
    return string.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-*$/, '');
  },

  // Extract a Jekyll date format from a filename
  extractDate: function(string) {
    var match = string.match(/^\d{4}-\d{2}-\d{2}/);
    return match ? match[0] : '';
  },

  // Extract filename from a given path
  // -------
  //
  // this.extractFilename('path/to/foo.md')
  // => ['path/to', 'foo.md']

  extractFilename: function(path) {
    var regex = /\//;
    if (!regex.test(path)) return ['', path];
    var matches = path.match(/(.*)\/(.*)$/);
    return [matches[1], matches[2]];
  },

  validPathname: function(path) {
    var regex = /^([a-zA-Z0-9_\-]|\.)+$/;
    return _.all(path.split('/'), function(filename) {
      return !!regex.test(filename);
    });
  },

  parentPath: function(path) {
    return path.replace(/\/?[a-zA-Z0-9_\-]*$/, '');
  },

  // Extract parts of the path
  // into a state from the router
  // -------

  extractURL: function(url) {
    url = url.split('/');

    return {
      mode: url[0],
      branch: url[1],
      path: (url.slice(2) || []).join('/')
    };
  },

  // Determine mode for CodeMirror
  // -------

  mode: function(extension) {
    if (this.isMarkdown(extension)) return 'gfm';
    if (_.include(['js', 'json'], extension)) return 'javascript';
    if (extension === 'html') return 'htmlmixed';
    if (extension === 'rb') return 'ruby';
    if (/(yml|yaml)/.test(extension)) return 'yaml';
    if (_.include(['java', 'c', 'cpp', 'cs', 'php'], extension)) return 'clike';

    return extension;
  },

  // Check if a given file has YAML frontmater
  // -------

  hasMetadata: function(content) {
    var regex = /^(---\n)((.|\n)*?)\n---\ne?/;
    content = content.replace(/\r\n/g, '\n'); // normalize a little bit
    return regex.test(content);
  },

  // Extract file extension
  // -------

  extension: function(file) {
    var match = file.match(/\.(\w+)$/);
    return match ? match[1] : null;
  },

  // Does the root of the path === _drafts?
  // -------

  draft: function(path) {
    return (path.split('/')[0] === '_drafts') ? true : false
  },

  // Determine types
  // -------

  markdown: function(file) {
    var regex = new RegExp(/.(md|mkdn?|mdown|markdown)$/);
    return !!(regex.test(file));
  },

  // chunked path
  // -------
  //
  // this.chunkedPath('path/to/foo')
  // =>
  // [
  //   { url: 'path',        name: 'path' },
  //   { url: 'path/to',     name: 'to' },
  //   { url: 'path/to/foo', name: 'foo' }
  // ]

  chunkedPath: function(path) {
    var chunks = path.split('/');
    return _.map(chunks, function(chunk, index) {
      var url = [];
      for (var i = 0; i <= index; i++) {
        url.push(chunks[i]);
      }
      return {
        url: url.join('/'),
        name: chunk
      };
    });
  },

  isBinary: function(path) {
    var regex = new RegExp(".(jpeg|jpg|gif|png|ico|eot|ttf|woff|otf|zip|swf|mov|dbf|index|prj|shp|shx|DS_Store|crx|glyphs)$", 'i');
    return !!(regex.test(path));
  },

  //isProd: function(extension) {
  // var regex = new RegExp("^(prod)$", 'i');
  //	return !!(regex.test(extension));
  //},
  
  isProd: function(path) {
    var regex = new RegExp("-prod.json$", 'i');
	return !!(regex.test(path));
  },
  
  isNutr: function(path) {
    var regex = new RegExp("-nutr.json$", 'i');
	return !!(regex.test(path));
  }, 

  isProc: function(path) {
    var regex = new RegExp("-proc.json$", 'i');
	return !!(regex.test(path));
  }, 
  
  isMarkdown: function(extension) {
    var regex = new RegExp("^(md|mkdn?|mdown|markdown)$", 'i');
    return !!(regex.test(extension));
  },

  isMedia: function(extension) {
    var regex = new RegExp("^(jpeg|jpg|gif|png|swf|mov)$", 'i');
    return !!(regex.test(extension));
  },

  isImage: function(extension) {
    var regex = new RegExp("^(jpeg|jpg|gif|png|svg*)$", 'i');
    return !!(regex.test(extension));
  },

  // Return a true or false boolean if a path
  // a absolute or not.
  // -------

  absolutePath: function(path) {
    return /^https?:\/\//i.test(path);
  },

  // Concatenate path + file to full filepath
  // -------

  filepath: function(path, file) {
    return (path ? path + '/' : '') + file;
  },

  // Returns a filename without the file extension
  // -------

  filename: function(file) {
    return file.replace(/\.[^\/.]+$/, '');
  },

  // String Manipulations
  // -------
  trim: function(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  },

  lTrim: function(str) {
    return str.replace(/^\s\s*/, '');
  },

  // UI Stuff
  // -------

  documentTitle: function(title) {
    document.title = title + ' · Prose';
  },

  fixedScroll: function($el, offset) {
    $(window).scroll(function(e) {
      var y = $(this).scrollTop();
      if (y >= offset) {
        $el.addClass('fixed');
      } else {
        $el.removeClass('fixed');
      }
    });
  },

  pageListing: function(handler) {
    if ($('.item').hasClass('active')) {
      var index = parseInt($('.item.active').data('index'), 10);
      var offset;

      $('.item.active').removeClass('active');

      function inView(el) {
          var curTop = el.offset().top;
          var screenHeight = $(window).height();
          return (curTop > screenHeight) ? false : true;
      }

      // UP
      if (handler === 'k') {
        if (index !== 0) --index;
        var $prev = $('.item[data-index=' + index + ']');
        var prevTop = $prev.offset().top + $prev.height();

        if (!inView($prev)) {
          // Offset is the list height minus the difference between the
          // height and .content-search (60) that is fixed down the page
          offset = $prev.height();

          $('html, body').animate({
            scrollTop: $prev.offset().top + ($prev.height() - offset)
          }, 0);
        } else {
          $('html, body').animate({
            scrollTop: 0
          }, 0);
        }

        $prev.addClass('active');

      // DOWN
      } else {
        if (index < $('#content li').length - 1) ++index;
        var $next = $('.item[data-index=' + index + ']');
        var nextTop = $next.offset().top + $next.height();
        offset = $next.height();

        if (!inView($next)) {
          $('html, body').animate({
             scrollTop: $next.offset().top + ($next.height() - offset)
          }, 0);
        }

        $next.addClass('active');
      }
    } else {
      $('.item[data-index=0]').addClass('active');
    }
  },

  goToFile: function() {
    var path = $('.item.active').data('navigate');
    if (path) router.navigate(path, true);
    return false;
  },

  autoSelect: function($el) {
    $el.on('click', function() {
      $el.select();
    });
  }
};

},{"../dist/templates":14,"jquery-browserify":11,"underscore":13,"chrono":33}],34:[function(require,module,exports){
module.exports = {
  help: [
    {
      menuName: t('dialogs.help.blockElements.title'),
      content: [{
          menuName: t('dialogs.help.blockElements.content.paragraphs.title'),
          data: t('dialogs.help.blockElements.content.paragraphs.content')
        }, {
          menuName: t('dialogs.help.blockElements.content.headers.title'),
          data: t('dialogs.help.blockElements.content.headers.content')
        }, {
          menuName: t('dialogs.help.blockElements.content.blockquotes.title'),
          data: t('dialogs.help.blockElements.content.blockquotes.content')
        }, {
          menuName: t('dialogs.help.blockElements.content.lists.title'),
          data: t('dialogs.help.blockElements.content.lists.content')
        }, {
          menuName: t('dialogs.help.blockElements.content.codeBlocks.title'),
          data: t('dialogs.help.blockElements.content.codeBlocks.content')
        }, {
          menuName: t('dialogs.help.blockElements.content.horizontalRules.title'),
          data: t('dialogs.help.blockElements.content.horizontalRules.content')
        }
      ]
    },

    {
      menuName: t('dialogs.help.spanElements.title'),
      content: [{
          menuName: t('dialogs.help.spanElements.content.links.title'),
          data: t('dialogs.help.spanElements.content.links.content')
        },
        {
          menuName: t('dialogs.help.spanElements.content.emphasis.title'),
          data: t('dialogs.help.spanElements.content.emphasis.content')
        },
        {
          menuName: t('dialogs.help.spanElements.content.code.title'),
          data: t('dialogs.help.spanElements.content.code.content')
        },
        {
          menuName: t('dialogs.help.spanElements.content.images.title'),
          data: t('dialogs.help.spanElements.content.images.content')
        }
      ]
    },

    {
      menuName: t('dialogs.help.miscellaneous.title'),
      content: [{
          menuName: t('dialogs.help.miscellaneous.content.automaticLinks.title'),
          data: t('dialogs.help.miscellaneous.content.automaticLinks.content')
        },
        {
          menuName: t('dialogs.help.miscellaneous.content.escaping.title'),
          data: t('dialogs.help.miscellaneous.content.escaping.content')
        }
      ]
    }
  ]
}

},{}],16:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var Org = require('../models/org');
var config = require('../config');

module.exports = Backbone.Collection.extend({
  model: Org,

  initialize: function(models, options) {
    options = _.clone(options) || {};
    _.bindAll(this);

    this.user = options.user;
  },

  url: function() {
    return this.user ? config.api + '/users/' + this.user.get('login') + '/orgs' :
      '/user/orgs';
  }
});

},{"../models/org":35,"../config":4,"underscore":13,"backbone":12}],17:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var Branches = require('../collections/branches');
var Commits = require('../collections/commits');
var config = require('../config');

module.exports = Backbone.Model.extend({
  constructor: function(attributes, options) {
    Backbone.Model.call(this, {
      id: attributes.id,
      description: attributes.description,
      fork: attributes.fork,
      homepage: attributes.homepage,
      default_branch: attributes.default_branch,
      name: attributes.name,
      owner: {
        id: attributes.owner.id,
        login: attributes.owner.login
      },
      permissions: attributes.permissions,
      private: attributes.private,
      updated_at: attributes.updated_at
    });
  },

  initialize: function(attributes, options) {
    this.branches = new Branches([], { repo: this });
    this.commits = new Commits([], { repo: this, branch: this.branch })
  },

  ref: function(options) {
    options = _.clone(options) || {};

    $.ajax({
      type: 'POST',
      url: this.url() + '/git/refs',
      data: JSON.stringify({
        ref: options.ref,
        sha: options.sha
      }),
      success: options.success,
      error: options.error
    });
  },

  fork: function(options) {
    options = _.clone(options) || {};

    var success = options.success;

    $.ajax({
      type: 'POST',
      url: this.url() + '/forks',
      success: (function(res) {
        // Initialize new Repo model
        // TODO: is referencing module.exports in this manner acceptable?
        var repo = new module.exports(res);

        // TODO: Forking is async, retry if request fails
        repo.branches.fetch({
          success: (function(collection, res, options) {
            var prefix = 'prose-patch-';

            var branches = collection.filter(function(model) {
              return model.get('name').indexOf(prefix) === 0;
            }).map(function(model) {
              return parseInt(model.get('name').split(prefix)[1]);
            });

            var branch = prefix + (branches.length ? _.max(branches) + 1 : 1);

            if (_.isFunction(success)) success(repo, branch);
          }).bind(this),
          error: options.error
        })
      }).bind(this),
      error: options.error
    });
  },

  url: function() {
    return config.api + '/repos/' + this.get('owner').login + '/' + this.get('name');
  }
});

},{"../collections/branches":36,"../config":4,"../collections/commits":37,"backbone":12,"underscore":13}],19:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var LoaderView = require('./loader');
var SidebarView = require('./sidebar');
var NavView = require('./nav');
var cookie = require('../cookie');
var templates = require('../../dist/templates');
var util = require('../util');

module.exports = Backbone.View.extend({
  className: 'application',

  template: templates.app,

  subviews: {},

  events: {
    'click a.logout': 'logout'
  },

  initialize: function(options) {
    _.bindAll(this);

    key('j, k, enter, o', (function(e, handler) {
      if (this.$el.find('.listing')[0]) {
        if (handler.key === 'j' || handler.key === 'k') {
          util.pageListing(handler.key);
        } else {
          util.goToFile();
        }
      }
    }).bind(this));

    this.user = options.user;

    // Loader
    this.loader = new LoaderView();
    this.subviews['loader'] = this.loader;

    // Sidebar
    this.sidebar = new SidebarView({
      app: this,
      user: this.user
    });
    this.subviews['sidebar'] = this.sidebar;

    // Nav
    this.nav = new NavView({
      app: this,
      sidebar: this.sidebar,
      user: this.user
    });
    this.subviews['nav'] = this.nav;
  },

  render: function() {
    this.$el.html(_.template(this.template, {}, { variable: 'data' }));

    this.loader.setElement(this.$el.find('#loader')).render();
    this.sidebar.setElement(this.$el.find('#drawer')).render();
    this.nav.setElement(this.$el.find('nav')).render();

    return this;
  },

  logout: function() {
    cookie.unset('oauth-token');
    cookie.unset('id');
    window.location.reload();
    return false;
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./loader":38,"./nav":39,"./sidebar":40,"../cookie":3,"../util":28,"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],20:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../dist/templates');
var auth = require('../config');

module.exports = Backbone.View.extend({
  id: 'start',

  template: templates.start,

  render: function() {
    this.$el.html(_.template(this.template, auth, { variable: 'auth' }));
    return this;
  }
});

},{"../../dist/templates":14,"../config":4,"jquery-browserify":11,"backbone":12,"underscore":13}],21:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var HeaderView = require('./header');
var OrgsView = require('./sidebar/orgs');
var utils = require('.././util');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.profile,

  subviews: {},

  initialize: function(options) {
    this.auth = options.auth;
    this.repos = options.repos;
    this.router = options.router;
    this.search = options.search;
    this.sidebar = options.sidebar;
    this.user = options.user;
  },

  render: function() {
    this.$el.empty().append(_.template(this.template));

    this.search.setElement(this.$el.find('#search')).render();
    this.repos.setElement(this.$el.find('#repos'));

    var header = new HeaderView({ user: this.user, alterable: false });
    header.setElement(this.$el.find('#heading')).render();
    this.subviews['header'] = header;

    if (this.auth) {
      var orgs = this.sidebar.initSubview('orgs', {
        model: this.auth.orgs,
        router: this.router,
        sidebar: this.sidebar,
        user: this.user
      });
      
      this.subviews['orgs'] = orgs;
    }

    return this;
  },

  remove: function() {
    this.sidebar.close();

    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./header":41,"./sidebar/orgs":42,".././util":28,"../../dist/templates":14,"jquery-browserify":11,"backbone":12,"underscore":13}],18:[function(require,module,exports){
var _ = require('underscore');
var marked = require('marked');
var Backbone = require('backbone');
var jsyaml = require('js-yaml');
var util = require('.././util');

module.exports = Backbone.Model.extend({
  idAttribute: 'path',

  initialize: function(attributes, options) {
    options = _.clone(options) || {};
    _.bindAll(this);

    this.isClone = function() {
      return !!options.clone;
    };

    this.placeholder = new Date().format('Y-m-d') + '-your-filename.md';
    var path = attributes.path.split('?')[0];

    // Append placeholder name if file is new and
    // path is an empty string, matches _drafts
    // or matches a directory in collection
    var dir = attributes.collection.get(path);
    if (this.isNew() && (!path || path === '_drafts' ||
      (dir && dir.get('type') === 'tree'))) {
      path = path ? path + '/' + this.placeholder : this.placeholder;
    }

    var extension = util.extension(path);
    var permissions = attributes.repo ?
      attributes.repo.get('permissions') : undefined;
    var type;

    this.collection = attributes.collection;

    if (this.isNew() || attributes.type === 'blob') {
      type = 'file';
    } else {
      type = attributes.type;
    }

    this.set({
      'binary': util.isBinary(path),
      'content': this.isNew() && _.isUndefined(attributes.content) ? t('main.new.body') : attributes.content,
      'content_url': attributes.url,
      'draft': function() {
        var path = this.get('path');
        return util.draft(path);
      },
      'extension': extension,
      'lang': util.mode(extension),
	  //'prod': util.isProd(extension),
      'prod': util.isProd(path),
      'nutr': util.isNutr(path),
      'proc': util.isProc(path),
      'media': util.isMedia(extension),
      'markdown': util.isMarkdown(extension),
      'name': util.extractFilename(path)[1],
      'oldpath': path,
      'path': path,
      'type': type,
      'writable': permissions ? permissions.push : false
    });
  },

  get: function(attr) {
    // Return result of functions set on model
    var value = Backbone.Model.prototype.get.call(this, attr);
    return _.isFunction(value) ? value.call(this) : value;
  },

  isNew: function() {
    return this.get('sha') == null;
  },

  parse: function(resp, options) {
    if (typeof resp === 'string') {
      return this.parseContent(resp);
    } else if (typeof resp === 'object') {
      // TODO: whitelist resp JSON
      return _.omit(resp, 'content');
    }
  },

  parseContent: function(resp, options) {
    // Extract YAML from a post, trims whitespace
    resp = resp.replace(/\r\n/g, '\n'); // normalize a little bit

    var hasMetadata = !!util.hasMetadata(resp);

    if (!hasMetadata) return {
      content: resp,
      metadata: false,
      previous: resp
    };

    var res = {
      previous: resp
    };

    res.content = resp.replace(/^(---\n)((.|\n)*?)---\n?/, function(match, dashes, frontmatter) {
      var regex = /published: false/;

      try {
        // TODO: _.defaults for each key
        res.metadata = jsyaml.safeLoad(frontmatter);

        // Default to published unless explicitly set to false
        res.metadata.published = !regex.test(frontmatter);
      } catch(err) {
        console.log('ERROR encoding YAML');
        console.log(err);
      }

      return '';
    }).trim();

    return res;
  },

  getContent: function(options) {
    options = options ? _.clone(options) : {};

    Backbone.Model.prototype.fetch.call(this, _.extend(options, {
      dataType: 'text',
      headers: {
        'Accept': 'application/vnd.github.v3.raw'
      },
      url: this.get('content_url')
    }));
  },

  getContentSync: function(options) {
    options = options ? _.clone(options) : {};

    return Backbone.Model.prototype.fetch.call(this, _.extend(options, {
      async: false,
      dataType: 'text',
      headers: {
        'Accept': 'application/vnd.github.v3.raw'
      },
      url: this.get('content_url')
    }));
  },

  serialize: function() {
    var metadata = this.get('metadata');

    var content = this.get('content') || '';
    var frontmatter;

    if (metadata) {
      try {
        frontmatter = jsyaml.safeDump(metadata).trim();
      } catch(err) {
        throw err;
      }

      return ['---', frontmatter, '---'].join('\n') + '\n\n' + content;
    } else {
      return content;
    }
  },

  encode: function(content) {
    // Encode UTF-8 to Base64
    // https://developer.mozilla.org/en-US/docs/Web/API/window.btoa#Unicode_Strings
    return window.btoa(window.unescape(window.encodeURIComponent(content)));
  },

  decode: function(content) {
    // Decode Base64 to UTF-8
    // https://developer.mozilla.org/en-US/docs/Web/API/window.btoa#Unicode_Strings
    return window.decodeURIComponent(window.escape(window.atob(content)));
  },

  getAttributes: function() {
    var data = {};

    _.each(this.attributes, function(value, key) {
      data[key] = this.get(key);
    }, this);

    return data;
  },

  toJSON: function() {
    // Override default toJSON method to only send necessary data to GitHub
    var path = this.get('oldpath') || this.get('path');
    var content = this.serialize();

    var data = {
      path: path,
      message: this.get('message') || this.get('placeholder'),
      content: this.get('binary') ? window.btoa(content) : this.encode(content),
      branch: this.collection.branch.get('name')
    };

    // Set sha if modifying existing file
    if (!this.isNew()) data.sha = this.get('sha');

    return data;
  },

  clone: function(attributes, options) {
    options = _.clone(options) || {};

    return new this.constructor(_.extend(_.pick(this.attributes, [
      'branch',
      'collection',
      'content',
      'metadata',
      'repo'
    ]), attributes), _.extend(options, {
      clone: true
    }));
  },

  fetch: function(options) {
    options = options ? _.clone(options) : {};

    // Series necessary for accurate isNew() check in getContent
    if (this.isNew()) {
      if (_.isFunction(options.success)) options.success();
      if (_.isFunction(options.complete)) options.complete();
    } else {
      // TODO: use deffered to fire callbacks when both functions complete
      Backbone.Model.prototype.fetch.call(this, _.omit(options, 'success', 'error', 'complete'));
      this.getContent.apply(this, arguments);
    }
  },

  save: function(options) {
    options = options ? _.clone(options) : {};

    var success = options.success;

    // set method to PUT even when this.isNew()
    if (this.isNew()) {
      options = _.extend(options, {
        type: 'PUT'
      });
    }

    options.success = (function(model, res, options) {
      this.set(_.extend(res.content, {
        previous: this.serialize()
      }));

      if (_.isFunction(success)) success.apply(this, arguments);
    }).bind(this);

    // Call save method with undefined attributes
    Backbone.Model.prototype.save.call(this, undefined, options);
  },

  patch: function(options) {
    options = _.clone(options) || {};

    var success = options.success;
    var error = options.error;

    this.collection.repo.fork({
      success: (function(repo, branch) {
        repo.ref({
          'ref': 'refs/heads/' + branch,
          'sha': this.collection.branch.get('sha'),
          'success': (function(res) {
            repo.branches.fetch({
              cache: false,
              success: (function(collection, res, options) {
                branch = collection.findWhere({ name: branch });

                // Create new File model in forked repo
                // TODO: serialize metadata, set raw content
                var file = new module.exports({
                  branch: branch,
                  collection: collection,
                  content: this.get('content'),
                  path: this.get('path'),
                  repo: repo,
                  sha: this.get('sha'),
                  message: this.get('message') || this.get('placeholder'),
                  metadata: this.get('metadata'),
                  defaults: this.get('defaults')
                });

                // Backbone expects these to be top level,
                // not in _attributes for some reason
                // TODO: Don't actually do this, but hey, YOLO.
                file.branch = branch;
                file.collection = collection;
                file.collection.branch = branch;

                // Add to collection on save
                file.save({
                  success: (function(model, res, options) {
                    // Update model attributes and add to collection
                    model.set(res.content);
                    branch.files.add(model);

                    $.ajax({
                      type: 'POST',
                      url: this.collection.repo.url() + '/pulls',
                      data: JSON.stringify({
                        title: res.commit.message,
                        body: 'This pull request has been automatically generated by prose.io.',
                        base: this.collection.branch.get('name'),
                        head: repo.get('owner').login + ':' + branch.get('name')
                      }),
                      success: success,
                      error: error
                    });
                  }).bind(this),
                  error: error
                });
              }).bind(this),
              error: error
            });
          }).bind(this),
          'error': options.error
        });
      }).bind(this),
      error: options.error
    });
  },

  destroy: function(options) {
    options = _.clone(options) || {};

    var path = this.get('path');

    var data = {
      path: path,
      message: t('actions.commits.deleted', { filename: path }),
      sha: this.get('sha'),
      branch: this.collection.branch.get('name')
    };

    var url = this.url().split('?')[0];
    var params = _.map(_.pairs(data), function(param) { return param.join('='); }).join('&');

    Backbone.Model.prototype.destroy.call(this, _.extend(options, {
      url: url + '?' + params,
      error: function(model, xhr, options) {
        // TODO: handle 422 Unprocessable Entity error
        console.log(model, xhr, options);
      },
      wait: true
    }));
  },

  url: function() {
    branch = this.collection.branch || this.branch || this.get("branch");
    return this.collection.repo.url() + '/contents/' + this.get('path') + '?ref=' + branch.get('name');
  },

  validate: function(attributes, options) {

    // For testing:
    // if (attributes) return 'uh oh spaghetti o'
    // Fail validation if path conflicts with another file in repo
    if (this.collection.where({ path: attributes.path }).length > 1) return t('actions.save.fileNameExists');

    // Fail validation if name matches default
    var name = util.extractFilename(this.get('path'));
    if (name === this.placeholder) return 'File name is default';

    // Fail validation if marked returns an error
    // TODO: does this work as callback?
    marked(attributes.content, {}, function(err, content) {
      if (err) return err;
    });
  }
});

},{".././util":28,"backbone":12,"marked":43,"js-yaml":44,"underscore":13}],22:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../dist/templates');
var util = require('../util');

module.exports = Backbone.View.extend({
  template: templates.search,

  events: {
    'keyup input': 'keyup'
  },

  initialize: function(options) {
    this.mode = options.mode;
    this.model = options.model;
  },

  render: function() {
    var placeholder = t('main.repos.filter');
    if (this.mode === 'repo') placeholder = t('main.repo.filter');

    var search = {
      placeholder: placeholder
    };

    this.$el.empty().append(_.template(this.template, search, {
      variable: 'search'
    }));

    this.input = this.$el.find('input');
    this.input.focus();
    return this;
  },

  keyup: function(e) {
    if (e && e.which === 27) {
      // ESC key
      this.input.val('');
      this.trigger('search');
    } else if (e && e.which === 40) {
      // Down Arrow
      util.pageListing('down');
      e.preventDefault();
      e.stopPropagation();
      this.input.blur();
    } else {
      this.trigger('search');
    }
  },

  search: function() {
    var searchstr = this.input ? this.input.val() : '';
    return this.model.filter(function(model) {
      return model.get('name').indexOf(searchstr) > -1;
    });
  }
});

},{"../../dist/templates":14,"../util":28,"jquery-browserify":11,"underscore":13,"backbone":12}],23:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var RepoView = require('./li/repo');

module.exports = Backbone.View.extend({
  subviews: {},

  events: {
    'mouseover .item': 'activeListing',
    'mouseover .item a': 'activeListing'
  },

  initialize: function(options) {
    _.bindAll(this);

    this.model = options.model;
    this.search = options.search;

    this.listenTo(this.search, 'search', this.render);
  },

  render: function() {
    var collection = this.search ? this.search.search() : this.model;
    var frag = document.createDocumentFragment();

    collection.each((function(repo, i) {
      var view = new RepoView({
        index: i,
        model: repo
      });

      frag.appendChild(view.render().el);
      this.subviews[repo.id] = view;
    }).bind(this));

    this.$el.html(frag);

    this.$listings = this.$el.find('.item');
    this.$search = this.$el.find('#filter');

    return this;
  },

  activeListing: function(e) {
    var $listing = $(e.target);

    if (!$listing.hasClass('item')) {
      $listing = $(e.target).closest('li');
    }

    this.$listings.removeClass('active');
    $listing.addClass('active');

    // Blur out search if its selected
    this.$search.blur();
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./li/repo":45,"underscore":13,"jquery-browserify":11,"backbone":12}],15:[function(require,module,exports){
var Backbone = require('backbone');
var User = require('../models/user');
var config = require('../config');

module.exports = Backbone.Collection.extend({
  model: User
});

},{"../models/user":7,"../config":4,"backbone":12}],26:[function(require,module,exports){
var $ = require('jquery-browserify');
var marked = require('marked');
var Backbone = require('backbone');

module.exports = Backbone.View.extend({
  className: 'inner deep prose limiter',

  render: function() {
    this.$el.empty()
      .append(marked(t('about.content')));
    return this;
  }
});

},{"marked":43,"jquery-browserify":11,"backbone":12}],24:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var queue = require('queue-async');
var Backbone = require('backbone');
var FilesView = require('./files');
var HeaderView = require('./header');
var SearchView = require('./search');
var util = require('.././util');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.repo,

  events: {
    'click a.new': 'create'
  },

  subviews: {},

  initialize: function(options) {
    _.bindAll(this);

    var app = options.app;
    app.loader.start();

    this.app = app;
    this.branch = options.branch || this.model.get('default_branch');
    this.model = options.model;
    this.nav = options.nav;
    this.path = options.path || '';
    this.router = options.router;
    this.sidebar = options.sidebar;

    // Init subviews
    this.initBranches();
    this.initHeader();

    var q = queue();
    q.defer(this.initSearch);
    q.defer(this.initHistory);
    q.awaitAll(this.initFiles);

    // Events from sidebar
    this.listenTo(this.sidebar, 'destroy', this.destroy);
    this.listenTo(this.sidebar, 'cancel', this.cancel);
    this.listenTo(this.sidebar, 'confirm', this.updateFile);

    app.loader.done();
  },

  render: function() {
    this.$el.html(_.template(this.template, {}, { variable: 'data' }));

    this.header.setElement(this.$el.find('#heading')).render();
    this.search.setElement(this.$el.find('#search')).render();
    this.files.setElement(this.$el.find('#files'));

    return this;
  },

  initHeader: function() {
    this.header = new HeaderView({
      repo: this.model,
      alterable: false
    });

    this.subviews['header'] = this.header;
  },

  initSearch: function(cb) {
    this.search = new SearchView({
      mode: 'repo'
    });

    this.subviews['search'] = this.search;

    if (_.isFunction(cb)) cb.apply(this);
  },

  initFiles: function() {
    this.files = new FilesView({
      app: this.app,
      branch: this.branch,
      branches: this.model.branches,
      history: this.history,
      nav: this.nav,
      path: this.path,
      repo: this.model,
      router: this.router,
      search: this.search,
      sidebar: this.sidebar
    });

    this.subviews['files'] = this.files;
  },

  initBranches: function() {
    this.branches = this.sidebar.initSubview('branches', {
      app: this.app,
      model: this.model.branches,
      repo: this.model,
      branch: this.branch,
      router: this.router,
      sidebar: this.sidebar
    });

    this.subviews['branches'] = this.branches;
  },

  initHistory: function(cb) {
    this.history = this.sidebar.initSubview('history', {
      app: this.app,
      branch: this.branch,
      commits: this.model.commits,
      repo: this.model,
      router: this.router,
      sidebar: this.sidebar,
      view: this
    });

    this.subviews['history'] = this.history;

    if (_.isFunction(cb)) cb.apply(this);
  },

  create: function() {
    this.files.newFile();
    return false;
  },

  remove: function() {
    this.sidebar.close();

    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./files":46,"./search":22,"./header":41,".././util":28,"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"queue-async":47,"backbone":12}],27:[function(require,module,exports){
var $ = require('jquery-browserify');
var Backbone = require('backbone');
var _ = require('underscore');
var cookie = require('../cookie');
var templates = require('../../dist/templates');
var LOCALES = require('../../translations/locales');

module.exports = Backbone.View.extend({
  className: 'inner deep prose limiter',

  template: templates.chooselanguage,

  events: {
    'click .language': 'setLanguage' 
  },

  render: function() {
    var chooseLanguages = {
      languages: LOCALES,
      active: app.locale ? app.locale : window.locale._current
    };

    this.$el.empty().append(_.template(this.template, chooseLanguages, {
      variable: 'chooseLanguage'
    }));
    return this;
  },

  setLanguage: function(e) {
    if (!$(e.target).hasClass('active')) {
      var code = $(e.target).data('code');
      cookie.set('lang', code);

      // Check if the browsers language is supported
      app.locale = code;

      if (app.locale && app.locale !== 'en') {
          $.getJSON('./translations/locales/' + app.locale + '.json', function(result) {
              window.locale[app.locale] = result;
              window.locale.current(app.locale);
          });
      }

      // Reflect changes. Could be more elegant.
      window.location.reload();
    }

    return false;
  }
});

},{"../cookie":3,"../../dist/templates":14,"../../translations/locales":2,"backbone":12,"jquery-browserify":11,"underscore":13}],25:[function(require,module,exports){
(function(){var $ = require('jquery-browserify');
var _ = require('underscore');
var queue = require('queue-async');
var jsyaml = require('js-yaml');
var patch = require('../../vendor/liquid.patch');

var ModalView = require('./modal');
var key = require('keymaster');
var marked = require('marked');
var diff = require('diff');
var Backbone = require('backbone');
var File = require('../models/file');
var HeaderView = require('./header');
var ToolbarView = require('./toolbar');
var MetadataView = require('./metadata');
var auth = require('../config');
var util = require('../util');
var upload = require('../upload');
var cookie = require('../cookie');
var templates = require('../../dist/templates');

var jsonform = require('json-form');
var jsonformformat = require('./jsonformformat.js');

module.exports = Backbone.View.extend({

  jsonFormFormatObj: null,

  id: 'post',

  template: templates.file,

  subviews: {},

  initialize: function(options) {
    _.bindAll(this);

    var app = options.app;
    app.loader.start();

    // Patch Liquid
    patch.apply(this);

    this.app = app;
    this.branch = options.branch || options.repo.get('default_branch');
    this.branches = options.branches;
    this.mode = options.mode;
    this.nav = options.nav;
    this.path = options.path || '';
    this.repo = options.repo;
    this.router = options.router;
    this.sidebar = options.sidebar;

    // Set the active nav element established by this.mode
    this.nav.setFileState(this.mode);

    // Events from vertical nav
    this.listenTo(this.nav, 'edit', this.edit);
    this.listenTo(this.nav, 'blob', this.blob);
    this.listenTo(this.nav, 'meta', this.meta);
    this.listenTo(this.nav, 'settings', this.settings);
    this.listenTo(this.nav, 'save', this.showDiff);

    // Events from sidebar
    this.listenTo(this.sidebar, 'destroy', this.destroy);
    this.listenTo(this.sidebar, 'draft', this.draft);
    this.listenTo(this.sidebar, 'cancel', this.cancel);
    this.listenTo(this.sidebar, 'confirm', this.updateFile);
    this.listenTo(this.sidebar, 'translate', this.translate);

    // Stash editor and metadataEditor content to sessionStorage on pagehide event
    this.listenTo($(window), 'pagehide', this.stashFile);

    // Prevent exit when there are unsaved changes
    // jQuery won't bind to 'beforeunload' event
    // e.returnValue for Firefox compatibility
    // https://developer.mozilla.org/en-US/docs/Web/Reference/Events/beforeunload
    window.onbeforeunload = (function(e) {
      if (this.dirty) {
        var message = t('actions.unsaved');
        (e || window.event).returnValue = message;

        return message;
      }
    }).bind(this);

    this.branches.fetch({
      success: this.setCollection,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: app.loader.done
    });
  },

  setCollection: function(collection, res, options) {
    this.app.loader.start();

    this.collection = collection.findWhere({ name: this.branch }).files;
    this.collection.fetch({
      success: this.setModel,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: this.app.loader.done,
      args: arguments
    });
  },

  setModel: function(model, res, options) {
    this.app.loader.start();

    // Set model either by calling directly for new File models
    // or by filtering collection for existing File models
    switch(this.mode) {
      case 'edit':
      case 'blob':
        this.model = this.collection.findWhere({ path: this.path });
        break;
      case 'preview':
        this.model = this.collection.findWhere({ path: this.path });
        if (!this.model) {
          // We may be trying to preview a new file that only has
          // stashed information lets check and create a dummy model
          var previewPath = this.absolutePathFromComponents (
            this.repo.get('owner').login,
            this.repo.get('name'),
            this.branch,
            this.path
          );
          if (this.getStashForPath(previewPath)) {
            this.model = this.newEmptyFile();
          }
        }
        break;
      case 'new':
        this.model = this.newEmptyFile();
        break;
    }
    
    // Set default metadata from collection
    var defaults = this.collection.defaults;
    var path;
    if (this.model) {
      if (defaults) {
        path = this.nearestPath(this.model.get('path'), defaults);
        this.model.set('defaults', defaults[path]);
      }

      // Render on complete to render even if model does not exist on remote yet
      this.model.fetch({
        complete: (function() {
          this.app.loader.done();
          this.render();
        }).bind(this)
      });
    } else {
      this.router.notify(
        t('notification.error.exists'),
        undefined,
        [
          {
            'title': t('notification.create'),
            'className': 'create',
            'link': '#'
          },
          {
            'title': t('notification.back'),
            'link': '#' + _.compact([
              this.repo.get('owner').login,
              this.repo.get('name'),
              'tree',
              this.branch,
              util.extractFilename(this.path)[0]
            ]).join('/')
          }
        ]
      );

      this.app.loader.done();
    }
  },

  newEmptyFile: function() {
    return new File({
      branch: this.branches.findWhere({ name: this.branch }),
      collection: this.collection,
      path: this.path,
      repo: this.repo
    });
  },

  nearestPath: function(path, defaults) {
    // Match nearest parent directory default metadata
    // Match paths in _drafts to corresponding defaults set at _posts
    path = path.replace(/^(_drafts)/, '_posts');
    var nearestDir = /\/?(?!.*\/).*$/;

    while (!_.has(defaults, path) && nearestDir.test(path) && path) {
      path = path.replace( nearestDir, '' );
    }

    return path;
  },

  cursor: function() {
    var view = this;
    var selection = util.trim(this.editor.getSelection());

    var match = {
      lineBreak: /\n/,
      h1: /^#{1}/,
      h2: /^#{2}/,
      h3: /^#{3}/,
      h4: /^#{4}/,
      strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
      italic: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
      isNumber: parseInt(selection.charAt(0), 10)
    };

    if (!match.isNumber) {
      switch (selection.charAt(0)) {
        case '#':
          if (!match.lineBreak.test(selection)) {
            if (match.h3.test(selection) && !match.h4.test(selection)) {
              this.toolbar.highlight('sub-heading');
            } else if (match.h2.test(selection) && !match.h3.test(selection)) {
              this.toolbar.highlight('heading');
            }
          }
          break;
        case '>':
          this.toolbar.highlight('quote');
          break;
        case '*':
        case '_':
          if (!match.lineBreak.test(selection)) {
            if (match.strong.test(selection)) {
              // trigger a change
              this.toolbar.highlight('bold');
            } else if (match.italic.test(selection)) {
              this.toolbar.highlight('italic');
            }
          }
          break;
        case '!':
          if (!match.lineBreak.test(selection) &&
              selection.charAt(1) === '[' &&
              selection.charAt(selection.length - 1) === ')') {
              this.toolbar.highlight('media');
          }
          break;
        case '[':
          if (!match.lineBreak.test(selection) &&
              selection.charAt(selection.length - 1) === ')') {
              this.toolbar.highlight('link');
          }
          break;
        case '-':
          if (selection.charAt(1) === ' ') {
            this.toolbar.highlight('list');
          }
        break;
        default:
          if (this.toolbar) this.toolbar.highlight();
        break;
      }
    } else {
      if (selection.charAt(1) === '.' && selection.charAt(2) === ' ') {
        this.toolbar.highlight('numbered-list');
      }
    }
  },

  compilePreview: function(content) {
    // Scan the content search for ![]()
    // grab the path and file and form a RAW github aboslute request for it
    var scan = /\!\[([^\[]*)\]\(([^\)]+)\)/g;
    var image = /\!\[([^\[]*)\]\(([^\)]+)\)/;
    var titleAttribute = /".*?"/;

    // Build an array of found images
    var results = content.match(scan);

    // Iterate over the results and replace
    _.each(results, (function(r) {
      var parts = (image).exec(r);
      var path;

      if (parts !== null) {
        path = parts[2];

        if (!util.absolutePath(path)) {
          // Remove any title attribute in the image tag is there is one.
          if (titleAttribute.test(path)) {
            path = path.split(titleAttribute)[0];
          }

          // Prepend directory path if not site root relative
          path = /^\//.test(path) ? path.slice(1) :
            util.extractFilename(this.model.get('path'))[0] + '/' + path;

          var url = auth.site + '/' + this.repo.get('owner').login + '/' + this.repo.get('name') + '/blob/' +  this.branch + '/' + window.escape(path) + '?raw=true';

          content = content.replace(r, '![' + parts[1] + '](' + url + ')');
        }
      }
    }).bind(this));

    return content;
  },

  initJsonFormEditor: function() {
 	
    var self = this;
	var contentStr = this.model.get('content') || '';
	
	// Replace all line breaks and carriage returns in json input to blanks
	var content = contentStr.replace(/(\n|\r)/g, " ");
	var contentObj = $.parseJSON(content);
	
	// Only append if tag does not exist yet
	if ($('#jsonform').length <= 0) {
	
      // Important: The jsonform output must be inside a <form> tag, otherwise
	  // the onSubmit/onSubmitValid Javascript code will not work.
	  $('#edit').append('<form id="jsonform"></form>');
	 
      // Inject the value attribute obtained from the prod/nutr/proc file
	  this.jsonFormFormatObj.value = contentObj;
	  this.jsonFormFormatObj.onSubmitValid = this.jsonFormFormatObj.onSubmitValid.bind(self);
	  //this.jsonFormFormatObj.onSubmit = this.jsonFormFormatObj.onSubmit.bind(self);
	  
      // Here we need to reference self.jsonFormFormatObj instead of this.jsonFormFormatObj
	  $('#jsonform').jsonForm(self.jsonFormFormatObj); 
	  
	  // When clicking the JSONForm submit button, a click event is first thrown. Through the
	  // click event, the native HTML5 form validation is triggered. Only if the form is valid
	  // a submit event is thrown. We want the native HTML5 style validation, but not JSONForm's
	  // submission. Instead, we'll use Prose's submission. Hence, remove the listeners for the
	  // submit event on the form.
	  $('#jsonform').unbind('submit');
	  $('#jsonform').unbind('submit.jsonform');
	}
  },
  
  initBaseEditor: function() {
    var lang = this.model.get('lang');

    // TODO: set default content for CodeMirror
    this.editor = CodeMirror(this.$el.find('#code')[0], {
      mode: lang,
      value: this.model.get('content') || '',
      lineWrapping: true,
      lineNumbers: (lang === 'gfm' || lang === null) ? false : true,
      extraKeys: this.keyMap(),
      matchBrackets: true,
      dragDrop: false,
      theme: 'prose-bright'
    });

    // Bind Drag and Drop work on the editor
    if (this.model.get('markdown') && this.model.get('writable')) {
      upload.dragDrop(this.$el, (function(e, file, content) {
        if (this.$el.find('#dialog').hasClass('dialog')) {
          this.updateImageInsert(e, file, content);
        } else {
          // Clear selection
          this.editor.focus();
          this.editor.replaceSelection('');

          // Append images links in this.upload()
          this.upload(e, file, content);
        }
      }).bind(this));
    }

    // Monitor the current selection and apply
    // an active class to any snippet links
    if (lang === 'gfm') {
      this.listenTo(this.editor, 'cursorActivity', this.cursor);
    }

    this.listenTo(this.editor, 'change', this.makeDirty, this);
    this.listenTo(this.editor, 'focus', this.focus, this);

    this.refreshCodeMirror();

    // Check sessionStorage for existing stash
    // Apply if stash exists and is current, remove if expired
    this.stashApply();
  },

  initEditor: function() {
 	if (this.model.get('prod')) {
	  // Editor for PROD files
	  this.jsonFormFormatObj = jsonformformat.prod;
	  this.initJsonFormEditor();
	}
	else if (this.model.get('nutr')) {
      // Editor for NUTR files
	  this.jsonFormFormatObj = jsonformformat.nutr;
      this.initJsonFormEditor();
	}
	else if (this.model.get('proc')) {
      // Editor for PROC files
	  this.jsonFormFormatObj = jsonformformat.proc;
      this.initJsonFormEditor();
	}
	else {
	  // Editor for everything else than PROD, NUTR, PROC files (e.g. markdown, html, plain text...)
	  this.initBaseEditor();
	}
 },

  keyMap: function() {
    var self = this;

    if (this.model.get('markdown')) {
      return {
        'Ctrl-S': function(codemirror) {
          self.updateFile();
        },
        'Cmd-B': function(codemirror) {
          if (self.editor.getSelection() !== '') self.toolbar.bold(self.editor.getSelection());
        },
        'Ctrl-B': function(codemirror) {
          if (self.editor.getSelection() !== '') self.toolbar.bold(self.editor.getSelection());
        },
        'Cmd-I': function(codemirror) {
          if (self.editor.getSelection() !== '') self.toolbar.italic(self.editor.getSelection());
        },
        'Ctrl-I': function(codemirror) {
          if (self.editor.getSelection() !== '') self.toolbar.italic(self.editor.getSelection());
        }
      };
    } else {
      return {
        'Ctrl-S': function(codemirror) {
          self.updateFile();
        }
      };
    }
  },

  focus: function() {
    // If an upload queue is set, we want to clear it.
    this.queue = undefined;

    // If a dialog window is open and the editor is in focus, close it.
    this.$el.find('.toolbar .group a').removeClass('on');
    this.$el.find('#dialog').empty().removeClass();
  },
  
  initToolbar: function() {
    this.toolbar = new ToolbarView({
      view: this,
      file: this.model,
      collection: this.collection,
      config: this.config
    });

    this.subviews['toolbar'] = this.toolbar;
    this.toolbar.setElement(this.$el.find('#toolbar')).render();

    this.listenTo(this.toolbar, 'updateImageInsert', this.updateImageInsert);
    this.listenTo(this.toolbar, 'post', this.post);
  },

  titleAsHeading: function() {
    // If the file is Markdown, has metadata for a title,
    // the editable field in the header should be
    // the title of the Markdown document.
    var metadata = this.model.get('metadata');

    if (this.model.get('markdown')) {

      // 1. A title exists in a files current metadata
      if (metadata && metadata.title) {
        return metadata.title;

      // 2. A title does not exist and should be checked in the defaults
      } else if (this.model.get('defaults')) {

        var defaultTitle = _(this.model.get('defaults')).find(function(t) {
          return t.name == 'title';
        });

        if (defaultTitle) {
          if (defaultTitle.field && defaultTitle.field.value) {
            return defaultTitle.field.value;
          } else {

            // 3. If a title entry is in the defaults but with no
            // default value, use an untitled placeholder message.
            // return t('main.file.noTitle');
            return t('main.file.noTitle');
          }
        } else {
          return false;
        }
      } else {

        // This is not a Markdown post, bounce
        // TODO: Should this handle _posts/name.html?
        return false;
      }
    }
  },

  initSidebar: function() {
    // Settings sidebar panel
    this.settings = this.sidebar.initSubview('settings', {
      sidebar: this.sidebar,
      config: this.collection.config,
      file: this.model,
      fileInput: this.titleAsHeading()
    }).render();
    this.subviews['settings'] = this.settings;

    this.listenTo(this.sidebar, 'makeDirty', this.makeDirty);

    // Commit message sidebar panel
    this.save = this.sidebar.initSubview('save', {
      sidebar: this.sidebar,
      file: this.model
    }).render();
    this.subviews['save'] = this.save;
  },

  initHeader: function() {
    var title = this.titleAsHeading();
    var input = title ?
      title :
      this.model.get('path');

    this.header = new HeaderView({
      input: input,
      title: title ? true : false,
      file: this.model,
      repo: this.repo,
      alterable: true,
      placeholder: this.model.isNew() && !this.model.translate
    });

    this.subviews['header'] = this.header;
    this.header.setElement(this.$el.find('#heading')).render();
    this.listenTo(this.header, 'makeDirty', this.makeDirty);
  },

  renderMetadata: function() {
    this.metadataEditor = new MetadataView({
      model: this.model,
      titleAsHeading: this.titleAsHeading(),
      view: this
    });

    this.metadataEditor.setElement(this.$el.find('#meta')).render();
    this.subviews['metadata'] = this.metadataEditor;
  },

  render: function() {
    this.app.loader.start();

    if (this.mode === 'preview') {
      this.preview();
    } else {
      var content = this.model.get('content');

      var file = {
        markdown: this.model.get('markdown'),
		prod: this.model.get('prod'),
		nutr: this.model.get('nutr'),
		proc: this.model.get('proc')
      };

      this.$el.empty().append(_.template(this.template, file, {
        variable: 'file'
      }));

      // Store the configuration object from the collection
      this.config = this.model.get('collection').config;

      // initialize the subviews
      this.initEditor();
      this.initHeader();
      this.initToolbar();
      this.initSidebar();

      var mode = ['file'];
      var markdown = this.model.get('markdown');
      var prod = this.model.get('prod');
      var nutr = this.model.get('nutr');
      var proc = this.model.get('proc');
      var jekyll = /^(_posts|_drafts)/.test(this.model.get('path'));

      // Update the navigation view with menu options
      // if a file contains metadata, has default metadata or is Markdown
	  // 
	  // Inside the IF-condition, we could explicitly add "|| (prod && jekyll)"
	  // to test for prod files with metadata, but this is not really necessary
	  // as metadata is automatically recognized already.
      if (this.model.get('metadata') || this.model.get('defaults') ||
        (markdown && jekyll)) {
        this.renderMetadata();

        mode.push('meta');
      }

      if (markdown || (jekyll && this.model.get('extension') === 'html')) mode.push('preview');
	  //if (prod) mode.push('prod-editor');
	  //if (nutr) mode.push('nutr-editor');
      if (!this.model.isNew()) mode.push('settings');

      this.nav.mode(mode.join(' '));

      this.updateDocumentTitle();

      // Preview needs access to marked, so it's registered here
      Liquid.Template.registerFilter({
        'markdownify': function(input) {
          return marked(input || '');
        }
      });

 //     if (this.model.get('markdown') && this.mode === 'blob') {
      if ((this.model.get('markdown') && this.mode === 'blob')
	      || (this.model.get('prod') && this.mode === 'blob')
		  || (this.model.get('nutr') && this.mode === 'blob')
		  || (this.model.get('proc') && this.mode === 'blob')) {
        this.blob();
      } else {
        // Editor is first up so trigger an active class for it
        this.$el.find('#edit').toggleClass('active', true);
        this.$el.find('.file .edit').addClass('active');

        if (this.model.get('markdown')) {
          util.fixedScroll(this.$el.find('.topbar'), 90);
        }
      }
/*	  
	  // Not sure if this is required...
	  if (this.model.get('prod') && this.mode === 'blob') {
	    this.blob();
	  } else {
		this.$el.find('#edit').toggleClass('active', true);
        this.$el.find('.file .edit').addClass('active');
		
		if (this.model.get('prod')) {
          util.fixedScroll(this.$el.find('.topbar'), 90);
        }
	  }
	  
	  // Not sure if this is required...
	  if (this.model.get('nutr') && this.mode === 'blob') {
	    this.blob();
	  } else {
		this.$el.find('#edit').toggleClass('active', true);
        this.$el.find('.file .edit').addClass('active');
		
		if (this.model.get('nutr')) {
          util.fixedScroll(this.$el.find('.topbar'), 90);
        }
	  }
*/
      if (this.mode === 'blob') {
        this.blob();
      }
    }

    this.app.loader.done();

    return this;
  },

  updateDocumentTitle: function() {
    var context = (this.mode === 'blob' ? t('docheader.preview') : t('docheader.editing'));

    var path = this.model.get('path');
    var pathTitle = path ? path : '';

    util.documentTitle(context + ' ' + pathTitle + '/' + this.model.get('name') + ' at ' + this.branch);
  },

  edit: function() {
    var view = this;
    this.sidebar.close();

    // If preview was hit on load this.editor
    // was not initialized.
    if (!this.editor) {
      this.initEditor();

      if (this.model.get('markdown')) {
        _.delay(function() {
          util.fixedScroll($('.topbar', view.el), 90);
        }, 1);
      }
	  
	  // TODO - the same for PROD?
	  if (this.model.get('prod')) {
        _.delay(function() {
          util.fixedScroll($('.topbar', view.el), 90);
        }, 1);
      }
	  
	  // TODO - the same for NUTR?
	  if (this.model.get('nutr')) {
        _.delay(function() {
          util.fixedScroll($('.topbar', view.el), 90);
        }, 1);
      }
	  
	  	  // TODO - the same for PROC?
	  if (this.model.get('proc')) {
        _.delay(function() {
          util.fixedScroll($('.topbar', view.el), 90);
        }, 1);
      }
    }

    $('#prose').toggleClass('open', false);

    this.contentMode('edit');
    this.mode = this.model.isNew() ? 'new' : 'edit';
    this.nav.setFileState(this.mode);
    this.updateURL();
  },

  blob: function(e) {
    this.sidebar.close();

    var metadata = this.model.get('metadata');
    var jekyll = this.config && this.config.siteurl && metadata && metadata.layout;

    if (jekyll && e) {
      // TODO: this could all be removed if preview button listened to
      // change:path event on model
      this.nav.setFileState('edit'); // Return to edit because we are creating a new window
      this.stashFile();

      var hash = this.absoluteFilepath().split('/');
      hash.splice(2, 0, 'preview');
      $(e.currentTarget).attr({
        target: '_blank',
        href: '#' + hash.join('/')
      });
    } else {
      if (e) e.preventDefault();

      this.$el.find('#preview').html(marked(this.compilePreview(this.model.get('content'))));

      this.mode = 'blob';
      this.contentMode('preview');
      this.nav.setFileState('blob');
      this.updateURL();
    }
  },

  preview: function() {
    var q = queue(1);
    // Retrieve the stash from the model path because thats what would
    // have been stored when the preview button is clicked
    var stash = this.getStashForPath(this.absolutePathFromFile(this.model));
    var metadata = {};
    var content = '';
    if (stash && stash.content) {
      metadata = stash.metadata;
      content = stash.content;
    } else {
      metadata = this.model.get('metadata') || {};
      content = this.model.get('content') || '';
    }

    var p = {
      site: this.collection.config,
      post: metadata,
      page: metadata,
      content: marked(Liquid.parse(this.compilePreview(content)).render({
        site: this.collection.config,
        post: metadata,
        page: metadata
      })) || ''
    };

    // Grab a date from the filename
    // and add this post to be evaluated as {{post.date}}
    var parts = util.extractFilename(this.path)[1].split('-');
    var year = parts[0];
    var month = parts[1];
    var day = parts[2];

    // TODO: remove EST specific time adjustment
    var date = [year, month, day].join('-') + ' 05:00:00';

    try {
      p.post.date = jsyaml.safeLoad(date).toDateString();
    } catch(err) {
      console.log("Error parsing date");
      console.log(err);
    }

    // Parse JSONP links
    if (p.site && p.site.site) {
      _(p.site.site).each(function(file, key) {
        q.defer(function(cb){
          var next = false;
          $.ajax({
            cache: true,
            dataType: 'jsonp',
            jsonp: false,
            jsonpCallback: 'callback',
            url: file,
            timeout: 5000,
            success: function(d) {
              p.site[key] = d;
              next = true;
              cb();
            },
            error: function(msg, b, c) {
              if (!next) cb();
            }
          });
        });
      });
    }

    function getLayout(cb) {
      var file = p.page.layout;
      var layout = this.collection.findWhere({ path: '_layouts/' + file + '.html' });

      layout.fetch({
        success: (function(model, res, options) {
          model.getContent({
            success: (function(model, res, options) {
              var meta = model.get('metadata');
              var content = model.get('content');
              var template = Liquid.parse(content);

              p.page = _.extend(metadata, meta);

              p.content = template.render({
                site: p.site,
                post: p.post,
                page: p.page,
                content: p.content
              });

              // Handle nested layouts
              if (meta && meta.layout) q.defer(getLayout.bind(this));

              cb();
            }).bind(this),
            error: (function(model, xhr, options) {
              this.router.error(xhr);
            }).bind(this)
          });
        }).bind(this),
        error: (function(model, xhr, options) {
          this.router.error(xhr);
        }).bind(this)
      });
    }

    if (p.page.layout) {
      q.defer(getLayout.bind(this));
    }

    q.await((function() {
      var config = this.collection.config;
      var content = p.content;

      // Set base URL to public site
      if (config && config.siteurl) {
        content = content.replace(/(<head(?:.*)>)/, (function() {
          return arguments[1] + '<base href="' + config.siteurl + '">';
        }).bind(this));
      }

      document.write(content);
      document.close();
    }).bind(this));
  },

  contentMode: function(mode) {
    this.$el.find('.views .view').removeClass('active');
    if (mode) {
      this.$el.find('#' + mode).addClass('active');
    } else {
      if (this.mode === 'blob') {
        this.$el.find('#preview').addClass('active');
      } else {
        this.$el.find('#edit').addClass('active');
      }
    }
  },
  
//  getEditorValue: function() {
//    // File is either -prod.js or -nutr.js
//    if (this.model.get('prod') || this.model.get('nutr')) {
//	
//      var jsonFormValueObj = $('#jsonform').jsonFormValue(); 
//	  
//      // Pretty print the json object using indentation of 2 and new lines
//      var jsonFormValueStr = JSON.stringify(jsonFormValueObj, null, 2);
//	
//      return (jsonFormValueStr) ? jsonFormValueStr : null;
//    }
//	
//	// Base case
//    else {
//      return ((this.editor && this.editor.getValue) ? editor.getValue() : null);
//    }
//  },

  meta: function() {
    this.sidebar.close();
    this.contentMode('meta');

    // Refresh any textarea's in the frontmatter form that use codemirror
    this.metadataEditor.refresh();
  },

  destroy: function() {
    if (confirm(t('actions.delete.warn'))) {
      this.model.destroy({
        success: (function() {
          this.router.navigate([
            this.repo.get('owner').login,
            this.repo.get('name'),
            'tree',
            this.branch
          ].join('/'), true);
        }).bind(this),
        error: (function(model, xhr, options) {
          this.router.error(xhr);
        }).bind(this)
      });
    }
  },

  updateURL: function() {
    var url = _.compact([
      this.repo.get('owner').login,
      this.repo.get('name'),
      this.mode,
      this.branch,
      this.path
    ]);

    this.router.navigate(url.join('/'), {
      trigger: false,
      replace: true
    });

    this.updateDocumentTitle();

    // TODO: what is this updating?
    this.$el.find('.chzn-select').trigger('liszt:updated');
  },

  makeDirty: function(e) {
    this.dirty = true;

//    // Update Content.
//	if (this.editor && this.editor.getValue) {
//		var content = this.getEditorValue();
//		if (content !== null) {
//		  this.model.set('content', content);
//		}
//	}
    if (this.editor && this.editor.getValue) {
      this.model.set('content', this.editor.getValue());	
    }

    // Update MetaData
    if (this.metadataEditor) {
      this.model.set('metadata', this.metadataEditor.getValue());
    }

    var label = this.model.get('writable') ?
      t('actions.change.save') :
      t('actions.change.submit');

    this.updateSaveState(label, 'save');
  },

  settings: function() {
    this.contentMode();
    this.sidebar.mode('settings');
    this.sidebar.open();
  },

  showDiff: function() {


    // ---------------- Custom Validation Begin --------------------- 
	if (this.model.get('prod')
		|| this.model.get('nutr')
		|| this.model.get('proc')) {
	  // Be aware that this requires that JSONForm's own version of jsv.js has been
      // added to the global scope. Also see index.html file.
      var env = JSONFormValidator.createEnvironment("json-schema-draft-03");
	  
	  var schema;
	  if (this.model.get('prod')) {
	    schema = { "properties": jsonformformat.prod.schema };
	  }
	  else if (this.model.get('nutr')) {
	    schema = { "properties": jsonformformat.nutr.schema };
	  }
	  else if (this.model.get('proc')) {
	    schema = { "properties": jsonformformat.proc.schema };
	  }
	  else {
	    // Invalid alternative, throw error or something
		Console.log("prose/app/views/file.js/showDiff: Invalid file type for validation.");
		return false;
	  }

      var report = env.validate($('form').jsonFormValue(), schema);
	  if (report.errors.length != 0) { 
	    $('#jsonform').jsonFormErrors(report.errors, {});
		this.edit();
		return false;
	  }
	}
    // ---------------- Custom Validation End ---------------------	
  
/*	// ---------------- Custom Validation Begin ---------------------
    
	// This code only triggers the Browser's validation, but not JSONForm's validation.

	// Not sure, but I believe checkValidity works only if we get the form element
	// through document.getElementById - but not through jQuery! Whatever the case,
	// this works (excluding old browsers).
	if (this.model.get('prod') || this.model.get('nutr')) {
		var jsonFormEl = document.getElementById('jsonform');
		if ((jsonFormEl !== null) && !(typeof jsonFormEl === undefined)) {
		
			var isFormValid = jsonFormEl.checkValidity();
			if (!isFormValid) {
			  // Change the "save" button back to its state
				this.edit();
				
				// Simulate a click on JSONForm submit button
				$('#jsonform input.btn-primary').click();
				return false;
			}
			
		}
	}
	// ---------------- Custom Validation End ---------------------	
*/
    this.contentMode('diff');
    this.sidebar.mode('save');
    this.sidebar.open();

    var $diff = this.$el.find('#diff');

    // Use _.escape() to prevent rendering HTML tags
    var text1 = this.model.isNew() ? '' : _.escape(this.model.get('previous'));
    var text2 = _.escape(this.model.serialize());

    var d = diff.diffWords(text1, text2);
    var length = d.length;
    var compare = '';

    for (var i = 0; i < length; i++) {
      if (d[i].removed) {
        compare += '<del>' + d[i].value + '</del>';
      } else if (d[i].added) {
        compare += '<ins>' + d[i].value + '</ins>';
      } else {
        compare += d[i].value;
      }
    }

    $diff.find('.diff-content').html('<pre>' + compare + '</pre>');
  },

  cancel: function() {
    // Close the sidebar and return the
    // active nav item to the current file mode.
    this.sidebar.close();
    this.nav.active(this.mode);

    // Return back to old mode.
    this.contentMode();
  },

  refreshCodeMirror: function() {
    if (typeof this.editor.refresh === 'function') this.editor.refresh();
  },

  updateMetaData: function() {
    if (!this.model.jekyll) return true; // metadata -> skip
    this.model.metadata = this.metadataEditor.getValue();
    return true;
  },

  patch: function() {
    // Submit a patch (fork + pull request workflow)
    this.updateSaveState(t('actions.save.patch'), 'saving');

    // view.updateMetaData();

    this.model.patch({
      success: (function(res) {
        /*
        // TODO: revert to previous state?
        var previous = view.model.get('previous');
        this.model.content = previous;
        this.editor.setValue(previous);
        this.dirty = false;
        this.model.persisted = true;
        this.model.file = filename;
        this.model.set('previous', filecontent);
        */

        // TODO: why is this breaking?
        // this.toolbar.updatePublishState();

        this.updateURL();
        this.sidebar.close();
        this.updateSaveState(t('actions.save.submission'), 'saved');
      }).bind(this),
      error: (function(model, xhr, options) {
        var res = JSON.parse(xhr.responseText);
        this.updateSaveState(res.message, 'error');
      }).bind(this)
    });
  },

  filepath: function() {
    if (this.titleAsHeading()) {
      return this.sidebar.filepathGet();
    } else {
      return this.header.inputGet();
    }
  },

  absoluteFilepath: function() {
    return this.absolutePathFromComponents(
      this.repo.get('owner').login,
      this.repo.get('name'),
      this.branch,
      this.filepath()
    );
  },

  absolutePathFromFile: function(file) {
    return this.absolutePathFromComponents(
      file.collection.repo.get('owner').login,
      file.collection.repo.get('name'),
      file.collection.branch.get('name'),
      file.get('path')
    );
  },

  absolutePathFromComponents: function(user, repo, branch, path) {
    var url = _.compact([ user, repo, branch, path ]);
    return url.join('/');
  },

  draft: function() {
    var defaults = this.collection.defaults || {};
    var path = this.model.get('path').replace(/^(_posts)/, '_drafts');
    var url;

    // Create File model clone with metadata and content
    // Reassign this.model to clone and re-render
    this.model = this.collection.get(path) || this.model.clone({
      path: path
    });

    // Set default metadata for new path
    if (this.model && defaults) {
      this.model.set('defaults', defaults[this.nearestPath(path, defaults)]);
    }

    // Update view properties
    this.path = path;

    url = _.compact([
      this.repo.get('owner').login,
      this.repo.get('name'),
      this.mode,
      this.branch,
      this.path
    ]);

    this.router.navigate(url.join('/'), {
      trigger: false
    });

    this.sidebar.close();
    this.nav.active('edit');

    this.model.fetch({ complete: this.render });
  },

  post: function(e) {
    var defaults = this.collection.defaults || {};
    var metadata = this.model.get('metadata') || {};
    var content = this.model.get('content') || '';
    var path = this.model.get('path').replace(/^(_drafts)/, '_posts');
    var url;

    // Create File model clone with metadata and content
    // Reassign this.model to clone and re-render
    this.model = this.collection.get(path) || this.model.clone({
      path: path
    });

    // Set default metadata for new path
    if (this.model && defaults) {
      this.model.set('defaults', defaults[this.nearestPath(path, defaults)]);
    }

    // Update view properties
    this.path = path;

    url = _.compact([
      this.repo.get('owner').login,
      this.repo.get('name'),
      this.mode,
      this.branch,
      this.path
    ]);

    this.router.navigate(url.join('/'), {
      trigger: false
    });

    this.model.fetch({
      complete: (function(model, res, options) {
        // Set metadata and content from draft on post model
        this.model.set('metadata', metadata);
        this.model.set('content', content);

        this.render();

        this.nav.active('save');
        this.showDiff();
      }).bind(this)
    });
  },

  translate: function(e) {
    var defaults = this.collection.defaults || {};
    var metadata = this.model.get('metadata') || {};
    var lang = $(e.currentTarget).attr('href').substr(1);
    var path = this.model.get('path').split('/');
    var model;
    var url;

    // TODO: Drop the 'en' requirement.
    if (lang === 'en') {
      // If current page is not english and target page is english
      path.splice(-2, 2, path[path.length - 1]);
    } else if (metadata.lang === 'en') {
      // If current page is english and target page is not english
      path.splice(-1, 1, lang, path[path.length - 1]);
    } else {
      // If current page is not english and target page is not english
      path.splice(-2, 2, lang, path[path.length - 1]);
    }

    path = _.compact(path).join('/');

    var categories = (metadata.categories || []);
    categories.unshift(lang);

    this.model = this.collection.get(path) || this.model.clone({
      metadata: {
        categories: categories,
        lang: lang
      },
      path: path
    });

    // Set default metadata for new path
    if (this.model && defaults) {
      this.model.set('defaults', defaults[this.nearestPath(path, defaults)]);
    }

    // Update view properties
    this.path = path;

    url = _.compact([
      this.repo.get('owner').login,
      this.repo.get('name'),
      this.mode,
      this.branch,
      this.path
    ]);

    this.router.navigate(url.join('/'), {
      trigger: false
    });

    this.sidebar.close();
    this.model.fetch({ complete: this.render });
  },

  stashFile: function(e) {
    if (e) e.preventDefault();
    if (!window.sessionStorage) return false;

    var store = window.sessionStorage;
    var filepath = this.absoluteFilepath();
    // Don't stash if filepath is undefined
    if (filepath) {
      try {
        store.setItem(filepath, JSON.stringify({
          sha: this.model.get('sha'),
          content: this.editor ? this.editor.getValue() : null,
//          content: this.getEditorValue(),
          metadata: this.metadataEditor ? this.metadataEditor.getValue() : null
        }));
      } catch (err) {
        console.log(err);
      }
    }
  },

  stashApply: function() {
    var filepath = this.absolutePathFromFile(this.model);
    var stash = this.getStashForPath(filepath);
    if (!stash) return false;
    if (stash.sha === this.model.get('sha')) {
      // Restore from stash if file sha hasn't changed
      if (this.editor && this.editor.setValue) this.editor.setValue(stash.content);
      if (this.metadataEditor) {
        // this.rawEditor.setValue('');
        this.metadataEditor.setValue(stash.metadata);
      }
    } else {
      // Remove expired content
      this.clearStashForPath(filepath);
    }
  },

  getStashForPath: function(filepath) {
    if (!window.sessionStorage) return false;
    var store = window.sessionStorage;
    var item = store.getItem(filepath);
    return JSON.parse(item);
  },

  clearStashForPath: function(filepath) {
    if (!window.sessionStorage) return;
    var store = window.sessionStorage;
    store.removeItem(filepath);
  },

  updateFile: function() {
    var view = this;
		
    // Trigger the save event
    this.updateSaveState(t('actions.save.saving'), 'saving');

    var method = this.model.get('writable') ? this.model.save : this.patch;

    //this.updateSaveState(t('actions.save.metaError'), 'error');
    //this.updateSaveState(t('actions.error'), 'error');
    //this.updateSaveState(t('actions.save.saved'), 'saved', true);
    //this.updateSaveState(t('actions.save.fileNameError'), 'error');
	
    // Validation checking
    this.model.on('invalid', (function(model, error) {
      this.updateSaveState(error, 'error');

      view.modal = new ModalView({
        message: error
      });

      view.$el.find('#modal').html(view.modal.el);
      view.modal.render();
    }).bind(this));

//	var content = this.getEditorValue();
//	this.model.set('content', (content === null) ? '' : content);
//---------------->	
    // Update content
	if (this.model.get('prod')
		|| this.model.get('nutr')
		|| this.model.get('proc')) {
	
	  //$('#jsonform').trigger('submit');
	  //$('#jsonform input.btn-primary').click();
	
	  var jsonFormValueObj = $('#jsonform').jsonFormValue(); 
	  
	  // Pretty print the json object using indentation of 2 and new lines
	  var jsonFormValueStr = JSON.stringify(jsonFormValueObj, null, 2);
	
    // TODO: Should we check here whether the PROD/NUTR/PROC editor has been initiated?
	  this.model.set('content', jsonFormValueStr);
	}
	else {
//----------------<
      this.model.content = (this.editor) ? this.editor.getValue() : '';

//---------------->
	}
//----------------<

    // Delegate
    method.call(this, {
      success: (function(model, res, options) {
        var url;
        var data;
        var params;

        this.sidebar.close();
        this.updateSaveState(t('actions.save.saved'), 'saved');

        // Enable settings sidebar item
        this.nav.$el.addClass('settings');

        // Update current path
        var path = model.get('path');
        this.path = path;

        // Unset dirty, return to edit view
        this.dirty = false;
        this.edit();

        var old = model.get('oldpath');
        var name = util.extractFilename(old)[1];
        var pathChange = path !== old;

        // Remove old file if renamed
        // TODO: remove this when Repo Contents API supports renaming
        if (model.previous('sha') && pathChange) {
          url = model.url().replace(path, old).split('?')[0];

          data = {
            path: old,
            message: t('actions.commits.deleted', { filename: name }),
            sha: model.previous('sha'),
            branch: this.collection.branch.get('name')
          };

          params = _.map(_.pairs(data), function(param) {
            return param.join('=');
          }).join('&');

          $.ajax({
            type: 'DELETE',
            url: url + '?' + params,
            error: (function(xhr, textStatus, errorThrown) {
              var res = JSON.parse(xhr.responseText);
              this.updateSaveState(res.message, 'error');
            }).bind(this)
          });
        }
      }).bind(this),
      error: (function(model, xhr, options) {
        var res = JSON.parse(xhr.responseText);
        this.updateSaveState(res.message, 'error');
      }).bind(this)
    });

    return false;
  },

  updateSaveState: function(label, classes, kill) {

    // Cancel if this condition is met
    if (classes === 'save' && $(this.el).hasClass('saving')) return;

    // Update the Sidebar save button
    if (this.sidebar) this.sidebar.updateState(label);

    // Update the avatar in the toolbar
    if (this.nav) this.nav.updateState(label, classes, kill);
  },

  updateImageInsert: function(e, file, content) {
    this.queue = {
      e: e,
      file: file,
      content: content
    };
  },

  upload: function(e, file, content, path) {
    // Loading State
    this.updateSaveState(t('actions.upload.uploading', { file: file.name }), 'saving');

    // Default to media directory if defined in config,
    // current directory if no path specified
    var dir = this.config.media ? this.config.media :
      util.extractFilename(this.model.get('path'))[0];
    path = path || _.compact([dir, file.name]).join('/');

    this.collection.upload(file, content, path, {
      success: (function(model, res, options) {
        var name = res.content.name;
        var path = res.content.path;

        // TODO: where does $alt exist in the UI?
        var $alt = $('input[name="alt"]');
        var value = $alt.val();
        var image = (value) ?
          '![' + value + '](/' + path + ')' :
          '![' + name + '](/' + path + ')';

        this.editor.focus();
        this.editor.replaceSelection(image + '\n', 'end');
        this.updateSaveState('Saved', 'saved', true);
      }).bind(this),
      error: (function(model, xhr, options) {
        // Display error message returned by XHR
        var res = JSON.parse(xhr.responseText);
        this.updateSaveState(res.message, 'error');
      }).bind(this)
    });
  },

  remove: function() {
    // Unbind beforeunload prompt
    window.onbeforeunload = null;

    // Reset dirty models on navigation
    if (this.dirty) {
      this.stashFile();
      this.model.fetch();
    }

    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    // Clear any file state classes in #prose
    this.updateSaveState('', '');

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

})()
},{"./jsonformformat.js":29,"../../vendor/liquid.patch":30,"./modal":48,"../models/file":18,"./toolbar":49,"./header":41,"./metadata":50,"../config":4,"../util":28,"../upload":31,"../cookie":3,"../../dist/templates":14,"jquery-browserify":11,"queue-async":47,"js-yaml":44,"underscore":13,"keymaster":51,"marked":43,"backbone":12,"json-form":52,"diff":53}],32:[function(require,module,exports){
var _ = require('underscore');

var Backbone = require('backbone');
var Repo = require('../models/repo');

var auth = require('../config');
var cookie = require('../cookie');

module.exports = Backbone.Collection.extend({
  model: Repo,

  initialize: function(models, options) {
    _.bindAll(this);

    this.user = options.user;

    this.comparator = function(repo) {
      return -(new Date(repo.get('updated_at')).getTime());
    };
  },

  parseLinkHeader: function(xhr, options) {
    options = _.clone(options) || {};

    var header = xhr.getResponseHeader('link');

    if (header) {
      var parts = header.split(',');
      var links = {};

      _.each(parts, function(link) {
        var section = link.split(';');

        var url = section[0].replace(/<(.*)>/, '$1').trim();
        var name = section[1].replace(/rel="(.*)"/, '$1').trim();

        links[name] = url;
      });

      if (links.next) {
        $.ajax({
          type: 'GET',
          url: links.next,
          success: options.success,
          error: options.error
        });
      } else {
        if (_.isFunction(options.complete)) options.complete();
      }
    } else {
      if (_.isFunction(options.error)) options.error();
    }
  },

  fetch: function(options) {
    options = _.clone(options) || {};

    var cb = options.success;

    var success = (function(res, statusText, xhr) {
      this.add(res);
      this.parseLinkHeader(xhr, {
        success: success,
        complete: cb
      });
    }).bind(this);

    Backbone.Collection.prototype.fetch.call(this, _.extend(options, {
      success: (function(model, res, options) {
        this.parseLinkHeader(options.xhr, {
          success: success,
          error: cb
        });
      }).bind(this)
    }));
  },

  url: function() {
    var id = cookie.get('id');
    var type = this.user.get('type');
    var path;

    switch(type) {
      case 'User':
        path = (id && this.user.get('id') === id) ? '/user' :
          ('/users/' + this.user.get('login'))
        break;
      case 'Organization':
        path = '/orgs/' + this.user.get('login');
        break;
    }

    return auth.api + path + '/repos?per_page=100';
  }
});

},{"../models/repo":17,"../config":4,"../cookie":3,"underscore":13,"backbone":12}],43:[function(require,module,exports){
(function(global){/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // url (gfm)
    if (cap = this.rules.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      out += this.outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<strong>'
        + this.output(cap[2] || cap[1])
        + '</strong>';
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<em>'
        + this.output(cap[2] || cap[1])
        + '</em>';
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<code>'
        + escape(cap[2], true)
        + '</code>';
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<br>';
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<del>'
        + this.output(cap[1])
        + '</del>';
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  if (cap[0].charAt(0) !== '!') {
    return '<a href="'
      + escape(link.href)
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>'
      + this.output(cap[1])
      + '</a>';
  } else {
    return '<img src="'
      + escape(link.href)
      + '" alt="'
      + escape(cap[1])
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>';
  }
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return '<hr>\n';
    }
    case 'heading': {
      return '<h'
        + this.token.depth
        + ' id="'
        + this.token.text.toLowerCase().replace(/[^\w]+/g, '-')
        + '">'
        + this.inline.output(this.token.text)
        + '</h'
        + this.token.depth
        + '>\n';
    }
    case 'code': {
      if (this.options.highlight) {
        var code = this.options.highlight(this.token.text, this.token.lang);
        if (code != null && code !== this.token.text) {
          this.token.escaped = true;
          this.token.text = code;
        }
      }

      if (!this.token.escaped) {
        this.token.text = escape(this.token.text, true);
      }

      return '<pre><code'
        + (this.token.lang
        ? ' class="'
        + this.options.langPrefix
        + this.token.lang
        + '"'
        : '')
        + '>'
        + this.token.text
        + '</code></pre>\n';
    }
    case 'table': {
      var body = ''
        , heading
        , i
        , row
        , cell
        , j;

      // header
      body += '<thead>\n<tr>\n';
      for (i = 0; i < this.token.header.length; i++) {
        heading = this.inline.output(this.token.header[i]);
        body += '<th';
        if (this.token.align[i]) {
          body += ' style="text-align:' + this.token.align[i] + '"';
        }
        body += '>' + heading + '</th>\n';
      }
      body += '</tr>\n</thead>\n';

      // body
      body += '<tbody>\n'
      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];
        body += '<tr>\n';
        for (j = 0; j < row.length; j++) {
          cell = this.inline.output(row[j]);
          body += '<td';
          if (this.token.align[j]) {
            body += ' style="text-align:' + this.token.align[j] + '"';
          }
          body += '>' + cell + '</td>\n';
        }
        body += '</tr>\n';
      }
      body += '</tbody>\n';

      return '<table>\n'
        + body
        + '</table>\n';
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return '<blockquote>\n'
        + body
        + '</blockquote>\n';
    }
    case 'list_start': {
      var type = this.token.ordered ? 'ol' : 'ul'
        , body = '';

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return '<'
        + type
        + '>\n'
        + body
        + '</'
        + type
        + '>\n';
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'html': {
      return !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
    }
    case 'paragraph': {
      return '<p>'
        + this.inline.output(this.token.text)
        + '</p>\n';
    }
    case 'text': {
      return '<p>'
        + this.parseText()
        + '</p>\n';
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function() {
      var out, err;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

})(window)
},{}],47:[function(require,module,exports){
(function() {
  var slice = [].slice;

  function queue(parallelism) {
    var q,
        tasks = [],
        started = 0, // number of tasks that have been started (and perhaps finished)
        active = 0, // number of tasks currently being executed (started but not finished)
        remaining = 0, // number of tasks not yet finished
        popping, // inside a synchronous task callback?
        error = null,
        await = noop,
        all;

    if (!parallelism) parallelism = Infinity;

    function pop() {
      while (popping = started < tasks.length && active < parallelism) {
        var i = started++,
            t = tasks[i],
            a = slice.call(t, 1);
        a.push(callback(i));
        ++active;
        t[0].apply(null, a);
      }
    }

    function callback(i) {
      return function(e, r) {
        --active;
        if (error != null) return;
        if (e != null) {
          error = e; // ignore new tasks and squelch active callbacks
          started = remaining = NaN; // stop queued tasks from starting
          notify();
        } else {
          tasks[i] = r;
          if (--remaining) popping || pop();
          else notify();
        }
      };
    }

    function notify() {
      if (error != null) await(error);
      else if (all) await(error, tasks);
      else await.apply(null, [error].concat(tasks));
    }

    return q = {
      defer: function() {
        if (!error) {
          tasks.push(arguments);
          ++remaining;
          pop();
        }
        return q;
      },
      await: function(f) {
        await = f;
        all = false;
        if (!remaining) notify();
        return q;
      },
      awaitAll: function(f) {
        await = f;
        all = true;
        if (!remaining) notify();
        return q;
      }
    };
  }

  function noop() {}

  queue.version = "1.0.7";
  if (typeof define === "function" && define.amd) define(function() { return queue; });
  else if (typeof module === "object" && module.exports) module.exports = queue;
  else this.queue = queue;
})();

},{}],51:[function(require,module,exports){
(function(){//     keymaster.js
//     (c) 2011-2012 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
  var k,
    _handlers = {},
    _mods = { 16: false, 18: false, 17: false, 91: false },
    _scope = 'all',
    // modifier keys
    _MODIFIERS = {
      '⇧': 16, shift: 16,
      '⌥': 18, alt: 18, option: 18,
      '⌃': 17, ctrl: 17, control: 17,
      '⌘': 91, command: 91
    },
    // special keys
    _MAP = {
      backspace: 8, tab: 9, clear: 12,
      enter: 13, 'return': 13,
      esc: 27, escape: 27, space: 32,
      left: 37, up: 38,
      right: 39, down: 40,
      del: 46, 'delete': 46,
      home: 36, end: 35,
      pageup: 33, pagedown: 34,
      ',': 188, '.': 190, '/': 191,
      '`': 192, '-': 189, '=': 187,
      ';': 186, '\'': 222,
      '[': 219, ']': 221, '\\': 220
    },
    code = function(x){
      return _MAP[x] || x.toUpperCase().charCodeAt(0);
    },
    _downKeys = [];

  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

  // IE doesn't support Array#indexOf, so have a simple replacement
  function index(array, item){
    var i = array.length;
    while(i--) if(array[i]===item) return i;
    return -1;
  }

  // for comparing mods before unassignment
  function compareArray(a1, a2) {
    if (a1.length != a2.length) return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  var modifierMap = {
      16:'shiftKey',
      18:'altKey',
      17:'ctrlKey',
      91:'metaKey'
  };
  function updateModifierKey(event) {
      for(k in _mods) _mods[k] = event[modifierMap[k]];
  };

  // handle keydown event
  function dispatch(event, scope){
    var key, handler, k, i, modifiersMatch;
    key = event.keyCode;

    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }

    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
    if(key in _mods) {
      _mods[key] = true;
      // 'assignKey' from inside this closure is exported to window.key
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
      return;
    }
    updateModifierKey(event);

    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if(!assignKey.filter.call(this, event)) return;

    // abort if no potentially matching shortcuts found
    if (!(key in _handlers)) return;

    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
      handler = _handlers[key][i];

      // see if it's in the current scope
      if(handler.scope == scope || handler.scope == 'all'){
        // check if modifiers match if any
        modifiersMatch = handler.mods.length > 0;
        for(k in _mods)
          if((!_mods[k] && index(handler.mods, +k) > -1) ||
            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
        // call the handler and stop the event if neccessary
        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
          if(handler.method(event, handler)===false){
            if(event.preventDefault) event.preventDefault();
              else event.returnValue = false;
            if(event.stopPropagation) event.stopPropagation();
            if(event.cancelBubble) event.cancelBubble = true;
          }
        }
      }
    }
  };

  // unset modifier keys on keyup
  function clearModifier(event){
    var key = event.keyCode, k,
        i = index(_downKeys, key);

    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }

    if(key == 93 || key == 224) key = 91;
    if(key in _mods) {
      _mods[key] = false;
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
    }
  };

  function resetModifiers() {
    for(k in _mods) _mods[k] = false;
    for(k in _MODIFIERS) assignKey[k] = false;
  };

  // parse and assign shortcut
  function assignKey(key, scope, method){
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
      method = scope;
      scope = 'all';
    }

    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
      // set modifier keys if any
      mods = [];
      key = keys[i].split('+');
      if (key.length > 1){
        mods = getMods(key);
        key = [key[key.length-1]];
      }
      // convert to keycode and...
      key = key[0]
      key = code(key);
      // ...store handler
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
    }
  };

  // unbind all handlers for given key in current scope
  function unbindKey(key, scope) {
    var keys = key.split('+'),
      mods = [],
      i, obj;

    if (keys.length > 1) {
      mods = getMods(keys);
      key = keys[keys.length - 1];
    }

    key = code(key);

    if (scope === undefined) {
      scope = getScope();
    }
    if (!_handlers[key]) {
      return;
    }
    for (i in _handlers[key]) {
      obj = _handlers[key][i];
      // only clear handlers if correct scope and mods match
      if (obj.scope === scope && compareArray(obj.mods, mods)) {
        _handlers[key][i] = {};
      }
    }
  };

  // Returns true if the key with code 'keyCode' is currently down
  // Converts strings into key codes.
  function isPressed(keyCode) {
      if (typeof(keyCode)=='string') {
        keyCode = code(keyCode);
      }
      return index(_downKeys, keyCode) != -1;
  }

  function getPressedKeyCodes() {
      return _downKeys.slice(0);
  }

  function filter(event){
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
  }

  // initialize key.<modifier> to false
  for(k in _MODIFIERS) assignKey[k] = false;

  // set current scope (default 'all')
  function setScope(scope){ _scope = scope || 'all' };
  function getScope(){ return _scope || 'all' };

  // delete all handlers for a given scope
  function deleteScope(scope){
    var key, handlers, i;

    for (key in _handlers) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);
        else i++;
      }
    }
  };

  // abstract key logic for assign and unassign
  function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if ((keys[keys.length - 1]) == '') {
      keys[keys.length - 2] += ',';
    }
    return keys;
  }

  // abstract mods logic for assign and unassign
  function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
    mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
  }

  // cross-browser events
  function addEvent(object, event, method) {
    if (object.addEventListener)
      object.addEventListener(event, method, false);
    else if(object.attachEvent)
      object.attachEvent('on'+event, function(){ method(window.event) });
  };

  // set the handlers globally on document
  addEvent(document, 'keydown', function(event) { dispatch(event, _scope) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
  addEvent(document, 'keyup', clearModifier);

  // reset modifiers to false whenever the window is (re)focused.
  addEvent(window, 'focus', resetModifiers);

  // store previously defined key
  var previousKey = global.key;

  // restore previously defined key and return reference to our key object
  function noConflict() {
    var k = global.key;
    global.key = previousKey;
    return k;
  }

  // set window.key and window.key.set/get/deleteScope, and the default filter
  global.key = assignKey;
  global.key.setScope = setScope;
  global.key.getScope = getScope;
  global.key.deleteScope = deleteScope;
  global.key.filter = filter;
  global.key.isPressed = isPressed;
  global.key.getPressedKeyCodes = getPressedKeyCodes;
  global.key.noConflict = noConflict;
  global.key.unbind = unbindKey;

  if(typeof module !== 'undefined') module.exports = key;

})(this);

})()
},{}],53:[function(require,module,exports){
/* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
var JsDiff = (function() {
  /*jshint maxparams: 5*/
  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }
  function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');

    return n;
  }

  var Diff = function(ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
  };
  Diff.prototype = {
      diff: function(oldString, newString) {
        // Handle the identity case (this is due to unrolling editLength == 0
        if (newString === oldString) {
          return [{ value: newString }];
        }
        if (!newString) {
          return [{ value: oldString, removed: true }];
        }
        if (!oldString) {
          return [{ value: newString, added: true }];
        }

        newString = this.tokenize(newString);
        oldString = this.tokenize(oldString);

        var newLen = newString.length, oldLen = oldString.length;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{ newPos: -1, components: [] }];

        // Seed editLength = 0
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {
          return bestPath[0].components;
        }

        for (var editLength = 1; editLength <= maxEditLength; editLength++) {
          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {
            var basePath;
            var addPath = bestPath[diagonalPath-1],
                removePath = bestPath[diagonalPath+1];
            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath-1] = undefined;
            }

            var canAdd = addPath && addPath.newPos+1 < newLen;
            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }

            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
              basePath = clonePath(removePath);
              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
            } else {
              basePath = clonePath(addPath);
              basePath.newPos++;
              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
            }

            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);

            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {
              return basePath.components;
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
        }
      },

      pushComponent: function(components, value, added, removed) {
        var last = components[components.length-1];
        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length-1] =
            {value: this.join(last.value, value), added: added, removed: removed };
        } else {
          components.push({value: value, added: added, removed: removed });
        }
      },
      extractCommon: function(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath;
        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {
          newPos++;
          oldPos++;

          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
        }
        basePath.newPos = newPos;
        return oldPos;
      },

      equals: function(left, right) {
        var reWhitespace = /\S/;
        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
          return true;
        } else {
          return left === right;
        }
      },
      join: function(left, right) {
        return left + right;
      },
      tokenize: function(value) {
        return value;
      }
  };

  var CharDiff = new Diff();

  var WordDiff = new Diff(true);
  var WordWithSpaceDiff = new Diff();
  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
    return removeEmpty(value.split(/(\s+|\b)/));
  };

  var CssDiff = new Diff(true);
  CssDiff.tokenize = function(value) {
    return removeEmpty(value.split(/([{}:;,]|\s+)/));
  };

  var LineDiff = new Diff();
  LineDiff.tokenize = function(value) {
    var retLines = [],
        lines = value.split(/^/m);

    for(var i = 0; i < lines.length; i++) {
      var line = lines[i],
          lastLine = lines[i - 1];

      // Merge lines that may contain windows new lines
      if (line == '\n' && lastLine && lastLine[lastLine.length - 1] === '\r') {
        retLines[retLines.length - 1] += '\n';
      } else if (line) {
        retLines.push(line);
      }
    }

    return retLines;
  };

  return {
    Diff: Diff,

    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
    diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },
    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },

    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },

    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
      var ret = [];

      ret.push('Index: ' + fileName);
      ret.push('===================================================================');
      ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
      ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));

      var diff = LineDiff.diff(oldStr, newStr);
      if (!diff[diff.length-1].value) {
        diff.pop();   // Remove trailing newline add
      }
      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier

      function contextLines(lines) {
        return lines.map(function(entry) { return ' ' + entry; });
      }
      function eofNL(curRange, i, current) {
        var last = diff[diff.length-2],
            isLast = i === diff.length-2,
            isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);

        // Figure out if this is the last line for the given file and missing NL
        if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
          curRange.push('\\ No newline at end of file');
        }
      }

      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
          oldLine = 1, newLine = 1;
      for (var i = 0; i < diff.length; i++) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
        current.lines = lines;

        if (current.added || current.removed) {
          if (!oldRangeStart) {
            var prev = diff[i-1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;

            if (prev) {
              curRange = contextLines(prev.lines.slice(-4));
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?'+':'-') + entry; }));
          eofNL(curRange, i, current);

          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            // Close out any changes that have been output (or join overlapping)
            if (lines.length <= 8 && i < diff.length-2) {
              // Overlapping
              curRange.push.apply(curRange, contextLines(lines));
            } else {
              // end the range and output
              var contextSize = Math.min(lines.length, 4);
              ret.push(
                  '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)
                  + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)
                  + ' @@');
              ret.push.apply(ret, curRange);
              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
              if (lines.length <= 4) {
                eofNL(ret, i, current);
              }

              oldRangeStart = 0;  newRangeStart = 0; curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      }

      return ret.join('\n') + '\n';
    },

    applyPatch: function(oldStr, uniDiff) {
      var diffstr = uniDiff.split('\n');
      var diff = [];
      var remEOFNL = false,
          addEOFNL = false;

      for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {
        if(diffstr[i][0] === '@') {
          var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
          diff.unshift({
            start:meh[3],
            oldlength:meh[2],
            oldlines:[],
            newlength:meh[4],
            newlines:[]
          });
        } else if(diffstr[i][0] === '+') {
          diff[0].newlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === '-') {
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === ' ') {
          diff[0].newlines.push(diffstr[i].substr(1));
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === '\\') {
          if (diffstr[i-1][0] === '+') {
            remEOFNL = true;
          } else if(diffstr[i-1][0] === '-') {
            addEOFNL = true;
          }
        }
      }

      var str = oldStr.split('\n');
      for (var i = diff.length - 1; i >= 0; i--) {
        var d = diff[i];
        for (var j = 0; j < d.oldlength; j++) {
          if(str[d.start-1+j] !== d.oldlines[j]) {
            return false;
          }
        }
        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
      }

      if (remEOFNL) {
        while (!str[str.length-1]) {
          str.pop();
        }
      } else if (addEOFNL) {
        str.push('');
      }
      return str.join('\n');
    },

    convertChangesToXML: function(changes){
      var ret = [];
      for ( var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push('<ins>');
        } else if (change.removed) {
          ret.push('<del>');
        }

        ret.push(escapeHTML(change.value));

        if (change.added) {
          ret.push('</ins>');
        } else if (change.removed) {
          ret.push('</del>');
        }
      }
      return ret.join('');
    },

    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
    convertChangesToDMP: function(changes){
      var ret = [], change;
      for ( var i = 0; i < changes.length; i++) {
        change = changes[i];
        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
      }
      return ret;
    }
  };
})();

if (typeof module !== 'undefined') {
    module.exports = JsDiff;
}

},{}],33:[function(require,module,exports){
module.exports = require('./lib/chrono');

},{"./lib/chrono":54}],44:[function(require,module,exports){
module.exports = require('./lib/js-yaml.js');

},{"./lib/js-yaml.js":55}],54:[function(require,module,exports){
(function(){

// CommonJS exports.
var data = (typeof exports !== 'undefined') ? exports : {};

data.tzToOffset = {
  'ACDT': -630,
  'ACST': -570,
  'ACT': -480,
  'ADT': +180,
  'AEDT': -660,
  'AEST': -600,
  'AFT': -270,
  'AKDT': +480,
  'AKST': +540,
  'AMST': -300,
  'AMT': -240,
  'ART': +180,
  'AST': -240, // Arab Standard Time
  'AWDT': -540,
  'AWST': -480,
  'AZOST': +60,
  'AZT': -240,
  'BDT': -480,
  'BIOT': -360,
  'BIT': +720,
  'BOT': +240,
  'BRT': +180,
  'BST': -60, // British Summer Time
  'BTT': -360,
  'CAT': -120,
  'CCT': -390,
  'CDT': +300,
  'CEDT': -120,
  'CEST': -120,
  'CET': -60,
  'CHAST': -765,
  'ChST': -600,
  'CIST': +480,
  'CKT': +600,
  'CLST': +180,
  'CLT': +240,
  'COST': +240,
  'COT': +300,
  'CST': -480,
  'CST': +360,
  'CVT': +60,
  'CXT': -420,
  'DFT': -60,
  'EAST': +360,
  'EAT': -180,
  'ECT': +240,
  'ECT': +300,
  'EDT': +240,
  'EEDT': -180,
  'EEST': -180,
  'EET': -120,
  'EST': +300,
  'FJT': -720,
  'FKST': +240,
  'GALT': +360,
  'GET': -240,
  'GFT': +180,
  'GILT': -720,
  'GIT': +540,
  'GMT': 0,
  'GST': +120,
  'GYT': +240,
  'HADT': +540,
  'HAST': +600,
  'HKT': -480,
  'HMT': -300,
  'HST': +600,
  'IRKT': -480,
  'IRST': -210,
  'IST': -120,
  'IST': -330,
  'IST': -60,
  'JST': -540,
  'KRAT': -420,
  'KST': -540,
  'LHST': -630,
  'LINT': -840,
  'MAGT': -660,
  'MDT': +360,
  'MIT': +570,
  'MSD': -240,
  'MSK': -180,
  'MST': -390,
  'MST': -480,
  'MST': +420,
  'MUT': -240,
  'NDT': +150,
  'NFT': -690,
  'NPT': -345,
  'NST': +210,
  'NT': +210,
  'NZST': -720,
  'NZDT': -780,
  'OMST': -360,
  'PDT': +420,
  'PETT': -720,
  'PHOT': -780,
  'PKT': -300,
  'PST': -480,
  'PST': +480,
  'RET': -240,
  'SAMT': -240,
  'SAST': -120,
  'SBT': -660,
  'SCT': -240,
  'SLT': -330,
  'SST': -480,
  'SST': +660,
  'TAHT': +600,
  'THA': -420,
  'UTC': 0,
  'UYST': +120,
  'UYT': +180,
  'VET': +270,
  'VLAT': -600,
  'WAT': -60,
  'WEDT': -60,
  'WEST': -60,
  'YAKT': -540,
  'YEKT': -300
};

// While indices are strings here, numbers work fine too when retrieving.
data.offsetToTz = {
  '720':  ['BIT'],
  '660':  ['SST'],
  '600':  ['HST', 'CKT', 'HAST', 'TAHT'],
  '570':  ['MIT'],
  '540':  ['AKST', 'GIT', 'HADT'],
  '480':  ['PST', 'AKDT', 'CIST'],
  '420':  ['MST', 'PDT'],
  '360':  ['CST', 'EAST', 'GALT', 'MDT'],
  '300':  ['EST', 'CDT', 'COT', 'ECT'],
  '270':  ['VET'],
  '240':  ['ECT', 'AST', 'BOT', 'CLT', 'COST', 'EDT', 'FKST', 'GYT'],
  '210':  ['NT', 'NST'],
  '180':  ['BRT', 'ADT', 'ART', 'CLST', 'GFT', 'UYT'],
  '150':  ['NDT'],
  '120':  ['GST', 'UYST'],
  '60':   ['AZOST', 'CVT'],
  '0':    ['UTC', 'GMT'],
  '-60':  ['CET', 'BST', 'DFT', 'IST', 'WAT', 'WEDT', 'WEST'],
  '-120': ['EET', 'CAT', 'CEDT', 'CEST', 'IST', 'SAST'],
  '-180': ['MSK', 'AST', 'AST', 'EAT', 'EEDT', 'EEST'],
  '-210': ['IRST'],
  '-240': ['AST', 'AMT', 'AZT', 'GET', 'MSD', 'MUT', 'RET', 'SAMT', 'SCT'],
  '-270': ['AFT'],
  '-300': ['AMST', 'HMT', 'PKT', 'YEKT'],
  '-330': ['IST', 'SLT'],
  '-345': ['NPT'],
  '-360': ['BIOT', 'BST', 'BTT', 'OMST'],
  '-390': ['CCT', 'MST'],
  '-420': ['CXT', 'KRAT', 'THA'],
  '-480': ['ACT', 'AWST', 'BDT', 'CST', 'HKT', 'IRKT', 'MST', 'PST', 'SST'],
  '-540': ['AWDT', 'JST', 'KST', 'YAKT'],
  '-570': ['ACST'],
  '-600': ['AEST', 'ChST', 'VLAT'],
  '-630': ['ACDT', 'LHST'],
  '-660': ['AEDT', 'MAGT', 'SBT'],
  '-690': ['NFT'],
  '-720': ['FJT', 'GILT', 'PETT', 'NZST'],
  '-765': ['CHAST'],
  '-780': ['PHOT', 'NZDT'],
  '-840': ['LINT']
};

data.weekdays = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ];

data.weekdaysShort = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ];

data.months = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ];

data.monthsShort = [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ];

data.intervals = [
    function(n) { return n !== 1 ? 'years' : 'year'; },
    function(n) { return n !== 1 ? 'months' : 'month'; },
    function(n) { return n !== 1 ? 'weeks' : 'week'; },
    function(n) { return n !== 1 ? 'days' : 'day'; },
    function(n) { return n !== 1 ? 'hours' : 'hour'; },
    function(n) { return n !== 1 ? 'minutes' : 'minute'; },
    function(n) { return n !== 1 ? 'seconds' : 'second'; }
];

data.intervalFormats = {
    'ago': '% ago',
    'in': 'in %'
};

data.ordinals = function(number) {
  switch (number % 10) {
    case 1: return (number % 100 !== 11) ? 'st' : 'th';
    case 2: return (number % 100 !== 12) ? 'nd' : 'th';
    case 3: return (number % 100 !== 13) ? 'rd' : 'th';
    default: return 'th';
  }
};

function pad2(i) {
  return i < 10 ? '0' + i : i;
};

function pad2sign(i) {
  var sgn = i < 0 ? '-' : '+';
  i = Math.abs(i);
  return sgn + (i < 10 ? '0' + i : i);
};

function pad3(i) {
  return i < 10 ? '00' + i : i < 100 ? '0' + i : i;
};

function pad4sign(i) {
  var sgn = i < 0 ? '-' : '+';
  i = Math.abs(i);
  return sgn + (i < 10 ? '000' + i : i < 100 ? '00' + i : i < 1000 ? '0' + i : i);
}

Date.prototype.interval = function(other) {
    var self = this, inverse = self > other;
    if (inverse) {
        self = other;
        other = this;
    }

    var parts = [
        other.getFullYear() - self.getFullYear(),
        other.getMonth() - self.getMonth(),
        0, // weeks
        other.getDate() - self.getDate(),
        other.getHours() - self.getHours(),
        other.getMinutes() - self.getMinutes(),
        other.getSeconds() - self.getSeconds()
    ];
    if (parts[6] < 0) { parts[5]--; parts[6] += 60; }
    if (parts[5] < 0) { parts[4]--; parts[5] += 60; }
    if (parts[4] < 0) { parts[3]--; parts[4] += 24; }
    if (parts[3] < 0) { parts[1]--; parts[3] += self.getUTCDaysOfMonth(); }
    if (parts[1] < 0) { parts[0]--; parts[1] += 12; }
    parts[2] = (parts[3] / 7) | 0;
    parts[3] -= parts[2] * 7;

    var fragments = [];
    for (var i = 0; i < parts.length; i++) {
        if (parts[i]) {
            fragments.push(parts[i] + ' ' + data.intervals[i](parts[i]));
        }
    }
    return fragments;
};

Date.prototype.format = function(format, tz) {
  var time = this.getTime();

  if (tz === undefined) {
    tz = this.getTimezone();
    tzName = this.getTimezoneName();
  }
  else {
    var tzData = parseTimezone(tz);
    tz = tzData[0];
    var tzName = tzData[1];
  }

  // Use correct timezone.
  this.setTime(time - tz * 60000);

  var result = '';
  for (var i = 0; i < format.length; i++) {
    switch (format.charAt(i)) {
      // Day
      case 'd': result += pad2(this.getUTCDate()); break;
      case 'D': result += data.weekdaysShort[this.getUTCDay()]; break;
      case 'j': result += this.getUTCDate(); break;
      case 'l': result += data.weekdays[this.getUTCDay()]; break;
      case 'N': result += this.getUTCDay() || 7; break;
      case 'S': result += data.ordinals(this.getUTCDate()); break;
      case 'w': result += this.getUTCDay(); break;
      case 'z': result += this.getUTCDayOfYear(); break;

      // Week
      case 'W': result += pad2(this.getUTCISOWeek()); break;

      // Month
      case 'F': result += data.months[this.getUTCMonth()]; break;
      case 'm': result += pad2(this.getUTCMonth() + 1); break;
      case 'M': result += data.monthsShort[this.getUTCMonth()]; break;
      case 'n': result += this.getUTCMonth() + 1; break;
      case 't': result += this.getUTCDaysOfMonth(); break;

      // Year
      case 'L': result += this.isLeapYear() ? 1 : 0; break;
      case 'o': result += this.getUTCISOFullYear(); break;
      case 'Y': result += this.getUTCFullYear(); break;
      case 'y': result += pad2(this.getUTCFullYear() % 100); break;

      // Time
      case 'a': result += this.getUTCHours() >= 12 ? 'pm' : 'am'; break;
      case 'A': result += this.getUTCHours() >= 12 ? 'PM' : 'AM'; break;
      case 'g': result += this.getUTCHours() % 12 || 12; break;
      case 'G': result += this.getUTCHours(); break;
      case 'h': result += pad2(this.getUTCHours() % 12 || 12); break;
      case 'H': result += pad2(this.getUTCHours()); break;
      case 'i': result += pad2(this.getUTCMinutes()); break;
      case 's': result += pad2(this.getUTCSeconds()); break;
      case 'u': result += pad3(this.getUTCMilliseconds()); break;

      // Timezone
      case 'O': result += pad4sign((tz < 0 ? 1 : -1) * (Math.floor(Math.abs(tz) / 60) * 100 + Math.abs(tz) % 60)); break;
      case 'P': result += pad2sign((tz < 0 ? 1 : -1) * (Math.floor(Math.abs(tz) / 60))) + ':' + pad2(Math.abs(tz) % 60); break;
      case 'T': result += tzName; break;
      case 'Z': result += -tz * 60; break;

      // Full Date/Time
      case 'c': this.setTime(time); result += this.format('Y-m-d\\TH:i:sP', tz); break;
      case 'r': this.setTime(time); result += this.format('D, d M y H:i:s O', tz); break;
      case 'U': result += Math.floor(this.getTime() / 1000); break;

      case '\\': if (format.charAt(++i) !== undefined) result += format.charAt(i); break;

      default: result += format.charAt(i); break;
    }
  }

  this.setTime(time);

  return result;
};

function parseTimezone(tz) {
  if (typeof tz === 'number') {
    return [tz, tz in data.offsetToTz ? data.offsetToTz[tz][0] : ''];
  }
  var number = parseInt(tz, 10);
  if (isNaN(number)) {
    return [data.tzToOffset[tz], tz];
  }
  else {
    tz = (number < 0 ? 1 : -1) * (Math.floor(Math.abs(number) / 100) * 60 + Math.abs(number) % 100);
    return [tz, tz in data.offsetToTz ? data.offsetToTz[tz][0] : ''];
  }
}

Date.prototype.isLeapYear = function() {
  var y = this.getUTCFullYear();
  return (y % 400 === 0) || (y % 4 === 0 && y % 100 !== 0);
};

Date.prototype.getUTCISOWeek = function() {
  // Go to the week's thursday.
  var d = new Date(this);
  d.setUTCDate(d.getUTCDate() - (d.getUTCDay() || 7) + 4);
  return Math.ceil((d.getTime() - Date.UTC(d.getUTCFullYear(), 0)) / 86400000 / 7);
};

Date.prototype.getUTCISOFullYear = function() {
  // Go to the week's thursday.
  var d = new Date(this);
  d.setUTCDate(d.getUTCDate() - (d.getUTCDay() || 7) + 4);
  return d.getUTCFullYear();
};

Date.prototype.getUTCDaysOfMonth = function() {
  var d = new Date(this);
  d.setUTCDate(1);
  d.setUTCMonth(d.getUTCMonth() + 1);
  d.setUTCDate(0);
  return d.getUTCDate();
};

Date.prototype.getUTCDayOfYear = function() {
  return Math.floor((this.getTime() - Date.UTC(this.getUTCFullYear(), 0)) / 86400000);
};

Date.prototype.getTimezone = function() {
  if (!('_tz' in this)) {
    this.setTimezone(new Date().getTimezoneOffset());
  }
  return this._tz;
};

Date.prototype.getTimezoneName = function() {
  this.getTimezone(); // Make sure the tz data is populated.
  return this._tzName;
};

Date.prototype.setTimezone = function(val) {
  var tzData = parseTimezone(val);
  this._tz = tzData[0];
  this._tzName = tzData[1];
};

})();

},{}],35:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
});

},{"backbone":12}],36:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var Branch = require('../models/branch');

module.exports = Backbone.Collection.extend({
  model: Branch,

  initialize: function(models, options) {
    this.repo = options.repo;
  },

  parse: function(resp, options) {
    return map = _.map(resp, (function(branch) {
     return  _.extend(branch, {
        repo: this.repo
      })
    }).bind(this));
  },

  url: function() {
    return this.repo.url() + '/branches';
  }
});

},{"../models/branch":56,"underscore":13,"backbone":12}],38:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.loading,

  queue: 0,

  initialize: function() {
    _.bindAll(this);
  },

  start: function(message) {
    this.queue++;

    if (message) {
      this.$el.find('.message').html(message);
    }

    this.$el.show();
  },

  stop: function() {
    this.queue = 0;
    this.$el.fadeOut(150);
  },

  done: function() {
    _.defer((function() {
      this.queue--;
      if (this.queue < 1) this.stop();
    }).bind(this));
  },

  render: function() {
    this.$el.html(_.template(this.template, {}, { variable: 'data' }));
    return this;
  }
});

},{"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],39:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var config = require('../config');
var utils = require('../util');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.nav,

  events: {
    'click a.edit': 'emit',
    'click a.preview': 'emit',
    'click a.meta': 'emit',
    'click a.settings': 'emit',
    'click a.save': 'emit',
    'click .mobile .toggle': 'toggleMobile'
  },

  initialize: function(options) {
    this.app = options.app;
    this.sidebar = options.sidebar;
    this.user = options.user;
  },

  render: function() {
    this.$el.html(_.template(this.template, {
      login: config.site + '/login/oauth/authorize?client_id=' + config.id + '&scope=repo'
    }, { variable: 'data' }));

    this.$save = this.$el.find('.file .save .popup');
    return this;
  },

  emit: function(e) {
    // TODO: get rid of this hack exception
    if (e && !$(e.currentTarget).hasClass('preview')) e.preventDefault();

    var state = $(e.currentTarget).data('state');
    if ($(e.currentTarget).hasClass('active')) {
      // return to file state
      state = this.state;
    }

    this.active(state);
    this.toggle(state, e);
  },

  setFileState: function(state) {
    this.state = state;
    this.active(state);
  },

  updateState: function(label, classes, kill) {

    if (!label) label = t('navigation.save');
    this.$save.html(label);

    // Add, remove classes to the file nav group
    this.$el.find('.file')
      .removeClass('error saving saved save')
      .addClass(classes);

    if (kill) {
      _.delay((function() {
        this.$el.find('.file').removeClass(classes);
      }).bind(this), 1000);
    }
  },

  mode: function(mode) {
    this.$el.attr('class', mode);
  },

  active: function(state) {
    // Coerce 'new' to 'edit' to activate correct icon
    state = (state === 'new' ? 'edit' : state);
    this.$el.find('.file a').removeClass('active');
    this.$el.find('.file a[data-state=' + state + ']').toggleClass('active');
  },

  toggle: function(state, e) {
    this.trigger(state, e);
  },

  toggleMobile: function(e) {
    this.sidebar.toggleMobile();
    $(e.target).toggleClass('active');
    return false;
  }
});

},{"../config":4,"../util":28,"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],40:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var util = require('../util');

var views = {
  branches: require('./sidebar/branches'),
  history: require('./sidebar/history'),
  drafts: require('./sidebar/drafts'),
  orgs: require('./sidebar/orgs'),
  save: require('./sidebar/save'),
  settings: require('./sidebar/settings')
};

var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.drawer,

  subviews: {},

  initialize: function(options) {
    _.bindAll(this);
  },

  render: function(options) {
    this.$el.html(_.template(this.template, {}, { variable: 'sidebar' }));
    _.invoke(this.subviews, 'render');
    return this;
  },

  initSubview: function(subview, options) {
    if (!views[subview]) return false;

    options = _.clone(options) || {};

    var view = new views[subview](options);
    this.$el.find('#' + subview).html(view.el);

    this.subviews[subview] = view;

    return view;
  },

  filepathGet: function() {
    return this.$el.find('.filepath').val();
  },

  updateState: function(label) {
    this.$el.find('.button.save').html(label);
  },

  open: function() {
    this.$el.toggleClass('open', true);
  },

  close: function() {
    this.$el.toggleClass('open', false);
  },

  toggle: function() {
    this.$el.toggleClass('open');
  },

  toggleMobile: function() {
    this.$el.toggleClass('mobile');
  },

  mode: function(mode) {
    // Set data-mode attribute to toggle nav buttons in CSS
    this.$el.attr('data-sidebar', mode);
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"../util":28,"./sidebar/branches":57,"./sidebar/history":58,"./sidebar/drafts":59,"./sidebar/orgs":42,"./sidebar/save":60,"./sidebar/settings":61,"../../dist/templates":14,"backbone":12,"underscore":13}],37:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var Commit = require('../models/commit');

module.exports = Backbone.Collection.extend({
  model: Commit,

  initialize: function(models, options) {
    this.repo = options.repo;
  },

  setBranch: function(branch, options) {
    this.branch = branch;
    this.fetch(options);
  },

  parse: function(resp, options) {
    return map = _.map(resp, (function(commit) {
     return  _.extend(commit, {
        repo: this.repo
      })
    }).bind(this));
  },

  url: function() {
    return this.repo.url() + '/commits?sha=' + this.branch;
  }
});

},{"../models/commit":62,"underscore":13,"backbone":12}],41:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var util = require('../util');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.header,

  events: {
    'focus input': 'checkPlaceholder',
    'change input[data-mode="path"]': 'updatePath',
    'change input[data-mode="title"]': 'updateTitle'
  },

  initialize: function(options) {
    _.bindAll(this);

    this.user = options.user;
    this.repo = options.repo;
    this.file = options.file;
    this.input = options.input;
    this.title = options.title;
    this.placeholder = options.placeholder;
    this.alterable = options.alterable;
  },

  render: function() {
    var user = this.user ? this.user.get('login') : this.repo.get('owner').login;
    var permissions = this.repo ? this.repo.get('permissions') : undefined;
    var isPrivate = this.repo && this.repo.get('private') ? true : false;
    var title = t('heading.explore');
    var avatar;
    var path = user;

    if (this.user) {
      avatar = '<img src="' + this.user.get('avatar_url') + '" width="40" height="40" alt="Avatar" />';
    } else if (this.file) {
      // File View
      avatar = '<span class="ico round document ' + this.file.get('lang') + '"></span>';
      title = this.file.get('path');
    } else {
      // Repo View
      var lock = (isPrivate) ? ' private' : '';

      title = this.repo.get('name');
      path = path + '/' + title;
      avatar = '<div class="avatar round"><span class="icon round repo' + lock + '"></span></div>';
    }

    var data = {
      alterable: this.alterable,
      avatar: avatar,
      repo: this.repo ? this.repo.attributes : undefined,
      isPrivate: isPrivate,
      input: this.input,
      path: path,
      placeholder: this.placeholder,
      user: user,
      title: title,
      mode: this.title ? 'title' : 'path',
      translate: this.file ? this.file.get('translate') : undefined
    };

    this.$el.empty().append(_.template(this.template, data, {
      variable: 'data'
    }));

    return this;
  },

  checkPlaceholder: function(e) {
    if (this.file.isNew()) {
      var $target = $(e.target, this.el);
      if (!$target.val()) {
        $target.val($target.attr('placeholder'));
      }
    }
  },

  updatePath: function(e) {
    var value = e.currentTarget.value;

    this.file.set('path', value);
    this.trigger('makeDirty');
    return false;
  },

  updateTitle: function(e) {
    if (e) e.preventDefault();

    // TODO: update metadata title here, don't rely on makeDi

    // Only update path on new files that are not cloned
    if (this.file.isNew() && !this.file.isClone()) {
      var value = e.currentTarget.value;

      var path = this.file.get('path');
      var parts = path.split('/');
      var name = parts.pop();

      // Preserve the date and the extension
      var date = util.extractDate(name);
      var extension = name.split('.').pop();

      path = parts.join('/') + '/' + date + '-' +
        util.stringToUrl(value) + '.' + extension;

      this.file.set('path', path);
    }

    this.trigger('makeDirty');
  },

  inputGet: function() {
    return this.$el.find('.headerinput').val();
  },

  headerInputFocus: function() {
    this.$el.find('.headerinput').focus();
  }
});

},{"../util":28,"../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],46:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var File = require('../models/file');
var Folder = require('../models/folder');
var FileView = require('./li/file');
var FolderView = require('./li/folder');
var templates = require('../../dist/templates');
var util = require('.././util');

module.exports = Backbone.View.extend({
  className: 'listings',

  template: templates.files,

  subviews: {},

  events: {
    'mouseover .item': 'activeListing',
    'mouseover .item a': 'activeListing',
    'click .breadcrumb a': 'navigate',
    'click .item a': 'navigate'
  },

  initialize: function(options) {
    _.bindAll(this);

    var app = options.app;
    app.loader.start();

    this.app = app;
    this.branch = options.branch || options.repo.get('default_branch');
    this.branches = options.branches;
    this.history = options.history;
    this.nav = options.nav;
    this.path = options.path || '';
    this.repo = options.repo;
    this.router = options.router;
    this.search = options.search;
    this.sidebar = options.sidebar;

    this.branches.fetch({
      success: this.setModel,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: this.app.loader.done
    });
  },

  setModel: function() {
    this.app.loader.start();

    this.model = this.branches.findWhere({ name: this.branch }).files;

    this.model.fetch({
      success: (function() {
        // Update this.path with rooturl
        var config = this.model.config;
        this.rooturl = config && config.rooturl ? config.rooturl : '';

        this.presentationModel = this.model.filteredModel || this.model;
        this.search.model = this.presentationModel;
        // Render on fetch and on search
        this.listenTo(this.search, 'search', this.render);
        this.render();
      }).bind(this),
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: this.app.loader.done,
      reset: true
    });
  },

  newFile: function() {
    var path = [
      this.repo.get('owner').login,
      this.repo.get('name'),
      'new',
      this.branch,
      this.path ? this.path : this.rooturl
    ]

    this.router.navigate(_.compact(path).join('/'), true);
  },

  render: function() {
    this.app.loader.start();

    var search = this.search && this.search.input && this.search.input.val();
    var rooturl = this.rooturl ? this.rooturl + '/' : '';
    var path = this.path ? this.path + '/' : '';
    var drafts;

    var url = [
      this.repo.get('owner').login,
      this.repo.get('name'),
      'tree',
      this.branch
    ].join('/');

    // Set rooturl jail from collection config
    var regex = new RegExp('^' + (path ? path : rooturl) + '[^\/]*$');

    // Render drafts link in sidebar as subview
    // if _posts directory exists and path does not begin with _drafts
    if (this.presentationModel.get('_posts') && /^(?!_drafts)/.test(this.path)) {
      drafts = this.sidebar.initSubview('drafts', {
        link: [url, '_drafts'].join('/'),
        sidebar: this.sidebar
      });

      this.subviews['drafts'] = drafts;
      drafts.render();
    }

    var data = {
      path: path,
      parts: util.chunkedPath(this.path),
      rooturl: rooturl,
      url: url
    };

    this.$el.html(_.template(this.template, data, {variable: 'data'}));

    // if not searching, filter to only show current level
    var collection = search ? this.search.search() : this.presentationModel.filter((function(file) {
      return regex.test(file.get('path'));
    }).bind(this));

    var frag = document.createDocumentFragment();

    collection.each((function(file, index) {
      var view;

      if (file instanceof File) {
        view = new FileView({
          branch: this.branch,
          history: this.history,
          index: index,
          model: file,
          repo: this.repo,
          router: this.router
        });
      } else if (file instanceof Folder) {
        view = new FolderView({
          branch: this.branch,
          history: this.history,
          index: index,
          model: file,
          repo: this.repo,
          router: this.router
        });
      }

      frag.appendChild(view.render().el);
      this.subviews[file.id] = view;
    }).bind(this));

    this.$el.find('ul').html(frag);

    this.app.loader.done();

    return this;
  },

  activeListing: function(e) {
    var $listing = $(e.target);

    if (!$listing.hasClass('item')) {
      $listing = $(e.target).closest('li');
    }

    this.$el.find('.item').removeClass('active');
    $listing.addClass('active');

    // Blur out search if its selected
    this.search.$el.blur();
  },

  navigate: function(e) {
    var target = e.currentTarget;
    var path = target.href.split('#')[1];
    var match = path.match(/tree\/([^\/]*)\/?(.*)$/);

    if (e && match) {
      e.preventDefault();

      this.path = match ? match[2] : path;
      this.render();

      this.router.navigate(path);
    }
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"../models/file":18,"../models/folder":63,"./li/file":64,"./li/folder":65,"../../dist/templates":14,".././util":28,"jquery-browserify":11,"underscore":13,"backbone":12}],48:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  className: 'modal overlay',

  template: templates.modal,

  events: {
    'click .got-it': 'confirm'
  },

  initialize: function() {
    this.message = this.options.message;
  },

  render: function() {
    var modal = {
      message: this.message
    };
    this.$el.empty().append(_.template(templates.modal, modal, {
      variable: 'modal'
    }));

    return this;
  },

  confirm: function() {
    var view = this;
    this.$el.fadeOut('fast', function() {
      view.remove();
    });
    return false;
  }
});

},{"../../dist/templates":14,"jquery-browserify":11,"backbone":12,"underscore":13}],49:[function(require,module,exports){
var $ = require('jquery-browserify');
var chosen = require('chosen-jquery-browserify');
var _ = require('underscore');
var util = require('../util');
var Backbone = require('backbone');
var toolbar = require('../toolbar/markdown.js');
var upload = require('../upload');
var templates = require('../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.toolbar,

  events: {
    'click .group a': 'markdownSnippet',
    'click .publish-flag': 'togglePublishing',
    'change #upload': 'fileInput',
    'click .dialog .insert': 'dialogInsert',
    'click .draft-to-post': 'post'
  },

  initialize: function(options) {
    var self = this;
    this.file = options.file;
    this.view = options.view;
    this.collection = options.collection;
    var config = options.config;

    if (config) {
      this.hasMedia = (config.media) ? true : false;
      this.siteUrl = (config.siteUrl) ? true : false;

      if (config.media) {
        // Fetch the media directory to display its contents
        this.mediaDirectoryPath = config.media;
        var match = new RegExp('^' + this.mediaDirectoryPath);

        this.media = this.collection.filter(function(m) {
          var path = m.get('path');

          return m.get('type') === 'file' && match.test(path) &&
            (util.isBinary(path) || util.isImage(m.get('extension')));
        });
      }

      if (config.relativeLinks) {
        $.ajax({
          cache: true,
          dataType: 'jsonp',
          jsonp: false,
          jsonpCallback: config.relativeLinks.split('?callback=')[1] || 'callback',
          url: config.relativeLinks,
          success: function(links) {
            self.relativeLinks = links;
          }
        });
      }
    }
  },

  render: function() {
    var toolbar = {
      markdown: this.file.get('markdown'),
      writable: this.file.get('writable'),
      lang: this.file.get('lang'),
      draft: this.file.get('draft'),
      metadata: this.file.get('metadata')
    };

    this.$el.html(_.template(this.template, toolbar, { variable: 'toolbar' }));

    return this;
  },

  fileInput: function(e) {
    var view = this;
    upload.fileSelect(e, function(e, file, content) {
      var path = (view.mediaDirectoryPath) ? view.mediaDirectoryPath : util.extractFilename(view.file.attributes.path)[0];
      var src = path + '/' + encodeURIComponent(file.name);

      view.$el.find('input[name="url"]').val(src);
      view.$el.find('input[name="alt"]').val('');
      view.trigger('updateImageInsert', e);
    });

    return false;
  },

  highlight: function(type) {
    this.$el.find('.group a').removeClass('active');
    if (arguments) this.$el.find('[data-key="' + type + '"]').addClass('active');
  },

  post: function(e) {
    if (e) e.preventDefault();
    this.trigger('post', e);
  },

  markdownSnippet: function(e) {
    var self = this;
    var $target = $(e.target).closest('a');
    var $dialog = this.$el.find('#dialog');
    var $snippets = this.$el.find('.group a');
    var key = $target.data('key');
    var snippet = $target.data('snippet');
    var selection = util.trim(this.view.editor.getSelection());

    $dialog.removeClass().empty();

    if (snippet) {
      $snippets.removeClass('on');

      if (selection) {
        switch (key) {
        case 'bold':
          this.bold(selection);
          break;
        case 'italic':
          this.italic(selection);
          break;
        case 'heading':
          this.heading(selection);
          break;
        case 'sub-heading':
          this.subHeading(selection);
          break;
        case 'quote':
          this.quote(selection);
          break;
        default:
          this.view.editor.replaceSelection(snippet);
          break;
        }
        this.view.editor.focus();
      } else {
        this.view.editor.replaceSelection(snippet);
        this.view.editor.focus();
      }
    } else if ($target.data('dialog')) {

      var tmpl, className;
      if (key === 'media' && !this.mediaDirectoryPath ||
          key === 'media' && !this.media.length) {
          className = key + ' no-directory';
      } else {
          className = key;
      }

      // This condition handles the link and media link in the toolbar.
      if ($target.hasClass('on')) {
        $target.removeClass('on');
        $dialog.removeClass().empty();
      } else {
        $snippets.removeClass('on');
        $target.addClass('on');
        $dialog
          .removeClass()
          .addClass('dialog ' + className)
          .empty();

        switch(key) {
          case 'link':
            tmpl = _(templates.dialogs.link).template();

            $dialog.append(tmpl({
              relativeLinks: self.relativeLinks
            }));

            if (self.relativeLinks) {
              $('.chzn-select', $dialog).chosen().change(function() {
                $('.chzn-single span').text('Insert a local link.');

                var parts = $(this).val().split(',');
                $('input[name=href]', $dialog).val(parts[0]);
                $('input[name=text]', $dialog).val(parts[1]);
              });
            }

            if (selection) {
              // test if this is a markdown link: [text](link)
              var link = /\[([^\]]+)\]\(([^)]+)\)/;
              var quoted = /".*?"/;

              var text = selection;
              var href;
              var title;

              if (link.test(selection)) {
                var parts = link.exec(selection);
                text = parts[1];
                href = parts[2];

                // Search for a title attrbute within the url string
                if (quoted.test(parts[2])) {
                  href = parts[2].split(quoted)[0];

                  // TODO: could be improved
                  title = parts[2].match(quoted)[0].replace(/"/g, '');
                }
              }

              $('input[name=text]', $dialog).val(text);
              if (href) $('input[name=href]', $dialog).val(href);
              if (title) $('input[name=title]', $dialog).val(title);
            }
          break;
          case 'media':
            tmpl = _(templates.dialogs.media).template();
            $dialog.append(tmpl({
              description: t('dialogs.media.description', {
                input: '<input id="upload" class="upload" type="file" />'
              }),
              assetsDirectory: (self.media && self.media.length) ? true : false,
              writable: self.file.get('writable')
            }));

            if (self.media && self.media.length) self.renderMedia(self.media);

            if (selection) {
              var image = /\!\[([^\[]*)\]\(([^\)]+)\)/;
              var src;
              var alt;

              if (image.test(selection)) {
                var imageParts = image.exec(selection);
                alt = imageParts[1];
                src = imageParts[2];

                $('input[name=url]', $dialog).val(src);
                if (alt) $('input[name=alt]', $dialog).val(alt);
              }
            }
          break;
          case 'help':
            tmpl = _(templates.dialogs.help).template();
            $dialog.append(tmpl({
              help: toolbar.help
            }));

            // Page through different help sections
            var $mainMenu = this.$el.find('.main-menu a');
            var $subMenu = this.$el.find('.sub-menu');
            var $content = this.$el.find('.help-content');

            $mainMenu.on('click', function() {
              if (!$(this).hasClass('active')) {

                $mainMenu.removeClass('active');
                $content.removeClass('active');
                $subMenu
                    .removeClass('active')
                    .find('a')
                    .removeClass('active');

                $(this).addClass('active');

                // Add the relavent sub menu
                var parent = $(this).data('id');
                $('.' + parent).addClass('active');

                // Add an active class and populate the
                // content of the first list item.
                var $firstSubElement = $('.' + parent + ' a:first', this.el);
                $firstSubElement.addClass('active');

                var subParent = $firstSubElement.data('id');
                $('.help-' + subParent).addClass('active');
              }
              return false;
            });

            $subMenu.find('a').on('click', function() {
              if (!$(this).hasClass('active')) {

                $subMenu.find('a').removeClass('active');
                $content.removeClass('active');
                $(this).addClass('active');

                // Add the relavent content section
                var parent = $(this).data('id');
                $('.help-' + parent).addClass('active');
              }

              return false;
            });

          break;
        }
      }
    }

    return false;
  },

  publishState: function() {
    if (this.$el.find('publish-state') === 'true') {
      return true;
    } else {
      return false;
    }
  },

  updatePublishState: function() {
    // Update the publish key wording depening on what was saved
    var $publishkey = this.$el.find('.publish-flag');
    var key = $publishKey.attr('data-state');

    if (key === 'true') {
      $publishKey.html(t('actions.publishing.published') +
                      '<span class="ico small checkmark"></span>');
    } else {
      $publishKey.html(t('actions.publishing.unpublished') +
                      '<span class="ico small checkmark"></span>');
    }
  },

  togglePublishing: function(e) {
    var $target = $(e.currentTarget);
    var metadata = this.file.get('metadata');
    var published = metadata.published;

    // TODO: remove HTML from view
    // Toggling publish state when the current file is published live
    if (published) {
      if ($target.hasClass('published')) {
        $target
          .empty()
          .append(t('actions.publishing.unpublish') +
                '<span class="ico small checkmark"></span>' +
                '<span class="popup round arrow-top">' +
                t('actions.publishing.unpublishInfo') +
                '</span>')
          .removeClass('published')
          .attr('data-state', false);
      } else {
        $target
          .empty()
          .append(t('actions.publishing.published') +
                '<span class="ico small checkmark"></span>')
          .addClass('published')
          .attr('data-state', true);
      }
    } else {
      if ($target.hasClass('published')) {
        $target
          .empty()
          .append(t('actions.publishing.unpublished') +
                '<span class="ico small checkmark"></span>')
          .removeClass('published')
          .attr('data-state', false);
      } else {
        $target
          .empty()
          .append(t('actions.publishing.publish') +
                '<span class="ico small checkmark"></span>' +
                '<span class="popup round arrow-top">' +
                t('actions.publishing.publishInfo') +
                '</span>')
          .addClass('published')
          .attr('data-state', true);
      }
    }

    this.file.set('metadata', _.extend(metadata, {
      published: !published
    }));

    this.view.makeDirty();
    return false;
  },

  dialogInsert: function(e) {
    var $dialog = $('#dialog', this.el);
    var $target = $(e.target, this.el);
    var type = $target.data('type');

    if (type === 'link') {
      var href = $('input[name="href"]').val();
      var text = $('input[name="text"]').val();
      var title = $('input[name="title"]').val();

      if (!text) text = href;

      if (title) {
        this.view.editor.replaceSelection('[' + text + '](' + href + ' "' + title + '")');
      } else {
        this.view.editor.replaceSelection('[' + text + '](' + href + ')');
      }

      this.view.editor.focus();
    }

    if (type === 'media') {
      if (this.queue) {
        var userDefinedPath = $('input[name="url"]').val();
        this.view.upload(this.queue.e, this.queue.file, this.queue.content, userDefinedPath);

        // Finally, clear the queue object
        this.queue = undefined;
      } else {
        var src = $('input[name="url"]').val();
        var alt = $('input[name="alt"]').val();
        this.view.editor.replaceSelection('![' + alt + '](/' + src + ')');
        this.view.editor.focus();
      }
    }

    return false;
  },

  heading: function(s) {
    if (s.charAt(0) === '#' && s.charAt(2) !== '#') {
      this.view.editor.replaceSelection(util.lTrim(s.replace(/#/g, '')));
    } else {
      this.view.editor.replaceSelection('## ' + s.replace(/#/g, ''));
    }
  },

  subHeading: function(s) {
    if (s.charAt(0) === '#' && s.charAt(3) !== '#') {
      this.view.editor.replaceSelection(util.lTrim(s.replace(/#/g, '')));
    } else {
      this.view.editor.replaceSelection('### ' + s.replace(/#/g, ''));
    }
  },

  italic: function(s) {
    if (s.charAt(0) === '_' && s.charAt(s.length - 1 === '_')) {
      this.view.editor.replaceSelection(s.replace(/_/g, ''));
    } else {
      this.view.editor.replaceSelection('_' + s.replace(/_/g, '') + '_');
    }
  },

  bold: function(s) {
    if (s.charAt(0) === '*' && s.charAt(s.length - 1 === '*')) {
      this.view.editor.replaceSelection(s.replace(/\*/g, ''));
    } else {
      this.view.editor.replaceSelection('**' + s.replace(/\*/g, '') + '**');
    }
  },

  quote: function(s) {
    if (s.charAt(0) === '>') {
      this.view.editor.replaceSelection(util.lTrim(s.replace(/\>/g, '')));
    } else {
      this.view.editor.replaceSelection('> ' + s.replace(/\>/g, ''));
    }
  },

  renderMedia: function(data, back) {
    var self = this;
    var $media = this.$el.find('#media');
    var tmpl = _(templates.dialogs.mediadirectory).template();

    // Reset some stuff
    $media.empty();

    if (back && (back.join() !== this.assetsDirectory)) {
      var link = back.slice(0, back.length - 1).join('/');
      $media.append('<li class="directory back"><a href="' + link + '"><span class="ico fl small inline back"></span>Back</a></li>');
    }

    data.each(function(d) {
      var parts = d.get('path').split('/');
      var path = parts.slice(0, parts.length - 1).join('/');

      $media.append(tmpl({
        name: d.get('name'),
        type: d.get('type'),
        path: path + '/' + encodeURIComponent(d.get('name')),
        isMedia: util.isMedia(d.get('name').split('.').pop())
      }));
    });

    $('.asset a', $media).on('click', function(e) {
      var href = $(this).attr('href');
      var alt = util.trim($(this).text());

      if (util.isImage(href.split('.').pop())) {
        self.$el.find('input[name="url"]').val(href);
        self.$el.find('input[name="alt"]').val(alt);
      } else {
        self.view.editor.replaceSelection(href);
        self.view.editor.focus();
      }
      return false;
    });
  }
});

},{"../toolbar/markdown.js":34,"../util":28,"../upload":31,"../../dist/templates":14,"jquery-browserify":11,"chosen-jquery-browserify":66,"underscore":13,"backbone":12}],50:[function(require,module,exports){
var $ = require('jquery-browserify');
var chosen = require('chosen-jquery-browserify');
var _ = require('underscore');
_.merge = require('deepmerge');
var jsyaml = require('js-yaml');
var Backbone = require('backbone');
var templates = require('../../dist/templates');
var util = require('.././util');

module.exports = Backbone.View.extend({
  template: templates.metadata,

  events: {
    'change .metafield': 'updateModel',
    'click .create-select': 'createSelect',
    'click .finish': 'exit'
  },

  initialize: function(options) {
    _.bindAll(this);

    this.model = options.model;
    this.titleAsHeading = options.titleAsHeading;
    this.view = options.view;
  },

  render: function() {
    this.$el.empty().append(_.template(this.template));

    var form = this.$el.find('.form');

    var metadata = this.model.get('metadata');
    var lang = metadata && metadata.lang ? metadata.lang : 'en';

    // This renders any fields defined in the metadata entry
    // of a given prose configuration file.
    _.each(this.model.get('defaults'), (function(data, key) {
      var metadata = this.model.get('metadata') || {};
      var renderTitle = true;

      if (data && data.name === 'title' && this.titleAsHeading) {
        renderTitle = false;
      }

      if (renderTitle) {
        if (data && data.field) {
          switch (data.field.element) {
            case 'button':
              var button = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                on: data.field.on,
                off: data.field.off
              };

              form.append(_.template(templates.meta.button, button, {
                variable: 'meta'
              }));
              break;
            case 'checkbox':
              var checkbox = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                value: data.name,
                checked: data.field.value
              };

              form.append(_.template(templates.meta.checkbox, checkbox, {
                variable: 'meta'
              }));
              break;
            case 'text':
              var text = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                value: data.field.value,
                placeholder: data.field.placeholder,
                type: 'text'
              };

              form.append(_.template(templates.meta.text, text, {
                variable: 'meta'
              }));
              break;
            case 'textarea':
              var id = util.stringToUrl(data.name);
              var textarea = {
                name: data.name,
                id: id,
                value: data.field.value,
                label: data.field.label,
                help: data.field.help,
                placeholder: data.field.placeholder,
                type: 'textarea'
              };

              form.append(_.template(templates.meta.textarea, textarea, {
                variable: 'meta'
              }));

              var textElement = document.getElementById(id);

              this[id] = CodeMirror(function(el) {
                textElement.parentNode.replaceChild(el, textElement);
                el.id = id;
                el.className += ' inner ';
                el.setAttribute('data-name', data.name);
              }, {
                mode: id,
                value: textElement.value,
                lineWrapping: true,
                theme: 'prose-bright'
              });

              break;
            case 'number':
              var number = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                value: data.field.value,
                type: 'number'
              };

              form.append(_.template(templates.meta.text, number, {
                variable: 'meta'
              }));
              break;
            case 'select':
              var select = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                placeholder: data.field.placeholder,
                options: data.field.options,
                lang: lang
              };

              form.append(_.template(templates.meta.select, select, {
                variable: 'meta'
              }));
              break;
            case 'multiselect':
              var multiselect = {
                name: data.name,
                label: data.field.label,
                help: data.field.help,
                alterable: data.field.alterable,
                placeholder: data.field.placeholder,
                options: data.field.options,
                lang: lang
              };

              form.append(_.template(templates.meta.multiselect, multiselect, {
                variable: 'meta'
              }));

              break;
            case 'hidden':
              var tmpl = {};
              var value = metadata[data.name];

              if (_.isArray(value)) {
                // Any defaults not currently in metadata?
                var diff = _.difference(data.field.value, value);
                tmpl[data.name] = diff.length ?
                  _.union(data.field.value, value) : value;
              } else {
                tmpl[data.name] = data.field.value;
              }

              this.model.set('metadata', _.extend(tmpl, this.model.get('metadata') || {}));
              break;
          }
        } else {
          var txt = {
            name: key,
            label: key,
            value: data,
            type: 'text'
          };

          form.append(_.template(templates.meta.text, txt, {
            variable: 'meta'
          }));
        }
      }
    }).bind(this));

    this.$el.find('.chzn-select').chosen().change(this.updateModel);
    this.renderRaw();

    return this;
  },

  updateModel: function(e) {
    var target = e.currentTarget;
    var key = target.name;
    var value = target.value;
    var delta = {};
    delta[key] = value;

    var metadata = this.model.get('metadata');
    this.model.set('metadata', _.extend(metadata, delta));
    this.view.makeDirty();
  },

  rawKeyMap: function() {
    return {
      'Ctrl-S': this.view.updateFile
    };
  },

  renderRaw: function() {
    var yaml = this.model.get('lang') === 'yaml';
    var $el;

    if (yaml) {
      $el = this.view.$el.find('#code');
      $el.empty();
    } else {
      this.$el.find('.form').append(_.template(templates.meta.raw));
    }

    var el = (yaml ? $el : this.$el.find('#raw'))[0];

    this.raw = CodeMirror(el, {
      mode: 'yaml',
      value: '',
      lineWrapping: true,
      lineNumbers: yaml,
      extraKeys: this.rawKeyMap(),
      theme: 'prose-bright'
    });

    this.listenTo(this.raw, 'blur', (function(cm) {
      var value = cm.getValue();
      var raw;

      try {
        raw = jsyaml.safeLoad(value);
      } catch(err) {
        console.log("Error parsing CodeMirror editor text");
        console.log(err);
      }

      if (raw) {
        var metadata = this.model.get('metadata');
        this.model.set('metadata', _.extend(metadata, raw));

        this.view.makeDirty();
      }
    }).bind(this));

    this.setValue(this.model.get('metadata'));
  },

  getValue: function() {
    var view = this;
    var metadata = this.model.get('metadata') || {};

    if (this.view.toolbar &&
       this.view.toolbar.publishState() ||
       (metadata && metadata.published)) {
      metadata.published = true;
    } else {
      metadata.published = false;
    }

    // Get the title value from heading if we need to.
    if (this.titleAsHeading) {
      metadata.title = (this.view.header) ?
        this.view.header.inputGet() :
        this.model.get('metadata').title[0];
    }

    _.each(this.$el.find('[name]'), function(item) {
      var $item = $(item);
      var value = $item.val();

      switch (item.type) {
        case 'select-multiple':
        case 'select-one':
        case 'textarea':
        case 'text':
          if (value) {
            value = $item.data('type') === 'number' ? Number(value) : value;
            if (_.has(metadata, item.name) && metadata[item.name] !== value) {
              metadata[item.name] = _.union(metadata[item.name], value);
            } else {
              metadata[item.name] = value;
            }
          }
          break;
        case 'checkbox':
          if (item.checked) {

            if (_.has(metadata, item.name) && item.name !== item.value) {
              metadata[item.name] = _.union(metadata[item.name], item.value);
            } else if (item.value === item.name) {
              metadata[item.name] = item.checked;
            } else {
              metadata[item.name] = item.value;
            }

          } else if (!_.has(metadata, item.name) && item.name === item.value) {
            metadata[item.name] = item.checked;
          } else {
            metadata[item.name] = item.checked;
          }
          break;
        case 'button':
          if (value === 'true') {
            metadata[item.name] = true;
          } else if (value === 'false') {
            metadata[item.name] = false;
          }
          break;
      }
    });

    // Load any data coming from a yaml-block of content.
    this.$el.find('.yaml-block').each(function() {
      var editor = $(this).find('.CodeMirror').attr('id');
      var name = $('#' + editor).data('name');

      if (view[editor]) {
        try {
          metadata[name] = jsyaml.safeLoad(view[editor].getValue());
        } catch(err) {
          console.log("Error parsing yaml front matter");
          console.log(err);
        }
      }
    });

    // Load any data coming from not defined raw yaml front matter.
    if (this.raw) {
      try {
        metadata = _.merge(metadata, jsyaml.safeLoad(this.raw.getValue()) || {});
      } catch (err) {
        console.log("Error parsing not defined raw yaml front matter");
        console.log(err);
      }
    }

    return metadata;
  },

  setValue: function(data) {
    var form = this.$el.find('.form');
    var missing = {};
    var raw;

    _.each(data, (function(value, key) {
      var matched = false;
      var input = this.$el.find('[name="' + key + '"]');
      var length = input.length;
      var options;

      if (length) {

        // iterate over matching fields
        for (var i = 0; i < length; i++) {

          // if value is an array
          if (_.isArray(value)) {

            // iterate over values in array
            for (var j = 0; j < value.length; j++) {
              switch (input[i].type) {
                case 'select-multiple':
                case 'select-one':
                  options = $(input[i]).find('option[value="' + value[j] + '"]');
                  if (options.length) {
                    for (var k = 0; k < options.length; k++) {
                      options[k].selected = 'selected';
                    }

                    matched = true;
                  }
                  break;
                case 'text':
                case 'textarea':
                  input[i].value = value;
                  matched = true;
                  break;
                case 'checkbox':
                  if (input[i].value === value) {
                    input[i].checked = 'checked';
                    matched = true;
                  }
                  break;
              }
            }

          } else {

            switch (input[i].type) {
              case 'select-multiple':
              case 'select-one':
                options = $(input[i]).find('option[value="' + value + '"]');
                if (options.length) {
                  for (var m = 0; m < options.length; m++) {
                    options[m].selected = 'selected';
                  }

                  matched = true;
                }
                break;
              case 'text':
              case 'textarea':
                input[i].value = value;
                matched = true;
                break;
              case 'checkbox':
                input[i].checked = value ? 'checked' : false;
                matched = true;
                break;
              case 'button':
                input[i].value = value ? true : false;
                input[i].innerHTML = value ? input[i].getAttribute('data-on') : input[i].getAttribute('data-off');
                matched = true;
                break;
            }

          }
        }

        if (!matched && value !== null) {
          if (missing.hasOwnProperty(key) && missing[key] !== value) {
            missing[key] = _.union(missing[key], value);
          } else {
            missing[key] = value;
          }
        }

      } else {
        // Don't render the 'published' field or hidden metadata
        // TODO: render metadata values that share a key with a hidden value
        var defaults = _.find(this.model.get('defaults'), function(data) { return data && (data.name === key); });
        var diff = defaults && _.isArray(value) ? _.difference(value, defaults.field.value) : value;

        if (key !== 'published' && key !== 'title' && !defaults) {
          raw = {};
          raw[key] = value;

          if (this.raw) {
            this.raw.setValue(this.raw.getValue() + jsyaml.safeDump(raw));
          }
        }
      }
    }).bind(this));

    _.each(missing, (function(value, key) {
      if (value === null) return;

      switch (typeof value) {
        case 'boolean':
          var bool = {
            name: key,
            label: value,
            value: value,
            checked: value ? 'checked' : false
          };

          form.append(_.template(templates.meta.checkbox, bool, {
            variable: 'meta'
          }));
          break;
        case 'string':
          var string = {
            name: key,
            label: value,
            value: value,
            type: 'text'
          };

          form.append(_.template(templates.meta.text, string, {
            variable: 'meta'
          }));
          break;
        case 'object':
          var obj = {
            name: key,
            label: key,
            placeholder: key,
            options: value,
            lang: data.lang || 'en'
          };

          form.append(_.template(templates.meta.multiselect, obj, {
            variable: 'meta'
          }));
          break;
        default:
          console.log('ERROR could not create metadata field for ' + typeof value, key + ': ' + value);
          break;
      }

      this.$el.find('.chzn-select').chosen().change(this.updateModel);
    }).bind(this));

    this.$el.find('.chzn-select').trigger('liszt:updated');

    // Update model with defaults
    // TODO: should this makeDirty if any differences?
    this.model.set('metadata', this.getValue());
  },

  getRaw: function() {
    return jsyaml.safeDump(this.getValue()).trim();
  },

  setRaw: function(data) {
    try {
      this.raw.setValue(jsyaml.safeDump(data));
      this.refresh;
    } catch (err) {
      throw err;
    }
  },

  refresh: function() {
    var view = this;
    this.$el.find('.yaml-block').each(function() {
      var editor = $(this).find('.CodeMirror').attr('id');
      if (view[editor]) view[editor].refresh();
    });

    // Refresh CodeMirror
    if (this.raw) this.raw.refresh();
  },

  createSelect: function(e) {
    var $parent = $(e.target).parent();
    var $input = $parent.find('input');
    var selectTarget = $(e.target).data('select');
    var $select = this.$el.find('#' + selectTarget);
    var value = _($input.val()).escape();

    if (value.length > 0) {
      var option = '<option value="' + value + '" selected="selected">' + value + '</option>';

      // Append this new option to the select list.
      $select.append(option);

      // Clear the now added value.
      $input.attr('value', '');

      // Update the list
      $select.trigger('liszt:updated');
      $select.trigger('change');
    }

    return false;
  },

  exit: function() {
    this.view.nav.active(this.view.mode);

    if (this.view.mode === 'blob') {
      this.view.blob();
    } else {
      this.view.edit();
    }

    return false;
  }
});

},{"../../dist/templates":14,".././util":28,"jquery-browserify":11,"chosen-jquery-browserify":66,"underscore":13,"js-yaml":44,"backbone":12,"deepmerge":67}],67:[function(require,module,exports){
module.exports = function merge (target, src) {
    var array = Array.isArray(src)
    var dst = array && [] || {}

    if (array) {
        target = target || []
        dst = dst.concat(target)
        src.forEach(function(e, i) {
            if (typeof target[i] === 'undefined') {
                dst[i] = e
            } else if (typeof e === 'object') {
                dst[i] = merge(target[i], e)
            } else {
                if (target.indexOf(e) === -1) {
                    dst.push(e)
                }
            }
        })
    } else {
        if (target && typeof target === 'object') {
            Object.keys(target).forEach(function (key) {
                dst[key] = target[key]
            })
        }
        Object.keys(src).forEach(function (key) {
            if (typeof src[key] !== 'object' || !src[key]) {
                dst[key] = src[key]
            }
            else {
                if (!target[key]) {
                    dst[key] = src[key]
                } else {
                    dst[key] = merge(target[key], src[key])
                }
            }
        })
    }

    return dst
}

},{}],42:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../../dist/templates');
var cookie = require('../../cookie');

module.exports = Backbone.View.extend({
  template: templates.sidebar.orgs,

  initialize: function(options) {
    _.bindAll(this);

    this.model = options.model;
    this.router = options.router;
    this.sidebar = options.sidebar;
    this.user = options.user;

    this.model.fetch({
      success: this.render,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this)
    });
  },

  render: function() {
    var orgs = {
      login: {
        user: cookie.get('login'),
        id: cookie.get('id')
      },
      user: this.user.toJSON(),
      orgs: this.model.toJSON()
    };

    this.$el.html(_.template(this.template, orgs, {
      variable: 'orgs'
    }));

    // Update active user or organization
    this.$el.find('li a').removeClass('active');
    this.$el.find('li a[data-id="' + this.user.get('id') + '"]').addClass('active');
    this.sidebar.open();

    return this;
  }
});

},{"../../../dist/templates":14,"../../cookie":3,"underscore":13,"backbone":12,"jquery-browserify":11}],45:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var cookie = require('../../cookie');
var templates = require('../../../dist/templates');

module.exports = Backbone.View.extend({
  tagName: 'li',

  className: 'item clearfix',

  template: templates.li.repo,

  initialize: function(options) {
    this.model = options.model;
    this.$el.attr('data-index', options.index);
    this.$el.attr('data-id', this.model.id);
    this.$el.attr('data-navigate', '#' + this.model.get('owner').login + '/' + this.model.get('name'));
  },

  render: function() {
    var data = _.extend(this.model.attributes, {
      login: cookie.get('login')
    });

    this.$el.empty().append(_.template(this.template, data, {
      variable: 'repo'
    }));

    return this;
  }
});

},{"../../cookie":3,"../../../dist/templates":14,"jquery-browserify":11,"backbone":12,"underscore":13}],55:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.NIL                 = require('./js-yaml/common').NIL;
module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


require('./js-yaml/require');

},{"./js-yaml/loader":68,"./js-yaml/dumper":69,"./js-yaml/common":70,"./js-yaml/type":71,"./js-yaml/schema":72,"./js-yaml/schema/failsafe":73,"./js-yaml/schema/json":74,"./js-yaml/schema/default_safe":75,"./js-yaml/schema/default_full":76,"./js-yaml/schema/core":77,"./js-yaml/exception":78,"./js-yaml/require":79}],56:[function(require,module,exports){
var Backbone = require('backbone');
var Files = require('../collections/files');
var config = require('../config');

module.exports = Backbone.Model.extend({
  initialize: function(attributes, options) {
    this.repo = attributes.repo;

    this.set('name', attributes.name);

    var sha = attributes.commit.sha;
    this.set('sha', sha);

    this.files = new Files([], {
      repo: this.repo,
      branch: this,
      sha: sha
    });
  },

  url: function() {
    return this.repo.url() + '/branches/' + this.get('name');
  }
});

},{"../config":4,"../collections/files":80,"backbone":12}],70:[function(require,module,exports){
'use strict';


var NIL = {};


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


module.exports.NIL        = NIL;
module.exports.isNothing  = isNothing;
module.exports.isObject   = isObject;
module.exports.toArray    = toArray;
module.exports.repeat     = repeat;
module.exports.extend     = extend;

},{}],78:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],63:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var util = require('.././util');

module.exports = Backbone.Model.extend({
  idAttribute: 'path',

  initialize: function(attributes, options) {
    _.bindAll(this);

    this.branch = attributes.branch;
    this.collection = attributes.collection;
    this.repo = attributes.repo;

    this.set({
      'name': util.extractFilename(attributes.path)[1],
      'path': attributes.path,
      'type': attributes.type
    });
  },

  url: function() {
    return this.repo.url() + '/contents/' + this.get('path') + '?ref=' + this.branch.get('name');
  }
});

},{".././util":28,"underscore":13,"backbone":12}],62:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  initialize: function(attributes, options) {
    _.bindAll(this);

    this.repo = attributes.repo;
  },

  url: function() {
    return this.repo.url() + '/commits/' + this.get('sha');
  }
});

},{"underscore":13,"backbone":12}],52:[function(require,module,exports){
(function(){/* Copyright (c) 2012 Joshfire - MIT license */
/**
 * @fileoverview Core of the JSON Form client-side library.
 *
 * Generates an HTML form from a structured data model and a layout description.
 *
 * The library may also validate inputs entered by the user against the data model
 * upon form submission and create the structured data object initialized with the
 * values that were submitted.
 *
 * The library depends on:
 *  - jQuery
 *  - the underscore library
 *  - a JSON parser/serializer. Nothing to worry about in modern browsers.
 *  - the JSONFormValidation library (in jsv.js) for validation purpose
 *
 * See documentation at:
 * http://developer.joshfire.com/doc/dev/ref/jsonform
 *
 * The library creates and maintains an internal data tree along with the DOM.
 * That structure is necessary to handle arrays (and nested arrays!) that are
 * dynamic by essence.
 */

 /*global window*/

(function(serverside, global, $, _, JSON) {
  if (serverside) {
    _ = require('underscore');
  }

  /**
   * Regular expressions used to extract array indexes in input field names
   */
  var reArray = /\[([0-9]*)\](?=\[|\.|$)/g;

  /**
   * Template settings for form views
   */
  var fieldTemplateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g
  };

  /**
   * Template settings for value replacement
   */
  var valueTemplateSettings = {
    evaluate    : /\{\[([\s\S]+?)\]\}/g,
    interpolate : /\{\{([\s\S]+?)\}\}/g
  };

  /**
   * Returns true if given value is neither "undefined" nor null
   */
  var isSet = function (value) {
    return !(_.isUndefined(value) || _.isNull(value));
  };

  /**
   * The jsonform object whose methods will be exposed to the window object
   */
  var jsonform = {util:{}};


  // From backbonejs
  var escapeHTML = function (string) {
    if (!isSet(string)) {
      return '';
    }
    string = '' + string;
    if (!string) {
      return '';
    }
    return string
      .replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  };

/**
 * Escapes selector name for use with jQuery
 *
 * All meta-characters listed in jQuery doc are escaped:
 * http://api.jquery.com/category/selectors/
 *
 * @function
 * @param {String} selector The jQuery selector to escape
 * @return {String} The escaped selector.
 */
var escapeSelector = function (selector) {
  return selector.replace(/([ \!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, '\\$1');
};


/**
 * Initializes tabular sections in forms. Such sections are generated by the
 * 'selectfieldset' type of elements in JSON Form.
 *
 * Input fields that are not visible are automatically disabled
 * not to appear in the submitted form. That's on purpose, as tabs
 * are meant to convey an alternative (and not a sequence of steps).
 *
 * The tabs menu is not rendered as tabs but rather as a select field because
 * it's easier to grasp that it's an alternative.
 *
 * Code based on bootstrap-tabs.js, updated to:
 * - react to option selection instead of tab click
 * - disable input fields in non visible tabs
 * - disable the possibility to have dropdown menus (no meaning here)
 * - act as a regular function instead of as a jQuery plug-in.
 *
 * @function
 * @param {Object} tabs jQuery object that contains the tabular sections
 *  to initialize. The object may reference more than one element.
 */
var initializeTabs = function (tabs) {
  var activate = function (element, container) {
    container
      .find('> .active')
      .removeClass('active');
    element.addClass('active');
  };

  var enableFields = function ($target, targetIndex) {
    // Enable all fields in the targeted tab
    $target.find('input, textarea, select').removeAttr('disabled');

    // Disable all fields in other tabs
    $target.parent()
      .children(':not([data-idx=' + targetIndex + '])')
      .find('input, textarea, select')
      .attr('disabled', 'disabled');
  };

  var optionSelected = function (e) {
    var $option = $("option:selected", $(this)),
      $select = $(this),
      // do not use .attr() as it sometimes unexplicably fails
      targetIdx = $option.get(0).getAttribute('data-idx') || $option.attr('value'),
      $target;

    e.preventDefault();
    if ($option.hasClass('active')) {
      return;
    }

    $target = $(this).parents('.tabbable').eq(0).find('.tab-content [data-idx=' + targetIdx + ']');

    activate($option, $select);
    activate($target, $target.parent());
    enableFields($target, targetIdx);
  };

  var tabClicked = function (e) {
    var $a = $('a', $(this));
    var $content = $(this).parents('.tabbable').first()
      .find('.tab-content').first();
    var targetIdx = $(this).index();
    var $target = $content.find('[data-idx=' + targetIdx + ']');

    e.preventDefault();
    activate($(this), $(this).parent());
    activate($target, $target.parent());
    if ($(this).parent().hasClass('jsonform-alternative')) {
      enableFields($target, targetIdx);
    }
  };

  tabs.each(function () {
    $(this).delegate('select.nav', 'change', optionSelected);
    $(this).find('select.nav').each(function () {
      $(this).val($(this).find('.active').attr('value'));
      // do not use .attr() as it sometimes unexplicably fails
      var targetIdx = $(this).find('option:selected').get(0).getAttribute('data-idx') ||
        $(this).find('option:selected').attr('value');
      var $target = $(this).parents('.tabbable').eq(0).find('.tab-content [data-idx=' + targetIdx + ']');
      enableFields($target, targetIdx);
    });

    $(this).delegate('ul.nav li', 'click', tabClicked);
    $(this).find('ul.nav li.active').click();
  });
};


// Twitter bootstrap-friendly HTML boilerplate for standard inputs
jsonform.fieldTemplate = function(inner) {
  return '<div class="control-group jsonform-error-<%= keydash %>' +
    '<%= elt.htmlClass ? " " + elt.htmlClass : "" %>' +
    '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== "boolean") ? " jsonform-required" : "") %>' +
    '<%= (node.readOnly ? " jsonform-readonly" : "") %>' +
    '<%= (node.disabled ? " jsonform-disabled" : "") %>' +
    '">' +
    '<% if (node.title && !elt.notitle) { %>' +
      '<label class="control-label" for="<%= node.id %>"><%= node.title %></label>' +
    '<% } %>' +
    '<div class="controls">' +
      '<% if (node.prepend || node.append) { %>' +
      '<div class="<% if (node.prepend) { %>input-prepend<% } %>' +
        '<% if (node.append) { %> input-append<% } %>">' +
        '<% if (node.prepend) { %>' +
          '<span class="add-on"><%= node.prepend %></span>' +
        '<% } %>' +
      '<% } %>' +
      inner +
      '<% if (node.append) { %>' +
        '<span class="add-on"><%= node.append %></span>' +
      '<% } %>' +
      '<% if (node.prepend || node.append) { %>' +
        '</div>' +
      '<% } %>' +
      '<% if (node.description) { %>' +
        '<span class="help-inline"><%= node.description %></span>' +
      '<% } %>' +
      '<span class="help-block jsonform-errortext" style="display:none;"></span>' +
    '</div></div>';
};

var fileDisplayTemplate = '<div class="_jsonform-preview">' +
  '<% if (value.type=="image") { %>' +
  '<img class="jsonform-preview" id="jsonformpreview-<%= id %>" src="<%= value.url %>" />' +
  '<% } else { %>' +
  '<a href="<%= value.url %>"><%= value.name %></a> (<%= Math.ceil(value.size/1024) %>kB)' +
  '<% } %>' +
  '</div>' +
  '<a href="#" class="btn _jsonform-delete"><i class="icon-remove" title="Remove"></i></a> ';

var inputFieldTemplate = function (type) {
  return {
    'template': '<input type="' + type + '" ' +
      '<%= (fieldHtmlClass ? "class=\'" + fieldHtmlClass + "\' " : "") %>' +
      'name="<%= node.name %>" value="<%= escape(value) %>" id="<%= id %>"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.readOnly ? " readonly=\'readonly\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.maxLength ? " maxlength=\'" + node.schemaElement.maxLength + "\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== "boolean") ? " required=\'required\'" : "") %>' +
      '<%= (node.placeholder? "placeholder=" + \'"\' + escape(node.placeholder) + \'"\' : "")%>' +
      ' />',
    'fieldtemplate': true,
    'inputfield': true
  }
};

jsonform.elementTypes = {
  'none': {
    'template': ''
  },
  'root': {
    'template': '<div><%= children %></div>'
  },
  'text': inputFieldTemplate('text'),
  'password': inputFieldTemplate('password'),
  'date': inputFieldTemplate('date'),
  'datetime': inputFieldTemplate('datetime'),
  'datetime-local': inputFieldTemplate('datetime-local'),
  'email': inputFieldTemplate('email'),
  'month': inputFieldTemplate('month'),
  'number': inputFieldTemplate('number'),
  'search': inputFieldTemplate('search'),
  'tel': inputFieldTemplate('tel'),
  'time': inputFieldTemplate('time'),
  'url': inputFieldTemplate('url'),
  'week': inputFieldTemplate('week'),
  'range': {
    'template': '<input type="range" ' +
      '<%= (fieldHtmlClass ? "class=\'" + fieldHtmlClass + "\' " : "") %>' +
      'name="<%= node.name %>" value="<%= escape(value) %>" id="<%= id %>"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      ' min=<%= range.min %>' +
      ' max=<%= range.max %>' +
      ' step=<%= range.step %>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      ' />',
    'fieldtemplate': true,
    'inputfield': true,
    'onBeforeRender': function (data, node) {
      data.range = {
        min: 1,
        max: 100,
        step: 1
      };
      if (!node || !node.schemaElement) return;
      if (node.formElement && node.formElement.step) {
        data.range.step = node.formElement.step;
      }
      if (typeof node.schemaElement.minimum !== 'undefined') {
        if (node.schemaElement.exclusiveMinimum) {
          data.range.min = node.schemaElement.minimum + data.range.step;
        }
        else {
          data.range.min = node.schemaElement.minimum;
        }
      }
      if (typeof node.schemaElement.maximum !== 'undefined') {
        if (node.schemaElement.exclusiveMaximum) {
          data.range.max = node.schemaElement.maximum + data.range.step;
        }
        else {
          data.range.max = node.schemaElement.maximum;
        }
      }
    }
  },
  'color':{
    'template':'<input type="text" ' +
      '<%= (fieldHtmlClass ? "class=\'" + fieldHtmlClass + "\' " : "") %>' +
      'name="<%= node.name %>" value="<%= escape(value) %>" id="<%= id %>"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      ' />',
    'fieldtemplate': true,
    'inputfield': true,
    'onInsert': function(evt, node) {
      $(node.el).find('#' + escapeSelector(node.id)).spectrum({
        preferredFormat: "hex",
        showInput: true
      });
    }
  },
  'textarea':{
    'template':'<textarea id="<%= id %>" name="<%= node.name %>" ' +
      'style="height:<%= elt.height || "150px" %>;width:<%= elt.width || "100%" %>;"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.readOnly ? " readonly=\'readonly\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.maxLength ? " maxlength=\'" + node.schemaElement.maxLength + "\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      '<%= (node.placeholder? "placeholder=" + \'"\' + escape(node.placeholder) + \'"\' : "")%>' +
      '><%= value %></textarea>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'wysihtml5':{
    'template':'<textarea id="<%= id %>" name="<%= node.name %>" style="height:<%= elt.height || "300px" %>;width:<%= elt.width || "100%" %>;"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.readOnly ? " readonly=\'readonly\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.maxLength ? " maxlength=\'" + node.schemaElement.maxLength + "\'" : "") %>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      '<%= (node.placeholder? "placeholder=" + \'"\' + escape(node.placeholder) + \'"\' : "")%>' +
      '><%= value %></textarea>',
    'fieldtemplate': true,
    'inputfield': true,
    'onInsert': function (evt, node) {
      var setup = function () {
        //protect from double init
        if ($(node.el).data("wysihtml5")) return;
        $(node.el).data("wysihtml5_loaded",true);

        $(node.el).find('#' + escapeSelector(node.id)).wysihtml5({
          "html": true,
          "link": true,
          "font-styles":true,
          "image": true,
          "events": {
            "load": function () {
              // In chrome, if an element is required and hidden, it leads to
              // the error 'An invalid form control with name='' is not focusable'
              // See http://stackoverflow.com/questions/7168645/invalid-form-control-only-in-google-chrome
              $(this.textareaElement).removeAttr('required');
            }
          }
        });
      };

      // Is there a setup hook?
      if (window.jsonform_wysihtml5_setup) {
        window.jsonform_wysihtml5_setup(setup);
        return;
      }

      // Wait until wysihtml5 is loaded
      var itv = window.setInterval(function() {
        if (window.wysihtml5) {
          window.clearInterval(itv);
          setup();
        }
      },1000);
    }
  },
  'ace':{
    'template':'<div id="<%= id %>" style="position:relative;height:<%= elt.height || "300px" %>;"><div id="<%= id %>__ace" style="width:<%= elt.width || "100%" %>;height:<%= elt.height || "300px" %>;"></div><input type="hidden" name="<%= node.name %>" id="<%= id %>__hidden" value="<%= escape(value) %>"/></div>',
    'fieldtemplate': true,
    'inputfield': true,
    'onInsert': function (evt, node) {
      var setup = function () {
        var formElement = node.formElement || {};
        var ace = window.ace;
        var editor = ace.edit($(node.el).find('#' + escapeSelector(node.id) + '__ace').get(0));
        var idSelector = '#' + escapeSelector(node.id) + '__hidden';
        // Force editor to use "\n" for new lines, not to bump into ACE "\r" conversion issue
        // (ACE is ok with "\r" on pasting but fails to return "\r" when value is extracted)
        editor.getSession().setNewLineMode('unix');
        editor.renderer.setShowPrintMargin(false);
        editor.setTheme("ace/theme/"+(formElement.aceTheme||"twilight"));

        if (formElement.aceMode) {
          editor.getSession().setMode("ace/mode/"+formElement.aceMode);
        }
        editor.getSession().setTabSize(2);

        // Set the contents of the initial manifest file
        editor.getSession().setValue(node.value||"");

        //TODO this is clearly sub-optimal
        // 'Lazily' bind to the onchange 'ace' event to give
        // priority to user edits
        var lazyChanged = _.debounce(function () {
          $(node.el).find(idSelector).val(editor.getSession().getValue());
          $(node.el).find(idSelector).change();
        }, 600);
        editor.getSession().on('change', lazyChanged);
        
        editor.on('blur', function() {
          $(node.el).find(idSelector).change();
          $(node.el).find(idSelector).trigger("blur");
        });
        editor.on('focus', function() {
          $(node.el).find(idSelector).trigger("focus");
        });
      };

      // Is there a setup hook?
      if (window.jsonform_ace_setup) {
        window.jsonform_ace_setup(setup);
        return;
      }

      // Wait until ACE is loaded
      var itv = window.setInterval(function() {
        if (window.ace) {
          window.clearInterval(itv);
          setup();
        }
      },1000);
    }
  },
  'checkbox':{
    'template': '<label class="checkbox"><input type="checkbox" id="<%= id %>" ' +
      'name="<%= node.name %>" value="1" <% if (value) {%>checked<% } %>' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== "boolean") ? " required=\'required\'" : "") %>' +
      ' /><span><%= node.inlinetitle || "" %></span>' +
      '</label>',
    'fieldtemplate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    }
  },
  'file':{
    'template':'<input class="input-file" id="<%= id %>" name="<%= node.name %>" type="file" ' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      '/>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'file-hosted-public':{
    'template':'<span><% if (value && (value.type||value.url)) { %>'+fileDisplayTemplate+'<% } %><input class="input-file" id="_transloadit_<%= id %>" type="file" name="<%= transloaditname %>" /><input data-transloadit-name="_transloadit_<%= transloaditname %>" type="hidden" id="<%= id %>" name="<%= node.name %>" value=\'<%= escape(JSON.stringify(node.value)) %>\' /></span>',
    'fieldtemplate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'onBeforeRender': function (data, node) {

      if (!node.ownerTree._transloadit_generic_public_index) {
        node.ownerTree._transloadit_generic_public_index=1;
      } else {
        node.ownerTree._transloadit_generic_public_index++;
      }
      
      data.transloaditname = "_transloadit_jsonform_genericupload_public_"+node.ownerTree._transloadit_generic_public_index;

      if (!node.ownerTree._transloadit_generic_elts) node.ownerTree._transloadit_generic_elts = {};
      node.ownerTree._transloadit_generic_elts[data.transloaditname] = node;
    },
    'onChange': function(evt,elt) {
      // The "transloadit" function should be called only once to enable
      // the service when the form is submitted. Has it already been done?
      if (elt.ownerTree._transloadit_bound) {
        return false;
      }
      elt.ownerTree._transloadit_bound = true;

      // Call the "transloadit" function on the form element
      var formElt = $(elt.ownerTree.domRoot);
      formElt.transloadit({
        autoSubmit: false,
        wait: true,
        onSuccess: function (assembly) {
          // Image has been uploaded. Check the "results" property that
          // contains the list of files that Transloadit produced. There
          // should be one image per file input in the form at most.
          // console.log(assembly.results);
          var results = _.values(assembly.results);
          results = _.flatten(results);
          _.each(results, function (result) {
            // Save the assembly result in the right hidden input field
            var id = elt.ownerTree._transloadit_generic_elts[result.field].id;
            var input = formElt.find('#' + escapeSelector(id));
            var nonEmptyKeys = _.filter(_.keys(result.meta), function (key) {
              return !!isSet(result.meta[key]);
            });
            result.meta = _.pick(result.meta, nonEmptyKeys);
            input.val(JSON.stringify(result));
          });

          // Unbind transloadit from the form
          elt.ownerTree._transloadit_bound = false;
          formElt.unbind('submit.transloadit');

          // Submit the form on next tick
          _.delay(function () {
            console.log('submit form');
            elt.ownerTree.submit();
          }, 10);
        },
        onError: function (assembly) {
          // TODO: report the error to the user
          console.log('assembly error', assembly);
        }
      });
    },
    'onInsert': function (evt, node) {
      $(node.el).find('a._jsonform-delete').on('click', function (evt) {
        $(node.el).find('._jsonform-preview').remove();
        $(node.el).find('a._jsonform-delete').remove();
        $(node.el).find('#' + escapeSelector(node.id)).val('');
        evt.preventDefault();
        return false;
      });
    },
    'onSubmit':function(evt, elt) {
      if (elt.ownerTree._transloadit_bound) {
        return false;
      }
      return true;
    }

  },
  'file-transloadit': {
    'template': '<span><% if (value && (value.type||value.url)) { %>'+fileDisplayTemplate+'<% } %><input class="input-file" id="_transloadit_<%= id %>" type="file" name="_transloadit_<%= node.name %>" /><input type="hidden" id="<%= id %>" name="<%= node.name %>" value=\'<%= escape(JSON.stringify(node.value)) %>\' /></span>',
    'fieldtemplate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'onChange': function (evt, elt) {
      // The "transloadit" function should be called only once to enable
      // the service when the form is submitted. Has it already been done?
      if (elt.ownerTree._transloadit_bound) {
        return false;
      }
      elt.ownerTree._transloadit_bound = true;

      // Call the "transloadit" function on the form element
      var formElt = $(elt.ownerTree.domRoot);
      formElt.transloadit({
        autoSubmit: false,
        wait: true,
        onSuccess: function (assembly) {
          // Image has been uploaded. Check the "results" property that
          // contains the list of files that Transloadit produced. Note
          // JSONForm only supports 1-to-1 associations, meaning it
          // expects the "results" property to contain only one image
          // per file input in the form.
          // console.log(assembly.results);
          var results = _.values(assembly.results);
          results = _.flatten(results);
          _.each(results, function (result) {
            // Save the assembly result in the right hidden input field
            var input = formElt.find('input[name="' +
              result.field.replace(/^_transloadit_/, '') +
              '"]');
            var nonEmptyKeys = _.filter(_.keys(result.meta), function (key) {
              return !!isSet(result.meta[key]);
            });
            result.meta = _.pick(result.meta, nonEmptyKeys);
            input.val(JSON.stringify(result));
          });

          // Unbind transloadit from the form
          elt.ownerTree._transloadit_bound = false;
          formElt.unbind('submit.transloadit');

          // Submit the form on next tick
          _.delay(function () {
            console.log('submit form');
            elt.ownerTree.submit();
          }, 10);
        },
        onError: function (assembly) {
          // TODO: report the error to the user
          console.log('assembly error', assembly);
        }
      });
    },
    'onInsert': function (evt, node) {
      $(node.el).find('a._jsonform-delete').on('click', function (evt) {
        $(node.el).find('._jsonform-preview').remove();
        $(node.el).find('a._jsonform-delete').remove();
        $(node.el).find('#' + escapeSelector(node.id)).val('');
        evt.preventDefault();
        return false;
      });
    },
    'onSubmit': function (evt, elt) {
      if (elt.ownerTree._transloadit_bound) {
        return false;
      }
      return true;
    }
  },
  'select':{
    'template':'<select name="<%= node.name %>" id="<%= id %>"' +
      '<%= (fieldHtmlClass ? " class=\'" + fieldHtmlClass + "\'" : "") %>' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      '> ' +
      '<% _.each(node.options, function(key, val) { if(key instanceof Object) { if (value === key.value) { %> <option selected value="<%= key.value %>"><%= key.title %></option> <% } else { %> <option value="<%= key.value %>"><%= key.title %></option> <% }} else { if (value === key) { %> <option selected value="<%= key %>"><%= key %></option> <% } else { %><option value="<%= key %>"><%= key %></option> <% }}}); %> ' +
      '</select>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'imageselect': {
    'template': '<div>' +
      '<input type="hidden" name="<%= node.name %>" id="<%= node.id %>" value="<%= value %>" />' +
      '<div class="dropdown">' +
      '<a class="btn<% if (buttonClass && node.value) { %> <%= buttonClass %><% } %>" data-toggle="dropdown" href="#"<% if (node.value) { %> style="max-width:<%= width %>px;max-height:<%= height %>px"<% } %>>' +
        '<% if (node.value) { %><img src="<% if (!node.value.match(/^https?:/)) { %><%= prefix %><% } %><%= node.value %><%= suffix %>" alt="" /><% } else { %><%= buttonTitle %><% } %>' +
      '</a>' +
      '<div class="dropdown-menu navbar" id="<%= node.id %>_dropdown">' +
        '<div>' +
        '<% _.each(node.options, function(key, idx) { if ((idx > 0) && ((idx % columns) === 0)) { %></div><div><% } %><a class="btn<% if (buttonClass) { %> <%= buttonClass %><% } %>" style="max-width:<%= width %>px;max-height:<%= height %>px"><% if (key instanceof Object) { %><img src="<% if (!key.value.match(/^https?:/)) { %><%= prefix %><% } %><%= key.value %><%= suffix %>" alt="<%= key.title %>" /></a><% } else { %><img src="<% if (!key.match(/^https?:/)) { %><%= prefix %><% } %><%= key %><%= suffix %>" alt="" /><% } %></a> <% }); %>' +
        '</div>' +
        '<div class="pagination-right"><a class="btn">Reset</a></div>' +
      '</div>' +
      '</div>' +
      '</div>',
    'fieldtemplate': true,
    'inputfield': true,
    'onBeforeRender': function (data, node) {
      var elt = node.formElement || {};
      var nbRows = null;
      var maxColumns = elt.imageSelectorColumns || 5;
      data.buttonTitle = elt.imageSelectorTitle || 'Select...';
      data.prefix = elt.imagePrefix || '';
      data.suffix = elt.imageSuffix || '';
      data.width = elt.imageWidth || 32;
      data.height = elt.imageHeight || 32;
      data.buttonClass = elt.imageButtonClass || false;
      if (node.options.length > maxColumns) {
        nbRows = Math.ceil(node.options.length / maxColumns);
        data.columns = Math.ceil(node.options.length / nbRows);
      }
      else {
        data.columns = maxColumns;
      }
    },
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'onInsert': function (evt, node) {
      $(node.el).on('click', '.dropdown-menu a', function (evt) {
        evt.preventDefault();
        evt.stopPropagation();
        var img = (evt.target.nodeName.toLowerCase() === 'img') ?
          $(evt.target) :
          $(evt.target).find('img');
        var value = img.attr('src');
        var elt = node.formElement || {};
        var prefix = elt.imagePrefix || '';
        var suffix = elt.imageSuffix || '';
        var width = elt.imageWidth || 32;
        var height = elt.imageHeight || 32;
        if (value) {
          if (value.indexOf(prefix) === 0) {
            value = value.substring(prefix.length);
          }
          value = value.substring(0, value.length - suffix.length);
          $(node.el).find('input').attr('value', value);
          $(node.el).find('a[data-toggle="dropdown"]')
            .addClass(elt.imageButtonClass)
            .attr('style', 'max-width:' + width + 'px;max-height:' + height + 'px')
            .html('<img src="' + (!value.match(/^https?:/) ? prefix : '') + value + suffix + '" alt="" />');
        }
        else {
          $(node.el).find('input').attr('value', '');
          $(node.el).find('a[data-toggle="dropdown"]')
            .removeClass(elt.imageButtonClass)
            .removeAttr('style')
            .html(elt.imageSelectorTitle || 'Select...');
        }
      });
    }
  },
  'radios':{
    'template': '<div id="<%= node.id %>"><% _.each(node.options, function(key, val) { %><label class="radio"><input type="radio" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked="checked" <% } %> name="<%= node.name %>" value="<%= (key instanceof Object ? key.value : key) %>"' +
      '<%= (node.disabled? " disabled" : "")%>' +
      '<%= (node.schemaElement && node.schemaElement.required ? " required=\'required\'" : "") %>' +
      '/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'radiobuttons': {
    'template': '<div id="<%= node.id %>">' +
      '<% _.each(node.options, function(key, val) { %>' +
        '<label class="radio btn">' +
        '<input type="radio" style="position:absolute;left:-9999px;" ' +
        '<% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked="checked" <% } %> name="<%= node.name %>" value="<%= (key instanceof Object ? key.value : key) %>" />' +
        '<span><%= (key instanceof Object ? key.title : key) %></span></label> ' +
        '<% }); %>' +
      '</div>',
    'fieldtempate': true,
    'inputfield': true,
    'onInsert': function (evt, node) {
      var activeClass = 'active';
      var elt = node.formElement || {};
      if (elt.activeClass) {
        activeClass += ' ' + elt.activeClass;
      }
      $(node.el).find('label').on('click', function () {
        $(this).parent().find('label').removeClass(activeClass);
        $(this).addClass(activeClass);
      });
    }
  },
  'checkboxes':{
    'template': '<div><%= choiceshtml %></div>',
    'fieldtemplate': true,
    'inputfield': true,
    'onBeforeRender': function (data, node) {
      // Build up choices from the enumeration list
      var choices = null;
      var choiceshtml = null;
      var template = '<label class="checkbox">' +
        '<input type="checkbox" <% if (value) { %> checked="checked" <% } %> name="<%= name %>" value="1"' +
        '<%= (node.disabled? " disabled" : "")%>' +
        '/><span><%= title %></span></label>';
      if (!node || !node.schemaElement || !node.schemaElement.items) return;
      choices = node.schemaElement.items['enum'] ||
        node.schemaElement.items[0]['enum'];
      if (!choices) return;

      choiceshtml = '';
      _.each(choices, function (choice, idx) {
        choiceshtml += _.template(template, {
          name: node.key + '[' + idx + ']',
          value: _.include(node.value, choice),
          title: node.formElement.titleMap ? node.formElement.titleMap[choice] : choice,
          node: node
        }, fieldTemplateSettings);
      });

      data.choiceshtml = choiceshtml;
    }
  },
  'array': {
    'template': '<div id="<%= id %>"><ul class="_jsonform-array-ul" style="list-style-type:none;"><%= children %></ul>' +
      '<span class="_jsonform-array-buttons">' +
        '<a href="#" class="btn _jsonform-array-addmore"><i class="icon-plus-sign" title="Add new"></i></a> ' +
        '<a href="#" class="btn _jsonform-array-deletelast"><i class="icon-minus-sign" title="Delete last"></i></a>' +
      '</span>' +
      '</div>',
    'fieldtemplate': true,
    'array': true,
    'childTemplate': function (inner) {
      if ($('').sortable) {
        // Insert a "draggable" icon
        // floating to the left of the main element
        return '<li data-idx="<%= node.childPos %>">' +
          '<span class="draggable line"><i class="icon-list" title="Move item"></i></span>' +
          inner +
          '</li>';
      }
      else {
        return '<li data-idx="<%= node.childPos %>">' +
          inner +
          '</li>';
      }
    },
    'onInsert': function (evt, node) {
      var $nodeid = $(node.el).find('#' + escapeSelector(node.id));
      var boundaries = node.getArrayBoundaries();

      // Switch two nodes in an array
      var moveNodeTo = function (fromIdx, toIdx) {
        // Note "switchValuesWith" extracts values from the DOM since field
        // values are not synchronized with the tree data structure, so calls
        // to render are needed at each step to force values down to the DOM
        // before next move.
        // TODO: synchronize field values and data structure completely and
        // call render only once to improve efficiency.
        if (fromIdx === toIdx) return;
        var incr = (fromIdx < toIdx) ? 1: -1;
        var i = 0;
        var parentEl = $('> ul', $nodeid);
        for (i = fromIdx; i !== toIdx; i += incr) {
          node.children[i].switchValuesWith(node.children[i + incr]);
          node.children[i].render(parentEl.get(0));
          node.children[i + incr].render(parentEl.get(0));
        }

        // No simple way to prevent DOM reordering with jQuery UI Sortable,
        // so we're going to need to move sorted DOM elements back to their
        // origin position in the DOM ourselves (we switched values but not
        // DOM elements)
        var fromEl = $(node.children[fromIdx].el);
        var toEl = $(node.children[toIdx].el);
        fromEl.detach();
        toEl.detach();
        if (fromIdx < toIdx) {
          if (fromIdx === 0) parentEl.prepend(fromEl);
          else $(node.children[fromIdx-1].el).after(fromEl);
          $(node.children[toIdx-1].el).after(toEl);
        }
        else {
          if (toIdx === 0) parentEl.prepend(toEl);
          else $(node.children[toIdx-1].el).after(toEl);
          $(node.children[fromIdx-1].el).after(fromEl);
        }
      };

      $('> span > a._jsonform-array-addmore', $nodeid).click(function (evt) {
        evt.preventDefault();
        evt.stopPropagation();
        var idx = node.children.length;
        if (boundaries.maxItems >= 0) {
          if (node.children.length > boundaries.maxItems - 2) {
            $nodeid.find('> span > a._jsonform-array-addmore')
              .addClass('disabled');
          }
          if (node.children.length > boundaries.maxItems - 1) {
            return false;
          }
        }
        node.insertArrayItem(idx, $('> ul', $nodeid).get(0));
        if ((boundaries.minItems <= 0) ||
            ((boundaries.minItems > 0) &&
              (node.children.length > boundaries.minItems - 1))) {
          $nodeid.find('> span > a._jsonform-array-deletelast')
            .removeClass('disabled');
        }
      });

      //Simulate Users click to setup the form with its minItems
      var curItems = $('> ul > li', $nodeid).length;
      if ((boundaries.minItems > 0) &&
          (curItems < boundaries.minItems)) {
        for (var i = 0; i < (boundaries.minItems - 1) && ($nodeid.find('> ul > li').length < boundaries.minItems); i++) {
          //console.log('Calling click: ',$nodeid);
          //$('> span > a._jsonform-array-addmore', $nodeid).click();
          node.insertArrayItem(curItems, $nodeid.find('> ul').get(0));
        }
      }
      if ((boundaries.minItems > 0) &&
          (node.children.length <= boundaries.minItems)) {
        $nodeid.find('> span > a._jsonform-array-deletelast')
          .addClass('disabled');
      }

      $('> span > a._jsonform-array-deletelast', $nodeid).click(function (evt) {
        var idx = node.children.length - 1;
        evt.preventDefault();
        evt.stopPropagation();
        if (boundaries.minItems > 0) {
          if (node.children.length < boundaries.minItems + 2) {
            $nodeid.find('> span > a._jsonform-array-deletelast')
              .addClass('disabled');
          }
          if (node.children.length <= boundaries.minItems) {
            return false;
          }
        }
        else if (node.children.length === 1) {
          $nodeid.find('> span > a._jsonform-array-deletelast')
            .addClass('disabled');
        }
        node.deleteArrayItem(idx);
        if ((boundaries.maxItems >= 0) && (idx <= boundaries.maxItems - 1)) {
          $nodeid.find('> span > a._jsonform-array-addmore')
            .removeClass('disabled');
        }
      });

      if ($(node.el).sortable) {
        $('> ul', $nodeid).sortable();
        $('> ul', $nodeid).bind('sortstop', function (event, ui) {
          var idx = $(ui.item).data('idx');
          var newIdx = $(ui.item).index();
          moveNodeTo(idx, newIdx);
        });
      }
    }
  },
  'tabarray': {
    'template': '<div id="<%= id %>"><div class="tabbable tabs-left">' +
      '<ul class="nav nav-tabs">' +
        '<%= tabs %>' +
      '</ul>' +
      '<div class="tab-content">' +
        '<%= children %>' +
      '</div>' +
      '</div>' +
      '<a href="#" class="btn _jsonform-array-addmore"><i class="icon-plus-sign" title="Add new"></i></a> ' +
      '<a href="#" class="btn _jsonform-array-deleteitem"><i class="icon-minus-sign" title="Delete item"></i></a></div>',
    'fieldtemplate': true,
    'array': true,
    'childTemplate': function (inner) {
      return '<div data-idx="<%= node.childPos %>" class="tab-pane">' +
        inner +
        '</div>';
    },
    'onBeforeRender': function (data, node) {
      // Generate the initial 'tabs' from the children
      var tabs = '';
      _.each(node.children, function (child, idx) {
        var title = child.legend ||
          child.title ||
          ('Item ' + (idx+1));
        tabs += '<li data-idx="' + idx + '"' +
          ((idx === 0) ? ' class="active"' : '') +
          '><a class="draggable tab" data-toggle="tab">' +
          escapeHTML(title) +
          '</a></li>';
      });
      data.tabs = tabs;
    },
    'onInsert': function (evt, node) {
      var $nodeid = $(node.el).find('#' + escapeSelector(node.id));
      var boundaries = node.getArrayBoundaries();

      var moveNodeTo = function (fromIdx, toIdx) {
        // Note "switchValuesWith" extracts values from the DOM since field
        // values are not synchronized with the tree data structure, so calls
        // to render are needed at each step to force values down to the DOM
        // before next move.
        // TODO: synchronize field values and data structure completely and
        // call render only once to improve efficiency.
        if (fromIdx === toIdx) return;
        var incr = (fromIdx < toIdx) ? 1: -1;
        var i = 0;
        var tabEl = $('> .tabbable > .tab-content', $nodeid).get(0);
        for (i = fromIdx; i !== toIdx; i += incr) {
          node.children[i].switchValuesWith(node.children[i + incr]);
          node.children[i].render(tabEl);
          node.children[i + incr].render(tabEl);
        }
      };


      // Refreshes the list of tabs
      var updateTabs = function (selIdx) {
        var tabs = '';
        var activateFirstTab = false;
        if (selIdx === undefined) {
          selIdx = $('> .tabbable > .nav-tabs .active', $nodeid).data('idx');
          if (selIdx) {
            selIdx = parseInt(selIdx, 10);
          }
          else {
            activateFirstTab = true;
            selIdx = 0;
          }
        }
        if (selIdx >= node.children.length) {
          selIdx = node.children.length - 1;
        }
        _.each(node.children, function (child, idx) {
          var title = child.legend ||
            child.title ||
            ('Item ' + (idx+1));
          tabs += '<li data-idx="' + idx + '">' +
            '<a class="draggable tab" data-toggle="tab">' +
            escapeHTML(title) +
            '</a></li>';
        });
        $('> .tabbable > .nav-tabs', $nodeid).html(tabs);
        if (activateFirstTab) {
          $('> .tabbable > .nav-tabs [data-idx="0"]', $nodeid).addClass('active');
        }
        $('> .tabbable > .nav-tabs [data-toggle="tab"]', $nodeid).eq(selIdx).click();
      };

      $('> a._jsonform-array-deleteitem', $nodeid).click(function (evt) {
        var idx = $('> .tabbable > .nav-tabs .active', $nodeid).data('idx');
        evt.preventDefault();
        evt.stopPropagation();
        if (boundaries.minItems > 0) {
          if (node.children.length < boundaries.minItems + 1) {
            $nodeid.find('> a._jsonform-array-deleteitem')
              .addClass('disabled');
          }
          if (node.children.length <= boundaries.minItems) return false;
        }
        node.deleteArrayItem(idx);
        updateTabs();
        if ((node.children.length < boundaries.minItems + 1) ||
            (node.children.length === 0)) {
          $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');
        }
        if ((boundaries.maxItems >= 0) &&
            (node.children.length <= boundaries.maxItems)) {
          $nodeid.find('> a._jsonform-array-addmore').removeClass('disabled');
        }
      });

      $('> a._jsonform-array-addmore', $nodeid).click(function (evt) {
        var idx = node.children.length;
        if (boundaries.maxItems>=0) {
          if (node.children.length>boundaries.maxItems-2) {
            $('> a._jsonform-array-addmore', $nodeid).addClass("disabled");
          }
          if (node.children.length > boundaries.maxItems - 1) {
            return false;
          }
        }
        evt.preventDefault();
        evt.stopPropagation();
        node.insertArrayItem(idx,
          $nodeid.find('> .tabbable > .tab-content').get(0));
        updateTabs(idx);
        if ((boundaries.minItems <= 0) ||
            ((boundaries.minItems > 0) && (idx > boundaries.minItems - 1))) {
          $nodeid.find('> a._jsonform-array-deleteitem').removeClass('disabled');
        }
      });

      $(node.el).on('legendUpdated', function (evt) {
        updateTabs();
        evt.preventDefault();
        evt.stopPropagation();
      });

      if ($(node.el).sortable) {
        $('> .tabbable > .nav-tabs', $nodeid).sortable({
          containment: node.el,
          tolerance: 'pointer'
        });
        $('> .tabbable > .nav-tabs', $nodeid).bind('sortstop', function (event, ui) {
          var idx = $(ui.item).data('idx');
          var newIdx = $(ui.item).index();
          moveNodeTo(idx, newIdx);
          updateTabs(newIdx);
        });
      }

      // Simulate User's click to setup the form with its minItems
      if (boundaries.minItems >= 0) {
        for (var i = 0; i < (boundaries.minItems - 1); i++) {
          $nodeid.find('> a._jsonform-array-addmore').click();
        }
        $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');
        updateTabs();
      }

      if ((boundaries.maxItems >= 0) &&
          (node.children.length >= boundaries.maxItems)) {
        $nodeid.find('> a._jsonform-array-addmore').addClass('disabled');
      }
      if ((boundaries.minItems >= 0) &&
          (node.children.length <= boundaries.minItems)) {
        $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');
      }
    }
  },
  'help':{
    'template':'<span class="help-block" style="padding-top:5px"><%= elt.helpvalue %></span>',
    'fieldtemplate': true
  },
  'msg': {
    'template': '<%= elt.msg %>'
  },
  'fieldset':{
    'template': '<fieldset class="control-group jsonform-error-<%= keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:"" %>" ' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      '>' +
      '<% if (node.title || node.legend) { %><legend><%= node.title || node.legend %></legend><% } %>' +
      '<% if (elt.expandable) { %><div class="control-group"><% } %>' +
      '<%= children %>' +
      '<% if (elt.expandable) { %></div><% } %>' +
      '</fieldset>'
  },
  'advancedfieldset': {
    'template': '<fieldset' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Advanced options</legend>' +
      '<div class="control-group">' +
      '<%= children %>' +
      '</div>' +
      '</fieldset>'
  },
  'authfieldset': {
    'template': '<fieldset' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Authentication settings</legend>' +
      '<div class="control-group">' +
      '<%= children %>' +
      '</div>' +
      '</fieldset>'
  },
  'submit':{
    'template':'<input type="submit" <% if (id) { %> id="<%= id %>" <% } %> class="btn btn-primary <%= elt.htmlClass?elt.htmlClass:"" %>" value="<%= value || node.title %>"<%= (node.disabled? " disabled" : "")%>/>'
  },
  'button':{
    'template':' <button <% if (id) { %> id="<%= id %>" <% } %> class="btn <%= elt.htmlClass?elt.htmlClass:"" %>"><%= node.title %></button> '
  },
  'actions':{
    'template':'<div class="form-actions <%= elt.htmlClass?elt.htmlClass:"" %>"><%= children %></div>'
  },
  'hidden':{
    'template':'<input type="hidden" id="<%= id %>" name="<%= node.name %>" value="<%= escape(value) %>" />',
    'inputfield': true
  },
  'selectfieldset': {
    'template': '<fieldset class="tab-container <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<% if (node.legend) { %><legend><%= node.legend %></legend><% } %>' +
      '<% if (node.formElement.key) { %><input type="hidden" id="<%= node.id %>" name="<%= node.name %>" value="<%= escape(value) %>" /><% } else { %>' +
        '<a id="<%= node.id %>"></a><% } %>' +
      '<div class="tabbable">' +
        '<div class="control-group<%= node.formElement.hideMenu ? " hide" : "" %>">' +
          '<% if (node.title && !elt.notitle) { %><label class="control-label" for="<%= node.id %>"><%= node.title %></label><% } %>' +
          '<div class="controls"><%= tabs %></div>' +
        '</div>' +
        '<div class="tab-content">' +
          '<%= children %>' +
        '</div>' +
      '</div>' +
      '</fieldset>',
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'childTemplate': function (inner) {
      return '<div data-idx="<%= node.childPos %>" class="tab-pane' +
        '<% if (node.active) { %> active<% } %>">' +
        inner +
        '</div>';
    },
    'onBeforeRender': function (data, node) {
      // Before rendering, this function ensures that:
      // 1. direct children have IDs (used to show/hide the tabs contents)
      // 2. the tab to active is flagged accordingly. The active tab is
      // the first one, except if form values are available, in which case
      // it's the first tab for which there is some value available (or back
      // to the first one if there are none)
      // 3. the HTML of the select field used to select tabs is exposed in the
      // HTML template data as "tabs"

      var children = null;
      var choices = [];
      if (node.schemaElement) {
        choices = node.schemaElement['enum'] || [];
      }
      if (node.options) {
        children = _.map(node.options, function (option, idx) {
          var child = node.children[idx];
          if (option instanceof Object) {
            option = _.extend({ node: child }, option);
            option.title = option.title ||
              child.legend ||
              child.title ||
              ('Option ' + (child.childPos+1));
            option.value = isSet(option.value) ? option.value :
              isSet(choices[idx]) ? choices[idx] : idx;
            return option;
          }
          else {
            return {
              title: option,
              value: isSet(choices[child.childPos]) ?
                choices[child.childPos] :
                child.childPos,
              node: child
            };
          }
        });
      }
      else {
        children = _.map(node.children, function (child, idx) {
          return {
            title: child.legend || child.title || ('Option ' + (child.childPos+1)),
            value: choices[child.childPos] || child.childPos,
            node: child
          };
        });
      }

      var activeChild = null;
      if (data.value) {
        activeChild = _.find(children, function (child) {
          return (child.value === node.value);
        });
      }
      if (!activeChild) {
        activeChild = _.find(children, function (child) {
          return child.node.hasNonDefaultValue();
        });
      }
      if (!activeChild) {
        activeChild = children[0];
      }
      activeChild.node.active = true;
      data.value = activeChild.value;

      var elt = node.formElement;
      var tabs = '<select class="nav"' +
        (node.disabled ? ' disabled' : '') +
        '>';
      _.each(children, function (child, idx) {
        tabs += '<option data-idx="' + idx + '" value="' + child.value + '"' +
          (child.node.active ? ' class="active"' : '') +
          '>' +
          escapeHTML(child.title) +
          '</option>';
      });
      tabs += '</select>';

      data.tabs = tabs;
      return data;
    },
    'onInsert': function (evt, node) {
      $(node.el).find('select.nav').first().on('change', function (evt) {
        var $option = $(this).find('option:selected');
        $(node.el).find('input[type="hidden"]').first().val($option.attr('value'));
      });
    }
  },
  'optionfieldset': {
    'template': '<div' +
      '<% if (node.id) { %> id="<%= node.id %>"<% } %>' +
      '>' +
      '<%= children %>' +
      '</div>'
  },
  'section': {
    'template': '<div' +
      '<% if (node.id) { %> id="<%= node.id %>"<% } %>' +
      '><%= children %></div>'
  },

  /**
   * A "questions" field renders a series of question fields and binds the
   * result to the value of a schema key.
   */
  'questions': {
    'template': '<div>' +
      '<input type="hidden" id="<%= node.id %>" name="<%= node.name %>" value="<%= escape(value) %>" />' +
      '<%= children %>' +
      '</div>',
    'fieldtempate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'onInsert': function (evt, node) {
      if (!node.children || (node.children.length === 0)) return;
      _.each(node.children, function (child) {
        $(child.el).hide();
      });
      $(node.children[0].el).show();
    }
  },

  /**
   * A "question" field lets user choose a response among possible choices.
   * The field is not associated with any schema key. A question should be
   * part of a "questions" field that binds a series of questions to a
   * schema key.
   */
  'question': {
    'template': '<div id="<%= node.id %>"><% _.each(node.options, function(key, val) { %><label class="radio<%= (node.formElement.optionsType === "radiobuttons") ? " btn" : "" %><%= ((key instanceof Object && key.htmlClass) ? " " + key.htmlClass : "") %>"><input type="radio" <% if (node.formElement.optionsType === "radiobuttons") { %> style="position:absolute;left:-9999px;" <% } %>name="<%= node.id %>" value="<%= val %>"<%= (node.disabled? " disabled" : "")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>',
    'fieldtemplate': true,
    'onInsert': function (evt, node) {
      var activeClass = 'active';
      var elt = node.formElement || {};
      if (elt.activeClass) {
        activeClass += ' ' + elt.activeClass;
      }

      // Bind to change events on radio buttons
      $(node.el).find('input[type="radio"]').on('change', function (evt) {
        var questionNode = null;
        var option = node.options[$(this).val()];
        if (!node.parentNode || !node.parentNode.el) return;

        $(this).parent().parent().find('label').removeClass(activeClass);
        $(this).parent().addClass(activeClass);
        $(node.el).nextAll().hide();
        $(node.el).nextAll().find('input[type="radio"]').prop('checked', false);

        // Execute possible actions (set key value, form submission, open link,
        // move on to next question)
        if (option.value) {
          // Set the key of the 'Questions' parent
          $(node.parentNode.el).find('input[type="hidden"]').val(option.value);
        }
        if (option.next) {
          questionNode = _.find(node.parentNode.children, function (child) {
            return (child.formElement && (child.formElement.qid === option.next));
          });
          $(questionNode.el).show();
          $(questionNode.el).nextAll().hide();
          $(questionNode.el).nextAll().find('input[type="radio"]').prop('checked', false);
        }
        if (option.href) {
          if (option.target) {
            window.open(option.href, option.target);
          }
          else {
            window.location = option.href;
          }
        }
        if (option.submit) {
          setTimeout(function () {
            node.ownerTree.submit();
          }, 0);
        }
      });
    }
  }
};


//Allow to access subproperties by splitting "."
/**
 * Retrieves the key identified by a path selector in the structured object.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * @function
 * @param {Object} obj Structured object to parse
 * @param {String} key Path to the key to retrieve
 * @param {boolean} ignoreArrays True to use first element in an array when
 *   stucked on a property. This parameter is basically only useful when
 *   parsing a JSON schema for which the "items" property may either be an
 *   object or an array with one object (only one because JSON form does not
 *   support mix of items for arrays).
 * @return {Object} The key's value.
 */
jsonform.util.getObjKey = function (obj, key, ignoreArrays) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;
  var prop = null;

  for (var i = 0; i < keyparts.length; i++) {
    if ((innerobj === null) || (typeof innerobj !== "object")) return null;
    subkey = keyparts[i];
    prop = subkey.replace(reArray, '');
    reArray.lastIndex = 0;
    arrayMatch = reArray.exec(subkey);
    if (arrayMatch) {
      while (true) {
        if (!_.isArray(innerobj[prop])) return null;
        innerobj = innerobj[prop][parseInt(arrayMatch[1], 10)];
        arrayMatch = reArray.exec(subkey);
        if (!arrayMatch) break;
      }
    }
    else if (ignoreArrays &&
        !innerobj[prop] &&
        _.isArray(innerobj) &&
        innerobj[0]) {
      innerobj = innerobj[0][prop];
    }
    else {
      innerobj = innerobj[prop];
    }
  }

  if (ignoreArrays && _.isArray(innerobj) && innerobj[0]) {
    return innerobj[0];
  }
  else {
    return innerobj;
  }
};


/**
 * Sets the key identified by a path selector to the given value.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * The hierarchy is automatically created if it does not exist yet.
 *
 * @function
 * @param {Object} obj The object to build
 * @param {String} key The path to the key to set where each level
 *  is separated by a dot, and array items are flagged with [x].
 * @param {Object} value The value to set, may be of any type.
 */
jsonform.util.setObjKey = function(obj,key,value) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;
  var prop = null;

  for (var i = 0; i < keyparts.length-1; i++) {
    subkey = keyparts[i];
    prop = subkey.replace(reArray, '');
    reArray.lastIndex = 0;
    arrayMatch = reArray.exec(subkey);
    if (arrayMatch) {
      // Subkey is part of an array
      while (true) {
        if (!_.isArray(innerobj[prop])) {
          innerobj[prop] = [];
        }
        innerobj = innerobj[prop];
        prop = parseInt(arrayMatch[1], 10);
        arrayMatch = reArray.exec(subkey);
        if (!arrayMatch) break;
      }
      if ((typeof innerobj[prop] !== 'object') ||
        (innerobj[prop] === null)) {
        innerobj[prop] = {};
      }
      innerobj = innerobj[prop];
    }
    else {
      // "Normal" subkey
      if ((typeof innerobj[prop] !== 'object') ||
        (innerobj[prop] === null)) {
        innerobj[prop] = {};
      }
      innerobj = innerobj[prop];
    }
  }

  // Set the final value
  subkey = keyparts[keyparts.length - 1];
  prop = subkey.replace(reArray, '');
  reArray.lastIndex = 0;
  arrayMatch = reArray.exec(subkey);
  if (arrayMatch) {
    while (true) {
      if (!_.isArray(innerobj[prop])) {
        innerobj[prop] = [];
      }
      innerobj = innerobj[prop];
      prop = parseInt(arrayMatch[1], 10);
      arrayMatch = reArray.exec(subkey);
      if (!arrayMatch) break;
    }
    innerobj[prop] = value;
  }
  else {
    innerobj[prop] = value;
  }
};


/**
 * Retrieves the key definition from the given schema.
 *
 * The key is identified by the path that leads to the key in the
 * structured object that the schema would generate. Each level is
 * separated by a '.'. Array levels are marked with []. For instance:
 *  foo.bar[].baz
 * ... to retrieve the definition of the key at the following location
 * in the JSON schema (using a dotted path notation):
 *  foo.properties.bar.items.properties.baz
 *
 * @function
 * @param {Object} schema The JSON schema to retrieve the key from
 * @param {String} key The path to the key, each level being separated
 *  by a dot and array items being flagged with [].
 * @return {Object} The key definition in the schema, null if not found.
 */
var getSchemaKey = function(schema,key) {
  var schemaKey = key
    .replace(/\./g, '.properties.')
    .replace(/\[[0-9]*\]/g, '.items');
  var schemaDef = jsonform.util.getObjKey(schema, schemaKey, true);
  if (schemaDef && schemaDef.$ref) {
    throw new Error('JSONForm does not yet support schemas that use the ' +
      '$ref keyword. See: https://github.com/joshfire/jsonform/issues/54');
  }
  return schemaDef;
};


/**
 * Truncates the key path to the requested depth.
 *
 * For instance, if the key path is:
 *  foo.bar[].baz.toto[].truc[].bidule
 * and the requested depth is 1, the returned key will be:
 *  foo.bar[].baz.toto
 *
 * Note the function includes the path up to the next depth level.
 *
 * @function
 * @param {String} key The path to the key in the schema, each level being
 *  separated by a dot and array items being flagged with [].
 * @param {Number} depth The array depth
 * @return {String} The path to the key truncated to the given depth.
 */
var truncateToArrayDepth = function (key, arrayDepth) {
  var depth = 0;
  var pos = 0;
  if (!key) return null;

  if (arrayDepth > 0) {
    while (depth < arrayDepth) {
      pos = key.indexOf('[]', pos);
      if (pos === -1) {
        // Key path is not "deep" enough, simply return the full key
        return key;
      }
      pos = pos + 2;
      depth += 1;
    }
  }

  // Move one step further to the right without including the final []
  pos = key.indexOf('[]', pos);
  if (pos === -1) return key;
  else return key.substring(0, pos);
};

/**
 * Applies the array path to the key path.
 *
 * For instance, if the key path is:
 *  foo.bar[].baz.toto[].truc[].bidule
 * and the arrayPath [4, 2], the returned key will be:
 *  foo.bar[4].baz.toto[2].truc[].bidule
 *
 * @function
 * @param {String} key The path to the key in the schema, each level being
 *  separated by a dot and array items being flagged with [].
 * @param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]
 * @return {String} The path to the key that matches the array path.
 */
var applyArrayPath = function (key, arrayPath) {
  var depth = 0;
  if (!key) return null;
  if (!arrayPath || (arrayPath.length === 0)) return key;
  var newKey = key.replace(reArray, function (str, p1) {
    // Note this function gets called as many times as there are [x] in the ID,
    // from left to right in the string. The goal is to replace the [x] with
    // the appropriate index in the new array path, if defined.
    var newIndex = str;
    if (isSet(arrayPath[depth])) {
      newIndex = '[' + arrayPath[depth] + ']';
    }
    depth += 1;
    return newIndex;
  });
  return newKey;
};


/**
 * Returns the initial value that a field identified by its key
 * should take.
 *
 * The "initial" value is defined as:
 * 1. the previously submitted value if already submitted
 * 2. the default value defined in the layout of the form
 * 3. the default value defined in the schema
 *
 * The "value" returned is intended for rendering purpose,
 * meaning that, for fields that define a titleMap property,
 * the function returns the label, and not the intrinsic value.
 *
 * The function handles values that contains template strings,
 * e.g. {{values.foo[].bar}} or {{idx}}.
 *
 * When the form is a string, the function truncates the resulting string
 * to meet a potential "maxLength" constraint defined in the schema, using
 * "..." to mark the truncation. Note it does not validate the resulting
 * string against other constraints (e.g. minLength, pattern) as it would
 * be hard to come up with an automated course of action to "fix" the value.
 *
 * @function
 * @param {Object} formObject The JSON Form object
 * @param {String} key The generic key path (e.g. foo[].bar.baz[])
 * @param {Array(Number)} arrayPath The array path that identifies
 *  the unique value in the submitted form (e.g. [1, 3])
 * @param {Object} tpldata Template data object
 * @param {Boolean} usePreviousValues true to use previously submitted values
 *  if defined.
 */
var getInitialValue = function (formObject, key, arrayPath, tpldata, usePreviousValues) {
  var value = null;

  // Complete template data for template function
  tpldata = tpldata || {};
  tpldata.idx = tpldata.idx ||
    (arrayPath ? arrayPath[arrayPath.length-1] : 1);
  tpldata.value = isSet(tpldata.value) ? tpldata.value : '';
  tpldata.getValue = tpldata.getValue || function (key) {
    return getInitialValue(formObject, key, arrayPath, tpldata, usePreviousValues);
  };

  // Helper function that returns the form element that explicitly
  // references the given key in the schema.
  var getFormElement = function (elements, key) {
    var formElement = null;
    if (!elements || !elements.length) return null;
    _.each(elements, function (elt) {
      if (formElement) return;
      if (elt === key) {
        formElement = { key: elt };
        return;
      }
      if (_.isString(elt)) return;
      if (elt.key === key) {
        formElement = elt;
      }
      else if (elt.items) {
        formElement = getFormElement(elt.items, key);
      }
    });
    return formElement;
  };
  var formElement = getFormElement(formObject.form || [], key);
  var schemaElement = getSchemaKey(formObject.schema.properties, key);

  if (usePreviousValues && formObject.value) {
    // If values were previously submitted, use them directly if defined
    value = jsonform.util.getObjKey(formObject.value, applyArrayPath(key, arrayPath));
  }
  if (!isSet(value)) {
    if (formElement && (typeof formElement['value'] !== 'undefined')) {
      // Extract the definition of the form field associated with
      // the key as it may override the schema's default value
      // (note a "null" value overrides a schema default value as well)
      value = formElement['value'];
    }
    else if (schemaElement) {
      // Simply extract the default value from the schema
      if (isSet(schemaElement['default'])) {
        value = schemaElement['default'];
      }
    }
    if (value && value.indexOf('{{values.') !== -1) {
      // This label wants to use the value of another input field.
      // Convert that construct into {{getValue(key)}} for
      // Underscore to call the appropriate function of formData
      // when template gets called (note calling a function is not
      // exactly Mustache-friendly but is supported by Underscore).
      value = value.replace(
        /\{\{values\.([^\}]+)\}\}/g,
        '{{getValue("$1")}}');
    }
    if (value) {
      value = _.template(value, tpldata, valueTemplateSettings);
    }
  }

  // Apply titleMap if needed
  if (isSet(value) && formElement &&
      formElement.titleMap &&
      formElement.titleMap[value]) {
    value = _.template(formElement.titleMap[value],
      tpldata, valueTemplateSettings);
  }

  // Check maximum length of a string
  if (value && _.isString(value) &&
    schemaElement && schemaElement.maxLength) {
    if (value.length > schemaElement.maxLength) {
      // Truncate value to maximum length, adding continuation dots
      value = value.substr(0, schemaElement.maxLength - 1) + '…';
    }
  }

  if (!isSet(value)) {
    return null;
  }
  else {
    return value;
  }
};


/**
 * Represents a node in the form.
 *
 * Nodes that have an ID are linked to the corresponding DOM element
 * when rendered
 *
 * Note the form element and the schema elements that gave birth to the
 * node may be shared among multiple nodes (in the case of arrays).
 *
 * @class
 */
var formNode = function () {
  /**
   * The node's ID (may not be set)
   */
  this.id = null;

  /**
   * The node's key path (may not be set)
   */
  this.key = null;

  /**
   * DOM element associated witht the form element.
   *
   * The DOM element is set when the form element is rendered.
   */
  this.el = null;

  /**
   * Link to the form element that describes the node's layout
   * (note the form element is shared among nodes in arrays)
   */
  this.formElement = null;

  /**
   * Link to the schema element that describes the node's value constraints
   * (note the schema element is shared among nodes in arrays)
   */
  this.schemaElement = null;

  /**
   * Pointer to the "view" associated with the node, typically the right
   * object in jsonform.elementTypes
   */
  this.view = null;

  /**
   * Node's subtree (if one is defined)
   */
  this.children = [];

  /**
   * A pointer to the form tree the node is attached to
   */
  this.ownerTree = null;

  /**
   * A pointer to the parent node of the node in the tree
   */
  this.parentNode = null;

  /**
   * Child template for array-like nodes.
   *
   * The child template gets cloned to create new array items.
   */
  this.childTemplate = null;


  /**
   * Direct children of array-like containers may use the value of a
   * specific input field in their subtree as legend. The link to the
   * legend child is kept here and initialized in computeInitialValues
   * when a child sets "valueInLegend"
   */
  this.legendChild = null;


  /**
   * The path of indexes that lead to the current node when the
   * form element is not at the root array level.
   *
   * Note a form element may well be nested element and still be
   * at the root array level. That's typically the case for "fieldset"
   * elements. An array level only gets created when a form element
   * is of type "array" (or a derivated type such as "tabarray").
   *
   * The array path of a form element linked to the foo[2].bar.baz[3].toto
   * element in the submitted values is [2, 3] for instance.
   *
   * The array path is typically used to compute the right ID for input
   * fields. It is also used to update positions when an array item is
   * created, moved around or suppressed.
   *
   * @type {Array(Number)}
   */
  this.arrayPath = [];

  /**
   * Position of the node in the list of children of its parents
   */
  this.childPos = 0;
};


/**
 * Clones a node
 *
 * @function
 * @param {formNode} New parent node to attach the node to
 * @return {formNode} Cloned node
 */
formNode.prototype.clone = function (parentNode) {
  var node = new formNode();
  node.arrayPath = _.clone(this.arrayPath);
  node.ownerTree = this.ownerTree;
  node.parentNode = parentNode || this.parentNode;
  node.formElement = this.formElement;
  node.schemaElement = this.schemaElement;
  node.view = this.view;
  node.children = _.map(this.children, function (child) {
    return child.clone(node);
  });
  if (this.childTemplate) {
    node.childTemplate = this.childTemplate.clone(node);
  }
  return node;
};


/**
 * Returns true if the subtree that starts at the current node
 * has some non empty value attached to it
 */
formNode.prototype.hasNonDefaultValue = function () {

  // hidden elements don't count because they could make the wrong selectfieldset element active
  if (this.formElement && this.formElement.type=="hidden") {
    return false;
  }
  
  if (this.value && !this.defaultValue) {
    return true;
  }
  var child = _.find(this.children, function (child) {
    return child.hasNonDefaultValue();
  });
  return !!child;
};


/**
 * Attaches a child node to the current node.
 *
 * The child node is appended to the end of the list.
 *
 * @function
 * @param {formNode} node The child node to append
 * @return {formNode} The inserted node (same as the one given as parameter)
 */
formNode.prototype.appendChild = function (node) {
  node.parentNode = this;
  node.childPos = this.children.length;
  this.children.push(node);
  return node;
};


/**
 * Removes the last child of the node.
 *
 * @function
 */
formNode.prototype.removeChild = function () {
  var child = this.children[this.children.length-1];
  if (!child) return;

  // Remove the child from the DOM
  $(child.el).remove();

  // Remove the child from the array
  return this.children.pop();
};


/**
 * Moves the user entered values set in the current node's subtree to the
 * given node's subtree.
 *
 * The target node must follow the same structure as the current node
 * (typically, they should have been generated from the same node template)
 *
 * The current node MUST be rendered in the DOM.
 *
 * TODO: when current node is not in the DOM, extract values from formNode.value
 * properties, so that the function be available even when current node is not
 * in the DOM.
 *
 * Moving values around allows to insert/remove array items at arbitrary
 * positions.
 *
 * @function
 * @param {formNode} node Target node.
 */
formNode.prototype.moveValuesTo = function (node) {
  var values = this.getFormValues(node.arrayPath);
  node.resetValues();
  node.computeInitialValues(values, true);
};


/**
 * Switches nodes user entered values.
 *
 * The target node must follow the same structure as the current node
 * (typically, they should have been generated from the same node template)
 *
 * Both nodes MUST be rendered in the DOM.
 *
 * TODO: update getFormValues to work even if node is not rendered, using
 * formNode's "value" property.
 *
 * @function
 * @param {formNode} node Target node
 */
formNode.prototype.switchValuesWith = function (node) {
  var values = this.getFormValues(node.arrayPath);
  var nodeValues = node.getFormValues(this.arrayPath);
  node.resetValues();
  node.computeInitialValues(values, true);
  this.resetValues();
  this.computeInitialValues(nodeValues, true);
};


/**
 * Resets all DOM values in the node's subtree.
 *
 * This operation also drops all array item nodes.
 * Note values are not reset to their default values, they are rather removed!
 *
 * @function
 */
formNode.prototype.resetValues = function () {
  var params = null;
  var idx = 0;

  // Reset value
  this.value = null;

  // Propagate the array path from the parent node
  // (adding the position of the child for nodes that are direct
  // children of array-like nodes)
  if (this.parentNode) {
    this.arrayPath = _.clone(this.parentNode.arrayPath);
    if (this.parentNode.view && this.parentNode.view.array) {
      this.arrayPath.push(this.childPos);
    }
  }
  else {
    this.arrayPath = [];
  }

  if (this.view && this.view.inputfield) {
    // Simple input field, extract the value from the origin,
    // set the target value and reset the origin value
    params = $(':input', this.el).serializeArray();
    _.each(params, function (param) {
      // TODO: check this, there may exist corner cases with this approach
      // (with multiple checkboxes for instance)
      $('[name="' + escapeSelector(param.name) + '"]', $(this.el)).val('');
    }, this);
  }
  else if (this.view && this.view.array) {
    // The current node is an array, drop all children
    while (this.children.length > 0) {
      this.removeChild();
    }
  }

  // Recurse down the tree
  _.each(this.children, function (child) {
    child.resetValues();
  });
};


/**
 * Sets the child template node for the current node.
 *
 * The child template node is used to create additional children
 * in an array-like form element. The template is never rendered.
 *
 * @function
 * @param {formNode} node The child template node to set
 */
formNode.prototype.setChildTemplate = function (node) {
  this.childTemplate = node;
  node.parentNode = this;
};


/**
 * Recursively sets values to all nodes of the current subtree
 * based on previously submitted values, or based on default
 * values when the submitted values are not enough
 *
 * The function should be called once in the lifetime of a node
 * in the tree. It expects its parent's arrayPath to be up to date.
 *
 * Three cases may arise:
 * 1. if the form element is a simple input field, the value is
 * extracted from previously submitted values of from default values
 * defined in the schema.
 * 2. if the form element is an array-like node, the child template
 * is used to create as many children as possible (and at least one).
 * 3. the function simply recurses down the node's subtree otherwise
 * (this happens when the form element is a fieldset-like element).
 *
 * @function
 * @param {Object} values Previously submitted values for the form
 * @param {Boolean} ignoreDefaultValues Ignore default values defined in the
 *  schema when set.
 */
formNode.prototype.computeInitialValues = function (values, ignoreDefaultValues) {
  var self = this;
  var node = null;
  var nbChildren = 1;
  var i = 0;
  var formData = this.ownerTree.formDesc.tpldata || {};

  // Propagate the array path from the parent node
  // (adding the position of the child for nodes that are direct
  // children of array-like nodes)
  if (this.parentNode) {
    this.arrayPath = _.clone(this.parentNode.arrayPath);
    if (this.parentNode.view && this.parentNode.view.array) {
      this.arrayPath.push(this.childPos);
    }
  }
  else {
    this.arrayPath = [];
  }

  // Prepare special data param "idx" for templated values
  // (is is the index of the child in its wrapping array, starting
  // at 1 since that's more human-friendly than a zero-based index)
  formData.idx = (this.arrayPath.length > 0) ?
    this.arrayPath[this.arrayPath.length-1] + 1 :
    this.childPos + 1;

  // Prepare special data param "value" for templated values
  formData.value = '';

  // Prepare special function to compute the value of another field
  formData.getValue = function (key) {
    return getInitialValue(self.ownerTree.formDesc,
      key, self.arrayPath,
      formData, !!values);
  };

  if (this.formElement) {
    // Compute the ID of the field (if needed)
    if (this.formElement.id) {
      this.id = applyArrayPath(this.formElement.id, this.arrayPath);
    }
    else if (this.view && this.view.array) {
      this.id = escapeSelector(this.ownerTree.formDesc.prefix) +
        '-elt-counter-' + _.uniqueId();
    }
    else if (this.parentNode && this.parentNode.view &&
      this.parentNode.view.array) {
      // Array items need an array to associate the right DOM element
      // to the form node when the parent is rendered.
      this.id = escapeSelector(this.ownerTree.formDesc.prefix) +
        '-elt-counter-' + _.uniqueId();
    }
    else if ((this.formElement.type === 'button') ||
      (this.formElement.type === 'selectfieldset') ||
      (this.formElement.type === 'question') ||
      (this.formElement.type === 'buttonquestion')) {
      // Buttons do need an id for "onClick" purpose
      this.id = escapeSelector(this.ownerTree.formDesc.prefix) +
        '-elt-counter-' + _.uniqueId();
    }

    // Compute the actual key (the form element's key is index-free,
    // i.e. it looks like foo[].bar.baz[].truc, so we need to apply
    // the array path of the node to get foo[4].bar.baz[2].truc)
    if (this.formElement.key) {
      this.key = applyArrayPath(this.formElement.key, this.arrayPath);
      this.keydash = this.key.replace(/\./g, '---');
    }

    // Same idea for the field's name
    this.name = applyArrayPath(this.formElement.name, this.arrayPath);

    // Consider that label values are template values and apply the
    // form's data appropriately (note we also apply the array path
    // although that probably doesn't make much sense for labels...)
    _.each([
      'title',
      'legend',
      'description',
      'append',
      'prepend',
      'inlinetitle',
      'helpvalue',
      'value',
      'disabled',
      'placeholder',
      'readOnly'
    ], function (prop) {
      if (_.isString(this.formElement[prop])) {
        if (this.formElement[prop].indexOf('{{values.') !== -1) {
          // This label wants to use the value of another input field.
          // Convert that construct into {{jsonform.getValue(key)}} for
          // Underscore to call the appropriate function of formData
          // when template gets called (note calling a function is not
          // exactly Mustache-friendly but is supported by Underscore).
          this[prop] = this.formElement[prop].replace(
            /\{\{values\.([^\}]+)\}\}/g,
            '{{getValue("$1")}}');
        }
        else {
          // Note applying the array path probably doesn't make any sense,
          // but some geek might want to have a label "foo[].bar[].baz",
          // with the [] replaced by the appropriate array path.
          this[prop] = applyArrayPath(this.formElement[prop], this.arrayPath);
        }
        if (this[prop]) {
          this[prop] = _.template(this[prop], formData, valueTemplateSettings);
        }
      }
      else {
        this[prop] = this.formElement[prop];
      }
    }, this);

    // Apply templating to options created with "titleMap" as well
    if (this.formElement.options) {
      this.options = _.map(this.formElement.options, function (option) {
        var title = null;
        if (_.isObject(option) && option.title) {
          // See a few lines above for more details about templating
          // preparation here.
          if (option.title.indexOf('{{values.') !== -1) {
            title = option.title.replace(
              /\{\{values\.([^\}]+)\}\}/g,
              '{{getValue("$1")}}');
          }
          else {
            title = applyArrayPath(option.title, self.arrayPath);
          }
          return _.extend({}, option, {
            value: (isSet(option.value) ? option.value : ''),
            title: _.template(title, formData, valueTemplateSettings)
          });
        }
        else {
          return option;
        }
      });
    }
  }

  if (this.view && this.view.inputfield && this.schemaElement) {
    // Case 1: simple input field
    if (values) {
      // Form has already been submitted, use former value if defined.
      // Note we won't set the field to its default value otherwise
      // (since the user has already rejected it)
      if (isSet(jsonform.util.getObjKey(values, this.key))) {
        this.value = jsonform.util.getObjKey(values, this.key);
      }
    }
    else if (!ignoreDefaultValues) {
      // No previously submitted form result, use default value
      // defined in the schema if it's available and not already
      // defined in the form element
      if (!isSet(this.value) && isSet(this.schemaElement['default'])) {
        this.value = this.schemaElement['default'];
        if (_.isString(this.value)) {
          if (this.value.indexOf('{{values.') !== -1) {
            // This label wants to use the value of another input field.
            // Convert that construct into {{jsonform.getValue(key)}} for
            // Underscore to call the appropriate function of formData
            // when template gets called (note calling a function is not
            // exactly Mustache-friendly but is supported by Underscore).
            this.value = this.value.replace(
              /\{\{values\.([^\}]+)\}\}/g,
              '{{getValue("$1")}}');
          }
          else {
            // Note applying the array path probably doesn't make any sense,
            // but some geek might want to have a label "foo[].bar[].baz",
            // with the [] replaced by the appropriate array path.
            this.value = applyArrayPath(this.value, this.arrayPath);
          }
          if (this.value) {
            this.value = _.template(this.value, formData, valueTemplateSettings);
          }
        }
        this.defaultValue = true;
      }
    }
  }
  else if (this.view && this.view.array) {
    // Case 2: array-like node
    nbChildren = 0;
    if (values) {
      nbChildren = this.getPreviousNumberOfItems(values, this.arrayPath);
    }
    // TODO: use default values at the array level when form has not been
    // submitted before. Note it's not that easy because each value may
    // be a complex structure that needs to be pushed down the subtree.
    // The easiest way is probably to generate a "values" object and
    // compute initial values from that object
    /*
    else if (this.schemaElement['default']) {
      nbChildren = this.schemaElement['default'].length;
    }
    */
    else if (nbChildren === 0) {
      // If form has already been submitted with no children, the array
      // needs to be rendered without children. If there are no previously
      // submitted values, the array gets rendered with one empty item as
      // it's more natural from a user experience perspective. That item can
      // be removed with a click on the "-" button.
      nbChildren = 1;
    }
    for (i = 0; i < nbChildren; i++) {
      this.appendChild(this.childTemplate.clone());
    }
  }

  // Case 3 and in any case: recurse through the list of children
  _.each(this.children, function (child) {
    child.computeInitialValues(values, ignoreDefaultValues);
  });

  // If the node's value is to be used as legend for its "container"
  // (typically the array the node belongs to), ensure that the container
  // has a direct link to the node for the corresponding tab.
  if (this.formElement && this.formElement.valueInLegend) {
    node = this;
    while (node) {
      if (node.parentNode &&
        node.parentNode.view &&
        node.parentNode.view.array) {
        node.legendChild = this;
        if (node.formElement && node.formElement.legend) {
          node.legend = applyArrayPath(node.formElement.legend, node.arrayPath);
          formData.idx = (node.arrayPath.length > 0) ?
            node.arrayPath[node.arrayPath.length-1] + 1 :
            node.childPos + 1;
          formData.value = isSet(this.value) ? this.value : '';
          node.legend = _.template(node.legend, formData, valueTemplateSettings);
          break;
        }
      }
      node = node.parentNode;
    }
  }
};


/**
 * Returns the number of items that the array node should have based on
 * previously submitted values.
 *
 * The whole difficulty is that values may be hidden deep in the subtree
 * of the node and may actually target different arrays in the JSON schema.
 *
 * @function
 * @param {Object} values Previously submitted values
 * @param {Array(Number)} arrayPath the array path we're interested in
 * @return {Number} The number of items in the array
 */
formNode.prototype.getPreviousNumberOfItems = function (values, arrayPath) {
  var key = null;
  var arrayValue = null;
  var childNumbers = null;
  var idx = 0;

  if (!values) {
    // No previously submitted values, no need to go any further
    return 0;
  }

  if (this.view.inputfield && this.schemaElement) {
    // Case 1: node is a simple input field that links to a key in the schema.
    // The schema key looks typically like:
    //  foo.bar[].baz.toto[].truc[].bidule
    // The goal is to apply the array path and truncate the key to the last
    // array we're interested in, e.g. with an arrayPath [4, 2]:
    //  foo.bar[4].baz.toto[2]
    key = truncateToArrayDepth(this.formElement.key, arrayPath.length);
    key = applyArrayPath(key, arrayPath);
    arrayValue = jsonform.util.getObjKey(values, key);
    if (!arrayValue) {
      // No key? That means this field had been left empty
      // in previous submit
      return 0;
    }
    childNumbers = _.map(this.children, function (child) {
      return child.getPreviousNumberOfItems(values, arrayPath);
    });
    return _.max([_.max(childNumbers) || 0, arrayValue.length]);
  }
  else if (this.view.array) {
    // Case 2: node is an array-like node, look for input fields
    // in its child template
    return this.childTemplate.getPreviousNumberOfItems(values, arrayPath);
  }
  else {
    // Case 3: node is a leaf or a container,
    // recurse through the list of children and return the maximum
    // number of items found in each subtree
    childNumbers = _.map(this.children, function (child) {
      return child.getPreviousNumberOfItems(values, arrayPath);
    });
    return _.max(childNumbers) || 0;
  }
};


/**
 * Returns the structured object that corresponds to the form values entered
 * by the user for the node's subtree.
 *
 * The returned object follows the structure of the JSON schema that gave
 * birth to the form.
 *
 * Obviously, the node must have been rendered before that function may
 * be called.
 *
 * @function
 * @param {Array(Number)} updateArrayPath Array path to use to pretend that
 *  the entered values were actually entered for another item in an array
 *  (this is used to move values around when an item is inserted/removed/moved
 *  in an array)
 * @return {Object} The object that follows the data schema and matches the
 *  values entered by the user.
 */
formNode.prototype.getFormValues = function (updateArrayPath) {
  // The values object that will be returned
  var values = {};

  if (!this.el) {
    throw new Error('formNode.getFormValues can only be called on nodes that are associated with a DOM element in the tree');
  }

  // Form fields values
  var formArray = $(':input', this.el).serializeArray();

  // Set values to false for unset checkboxes and radio buttons
  // because serializeArray() ignores them
  formArray = formArray.concat(
    $(':input[type=checkbox]:not(:disabled):not(:checked)', this.el).map( function() {
      return {"name": this.name, "value": this.checked}
    }).get()
  );

  if (updateArrayPath) {
    _.each(formArray, function (param) {
      param.name = applyArrayPath(param.name, updateArrayPath);
    });
  }

  // The underlying data schema
  var formSchema = this.ownerTree.formDesc.schema;

  for (var i = 0; i < formArray.length; i++) {
    // Retrieve the key definition from the data schema
    var name = formArray[i].name;
    var eltSchema = getSchemaKey(formSchema.properties, name);
    var arrayMatch = null;
    var cval = null;

    // Skip the input field if it's not part of the schema
    if (!eltSchema) continue;

    // Handle multiple checkboxes separately as the idea is to generate
    // an array that contains the list of enumeration items that the user
    // selected.
    if (eltSchema._jsonform_checkboxes_as_array) {
      arrayMatch = name.match(/\[([0-9]*)\]$/);
      if (arrayMatch) {
        name = name.replace(/\[([0-9]*)\]$/, '');
        cval = jsonform.util.getObjKey(values, name) || [];
        if (formArray[i].value === '1') {
          // Value selected, push the corresponding enumeration item
          // to the data result
          cval.push(eltSchema['enum'][parseInt(arrayMatch[1],10)]);
        }
        jsonform.util.setObjKey(values, name, cval);
        continue;
      }
    }

    // Type casting
    if (eltSchema.type === 'boolean') {
      if (formArray[i].value === '0') {
        formArray[i].value = false;
      } else {
        formArray[i].value = !!formArray[i].value;
      }
    }
    if ((eltSchema.type === 'number') ||
      (eltSchema.type === 'integer')) {
      if (_.isString(formArray[i].value)) {
        if (!formArray[i].value.length) {
          formArray[i].value = null;
        } else if (!isNaN(Number(formArray[i].value))) {
          formArray[i].value = Number(formArray[i].value);
        }
      }
    }
    if ((eltSchema.type === 'string') &&
      (formArray[i].value === '') &&
      !eltSchema._jsonform_allowEmpty) {
      formArray[i].value=null;
    }
    if ((eltSchema.type === 'object') &&
      _.isString(formArray[i].value) &&
      (formArray[i].value.substring(0,1) === '{')) {
      try {
        formArray[i].value = JSON.parse(formArray[i].value);
      } catch (e) {
        formArray[i].value = {};
      }
    }
    //TODO is this due to a serialization bug?
    if ((eltSchema.type === 'object') &&
      (formArray[i].value === 'null' || formArray[i].value === '')) {
      formArray[i].value = null;
    }

    if (formArray[i].name && (formArray[i].value !== null)) {
      jsonform.util.setObjKey(values, formArray[i].name, formArray[i].value);
    }
  }
  // console.log("Form value",values);
  return values;
};



/**
 * Renders the node.
 *
 * Rendering is done in three steps: HTML generation, DOM element creation
 * and insertion, and an enhance step to bind event handlers.
 *
 * @function
 * @param {Node} el The DOM element where the node is to be rendered. The
 *  node is inserted at the right position based on its "childPos" property.
 */
formNode.prototype.render = function (el) {
  var html = this.generate();
  this.setContent(html, el);
  this.enhance();
};


/**
 * Inserts/Updates the HTML content of the node in the DOM.
 *
 * If the HTML is an update, the new HTML content replaces the old one.
 * The new HTML content is not moved around in the DOM in particular.
 *
 * The HTML is inserted at the right position in its parent's DOM subtree
 * otherwise (well, provided there are enough children, but that should always
 * be the case).
 *
 * @function
 * @param {string} html The HTML content to render
 * @param {Node} parentEl The DOM element that is to contain the DOM node.
 *  This parameter is optional (the node's parent is used otherwise) and
 *  is ignored if the node to render is already in the DOM tree.
 */
formNode.prototype.setContent = function (html, parentEl) {
  var node = $(html);
  var parentNode = parentEl ||
    (this.parentNode ? this.parentNode.el : this.ownerTree.domRoot);
  var nextSibling = null;

  if (this.el) {
    // Replace the contents of the DOM element if the node is already in the tree
    $(this.el).replaceWith(node);
  }
  else {
    // Insert the node in the DOM if it's not already there
    nextSibling = $(parentNode).children().get(this.childPos);
    if (nextSibling) {
      $(nextSibling).before(node);
    }
    else {
      $(parentNode).append(node);
    }
  }

  // Save the link between the form node and the generated HTML
  this.el = node;

  // Update the node's subtree, extracting DOM elements that match the nodes
  // from the generated HTML
  this.updateElement(this.el);
};


/**
 * Updates the DOM element associated with the node.
 *
 * Only nodes that have ID are directly associated with a DOM element.
 *
 * @function
 */
formNode.prototype.updateElement = function (domNode) {
  if (this.id) {
    this.el = $('#' + escapeSelector(this.id), domNode).get(0);
    if (this.view && this.view.getElement) {
      this.el = this.view.getElement(this.el);
    }
    if ((this.fieldtemplate !== false) &&
      this.view && this.view.fieldtemplate) {
      // The field template wraps the element two or three level deep
      // in the DOM tree, depending on whether there is anything prepended
      // or appended to the input field
      this.el = $(this.el).parent().parent();
      if (this.prepend || this.prepend) {
        this.el = this.el.parent();
      }
      this.el = this.el.get(0);
    }
    if (this.parentNode && this.parentNode.view &&
      this.parentNode.view.childTemplate) {
      // TODO: the child template may introduce more than one level,
      // so the number of levels introduced should rather be exposed
      // somehow in jsonform.fieldtemplate.
      this.el = $(this.el).parent().get(0);
    }
  }

  _.each(this.children, function (child) {
    child.updateElement(this.el || domNode);
  });
};


/**
 * Generates the view's HTML content for the underlying model.
 *
 * @function
 */
formNode.prototype.generate = function () {
  var data = {
    id: this.id,
    keydash: this.keydash,
    elt: this.formElement,
    schema: this.schemaElement,
    node: this,
    value: isSet(this.value) ? this.value : '',
    escape: escapeHTML
  };
  var template = null;
  var html = '';

  // Complete the data context if needed
  if (this.ownerTree.formDesc.onBeforeRender) {
    this.ownerTree.formDesc.onBeforeRender(data, this);
  }
  if (this.view.onBeforeRender) {
    this.view.onBeforeRender(data, this);
  }

  // Use the template that 'onBeforeRender' may have set,
  // falling back to that of the form element otherwise
  if (this.template) {
    template = this.template;
  }
  else if (this.formElement && this.formElement.template) {
    template = this.formElement.template;
  }
  else {
    template = this.view.template;
  }

  // Wrap the view template in the generic field template
  // (note the strict equality to 'false', needed as we fallback
  // to the view's setting otherwise)
  if ((this.fieldtemplate !== false) &&
    (this.fieldtemplate || this.view.fieldtemplate)) {
    template = jsonform.fieldTemplate(template);
  }

  // Wrap the content in the child template of its parent if necessary.
  if (this.parentNode && this.parentNode.view &&
    this.parentNode.view.childTemplate) {
    template = this.parentNode.view.childTemplate(template);
  }

  // Prepare the HTML of the children
  var childrenhtml = '';
  _.each(this.children, function (child) {
    childrenhtml += child.generate();
  });
  data.children = childrenhtml;

  data.fieldHtmlClass = '';
  if (this.ownerTree &&
      this.ownerTree.formDesc &&
      this.ownerTree.formDesc.params &&
      this.ownerTree.formDesc.params.fieldHtmlClass) {
    data.fieldHtmlClass = this.ownerTree.formDesc.params.fieldHtmlClass;
  }
  if (this.formElement &&
      (typeof this.formElement.fieldHtmlClass !== 'undefined')) {
    data.fieldHtmlClass = this.formElement.fieldHtmlClass;
  }

  // Apply the HTML template
  html = _.template(template, data, fieldTemplateSettings);
  return html;
};


/**
 * Enhances the view with additional logic, binding event handlers
 * in particular.
 *
 * The function also runs the "insert" event handler of the view and
 * form element if they exist (starting with that of the view)
 *
 * @function
 */
formNode.prototype.enhance = function () {
  var node = this;
  var handlers = null;
  var handler = null;
  var formData = _.clone(this.ownerTree.formDesc.tpldata) || {};

  if (this.formElement) {
    // Check the view associated with the node as it may define an "onInsert"
    // event handler to be run right away
    if (this.view.onInsert) {
      this.view.onInsert({ target: $(this.el) }, this);
    }

    handlers = this.handlers || this.formElement.handlers;

    // Trigger the "insert" event handler
    handler = this.onInsert || this.formElement.onInsert;
    if (handler) {
      handler({ target: $(this.el) }, this);
    }
    if (handlers) {
      _.each(handlers, function (handler, onevent) {
        if (onevent === 'insert') {
          handler({ target: $(this.el) }, this);
        }
      }, this);
    }

    // No way to register event handlers if the DOM element is unknown
    // TODO: find some way to register event handlers even when this.el is not set.
    if (this.el) {

      // Register specific event handlers
      // TODO: Add support for other event handlers
      if (this.onChange)
        $(this.el).bind('change', function(evt) { node.onChange(evt, node); });
      if (this.view.onChange)
        $(this.el).bind('change', function(evt) { node.view.onChange(evt, node); });
      if (this.formElement.onChange)
        $(this.el).bind('change', function(evt) { node.formElement.onChange(evt, node); });

      if (this.onClick)
        $(this.el).bind('click', function(evt) { node.onClick(evt, node); });
      if (this.view.onClick)
        $(this.el).bind('click', function(evt) { node.view.onClick(evt, node); });
      if (this.formElement.onClick)
        $(this.el).bind('click', function(evt) { node.formElement.onClick(evt, node); });

      if (this.onKeyUp)
        $(this.el).bind('keyup', function(evt) { node.onKeyUp(evt, node); });
      if (this.view.onKeyUp)
        $(this.el).bind('keyup', function(evt) { node.view.onKeyUp(evt, node); });
      if (this.formElement.onKeyUp)
        $(this.el).bind('keyup', function(evt) { node.formElement.onKeyUp(evt, node); });

      if (handlers) {
        _.each(handlers, function (handler, onevent) {
          if (onevent !== 'insert') {
            $(this.el).bind(onevent, function(evt) { handler(evt, node); });
          }
        }, this);
      }
    }

    // Auto-update legend based on the input field that's associated with it
    if (this.legendChild && this.legendChild.formElement) {
      $(this.legendChild.el).bind('keyup', function (evt) {
        if (node.formElement && node.formElement.legend && node.parentNode) {
          node.legend = applyArrayPath(node.formElement.legend, node.arrayPath);
          formData.idx = (node.arrayPath.length > 0) ?
            node.arrayPath[node.arrayPath.length-1] + 1 :
            node.childPos + 1;
          formData.value = $(evt.target).val();
          node.legend = _.template(node.legend, formData, valueTemplateSettings);
          $(node.parentNode.el).trigger('legendUpdated');
        }
      });
    }
  }

  // Recurse down the tree to enhance children
  _.each(this.children, function (child) {
    child.enhance();
  });
};



/**
 * Inserts an item in the array at the requested position and renders the item.
 *
 * @function
 * @param {Number} idx Insertion index
 */
formNode.prototype.insertArrayItem = function (idx, domElement) {
  var i = 0;

  // Insert element at the end of the array if index is not given
  if (idx === undefined) {
    idx = this.children.length;
  }

  // Create the additional array item at the end of the list,
  // using the item template created when tree was initialized
  // (the call to resetValues ensures that 'arrayPath' is correctly set)
  var child = this.childTemplate.clone();
  this.appendChild(child);
  child.resetValues();

  // To create a blank array item at the requested position,
  // shift values down starting at the requested position
  // one to insert (note we start with the end of the array on purpose)
  for (i = this.children.length-2; i >= idx; i--) {
    this.children[i].moveValuesTo(this.children[i+1]);
  }

  // Initialize the blank node we've created with default values
  this.children[idx].resetValues();
  this.children[idx].computeInitialValues();

  // Re-render all children that have changed
  for (i = idx; i < this.children.length; i++) {
    this.children[i].render(domElement);
  }
};


/**
 * Remove an item from an array
 *
 * @function
 * @param {Number} idx The index number of the item to remove
 */
formNode.prototype.deleteArrayItem = function (idx) {
  var i = 0;
  var child = null;

  // Delete last item if no index is given
  if (idx === undefined) {
    idx = this.children.length - 1;
  }

  // Move values up in the array
  for (i = idx; i < this.children.length-1; i++) {
    this.children[i+1].moveValuesTo(this.children[i]);
    this.children[i].render();
  }

  // Remove the last array item from the DOM tree and from the form tree
  this.removeChild();
};

/**
 * Returns the minimum/maximum number of items that an array field
 * is allowed to have according to the schema definition of the fields
 * it contains.
 *
 * The function parses the schema definitions of the array items that
 * compose the current "array" node and returns the minimum value of
 * "maxItems" it encounters as the maximum number of items, and the
 * maximum value of "minItems" as the minimum number of items.
 *
 * The function reports a -1 for either of the boundaries if the schema
 * does not put any constraint on the number of elements the current
 * array may have of if the current node is not an array.
 *
 * Note that array boundaries should be defined in the JSON Schema using
 * "minItems" and "maxItems". The code also supports "minLength" and
 * "maxLength" as a fallback, mostly because it used to by mistake (see #22)
 * and because other people could make the same mistake.
 *
 * @function
 * @return {Object} An object with properties "minItems" and "maxItems"
 *  that reports the corresponding number of items that the array may
 *  have (value is -1 when there is no constraint for that boundary)
 */
formNode.prototype.getArrayBoundaries = function () {
  var boundaries = {
    minItems: -1,
    maxItems: -1
  };
  if (!this.view || !this.view.array) return boundaries;

  var getNodeBoundaries = function (node, initialNode) {
    var schemaKey = null;
    var arrayKey = null;
    var boundaries = {
      minItems: -1,
      maxItems: -1
    };
    initialNode = initialNode || node;

    if (node.view && node.view.array && (node !== initialNode)) {
      // New array level not linked to an array in the schema,
      // so no size constraints
      return boundaries;
    }

    if (node.key) {
      // Note the conversion to target the actual array definition in the
      // schema where minItems/maxItems may be defined. If we're still looking
      // at the initial node, the goal is to convert from:
      //  foo[0].bar[3].baz to foo[].bar[].baz
      // If we're not looking at the initial node, the goal is to look at the
      // closest array parent:
      //  foo[0].bar[3].baz to foo[].bar
      arrayKey = node.key.replace(/\[[0-9]+\]/g, '[]');
      if (node !== initialNode) {
        arrayKey = arrayKey.replace(/\[\][^\[\]]*$/, '');
      }
      schemaKey = getSchemaKey(
        node.ownerTree.formDesc.schema.properties,
        arrayKey
      );
      if (!schemaKey) return boundaries;
      return {
        minItems: schemaKey.minItems || schemaKey.minLength || -1,
        maxItems: schemaKey.maxItems || schemaKey.maxLength || -1
      };
    }
    else {
      _.each(node.children, function (child) {
        var subBoundaries = getNodeBoundaries(child, initialNode);
        if (subBoundaries.minItems !== -1) {
          if (boundaries.minItems !== -1) {
            boundaries.minItems = Math.max(
              boundaries.minItems,
              subBoundaries.minItems
            );
          }
          else {
            boundaries.minItems = subBoundaries.minItems;
          }
        }
        if (subBoundaries.maxItems !== -1) {
          if (boundaries.maxItems !== -1) {
            boundaries.maxItems = Math.min(
              boundaries.maxItems,
              subBoundaries.maxItems
            );
          }
          else {
            boundaries.maxItems = subBoundaries.maxItems;
          }
        }
      });
    }
    return boundaries;
  };
  return getNodeBoundaries(this);
};


/**
 * Form tree class.
 *
 * Holds the internal representation of the form.
 * The tree is always in sync with the rendered form, this allows to parse
 * it easily.
 *
 * @class
 */
var formTree = function () {
  this.eventhandlers = [];
  this.root = null;
  this.formDesc = null;
};

/**
 * Initializes the form tree structure from the JSONForm object
 *
 * This function is the main entry point of the JSONForm library.
 *
 * Initialization steps:
 * 1. the internal tree structure that matches the JSONForm object
 *  gets created (call to buildTree)
 * 2. initial values are computed from previously submitted values
 *  or from the default values defined in the JSON schema.
 *
 * When the function returns, the tree is ready to be rendered through
 * a call to "render".
 *
 * @function
 */
formTree.prototype.initialize = function (formDesc) {
  formDesc = formDesc || {};

  // Keep a pointer to the initial JSONForm
  // (note clone returns a shallow copy, only first-level is cloned)
  this.formDesc = _.clone(formDesc);

  // Compute form prefix if no prefix is given.
  this.formDesc.prefix = this.formDesc.prefix ||
    'jsonform-' + _.uniqueId();

  // JSON schema shorthand
  if (this.formDesc.schema && !this.formDesc.schema.properties) {
    this.formDesc.schema = {
      properties: this.formDesc.schema
    };
  }

  // Ensure layout is set
  this.formDesc.form = this.formDesc.form || [
    '*',
    {
      type: 'actions',
      items: [
        {
          type: 'submit',
          value: 'Submit'
        }
      ]
    }
  ];
  this.formDesc.form = (_.isArray(this.formDesc.form) ?
    this.formDesc.form :
    [this.formDesc.form]);

  this.formDesc.params = this.formDesc.params || {};

  // Create the root of the tree
  this.root = new formNode();
  this.root.ownerTree = this;
  this.root.view = jsonform.elementTypes['root'];

  // Generate the tree from the form description
  this.buildTree();

  // Compute the values associated with each node
  // (for arrays, the computation actually creates the form nodes)
  this.computeInitialValues();
};


/**
 * Constructs the tree from the form description.
 *
 * The function must be called once when the tree is first created.
 *
 * @function
 */
formTree.prototype.buildTree = function () {
  // Parse and generate the form structure based on the elements encountered:
  // - '*' means "generate all possible fields using default layout"
  // - a key reference to target a specific data element
  // - a more complex object to generate specific form sections
  _.each(this.formDesc.form, function (formElement) {
    if (formElement === '*') {
      _.each(this.formDesc.schema.properties, function (element, key) {
        this.root.appendChild(this.buildFromLayout({
          key: key
        }));
      }, this);
    }
    else {
      if (_.isString(formElement)) {
        formElement = {
          key: formElement
        };
      }
      this.root.appendChild(this.buildFromLayout(formElement));
    }
  }, this);
};


/**
 * Builds the internal form tree representation from the requested layout.
 *
 * The function is recursive, generating the node children as necessary.
 * The function extracts the values from the previously submitted values
 * (this.formDesc.value) or from default values defined in the schema.
 *
 * @function
 * @param {Object} formElement JSONForm element to render
 * @param {Object} context The parsing context (the array depth in particular)
 * @return {Object} The node that matches the element.
 */
formTree.prototype.buildFromLayout = function (formElement, context) {
  var schemaElement = null;
  var node = new formNode();
  var view = null;
  var key = null;

  // The form element parameter directly comes from the initial
  // JSONForm object. We'll make a shallow copy of it and of its children
  // not to pollute the original object.
  // (note JSON.parse(JSON.stringify()) cannot be used since there may be
  // event handlers in there!)
  formElement = _.clone(formElement);
  if (formElement.items) {
    if (_.isArray(formElement.items)) {
      formElement.items = _.map(formElement.items, _.clone);
    }
    else {
      formElement.items = [ _.clone(formElement.items) ];
    }
  }

  if (formElement.key) {
    // The form element is directly linked to an element in the JSON
    // schema. The properties of the form element override those of the
    // element in the JSON schema. Properties from the JSON schema complete
    // those of the form element otherwise.

    // Retrieve the element from the JSON schema
    schemaElement = getSchemaKey(
      this.formDesc.schema.properties,
      formElement.key);
    if (!schemaElement) {
      // The JSON Form is invalid!
      throw new Error('The JSONForm object references the schema key "' +
        formElement.key + '" but that key does not exist in the JSON schema');
    }

    // Schema element has just been found, let's trigger the
    // "onElementSchema" event
    // (tidoust: not sure what the use case for this is, keeping the
    // code for backward compatibility)
    if (this.formDesc.onElementSchema) {
      this.formDesc.onElementSchema(formElement, schemaElement);
    }

    formElement.name =
      formElement.name ||
      formElement.key;
    formElement.title =
      formElement.title ||
      schemaElement.title;
    formElement.description =
      formElement.description ||
      schemaElement.description;
    formElement.readOnly =
      formElement.readOnly ||
      schemaElement.readOnly ||
      formElement.readonly ||
      schemaElement.readonly;

    // Compute the ID of the input field
    if (!formElement.id) {
      formElement.id = escapeSelector(this.formDesc.prefix) +
        '-elt-' + formElement.key;
    }

    // Should empty strings be included in the final value?
    // TODO: it's rather unclean to pass it through the schema.
    if (formElement.allowEmpty) {
      schemaElement._jsonform_allowEmpty = true;
    }

    // If the form element does not define its type, use the type of
    // the schema element.
    if (!formElement.type) {
      if ((schemaElement.type === 'string') &&
        (schemaElement.format === 'color')) {
        formElement.type = 'color';
      } else if ((schemaElement.type === 'number' ||
          schemaElement.type === 'integer' ||
          schemaElement.type === 'string' ||
          schemaElement.type === 'any') &&
        !schemaElement['enum']) {
        formElement.type = 'text';
      } else if (schemaElement.type === 'boolean') {
        formElement.type = 'checkbox';
      } else if (schemaElement.type === 'object') {
        if (schemaElement.properties) {
          formElement.type = 'fieldset';
        } else {
          formElement.type = 'textarea';
        }
      } else if (!_.isUndefined(schemaElement['enum'])) {
        formElement.type = 'select';
      } else {
        formElement.type = schemaElement.type;
      }
    }

    // Unless overridden in the definition of the form element (or unless
    // there's a titleMap defined), use the enumeration list defined in
    // the schema
    if (!formElement.options && schemaElement['enum']) {
      if (formElement.titleMap) {
        formElement.options = _.map(schemaElement['enum'], function (value) {
          return {
            value: value,
            title: formElement.titleMap[value] || value
          };
        });
      }
      else {
        formElement.options = schemaElement['enum'];
      }
    }

    // Flag a list of checkboxes with multiple choices
    if ((formElement.type === 'checkboxes') && schemaElement.items) {
      var itemsEnum = schemaElement.items['enum'];
      if (itemsEnum) {
        schemaElement.items._jsonform_checkboxes_as_array = true;
      }
      if (!itemsEnum && schemaElement.items[0]) {
        itemsEnum = schemaElement.items[0]['enum'];
        if (itemsEnum) {
          schemaElement.items[0]._jsonform_checkboxes_as_array = true;
        }
      }
    }

    // If the form element targets an "object" in the JSON schema,
    // we need to recurse through the list of children to create an
    // input field per child property of the object in the JSON schema
    if (schemaElement.type === 'object') {
      _.each(schemaElement.properties, function (prop, propName) {
        node.appendChild(this.buildFromLayout({
          key: formElement.key + '.' + propName
        }));
      }, this);
    }
  }

  if (!formElement.type) {
    formElement.type = 'none';
  }
  view = jsonform.elementTypes[formElement.type];
  if (!view) {
    throw new Error('The JSONForm contains an element whose type is unknown: "' +
      formElement.type + '"');
  }
  

  if (schemaElement) {
    // The form element is linked to an element in the schema.
    // Let's make sure the types are compatible.
    // In particular, the element must not be a "container"
    // (or must be an "object" or "array" container)
    if (!view.inputfield && !view.array &&
      (formElement.type !== 'selectfieldset') &&
      (schemaElement.type !== 'object')) {
      throw new Error('The JSONForm contains an element that links to an ' +
        'element in the JSON schema (key: "' + formElement.key + '") ' +
        'and that should not based on its type ("' + formElement.type + '")');
    }
  }
  else {
    // The form element is not linked to an element in the schema.
    // This means the form element must be a "container" element,
    // and must not define an input field.
    if (view.inputfield && (formElement.type !== 'selectfieldset')) {
      throw new Error('The JSONForm defines an element of type ' +
        '"' + formElement.type + '" ' +
        'but no "key" property to link the input field to the JSON schema');
    }
  }

  // A few characters need to be escaped to use the ID as jQuery selector
  formElement.iddot = escapeSelector(formElement.id || '');

  // Initialize the form node from the form element and schema element
  node.formElement = formElement;
  node.schemaElement = schemaElement;
  node.view = view;
  node.ownerTree = this;

  // Set event handlers
  if (!formElement.handlers) {
    formElement.handlers = {};
  }

  // Parse children recursively
  if (node.view.array) {
    // The form element is an array. The number of items in an array
    // is by definition dynamic, up to the form user (through "Add more",
    // "Delete" commands). The positions of the items in the array may
    // also change over time (through "Move up", "Move down" commands).
    //
    // The form node stores a "template" node that serves as basis for
    // the creation of an item in the array.
    //
    // Array items may be complex forms themselves, allowing for nesting.
    //
    // The initial values set the initial number of items in the array.
    // Note a form element contains at least one item when it is rendered.
    if (formElement.items) {
      key = formElement.items[0] || formElement.items;
    }
    else {
      key = formElement.key + '[]';
    }
    if (_.isString(key)) {
      key = { key: key };
    }
    node.setChildTemplate(this.buildFromLayout(key));
  }
  else if (formElement.items) {
    // The form element defines children elements
    _.each(formElement.items, function (item) {
      if (_.isString(item)) {
        item = { key: item };
      }
      node.appendChild(this.buildFromLayout(item));
    }, this);
  }

  return node;
};


/**
 * Computes the values associated with each input field in the tree based
 * on previously submitted values or default values in the JSON schema.
 *
 * For arrays, the function actually creates and inserts additional
 * nodes in the tree based on previously submitted values (also ensuring
 * that the array has at least one item).
 *
 * The function sets the array path on all nodes.
 * It should be called once in the lifetime of a form tree right after
 * the tree structure has been created.
 *
 * @function
 */
formTree.prototype.computeInitialValues = function () {
  this.root.computeInitialValues(this.formDesc.value);
};


/**
 * Renders the form tree
 *
 * @function
 * @param {Node} domRoot The "form" element in the DOM tree that serves as
 *  root for the form
 */
formTree.prototype.render = function (domRoot) {
  if (!domRoot) return;
  this.domRoot = domRoot;
  this.root.render();

  // If the schema defines required fields, flag the form with the
  // "jsonform-hasrequired" class for styling purpose
  // (typically so that users may display a legend)
  if (this.hasRequiredField()) {
    $(domRoot).addClass('jsonform-hasrequired');
  }
};

/**
 * Walks down the element tree with a callback
 *
 * @function
 * @param {Function} callback The callback to call on each element
 */
formTree.prototype.forEachElement = function (callback) {
  
  var f = function(root) {
    for (var i=0;i<root.children.length;i++) {
      callback(root.children[i]);
      f(root.children[i]);
    }
  };
  f(this.root);

};

formTree.prototype.validate = function(noErrorDisplay) {

  var values = jsonform.getFormValue(this.domRoot);
  var errors = false;

  var options = this.formDesc;

  if (options.validate!==false) {
    var validator = false;
    if (typeof options.validate!="object") {
      if (global.JSONFormValidator) {
        validator = global.JSONFormValidator.createEnvironment("json-schema-draft-03");
      }
    } else {
      validator = options.validate;
    }
    if (validator) {
      var v = validator.validate(values, this.formDesc.schema);
      $(this.domRoot).jsonFormErrors(false,options);
      if (v.errors.length) {
        if (!errors) errors = [];
        errors = errors.concat(v.errors);
      }
    }
  }

  if (errors && !noErrorDisplay) {
    if (options.displayErrors) {
      options.displayErrors(errors,this.domRoot);
    } else {
      $(this.domRoot).jsonFormErrors(errors,options);
    }
  }

  return {"errors":errors}

}

formTree.prototype.submit = function(evt) {

  var stopEvent = function() {
    if (evt) {
      evt.preventDefault();
      evt.stopPropagation();
    }
    return false;
  };
  var values = jsonform.getFormValue(this.domRoot);
  var options = this.formDesc;

  var brk=false;
  this.forEachElement(function(elt) {
    if (brk) return;
    if (elt.view.onSubmit) {
      brk = !elt.view.onSubmit(evt, elt); //may be called multiple times!!
    }
  });

  if (brk) return stopEvent();

  var validated = this.validate();

  if (options.onSubmit && !options.onSubmit(validated.errors,values)) {
    return stopEvent();
  }

  if (validated.errors) return stopEvent();

  if (options.onSubmitValid && !options.onSubmitValid(values)) {
    return stopEvent();
  }

  return false;

};


/**
 * Returns true if the form displays a "required" field.
 *
 * To keep things simple, the function parses the form's schema and returns
 * true as soon as it finds a "required" flag even though, in theory, that
 * schema key may not appear in the final form.
 *
 * Note that a "required" constraint on a boolean type is always enforced,
 * the code skips such definitions.
 *
 * @function
 * @return {boolean} True when the form has some required field,
 *  false otherwise.
 */
formTree.prototype.hasRequiredField = function () {
  var parseElement = function (element) {
    if (!element) return null;
    if (element.required && (element.type !== 'boolean')) {
      return element;
    }

    var prop = _.find(element.properties, function (property) {
      return parseElement(property);
    });
    if (prop) {
      return prop;
    }

    if (element.items) {
      if (_.isArray(element.items)) {
        prop = _.find(element.items, function (item) {
          return parseElement(item);
        });
      }
      else {
        prop = parseElement(element.items);
      }
      if (prop) {
        return prop;
      }
    }
  };

  return parseElement(this.formDesc.schema);
};


/**
 * Returns the structured object that corresponds to the form values entered
 * by the use for the given form.
 *
 * The form must have been previously rendered through a call to jsonform.
 *
 * @function
 * @param {Node} The <form> tag in the DOM
 * @return {Object} The object that follows the data schema and matches the
 *  values entered by the user.
 */
jsonform.getFormValue = function (formelt) {
  var form = $(formelt).data('jsonform-tree');
  if (!form) return null;
  return form.root.getFormValues();
};


/**
 * Highlights errors reported by the JSON schema validator in the document.
 *
 * @function
 * @param {Object} errors List of errors reported by the JSON schema validator
 * @param {Object} options The JSON Form object that describes the form
 *  (unused for the time being, could be useful to store example values or
 *   specific error messages)
 */
$.fn.jsonFormErrors = function(errors, options) {
  $(".error", this).removeClass("error");
  $(".warning", this).removeClass("warning");

  $(".jsonform-errortext", this).hide();
  if (!errors) return;

  var errorSelectors = [];
  for (var i = 0; i < errors.length; i++) {
    // Compute the address of the input field in the form from the URI
    // returned by the JSON schema validator.
    // These URIs typically look like:
    //  urn:uuid:cccc265e-ffdd-4e40-8c97-977f7a512853#/pictures/1/thumbnail
    // What we need from that is the path in the value object:
    //  pictures[1].thumbnail
    // ... and the jQuery-friendly class selector of the input field:
    //  .jsonform-error-pictures\[1\]---thumbnail
    var key = errors[i].uri
      .replace(/.*#\//, '')
      .replace(/\//g, '.')
      .replace(/\.([0-9]+)(?=\.|$)/g, '[$1]');
    var errormarkerclass = ".jsonform-error-" +
      escapeSelector(key.replace(/\./g,"---"));
    errorSelectors.push(errormarkerclass);

    var errorType = errors[i].type || "error";
    $(errormarkerclass, this).addClass(errorType);
    $(errormarkerclass + " .jsonform-errortext", this).html(errors[i].message).show();
  }

  // Look for the first error in the DOM and ensure the element
  // is visible so that the user understands that something went wrong
  errorSelectors = errorSelectors.join(',');
  var firstError = $(errorSelectors).get(0);
  if (firstError && firstError.scrollIntoView) {
    firstError.scrollIntoView(true, {
      behavior: 'smooth'
    });
  }
};


/**
 * Generates the HTML form from the given JSON Form object and renders the form.
 *
 * Main entry point of the library. Defined as a jQuery function that typically
 * needs to be applied to a <form> element in the document.
 *
 * The function handles the following properties for the JSON Form object it
 * receives as parameter:
 * - schema (required): The JSON Schema that describes the form to render
 * - form: The options form layout description, overrides default layout
 * - prefix: String to use to prefix computed IDs. Default is an empty string.
 *  Use this option if JSON Form is used multiple times in an application with
 *  schemas that have overlapping parameter names to avoid running into multiple
 *  IDs issues. Default value is "jsonform-[counter]".
 * - transloadit: Transloadit parameters when transloadit is used
 * - validate: Validates form against schema upon submission. Uses the value
 * of the "validate" property as validator if it is an object.
 * - displayErrors: Function to call with errors upon form submission.
 *  Default is to render the errors next to the input fields.
 * - submitEvent: Name of the form submission event to bind to.
 *  Default is "submit". Set this option to false to avoid event binding.
 * - onSubmit: Callback function to call when form is submitted
 * - onSubmitValid: Callback function to call when form is submitted without
 *  errors.
 *
 * @function
 * @param {Object} options The JSON Form object to use as basis for the form
 */
$.fn.jsonForm = function(options) {
  var formElt = this;

  options = _.defaults({}, options, {submitEvent: 'submit'});

  var form = new formTree();
  form.initialize(options);
  form.render(formElt.get(0));

  // TODO: move that to formTree.render
  if (options.transloadit) {
    formElt.append('<input type="hidden" name="params" value=\'' +
      escapeHTML(JSON.stringify(options.transloadit.params)) +
      '\'>');
  }

  // Keep a direct pointer to the JSON schema for form submission purpose
  formElt.data("jsonform-tree", form);

  if (options.submitEvent) {
    formElt.unbind((options.submitEvent)+'.jsonform');
    formElt.bind((options.submitEvent)+'.jsonform', function(evt) {
      form.submit(evt);
    });
  }

  // Initialize tabs sections, if any
  initializeTabs(formElt);

  // Initialize expandable sections, if any
  $('.expandable > div, .expandable > fieldset', formElt).hide();
  $('.expandable > legend', formElt).click(function () {
    var parent = $(this).parent();
    parent.toggleClass('expanded');
    $('> div', parent).slideToggle(100);
  });

  return form;
};


/**
 * Retrieves the structured values object generated from the values
 * entered by the user and the data schema that gave birth to the form.
 *
 * Defined as a jQuery function that typically needs to be applied to
 * a <form> element whose content has previously been generated by a
 * call to "jsonForm".
 *
 * Unless explicitly disabled, the values are automatically validated
 * against the constraints expressed in the schema.
 *
 * @function
 * @return {Object} Structured values object that matches the user inputs
 *  and the data schema.
 */
$.fn.jsonFormValue = function() {
  return jsonform.getFormValue(this);
};

// Expose the getFormValue method to the global object
// (other methods exposed as jQuery functions)
global.JSONForm = global.JSONForm || {util:{}};
global.JSONForm.getFormValue = jsonform.getFormValue;
global.JSONForm.fieldTemplate = jsonform.fieldTemplate;
global.JSONForm.fieldTypes = jsonform.elementTypes;
global.JSONForm.getInitialValue = getInitialValue;
global.JSONForm.util.getObjKey = jsonform.util.getObjKey;
global.JSONForm.util.setObjKey = jsonform.util.setObjKey;

})((typeof exports !== 'undefined'),
  ((typeof exports !== 'undefined') ? exports : window),
  ((typeof jQuery !== 'undefined') ? jQuery : { fn: {} }),
  ((typeof _ !== 'undefined') ? _ : null),
  JSON);

})()
},{"underscore":13}],81:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],57:[function(require,module,exports){
var $ = require('jquery-browserify');
var chosen = require('chosen-jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var BranchView = require('./branch');
var templates = require('../../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.sidebar.branches,

  subviews: {},

  initialize: function(options) {
    _.bindAll(this);

    var app = options.app;
    app.loader.start();

    this.app = app;
    this.model = options.model;
    this.repo = options.repo;
    this.branch = options.branch || this.repo.get('default_branch');
    this.router = options.router;
    this.sidebar = options.sidebar;

    this.model.fetch({
      success: this.render,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: this.app.loader.done
    });
  },

  render: function() {
    // only render branches selector if two or more branches
    if (this.model.length < 2) return;

    this.app.loader.start();

    this.$el.empty().append(_.template(this.template));
    var frag = document.createDocumentFragment();

    this.model.each((function(branch, index) {
      var view = new BranchView({
        model: branch,
        repo: this.repo,
        branch: this.branch
      });

      frag.appendChild(view.render().el);
      this.subviews[branch.get('name')] = view;
    }).bind(this));

    this.$el.find('select').html(frag);

    var router = this.router;
    this.$el.find('.chzn-select').chosen().change(function() {
      router.navigate($(this).val(), true);
    });

    this.sidebar.open();

    this.app.loader.done();

    return this;
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./branch":82,"../../../dist/templates":14,"jquery-browserify":11,"backbone":12,"underscore":13,"chosen-jquery-browserify":66}],58:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var CommitView = require('./li/commit');

var queue = require('queue-async');

var cookie = require('../../cookie');
var templates = require('../../../dist/templates');
var utils = require('../../util');

module.exports = Backbone.View.extend({
  subviews: {},

  template: templates.sidebar.label,

  initialize: function(options) {
    _.bindAll(this);

    var app = options.app;
    app.loader.start();

    this.app = app;
    this.branch = options.branch;
    this.commits = options.commits;
    this.repo = options.repo;
    this.router = options.router;
    this.sidebar = options.sidebar;
    this.user = options.user;
    this.view = options.view;

    this.commits.setBranch(this.branch, {
      success: this.render,
      error: (function(model, xhr, options) {
        this.router.error(xhr);
      }).bind(this),
      complete: this.app.loader.done
    });
  },

  renderFiles: function(commits, label) {
    this.app.loader.start();

    // Shallow flatten mapped array of all commit files
    var files = _.flatten(_.map(commits, function(commit) {
      return commit.get('files');
    }), true);

    /*
    // TODO: jail files to rooturl #541
    // This is difficult, as rooturl is set in Files collection
    // on a successful fetch

    if (rooturl) {
      files = files.filter(function(file) {
        return file.filename.indexOf(rooturl) === 0;
      });
    }
    */

    var map = _.groupBy(files, function(file) {
      return file.filename;
    });

    var list = _.uniq(_.map(files, function(file) {
      return file.filename;
    }));

    if (list.length) {
      // Iterate over files and build fragment to append
      var frag = document.createDocumentFragment();
      var ul = frag.appendChild(document.createElement('ul'));
      ul.className = 'listing';

      list.slice(0,5).each((function(file, index) {
        var commits = map[file];
        var commit = commits[0];

        var view = new CommitView({
          branch: this.branch,
          file: commit,
          repo: this.repo,
          view: this.view
        });

        ul.appendChild(view.render().el);

        this.subviews[commit.sha] = view;
      }).bind(this));

      var tmpl = _.template(this.template, label, { variable: 'label' });
      this.$el.append(tmpl, frag);
    }

    this.app.loader.done();
  },

  render: function(options) {
    this.app.loader.start();

    this.$el.empty();

    // Filter on commit.get('author').id === this.user.get('id')
    var id = cookie.get('id') || false;

    // Group and deduplicate commits by authenticated user
    var history = this.commits.groupBy(function(commit) {
      // Handle malformed commit data
      var author = commit.get('author') || commit.get('commit').author;
      return author && author.id === id ? 'author' : 'all';
    });

    // TODO: how many commits should be fetched initially?
    // TODO: option to load more?

    // List of recent updates by all other users
    this.history = (history.all || []).slice(0, 15);

    // Recent commits by authenticated user
    this.recent = (history.author || []).slice(0, 15);

    var q = queue();

    _.union(this.history, this.recent).each(function(commit) {
      q.defer(function(cb) {
        commit.fetch({
          success: function(model, res, options) {
            // This is necessary instead of success: cb for some reason
            cb();
          },
          error: (function(model, xhr, options) {
            this.router.error(xhr);
          }).bind(this),
        });
      });
    });

    q.awaitAll((function(err, res) {
      if (err) return err;

      this.renderFiles(this.history, 'History');
      this.renderFiles(this.recent, t('sidebar.repo.history.label'));

      this.sidebar.open();

      this.app.loader.done();
    }).bind(this));

    return this;
  },

  remove: function() {
    _.invoke(this.subviews, 'remove');
    this.subviews = {};

    Backbone.View.prototype.remove.apply(this, arguments);
  }
});

},{"./li/commit":83,"../../cookie":3,"../../../dist/templates":14,"../../util":28,"jquery-browserify":11,"underscore":13,"backbone":12,"queue-async":47}],59:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../../dist/templates');

module.exports = Backbone.View.extend({
  className: 'inner',

  template: templates.sidebar.drafts,

  initialize: function(options) {
    _.bindAll(this);

    this.link = options.link;
    this.sidebar = options.sidebar;
  },

  render: function() {
    this.$el.html(_.template(this.template, this.link, {
      variable: 'link'
    }));

    this.sidebar.open();

    return this;
  }
});

},{"../../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],60:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var NavView = require('../nav');
var templates = require('../../../dist/templates');
var util = require('../../util');

module.exports = Backbone.View.extend({
  template: templates.sidebar.save,

  events: {
    'change .commit-message': 'setMessage',
    'click a.cancel': 'emit',
    'click a.confirm': 'emit'
  },

  initialize: function(options) {
    _.bindAll(this);

    this.sidebar = options.sidebar;
    this.file = options.file;

    // Re-render updated path in commit message
    this.listenTo(this.file, 'change:path', this.updatePlaceholder);
  },

  emit: function(e) {
    var action = $(e.currentTarget).data('action');
    this.sidebar.trigger(action, e);
    return false;
  },

  setMessage: function(e) {
    var value = e.currentTarget.value;
    this.file.set('message', value);
  },

  updatePlaceholder: function(model, value, options) {
    var name = util.extractFilename(value)[1];

    var placeholder = this.file.isNew() ?
      t('actions.commits.created', { filename: name }) :
      t('actions.commits.updated', { filename: name });

    this.file.set('placeholder', placeholder);
    this.$el.find('.commit-message').attr('placeholder', placeholder);
  },

  render: function() {
    var writable = this.file.get('writable') ?
      t('sidebar.save.save') :
      t('sidebar.save.submit')

    this.$el.html(_.template(this.template, writable, {
      variable: 'writable'
    }));

    this.updatePlaceholder(this.file, this.file.get('path'));

    return this;
  }
});

},{"../../../dist/templates":14,"../../util":28,"../nav":39,"jquery-browserify":11,"underscore":13,"backbone":12}],61:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var NavView = require('../nav');
var util = require('../../util');
var templates = require('../../../dist/templates');

module.exports = Backbone.View.extend({
  template: templates.sidebar.settings,

  events: {
    'click a.delete': 'emit',
    'click a.translate': 'emit',
    'click a.draft': 'emit',
    'change input.filepath': 'setPath'
  },

  initialize: function(options) {
    this.sidebar = options.sidebar;
    this.config = options.config;
    this.file = options.file;

    // fileInput is passed if a title replaces where it
    // normally is shown in the heading of the file.
    this.fileInput = options.fileInput;

    this.listenTo(this.file, 'change:path', this.updatePath);
  },

  emit: function(e) {
    if (e) e.preventDefault();

    var action = $(e.currentTarget).data('action');
    this.sidebar.trigger(action, e);
  },

  updatePath: function(model, value, options) {
    // Set path value from path attr in file model
    this.$el.find('input.filepath').attr('value', value);
  },

  setPath: function(e) {
    this.file.set('path', e.currentTarget.value);
    this.trigger('makeDirty');
    return false;
  },

  render: function() {
    // this.file.get('lang') is programming language
    // this.file.get('metadata').lang is ISO 639-1 language code
    var settings = {
      languages: this.config ? this.config.languages : [],
      lang: this.file.get('lang'),
      metadata: this.file.get('metadata'),
      fileInput: this.fileInput,
      path: this.file.get('path')
    };

    this.$el.html(_.template(this.template, settings, {
      variable: 'settings'
    }));

    util.autoSelect(this.$el.find('input.filepath'));
    return this;
  }
});

},{"../nav":39,"../../util":28,"../../../dist/templates":14,"jquery-browserify":11,"underscore":13,"backbone":12}],64:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var CommitView = require('../sidebar/li/commit');
var templates = require('../../../dist/templates');
var util = require('../../util');

module.exports = Backbone.View.extend({
  template: templates.li.file,

  tagName: 'li',

  className: 'item clearfix',

  events: {
    'click a.delete': 'destroy'
  },

  initialize: function(options) {
    this.branch = options.branch;
    this.history = options.history;
    this.model = options.model;
    this.repo = options.repo;
    this.router = options.router;

    this.$el.attr('data-index', options.index);

    if (!this.model.get('binary')) {
      this.$el.attr('data-navigate', '#' + this.repo.get('owner').login + '/' +
        this.repo.get('name') + '/edit/' + this.branch + '/' +
        this.model.get('path'));
    }
  },

  render: function() {
    var data = _.extend(this.model.attributes, {
      branch: this.branch,
      repo: this.repo.attributes
    });

    var rooturl = this.model.collection.config &&
      this.model.collection.config.rooturl;
    var regex = new RegExp('^' + rooturl + '(.*)');
    var jailpath = rooturl ? data.path.match(regex) : false;

    data.jailpath = jailpath ? jailpath[1] : data.path;

    this.$el.html(_.template(this.template, data, {
      variable: 'file'
    }));

    return this;
  },

  destroy: function(e) {
    if (confirm(t('actions.delete.warn'))) {
      this.model.destroy({
        success: (function(model, res, options) {
          var commit = res.commit;

          var view = new CommitView({
            branch: this.branch,
            file: _.extend(commit, {
              contents_url: model.get('content_url'),
              filename: model.get('path'),
              status: 'removed'
            }),
            repo: this.repo,
            view: this.view
          });

          this.history.$el.find('#commits').prepend(view.render().el);
          this.history.subviews[commit.sha] = view;

          this.$el.fadeOut('fast');
        }).bind(this),
        error: (function(model, xhr, options) {
          this.router.error(xhr);
        }).bind(this)
      });
    }

    return false;
  }
});

},{"../sidebar/li/commit":83,"../../../dist/templates":14,"../../util":28,"underscore":13,"jquery-browserify":11,"backbone":12}],65:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../../dist/templates');

module.exports = Backbone.View.extend({
  tagName: 'li',

  className: 'item clearfix',

  template: templates.li.folder,

  initialize: function(options) {
    this.model = options.model;
    this.repo = options.repo;
    this.branch = options.branch;

    this.$el.attr('data-index', options.index);
    this.$el.attr('data-navigate', '#' + this.repo.get('owner').login + '/' +
      this.repo.get('name') + '/tree/' + this.branch + '/' +
      this.model.get('path'));
  },

  render: function() {
    var data = _.extend(this.model.attributes, {
      branch: this.branch,
      repo: this.repo.attributes
    });

    var rooturl = this.model.collection.config &&
      this.model.collection.config.rooturl;
    var regex = new RegExp('^' + rooturl + '(.*)');
    var jailpath = rooturl ? data.path.match(regex) : false;

    data.jailpath = jailpath ? jailpath[1] : data.path;

    this.$el.empty().append(_.template(this.template, data, {
      variable: 'folder'
    }));

    return this;
  }
});

},{"../../../dist/templates":14,"backbone":12,"underscore":13,"jquery-browserify":11}],72:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (null !== type.loader && 'string' !== type.loader.kind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":70,"./exception":78,"./type":71}],71:[function(require,module,exports){
'use strict';


var YAMLException = require('./exception');


// TODO: Add tag format check.
function Type(tag, options) {
  options = options || {};

  this.tag    = tag;
  this.loader = options['loader'] || null;
  this.dumper = options['dumper'] || null;

  if (null === this.loader && null === this.dumper) {
    throw new YAMLException('Incomplete YAML type definition. "loader" or "dumper" setting must be specified.');
  }

  if (null !== this.loader) {
    this.loader = new Type.Loader(this.loader);
  }

  if (null !== this.dumper) {
    this.dumper = new Type.Dumper(this.dumper);
  }
}


Type.Loader = function TypeLoader(options) {
  options = options || {};

  this.kind     = options['kind']     || null;
  this.resolver = options['resolver'] || null;

  if ('string' !== this.kind &&
      'array'  !== this.kind &&
      'object' !== this.kind) {
    throw new YAMLException('Unacceptable "kind" setting of a type loader.');
  }
};


function compileAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}


Type.Dumper = function TypeDumper(options) {
  options = options || {};

  this.kind         = options['kind']         || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.representer  = options['representer']  || null;
  this.styleAliases = compileAliases(options['styleAliases'] || null);

  if ('undefined' !== this.kind &&
      'null'      !== this.kind &&
      'boolean'   !== this.kind &&
      'integer'   !== this.kind &&
      'float'     !== this.kind &&
      'string'    !== this.kind &&
      'array'     !== this.kind &&
      'object'    !== this.kind &&
      'function'  !== this.kind) {
    throw new YAMLException('Unacceptable "kind" setting of a type dumper.');
  }
};


module.exports = Type;

},{"./exception":78}],79:[function(require,module,exports){
'use strict';


var fs     = require('fs');
var loader = require('./loader');


function yamlRequireHandler(module, filename) {
  var content = fs.readFileSync(filename, 'utf8');

  // fill in documents
  module.exports = loader.safeLoad(content, { filename: filename });
}

// register require extensions only if we're on node.js
// hack for browserify
if (undefined !== require.extensions) {
  require.extensions['.yml']  = yamlRequireHandler;
  require.extensions['.yaml'] = yamlRequireHandler;
}


module.exports = require;

},{"fs":81,"./loader":68}],68:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var NIL                 = common.NIL;
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var KIND_STRING = 'string';
var KIND_ARRAY  = 'array';
var KIND_OBJECT = 'object';


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var CHAR_TAB                  = 0x09;   /* Tab */
var CHAR_LINE_FEED            = 0x0A;   /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D;   /* CR */
var CHAR_SPACE                = 0x20;   /* Space */
var CHAR_EXCLAMATION          = 0x21;   /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22;   /* " */
var CHAR_SHARP                = 0x23;   /* # */
var CHAR_PERCENT              = 0x25;   /* % */
var CHAR_AMPERSAND            = 0x26;   /* & */
var CHAR_SINGLE_QUOTE         = 0x27;   /* ' */
var CHAR_ASTERISK             = 0x2A;   /* * */
var CHAR_PLUS                 = 0x2B;   /* + */
var CHAR_COMMA                = 0x2C;   /* , */
var CHAR_MINUS                = 0x2D;   /* - */
var CHAR_DOT                  = 0x2E;   /* . */
var CHAR_SLASH                = 0x2F;   /* / */
var CHAR_DIGIT_ZERO           = 0x30;   /* 0 */
var CHAR_DIGIT_ONE            = 0x31;   /* 1 */
var CHAR_DIGIT_NINE           = 0x39;   /* 9 */
var CHAR_COLON                = 0x3A;   /* : */
var CHAR_LESS_THAN            = 0x3C;   /* < */
var CHAR_GREATER_THAN         = 0x3E;   /* > */
var CHAR_QUESTION             = 0x3F;   /* ? */
var CHAR_COMMERCIAL_AT        = 0x40;   /* @ */
var CHAR_CAPITAL_A            = 0x41;   /* A */
var CHAR_CAPITAL_F            = 0x46;   /* F */
var CHAR_CAPITAL_L            = 0x4C;   /* L */
var CHAR_CAPITAL_N            = 0x4E;   /* N */
var CHAR_CAPITAL_P            = 0x50;   /* P */
var CHAR_CAPITAL_U            = 0x55;   /* U */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B;   /* [ */
var CHAR_BACKSLASH            = 0x5C;   /* \ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;   /* ] */
var CHAR_UNDERSCORE           = 0x5F;   /* _ */
var CHAR_GRAVE_ACCENT         = 0x60;   /* ` */
var CHAR_SMALL_A              = 0x61;   /* a */
var CHAR_SMALL_B              = 0x62;   /* b */
var CHAR_SMALL_E              = 0x65;   /* e */
var CHAR_SMALL_F              = 0x66;   /* f */
var CHAR_SMALL_N              = 0x6E;   /* n */
var CHAR_SMALL_R              = 0x72;   /* r */
var CHAR_SMALL_T              = 0x74;   /* t */
var CHAR_SMALL_U              = 0x75;   /* u */
var CHAR_SMALL_V              = 0x76;   /* v */
var CHAR_SMALL_X              = 0x78;   /* x */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B;   /* { */
var CHAR_VERTICAL_LINE        = 0x7C;   /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D;   /* } */


var SIMPLE_ESCAPE_SEQUENCES = {};

SIMPLE_ESCAPE_SEQUENCES[CHAR_DIGIT_ZERO]   = '\x00';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_A]      = '\x07';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_B]      = '\x08';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_T]      = '\x09';
SIMPLE_ESCAPE_SEQUENCES[CHAR_TAB]          = '\x09';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_N]      = '\x0A';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_V]      = '\x0B';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_F]      = '\x0C';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_R]      = '\x0D';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SMALL_E]      = '\x1B';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SPACE]        = ' ';
SIMPLE_ESCAPE_SEQUENCES[CHAR_DOUBLE_QUOTE] = '\x22';
SIMPLE_ESCAPE_SEQUENCES[CHAR_SLASH]        = '/';
SIMPLE_ESCAPE_SEQUENCES[CHAR_BACKSLASH]    = '\x5C';
SIMPLE_ESCAPE_SEQUENCES[CHAR_CAPITAL_N]    = '\x85';
SIMPLE_ESCAPE_SEQUENCES[CHAR_UNDERSCORE]   = '\xA0';
SIMPLE_ESCAPE_SEQUENCES[CHAR_CAPITAL_L]    = '\u2028';
SIMPLE_ESCAPE_SEQUENCES[CHAR_CAPITAL_P]    = '\u2029';


var HEXADECIMAL_ESCAPE_SEQUENCES = {};

HEXADECIMAL_ESCAPE_SEQUENCES[CHAR_SMALL_X]   = 2;
HEXADECIMAL_ESCAPE_SEQUENCES[CHAR_SMALL_U]   = 4;
HEXADECIMAL_ESCAPE_SEQUENCES[CHAR_CAPITAL_U] = 8;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function loadAll(input, output, options) {
  options = options || {};

  var filename = options['filename'] || null,
      schema   = options['schema']   || DEFAULT_FULL_SCHEMA,
      resolve  = options['resolve']  || true,
      validate = options['validate'] || true,
      strict   = options['strict']   || false,
      legacy   = options['legacy']   || false,

      directiveHandlers = {},
      implicitTypes     = schema.compiledImplicit,
      typeMap           = schema.compiledTypeMap,

      length     = input.length,
      position   = 0,
      line       = 0,
      lineStart  = 0,
      lineIndent = 0,
      character  = input.charCodeAt(position),

      version,
      checkLineBreaks,
      tagMap,
      anchorMap,
      tag,
      anchor,
      kind,
      result;

  function generateError(message) {
    return new YAMLException(
      message,
      new Mark(filename, input, position, line, (position - lineStart)));
  }

  function throwError(message) {
    throw generateError(message);
  }

  function throwWarning(message) {
    var error = generateError(message);

    if (strict) {
      throw error;
    } else {
      console.warn(error.toString());
    }
  }

  directiveHandlers['YAML'] = function handleYamlDirective(name, args) {
    var match, major, minor;

    if (null !== version) {
      throwError('duplication of %YAML directive');
    }

    if (1 !== args.length) {
      throwError('YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (null === match) {
      throwError('ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (1 !== major) {
      throwError('unacceptable YAML version of the document');
    }

    version = args[0];
    checkLineBreaks = (minor < 2);

    if (1 !== minor && 2 !== minor) {
      throwWarning('unsupported YAML version of the document');
    }
  };

  directiveHandlers['TAG'] = function handleTagDirective(name, args) {
    var handle, prefix;

    if (2 !== args.length) {
      throwError('TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError('ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(tagMap, handle)) {
      throwError('there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError('ill-formed tag prefix (second argument) of the TAG directive');
    }

    tagMap[handle] = prefix;
  };

  function captureSegment(start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = input.slice(start, end);

      if (checkJson && validate) {
        for (_position = 0, _length = _result.length;
             _position < _length;
             _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(0x09 === _character ||
                0x20 <= _character && _character <= 0x10FFFF)) {
            throwError('expected valid JSON character');
          }
        }
      }

      result += _result;
    }
  }

  function mergeMappings(destination, source) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError('cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
      }
    }
  }

  function storeMappingPair(_result, keyTag, keyNode, valueNode) {
    var index, quantity;

    keyNode = String(keyNode);

    if (null === _result) {
      _result = {};
    }

    if ('tag:yaml.org,2002:merge' === keyTag) {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(_result, valueNode[index]);
        }
      } else {
        mergeMappings(_result, valueNode);
      }
    } else {
      _result[keyNode] = valueNode;
    }

    return _result;
  }

  function readLineBreak() {
    if (CHAR_LINE_FEED === character) {
      position += 1;
    } else if (CHAR_CARRIAGE_RETURN === character) {
      if (CHAR_LINE_FEED === input.charCodeAt(position + 1)) {
        position += 2;
      } else {
        position += 1;
      }
    } else {
      throwError('a line break is expected');
    }

    line += 1;
    lineStart = position;
    character = input.charCodeAt(position);
  }

  function skipSeparationSpace(allowComments, checkIndent) {
    var lineBreaks = 0;

    while (position < length) {
      while (CHAR_SPACE === character || CHAR_TAB === character) {
        character = input.charCodeAt(++position);
      }

      if (allowComments && CHAR_SHARP === character) {
        do { character = input.charCodeAt(++position); }
        while (position < length &&
               CHAR_LINE_FEED !== character &&
               CHAR_CARRIAGE_RETURN !== character);
      }

      if (CHAR_LINE_FEED === character || CHAR_CARRIAGE_RETURN === character) {
        readLineBreak();
        lineBreaks += 1;
        lineIndent = 0;

        while (CHAR_SPACE === character) {
          lineIndent += 1;
          character = input.charCodeAt(++position);
        }

        if (lineIndent < checkIndent) {
          throwWarning('deficient indentation');
        }
      } else {
        break;
      }
    }

    return lineBreaks;
  }

  function testDocumentSeparator() {
    var _position, _character;

    if (position === lineStart &&
        (CHAR_MINUS === character || CHAR_DOT === character) &&
        input.charCodeAt(position + 1) === character &&
        input.charCodeAt(position + 2) === character) {

      _position = position + 3;
      _character = input.charCodeAt(_position);

      if (_position >= length ||
          CHAR_SPACE           === _character ||
          CHAR_TAB             === _character ||
          CHAR_LINE_FEED       === _character ||
          CHAR_CARRIAGE_RETURN === _character) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(count) {
    if (1 === count) {
      result += ' ';
    } else if (count > 1) {
      result += common.repeat('\n', count - 1);
    }
  }

  function readPlainScalar(nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = kind,
        _result = result;

    if (CHAR_SPACE                === character ||
        CHAR_TAB                  === character ||
        CHAR_LINE_FEED            === character ||
        CHAR_CARRIAGE_RETURN      === character ||
        CHAR_COMMA                === character ||
        CHAR_LEFT_SQUARE_BRACKET  === character ||
        CHAR_RIGHT_SQUARE_BRACKET === character ||
        CHAR_LEFT_CURLY_BRACKET   === character ||
        CHAR_RIGHT_CURLY_BRACKET  === character ||
        CHAR_SHARP                === character ||
        CHAR_AMPERSAND            === character ||
        CHAR_ASTERISK             === character ||
        CHAR_EXCLAMATION          === character ||
        CHAR_VERTICAL_LINE        === character ||
        CHAR_GREATER_THAN         === character ||
        CHAR_SINGLE_QUOTE         === character ||
        CHAR_DOUBLE_QUOTE         === character ||
        CHAR_PERCENT              === character ||
        CHAR_COMMERCIAL_AT        === character ||
        CHAR_GRAVE_ACCENT         === character) {
      return false;
    }

    if (CHAR_QUESTION === character ||
        CHAR_MINUS === character) {
      following = input.charCodeAt(position + 1);

      if (CHAR_SPACE                 === following ||
          CHAR_TAB                   === following ||
          CHAR_LINE_FEED             === following ||
          CHAR_CARRIAGE_RETURN       === following ||
          withinFlowCollection &&
          (CHAR_COMMA                === following ||
           CHAR_LEFT_SQUARE_BRACKET  === following ||
           CHAR_RIGHT_SQUARE_BRACKET === following ||
           CHAR_LEFT_CURLY_BRACKET   === following ||
           CHAR_RIGHT_CURLY_BRACKET  === following)) {
        return false;
      }
    }

    kind = KIND_STRING;
    result = '';
    captureStart = captureEnd = position;
    hasPendingContent = false;

    while (position < length) {
      if (CHAR_COLON === character) {
        following = input.charCodeAt(position + 1);

        if (CHAR_SPACE                 === following ||
            CHAR_TAB                   === following ||
            CHAR_LINE_FEED             === following ||
            CHAR_CARRIAGE_RETURN       === following ||
            withinFlowCollection &&
            (CHAR_COMMA                === following ||
             CHAR_LEFT_SQUARE_BRACKET  === following ||
             CHAR_RIGHT_SQUARE_BRACKET === following ||
             CHAR_LEFT_CURLY_BRACKET   === following ||
             CHAR_RIGHT_CURLY_BRACKET  === following)) {
          break;
        }

      } else if (CHAR_SHARP === character) {
        preceding = input.charCodeAt(position - 1);

        if (CHAR_SPACE           === preceding ||
            CHAR_TAB             === preceding ||
            CHAR_LINE_FEED       === preceding ||
            CHAR_CARRIAGE_RETURN === preceding) {
          break;
        }

      } else if ((position === lineStart && testDocumentSeparator()) ||
                 withinFlowCollection &&
                 (CHAR_COMMA                === character ||
                  CHAR_LEFT_SQUARE_BRACKET  === character ||
                  CHAR_RIGHT_SQUARE_BRACKET === character ||
                  CHAR_LEFT_CURLY_BRACKET   === character ||
                  CHAR_RIGHT_CURLY_BRACKET  === character)) {
        break;

      } else if (CHAR_LINE_FEED === character ||
                 CHAR_CARRIAGE_RETURN === character) {
        _line = line;
        _lineStart = lineStart;
        _lineIndent = lineIndent;
        skipSeparationSpace(false, -1);

        if (lineIndent >= nodeIndent) {
          hasPendingContent = true;
          continue;
        } else {
          position = captureEnd;
          line = _line;
          lineStart = _lineStart;
          lineIndent = _lineIndent;
          character = input.charCodeAt(position);
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(captureStart, captureEnd, false);
        writeFoldedLines(line - _line);
        captureStart = captureEnd = position;
        hasPendingContent = false;
      }

      if (CHAR_SPACE !== character && CHAR_TAB !== character) {
        captureEnd = position + 1;
      }

      character = input.charCodeAt(++position);
    }

    captureSegment(captureStart, captureEnd, false);

    if (result) {
      return true;
    } else {
      kind = _kind;
      result = _result;
      return false;
    }
  }

  function readSingleQuotedScalar(nodeIndent) {
    var captureStart, captureEnd;

    if (CHAR_SINGLE_QUOTE !== character) {
      return false;
    }

    kind = KIND_STRING;
    result = '';
    character = input.charCodeAt(++position);
    captureStart = captureEnd = position;

    while (position < length) {
      if (CHAR_SINGLE_QUOTE === character) {
        captureSegment(captureStart, position, true);
        character = input.charCodeAt(++position);

        if (CHAR_SINGLE_QUOTE === character) {
          captureStart = captureEnd = position;
          character = input.charCodeAt(++position);
        } else {
          return true;
        }

      } else if (CHAR_LINE_FEED === character ||
                 CHAR_CARRIAGE_RETURN === character) {
        captureSegment(captureStart, captureEnd, true);
        writeFoldedLines(skipSeparationSpace(false, nodeIndent));
        captureStart = captureEnd = position;
        character = input.charCodeAt(position);

      } else if (position === lineStart && testDocumentSeparator()) {
        throwError('unexpected end of the document within a single quoted scalar');

      } else {
        character = input.charCodeAt(++position);
        captureEnd = position;
      }
    }

    throwError('unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexIndex,
        hexOffset,
        hexResult;

    if (CHAR_DOUBLE_QUOTE !== character) {
      return false;
    }

    kind = KIND_STRING;
    result = '';
    character = input.charCodeAt(++position);
    captureStart = captureEnd = position;

    while (position < length) {
      if (CHAR_DOUBLE_QUOTE === character) {
        captureSegment(captureStart, position, true);
        character = input.charCodeAt(++position);
        return true;

      } else if (CHAR_BACKSLASH === character) {
        captureSegment(captureStart, position, true);
        character = input.charCodeAt(++position);

        if (CHAR_LINE_FEED       === character ||
            CHAR_CARRIAGE_RETURN === character) {
          skipSeparationSpace(false, nodeIndent);

        } else if (SIMPLE_ESCAPE_SEQUENCES[character]) {
          result += SIMPLE_ESCAPE_SEQUENCES[character];
          character = input.charCodeAt(++position);

        } else if (HEXADECIMAL_ESCAPE_SEQUENCES[character]) {
          hexLength = HEXADECIMAL_ESCAPE_SEQUENCES[character];
          hexResult = 0;

          for (hexIndex = 1; hexIndex <= hexLength; hexIndex += 1) {
            hexOffset = (hexLength - hexIndex) * 4;
            character = input.charCodeAt(++position);

            if (CHAR_DIGIT_ZERO <= character && character <= CHAR_DIGIT_NINE) {
              hexResult |= (character - CHAR_DIGIT_ZERO) << hexOffset;

            } else if (CHAR_CAPITAL_A <= character && character <= CHAR_CAPITAL_F) {
              hexResult |= (character - CHAR_CAPITAL_A + 10) << hexOffset;

            } else if (CHAR_SMALL_A <= character && character <= CHAR_SMALL_F) {
              hexResult |= (character - CHAR_SMALL_A + 10) << hexOffset;

            } else {
              throwError('expected hexadecimal character');
            }
          }

          result += String.fromCharCode(hexResult);
          character = input.charCodeAt(++position);

        } else {
          throwError('unknown escape sequence');
        }

        captureStart = captureEnd = position;

      } else if (CHAR_LINE_FEED === character ||
                 CHAR_CARRIAGE_RETURN === character) {
        captureSegment(captureStart, captureEnd, true);
        writeFoldedLines(skipSeparationSpace(false, nodeIndent));
        captureStart = captureEnd = position;
        character = input.charCodeAt(position);

      } else if (position === lineStart && testDocumentSeparator()) {
        throwError('unexpected end of the document within a double quoted scalar');

      } else {
        character = input.charCodeAt(++position);
        captureEnd = position;
      }
    }

    throwError('unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(nodeIndent) {
    var readNext = true,
        _line,
        _tag     = tag,
        _result,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        keyNode,
        keyTag,
        valueNode;

    switch (character) {
    case CHAR_LEFT_SQUARE_BRACKET:
      terminator = CHAR_RIGHT_SQUARE_BRACKET;
      isMapping = false;
      _result = [];
      break;

    case CHAR_LEFT_CURLY_BRACKET:
      terminator = CHAR_RIGHT_CURLY_BRACKET;
      isMapping = true;
      _result = {};
      break;

    default:
      return false;
    }

    if (null !== anchor) {
      anchorMap[anchor] = _result;
    }

    character = input.charCodeAt(++position);

    while (position < length) {
      skipSeparationSpace(true, nodeIndent);

      if (character === terminator) {
        character = input.charCodeAt(++position);
        tag = _tag;
        kind = isMapping ? KIND_OBJECT : KIND_ARRAY;
        result = _result;
        return true;
      } else if (!readNext) {
        throwError('missed comma between flow collection entries');
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (CHAR_QUESTION === character) {
        following = input.charCodeAt(position + 1);

        if (CHAR_SPACE === following ||
            CHAR_TAB === following ||
            CHAR_LINE_FEED === following ||
            CHAR_CARRIAGE_RETURN === following) {
          isPair = isExplicitPair = true;
          position += 1;
          character = following;
          skipSeparationSpace(true, nodeIndent);
        }
      }

      _line = line;
      composeNode(nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = tag;
      keyNode = result;

      if ((isExplicitPair || line === _line) && CHAR_COLON === character) {
        isPair = true;
        character = input.charCodeAt(++position);
        skipSeparationSpace(true, nodeIndent);
        composeNode(nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = result;
      }

      if (isMapping) {
        storeMappingPair(_result, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(null, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(true, nodeIndent);

      if (CHAR_COMMA === character) {
        readNext = true;
        character = input.charCodeAt(++position);
      } else {
        readNext = false;
      }
    }

    throwError('unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = -1;

    switch (character) {
    case CHAR_VERTICAL_LINE:
      folding = false;
      break;

    case CHAR_GREATER_THAN:
      folding = true;
      break;

    default:
      return false;
    }

    kind = KIND_STRING;
    result = '';

    while (position < length) {
      character = input.charCodeAt(++position);

      if (CHAR_PLUS === character || CHAR_MINUS === character) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (CHAR_PLUS === character) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError('repeat of a chomping mode identifier');
        }

      } else if (CHAR_DIGIT_ZERO <= character && character <= CHAR_DIGIT_NINE) {
        if (CHAR_DIGIT_ZERO === character) {
          throwError('bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + (character - CHAR_DIGIT_ONE);
          detectedIndent = true;
        } else {
          throwError('repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (CHAR_SPACE === character || CHAR_TAB === character) {
      do { character = input.charCodeAt(++position); }
      while (CHAR_SPACE === character || CHAR_TAB === character);

      if (CHAR_SHARP === character) {
        do { character = input.charCodeAt(++position); }
        while (position < length &&
               CHAR_LINE_FEED !== character &&
               CHAR_CARRIAGE_RETURN !== character);
      }
    }

    while (position < length) {
      readLineBreak();
      lineIndent = 0;

      while ((!detectedIndent || lineIndent < textIndent) &&
             (CHAR_SPACE === character)) {
        lineIndent += 1;
        character = input.charCodeAt(++position);
      }

      if (!detectedIndent && lineIndent > textIndent) {
        textIndent = lineIndent;
      }

      if (CHAR_LINE_FEED === character || CHAR_CARRIAGE_RETURN === character) {
        emptyLines += 1;
        continue;
      }

      // End of the scalar. Perform the chomping.
      if (lineIndent < textIndent) {
        if (CHOMPING_KEEP === chomping) {
          result += common.repeat('\n', emptyLines + 1);
        } else if (CHOMPING_CLIP === chomping) {
          result += '\n';
        }
        break;
      }

      detectedIndent = true;

      if (folding) {
        if (CHAR_SPACE === character || CHAR_TAB === character) {
          result += common.repeat('\n', emptyLines + 1);
          emptyLines = 1;
        } else if (0 === emptyLines) {
          result += ' ';
          emptyLines = 0;
        } else {
          result += common.repeat('\n', emptyLines);
          emptyLines = 0;
        }
      } else {
        result += common.repeat('\n', emptyLines + 1);
        emptyLines = 0;
      }

      captureStart = position;

      do { character = input.charCodeAt(++position); }
      while (position < length &&
             CHAR_LINE_FEED !== character &&
             CHAR_CARRIAGE_RETURN !== character);

      captureSegment(captureStart, position, false);
    }

    return true;
  }

  function readBlockSequence(nodeIndent) {
    var _line,
        _tag      = tag,
        _result   = [],
        following,
        detected  = false;

    if (null !== anchor) {
      anchorMap[anchor] = _result;
    }

    while (position < length) {
      if (CHAR_MINUS !== character) {
        break;
      }

      following = input.charCodeAt(position + 1);

      if (CHAR_SPACE           !== following &&
          CHAR_TAB             !== following &&
          CHAR_LINE_FEED       !== following &&
          CHAR_CARRIAGE_RETURN !== following) {
        break;
      }

      detected = true;
      position += 1;
      character = following;

      if (skipSeparationSpace(true, -1)) {
        if (lineIndent <= nodeIndent) {
          _result.push(null);
          continue;
        }
      }

      _line = line;
      composeNode(nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(result);
      skipSeparationSpace(true, -1);

      if ((line === _line || lineIndent > nodeIndent) && position < length) {
        throwError('bad indentation of a sequence entry');
      } else if (lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      tag = _tag;
      kind = KIND_ARRAY;
      result = _result;
      return true;
    } else {
      return false;
    }
  }

  function readBlockMapping(nodeIndent) {
    var following,
        allowCompact,
        _line,
        _tag          = tag,
        _result       = {},
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false;

    if (null !== anchor) {
      anchorMap[anchor] = _result;
    }

    while (position < length) {
      following = input.charCodeAt(position + 1);
      _line = line; // Save the current line.

      if ((CHAR_QUESTION        === character ||
           CHAR_COLON           === character) &&
          (CHAR_SPACE           === following ||
           CHAR_TAB             === following ||
           CHAR_LINE_FEED       === following ||
           CHAR_CARRIAGE_RETURN === following)) {

        if (CHAR_QUESTION === character) {
          if (atExplicitKey) {
            storeMappingPair(_result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. CHAR_COLON === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError('incomplete explicit mapping pair; a key node is missed');
        }

        position += 1;
        character = following;

      } else if (composeNode(nodeIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (line === _line) {
          // TODO: Remove this cycle when the flow readers will consume
          // trailing whitespaces like the block readers.
          while (CHAR_SPACE === character ||
                 CHAR_TAB === character) {
            character = input.charCodeAt(++position);
          }

          if (CHAR_COLON === character) {
            character = input.charCodeAt(++position);

            if (CHAR_SPACE           !== character &&
                CHAR_TAB             !== character &&
                CHAR_LINE_FEED       !== character &&
                CHAR_CARRIAGE_RETURN !== character) {
              throwError('a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(_result, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = tag;
            keyNode = result;

          } else if (detected) {
            throwError('can not read an implicit mapping pair; a colon is missed');

          } else {
            tag = _tag;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError('can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          tag = _tag;
          return true; // Keep the result of `composeNode`.
        }

      } else {
        break;
      }

      if (line === _line || lineIndent > nodeIndent) {
        if (composeNode(nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = result;
          } else {
            valueNode = result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(_result, keyTag, keyNode, valueNode);
          keyTag = keyNode = valueNode = null;
        }

        // TODO: It is needed only for flow node readers. It should be removed
        // when the flow readers will consume trailing whitespaces as well as
        // the block readers.
        skipSeparationSpace(true, -1);
      }

      if (lineIndent > nodeIndent && position < length) {
        throwError('bad indentation of a mapping entry');
      } else if (lineIndent < nodeIndent) {
        break;
      }
    }

    if (atExplicitKey) {
      storeMappingPair(_result, keyTag, keyNode, null);
    }

    if (detected) {
      tag = _tag;
      kind = KIND_OBJECT;
      result = _result;
    }

    return detected;
  }

  function readTagProperty() {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName;

    if (CHAR_EXCLAMATION !== character) {
      return false;
    }

    if (null !== tag) {
      throwError('duplication of a tag property');
    }

    character = input.charCodeAt(++position);

    if (CHAR_LESS_THAN === character) {
      isVerbatim = true;
      character = input.charCodeAt(++position);

    } else if (CHAR_EXCLAMATION === character) {
      isNamed = true;
      tagHandle = '!!';
      character = input.charCodeAt(++position);

    } else {
      tagHandle = '!';
    }

    _position = position;

    if (isVerbatim) {
      do { character = input.charCodeAt(++position); }
      while (position < length && CHAR_GREATER_THAN !== character);

      if (position < length) {
        tagName = input.slice(_position, position);
        character = input.charCodeAt(++position);
      } else {
        throwError('unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (position < length &&
             CHAR_SPACE           !== character &&
             CHAR_TAB             !== character &&
             CHAR_LINE_FEED       !== character &&
             CHAR_CARRIAGE_RETURN !== character) {

        if (CHAR_EXCLAMATION === character) {
          if (!isNamed) {
            tagHandle = input.slice(_position - 1, position + 1);

            if (validate && !PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError('named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = position + 1;
          } else {
            throwError('tag suffix cannot contain exclamation marks');
          }
        }

        character = input.charCodeAt(++position);
      }

      tagName = input.slice(_position, position);

      if (validate && PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError('tag suffix cannot contain flow indicator characters');
      }
    }

    if (validate && tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError('tag name cannot contain such characters: ' + tagName);
    }

    if (isVerbatim) {
      tag = tagName;

    } else if (_hasOwnProperty.call(tagMap, tagHandle)) {
      tag = tagMap[tagHandle] + tagName;

    } else if ('!' === tagHandle) {
      tag = '!' + tagName;

    } else if ('!!' === tagHandle) {
      tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError('undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty() {
    var _position;

    if (CHAR_AMPERSAND !== character) {
      return false;
    }

    if (null !== anchor) {
      throwError('duplication of an anchor property');
    }

    character = input.charCodeAt(++position);
    _position = position;

    while (position < length &&
           CHAR_SPACE                !== character &&
           CHAR_TAB                  !== character &&
           CHAR_LINE_FEED            !== character &&
           CHAR_CARRIAGE_RETURN      !== character &&
           CHAR_COMMA                !== character &&
           CHAR_LEFT_SQUARE_BRACKET  !== character &&
           CHAR_RIGHT_SQUARE_BRACKET !== character &&
           CHAR_LEFT_CURLY_BRACKET   !== character &&
           CHAR_RIGHT_CURLY_BRACKET  !== character) {
      character = input.charCodeAt(++position);
    }

    if (position === _position) {
      throwError('name of an anchor node must contain at least one character');
    }

    anchor = input.slice(_position, position);
    return true;
  }

  function readAlias() {
    var _position, alias;

    if (CHAR_ASTERISK !== character) {
      return false;
    }

    character = input.charCodeAt(++position);
    _position = position;

    while (position < length &&
           CHAR_SPACE                !== character &&
           CHAR_TAB                  !== character &&
           CHAR_LINE_FEED            !== character &&
           CHAR_CARRIAGE_RETURN      !== character &&
           CHAR_COMMA                !== character &&
           CHAR_LEFT_SQUARE_BRACKET  !== character &&
           CHAR_RIGHT_SQUARE_BRACKET !== character &&
           CHAR_LEFT_CURLY_BRACKET   !== character &&
           CHAR_RIGHT_CURLY_BRACKET  !== character) {
      character = input.charCodeAt(++position);
    }

    if (position === _position) {
      throwError('name of an alias node must contain at least one character');
    }

    alias = input.slice(_position, position);

    if (!anchorMap.hasOwnProperty(alias)) {
      throwError('unidentified alias "' + alias + '"');
    }

    result = anchorMap[alias];
    skipSeparationSpace(true, -1);
    return true;
  }

  function composeNode(parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        atNewLine  = false,
        isIndented = true,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        typeLoader,
        flowIndent,
        blockIndent,
        _result;

    tag    = null;
    anchor = null;
    kind   = null;
    result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(true, -1)) {
        atNewLine = true;

        if (lineIndent === parentIndent) {
          isIndented = false;

        } else if (lineIndent > parentIndent) {
          isIndented = true;

        } else {
          return false;
        }
      }
    }

    if (isIndented) {
      while (readTagProperty() || readAnchorProperty()) {
        if (skipSeparationSpace(true, -1)) {
          atNewLine = true;

          if (lineIndent > parentIndent) {
            isIndented = true;
            allowBlockCollections = allowBlockStyles;

          } else if (lineIndent === parentIndent) {
            isIndented = false;
            allowBlockCollections = allowBlockStyles;

          } else {
            return true;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (isIndented || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = position - lineStart;

      if (isIndented) {
        if (allowBlockCollections &&
            (readBlockSequence(blockIndent) ||
             readBlockMapping(blockIndent)) ||
            readFlowCollection(flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(flowIndent)) ||
              readSingleQuotedScalar(flowIndent) ||
              readDoubleQuotedScalar(flowIndent)) {
            hasContent = true;

          } else if (readAlias()) {
            hasContent = true;

            if (null !== tag || null !== anchor) {
              throwError('alias node should not have any properties');
            }

          } else if (readPlainScalar(flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (null === tag) {
              tag = '?';
            }
          }

          if (null !== anchor) {
            anchorMap[anchor] = result;
          }
        }
      } else {
        hasContent = allowBlockCollections && readBlockSequence(blockIndent);
      }
    }

    if (null !== tag && '!' !== tag) {
      if ('?' === tag) {
        if (resolve) {
          for (typeIndex = 0, typeQuantity = implicitTypes.length;
               typeIndex < typeQuantity;
               typeIndex += 1) {
            type = implicitTypes[typeIndex];

            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only assigned to plain scalars. So, it isn't
            // needed to check for 'kind' conformity.
            _result = type.loader.resolver(result, false);

            if (NIL !== _result) {
              tag = type.tag;
              result = _result;
              break;
            }
          }
        }
      } else if (_hasOwnProperty.call(typeMap, tag)) {
        typeLoader = typeMap[tag].loader;

        if (null !== result && typeLoader.kind !== kind) {
          throwError('unacceptable node kind for !<' + tag + '> tag; it should be "' + typeLoader.kind + '", not "' + kind + '"');
        }

        if (typeLoader.resolver) {
          _result = typeLoader.resolver(result, true);

          if (NIL !== _result) {
            result = _result;
          } else {
            throwError('cannot resolve a node with !<' + tag + '> explicit tag');
          }
        }
      } else {
        throwWarning('unknown tag !<' + tag + '>');
      }
    }

    return null !== tag || null !== anchor || hasContent;
  }

  function readDocument() {
    var documentStart = position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false;

    version = null;
    checkLineBreaks = legacy;
    tagMap = {};
    anchorMap = {};

    while (position < length) {
      skipSeparationSpace(true, -1);

      if (lineIndent > 0 || CHAR_PERCENT !== character) {
        break;
      }

      hasDirectives = true;
      character = input.charCodeAt(++position);
      _position = position;

      while (position < length &&
             CHAR_SPACE           !== character &&
             CHAR_TAB             !== character &&
             CHAR_LINE_FEED       !== character &&
             CHAR_CARRIAGE_RETURN !== character) {
        character = input.charCodeAt(++position);
      }

      directiveName = input.slice(_position, position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError('directive name must not be less than one character in length');
      }

      while (position < length) {
        while (CHAR_SPACE === character || CHAR_TAB === character) {
          character = input.charCodeAt(++position);
        }

        if (CHAR_SHARP === character) {
          do { character = input.charCodeAt(++position); }
          while (position < length &&
                 CHAR_LINE_FEED !== character &&
                 CHAR_CARRIAGE_RETURN !== character);
          break;
        }

        if (CHAR_LINE_FEED === character || CHAR_CARRIAGE_RETURN === character) {
          break;
        }

        _position = position;

        while (position < length &&
               CHAR_SPACE           !== character &&
               CHAR_TAB             !== character &&
               CHAR_LINE_FEED       !== character &&
               CHAR_CARRIAGE_RETURN !== character) {
          character = input.charCodeAt(++position);
        }

        directiveArgs.push(input.slice(_position, position));
      }

      if (position < length) {
        readLineBreak();
      }

      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](directiveName, directiveArgs);
      } else {
        throwWarning('unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(true, -1);

    if (0 === lineIndent &&
        CHAR_MINUS === character &&
        CHAR_MINUS === input.charCodeAt(position + 1) &&
        CHAR_MINUS === input.charCodeAt(position + 2)) {
      position += 3;
      character = input.charCodeAt(position);
      skipSeparationSpace(true, -1);

    } else if (hasDirectives) {
      throwError('directives end mark is expected');
    }

    composeNode(lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(true, -1);

    if (validate && checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(input.slice(documentStart, position))) {
      throwWarning('non-ASCII line breaks are interpreted as content');
    }

    output(result);

    if (position === lineStart && testDocumentSeparator()) {
      if (CHAR_DOT === character) {
        position += 3;
        character = input.charCodeAt(position);
        skipSeparationSpace(true, -1);
      }
      return;
    }

    if (position < length) {
      throwError('end of the stream or a document separator is expected');
    } else {
      return;
    }
  }

  if (validate && PATTERN_NON_PRINTABLE.test(input)) {
    throwError('the stream contains non-printable characters');
  }

  while (CHAR_SPACE === character) {
    lineIndent += 1;
    character = input.charCodeAt(++position);
  }

  while (position < length) {
    readDocument();
  }
}


function load(input, options) {
  var result = null, received = false;

  function callback(data) {
    if (!received) {
      result = data;
      received = true;
    } else {
      throw new YAMLException('expected a single document in the stream, but found more');
    }
  }

  loadAll(input, callback, options);

  return result;
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":70,"./mark":84,"./schema/default_safe":75,"./schema/default_full":76,"./exception":78}],69:[function(require,module,exports){
(function(){'use strict';


var common              = require('./common');
var NIL                 = common.NIL;
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


function kindOf(object) {
  var kind = typeof object;

  if (null === object) {
    return 'null';
  } else if ('number' === kind) {
    return 0 === object % 1 ? 'integer' : 'float';
  } else if ('object' === kind && Array.isArray(object)) {
    return 'array';
  } else {
    return kind;
  }
}


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && type.dumper) {
      if (_hasOwnProperty.call(type.dumper.styleAliases, style)) {
        style = type.dumper.styleAliases[style];
      }
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function dump(input, options) {
  options = options || {};

  var schema      = options['schema'] || DEFAULT_FULL_SCHEMA,
      indent      = Math.max(1, (options['indent'] || 2)),
      skipInvalid = options['skipInvalid'] || false,
      flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']),
      styleMap    = compileStyleMap(schema, options['styles'] || null),

      implicitTypes = schema.compiledImplicit,
      explicitTypes = schema.compiledExplicit,

      kind,
      tag,
      result;

  function generateNextLine(level) {
    return '\n' + common.repeat(' ', indent * level);
  }

  function testImplicitResolving(object) {
    var index, length, type;

    for (index = 0, length = implicitTypes.length; index < length; index += 1) {
      type = implicitTypes[index];

      if (null !== type.loader &&
          NIL !== type.loader.resolver(object, false)) {
        return true;
      }
    }

    return false;
  }

  function writeScalar(object) {
    var isQuoted, checkpoint, position, length, character, booleans;

    result = '';
    isQuoted = false;
    checkpoint = 0;
    booleans = /^(y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$/;

    if (0          === object.length ||
        CHAR_SPACE === object.charCodeAt(0) ||
        CHAR_SPACE === object.charCodeAt(object.length - 1)) {
      isQuoted = true;
    }

    for (position = 0, length = object.length; position < length; position += 1) {
      character = object.charCodeAt(position);

      if (!isQuoted) {
        if (CHAR_TAB                  === character ||
            CHAR_LINE_FEED            === character ||
            CHAR_CARRIAGE_RETURN      === character ||
            CHAR_COMMA                === character ||
            CHAR_LEFT_SQUARE_BRACKET  === character ||
            CHAR_RIGHT_SQUARE_BRACKET === character ||
            CHAR_LEFT_CURLY_BRACKET   === character ||
            CHAR_RIGHT_CURLY_BRACKET  === character ||
            CHAR_SHARP                === character ||
            CHAR_AMPERSAND            === character ||
            CHAR_ASTERISK             === character ||
            CHAR_EXCLAMATION          === character ||
            CHAR_VERTICAL_LINE        === character ||
            CHAR_GREATER_THAN         === character ||
            CHAR_SINGLE_QUOTE         === character ||
            CHAR_DOUBLE_QUOTE         === character ||
            CHAR_PERCENT              === character ||
            CHAR_COMMERCIAL_AT        === character ||
            CHAR_GRAVE_ACCENT         === character ||
            CHAR_QUESTION             === character ||
            CHAR_COLON                === character ||
            CHAR_MINUS                === character) {
          isQuoted = true;
        }
      }

      if (ESCAPE_SEQUENCES[character] ||
          !((0x00020 <= character && character <= 0x00007E) ||
            (0x00085 === character)                         ||
            (0x000A0 <= character && character <= 0x00D7FF) ||
            (0x0E000 <= character && character <= 0x00FFFD) ||
            (0x10000 <= character && character <= 0x10FFFF))) {
        result += object.slice(checkpoint, position);
        result += ESCAPE_SEQUENCES[character] || encodeHex(character);
        checkpoint = position + 1;
        isQuoted = true;
      }
    }

    if (checkpoint < position) {
      result += object.slice(checkpoint, position);
    }

    if (!isQuoted && testImplicitResolving(result)) {
      isQuoted = true;
    }

    if (!isQuoted && booleans.test(object)) {
      isQuoted = true;
    }

    if (isQuoted) {
      result = '"' + result + '"';
    }
  }

  function writeFlowSequence(level, object) {
    var _result = '',
        _tag    = tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(level, object[index], false, false)) {
        if (0 !== index) {
          _result += ', ';
        }
        _result += result;
      }
    }

    tag = _tag;
    result = '[' + _result + ']';
  }

  function writeBlockSequence(level, object, compact) {
    var _result = '',
        _tag    = tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(level + 1, object[index], true, true)) {
        if (!compact || 0 !== index) {
          _result += generateNextLine(level);
        }
        _result += '- ' + result;
      }
    }

    tag = _tag;
    result = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(level, object) {
    var _result       = '',
        _tag          = tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (0 !== index) {
        pairBuffer += ', ';
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (result.length > 1024) {
        pairBuffer += '? ';
      }

      pairBuffer += result + ': ';

      if (!writeNode(level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += result;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    tag = _tag;
    result = '{' + _result + '}';
  }

  function writeBlockMapping(level, object, compact) {
    var _result       = '',
        _tag          = tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || 0 !== index) {
        pairBuffer += generateNextLine(level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(level + 1, objectKey, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (null !== tag && '?' !== tag && result.length <= 1024);

      if (explicitPair) {
        pairBuffer += '? ';
      }

      pairBuffer += result;

      if (explicitPair) {
        pairBuffer += generateNextLine(level);
      }

      if (!writeNode(level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += ': ' + result;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    tag = _tag;
    result = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? explicitTypes : implicitTypes;
    kind = kindOf(object);

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((null !== type.dumper) &&
          (null === type.dumper.kind       || kind === type.dumper.kind) &&
          (null === type.dumper.instanceOf || object instanceof type.dumper.instanceOf) &&
          (null === type.dumper.predicate  || type.dumper.predicate(object))) {
        tag = explicit ? type.tag : '?';

        if (null !== type.dumper.representer) {
          style = styleMap[type.tag] || type.dumper.defaultStyle;

          if ('function' === typeof type.dumper.representer) {
            _result = type.dumper.representer(object, style);
          } else if (_hasOwnProperty.call(type.dumper.representer, style)) {
            _result = type.dumper.representer[style](object, style);
          } else {
            throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          if (NIL !== _result) {
            kind = kindOf(_result);
            result = _result;
          } else {
            if (explicit) {
              throw new YAMLException('cannot represent an object of !<' + type.tag + '> type');
            } else {
              continue;
            }
          }
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(level, object, block, compact) {
    tag = null;
    result = object;

    if (!detectType(object, false)) {
      detectType(object, true);
    }

    if (block) {
      block = (0 > flowLevel || flowLevel > level);
    }

    if ((null !== tag && '?' !== tag) || (2 !== indent && level > 0)) {
      compact = false;
    }

    if ('object' === kind) {
      if (block && (0 !== Object.keys(result).length)) {
        writeBlockMapping(level, result, compact);
      } else {
        writeFlowMapping(level, result);
      }
    } else if ('array' === kind) {
      if (block && (0 !== result.length)) {
        writeBlockSequence(level, result, compact);
      } else {
        writeFlowSequence(level, result);
      }
    } else if ('string' === kind) {
      if ('?' !== tag) {
        writeScalar(result);
      }
    } else if (skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptabe kind of an object to dump (' + kind + ')');
    }

    if (null !== tag && '?' !== tag) {
      result = '!<' + tag + '> ' + result;
    }
    return true;
  }

  if (writeNode(0, input, true, true)) {
    return result + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

})()
},{"./common":70,"./schema/default_full":76,"./schema/default_safe":75,"./exception":78}],74:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":72,"./failsafe":73,"../type/null":85,"../type/bool":86,"../type/int":87,"../type/float":88}],73:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":72,"../type/str":89,"../type/seq":90,"../type/map":91}],75:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":72,"./core":77,"../type/timestamp":92,"../type/merge":93,"../type/binary":94,"../type/omap":95,"../type/pairs":96,"../type/set":97}],76:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":72,"./default_safe":75,"../type/js/undefined":98,"../type/js/regexp":99,"../type/js/function":100}],77:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":72,"./json":74}],66:[function(require,module,exports){
(function(global){(function() {
  var $, AbstractChosen, Chosen, SelectParser, get_side_border_padding, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  AbstractChosen = (function() {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.finish_setup();
    }

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;

      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.search_contains = this.options.search_contains || false;
      this.choices = 0;
      this.single_backstroke_delete = this.options.single_backstroke_delete || false;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      return this.inherit_select_classes = this.options.inherit_select_classes || false;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || "Select Some Options";
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || "Select an Option";
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || "No results match";
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;

      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;

      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, style;

      if (!option.disabled) {
        option.dom_id = this.container_id + "_o_" + option.array_index;
        classes = option.selected && this.is_multiple ? [] : ["active-result"];
        if (option.selected) {
          classes.push("result-selected");
        }
        if (option.group_array_index != null) {
          classes.push("group-option");
        }
        if (option.classes !== "") {
          classes.push(option.classes);
        }
        style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
        return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
      } else {
        return "";
      }
    };

    AbstractChosen.prototype.results_update_field = function() {
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.result_single_selected = null;
      return this.results_build();
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;

      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.generate_field_id = function() {
      var new_id;

      new_id = this.generate_random_id();
      this.form_field.id = new_id;
      return new_id;
    };

    AbstractChosen.prototype.generate_random_char = function() {
      var chars, newchar, rand;

      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      rand = Math.floor(Math.random() * chars.length);
      return newchar = chars.substring(rand, rand + 1);
    };

    return AbstractChosen;

  })();

  $ = global.$;

  $ || ($ = require('jquery-browserify'));

  get_side_border_padding = function(elmt) {
    var side_border_padding;

    return side_border_padding = elmt.outerWidth() - elmt.width();
  };

  $.fn.extend({
    chosen: function(options) {
      var browser, match, ua;

      ua = window.navigator.userAgent.toLowerCase();
      match = /(msie) ([\w.]+)/.exec(ua) || [];
      browser = {
        name: match[1] || "",
        version: match[2] || "0"
      };
      if (browser.name === "msie" && (browser.version === "6.0" || (browser.version === "7.0" && document.documentMode === 7))) {
        return this;
      }
      return this.each(function(input_field) {
        var $this;

        $this = $(this);
        if (!$this.hasClass("chzn-done")) {
          return $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_value = this.form_field_jq.val();
      return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
    };

    Chosen.prototype.finish_setup = function() {
      return this.form_field_jq.addClass("chzn-done");
    };

    Chosen.prototype.set_up_html = function() {
      var container_classes, container_div, container_props, dd_top, dd_width, sf_width;

      this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, '_') : this.generate_field_id();
      this.container_id += "_chzn";
      container_classes = ["chzn-container"];
      container_classes.push("chzn-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chzn-rtl");
      }
      this.f_width = this.form_field_jq.outerWidth();
      container_props = {
        id: this.container_id,
        "class": container_classes.join(' '),
        style: 'width: ' + this.f_width + 'px;',
        title: this.form_field.title
      };
      container_div = $("<div />", container_props);
      if (this.is_multiple) {
        container_div.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>');
      } else {
        container_div.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
      }
      this.form_field_jq.hide().after(container_div);
      this.container = $('#' + this.container_id);
      this.dropdown = this.container.find('div.chzn-drop').first();
      dd_top = this.container.height();
      dd_width = this.f_width - get_side_border_padding(this.dropdown);
      this.dropdown.css({
        "width": dd_width + "px",
        "top": dd_top + "px"
      });
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chzn-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chzn-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chzn-search').first();
        this.selected_item = this.container.find('.chzn-single').first();
        sf_width = dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field);
        this.search_field.css({
          "width": sf_width + "px"
        });
      }
      this.results_build();
      this.set_tab_index();
      return this.form_field_jq.trigger("liszt:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;

      this.container.mousedown(function(evt) {
        return _this.container_mousedown(evt);
      });
      this.container.mouseup(function(evt) {
        return _this.container_mouseup(evt);
      });
      this.container.mouseenter(function(evt) {
        return _this.mouse_enter(evt);
      });
      this.container.mouseleave(function(evt) {
        return _this.mouse_leave(evt);
      });
      this.search_results.mouseup(function(evt) {
        return _this.search_results_mouseup(evt);
      });
      this.search_results.mouseover(function(evt) {
        return _this.search_results_mouseover(evt);
      });
      this.search_results.mouseout(function(evt) {
        return _this.search_results_mouseout(evt);
      });
      this.form_field_jq.bind("liszt:updated", function(evt) {
        return _this.results_update_field(evt);
      });
      this.form_field_jq.bind("liszt:activate", function(evt) {
        return _this.activate_field(evt);
      });
      this.form_field_jq.bind("liszt:open", function(evt) {
        return _this.container_mousedown(evt);
      });
      this.search_field.blur(function(evt) {
        return _this.input_blur(evt);
      });
      this.search_field.keyup(function(evt) {
        return _this.keyup_checker(evt);
      });
      this.search_field.keydown(function(evt) {
        return _this.keydown_checker(evt);
      });
      this.search_field.focus(function(evt) {
        return _this.input_focus(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.click(function(evt) {
          return _this.choices_click(evt);
        });
      } else {
        return this.container.click(function(evt) {
          return evt.preventDefault();
        });
      }
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chzn-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chzn-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      var target_closelink;

      if (!this.is_disabled) {
        target_closelink = evt != null ? $(evt.target).hasClass("search-choice-close") : false;
        if ((evt != null ? evt.type : void 0) === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!this.pending_destroy_click && !target_closelink) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(document).click(this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        } else {
          return this.pending_destroy_click = false;
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chzn-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(document).unbind("click", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chzn-container-active");
      this.winnow_results_clear();
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      this.container.addClass("chzn-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      if ($(evt.target).parents('#' + this.container_id).length) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      var content, data, _i, _len, _ref1;

      this.parsing = true;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple && this.choices > 0) {
        this.search_choices.find("li.search-choice").remove();
        this.choices = 0;
      } else if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.container.addClass("chzn-container-single-nosearch");
        } else {
          this.container.removeClass("chzn-container-single-nosearch");
        }
      }
      content = '';
      _ref1 = this.results_data;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        data = _ref1[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else if (!data.empty) {
          content += this.result_add_option(data);
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.selected_item.removeClass("chzn-default").find("span").text(data.text);
            if (this.allow_single_deselect) {
              this.single_deselect_control_build();
            }
          }
        }
      }
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      this.search_results.html(content);
      return this.parsing = false;
    };

    Chosen.prototype.result_add_group = function(group) {
      if (!group.disabled) {
        group.dom_id = this.container_id + "_g_" + group.array_index;
        return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
      } else {
        return "";
      }
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;

      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      var dd_top;

      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-single-with-drop");
        if (this.result_single_selected) {
          this.result_do_highlight(this.result_single_selected);
        }
      } else if (this.max_selected_options <= this.choices) {
        this.form_field_jq.trigger("liszt:maxselected", {
          chosen: this
        });
        false;
      }
      dd_top = this.is_multiple ? this.container.height() : this.container.height() - 1;
      this.form_field_jq.trigger("liszt:showing_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "top": dd_top + "px",
        "left": 0
      });
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };

    Chosen.prototype.results_hide = function() {
      if (!this.is_multiple) {
        this.selected_item.removeClass("chzn-single-with-drop");
      }
      this.result_clear_highlight();
      this.form_field_jq.trigger("liszt:hiding_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        left: "-9000px"
      });
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;

      if (this.form_field_jq.attr("tabindex")) {
        ti = this.form_field_jq.attr("tabindex");
        this.form_field_jq.attr("tabindex", -1);
        return this.search_field.attr("tabindex", ti);
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;

      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;

      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (this.active_field && !($(evt.target).hasClass("search-choice" || $(evt.target).parents('.search-choice').first)) && !this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice_id, html, link,
        _this = this;

      if (this.is_multiple && this.max_selected_options <= this.choices) {
        this.form_field_jq.trigger("liszt:maxselected", {
          chosen: this
        });
        false;
      }
      choice_id = this.container_id + "_c_" + item.array_index;
      this.choices += 1;
      if (item.disabled) {
        html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
      } else {
        html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
      }
      this.search_container.before(html);
      link = $('#' + choice_id).find("a").first();
      return link.click(function(evt) {
        return _this.choice_destroy_link_click(evt);
      });
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      if (!this.is_disabled) {
        this.pending_destroy_click = true;
        return this.choice_destroy($(evt.target));
      } else {
        return evt.stopPropagation;
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link.attr("rel"))) {
        this.choices -= 1;
        this.show_search_field_default();
        if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.form_field.options[0].selected = true;
      this.selected_item.find("span").text(this.default_text);
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default");
      }
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_value = this.form_field_jq.val();
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, high_id, item, position;

      if (this.result_highlight) {
        high = this.result_highlight;
        high_id = high.attr("id");
        this.result_clear_highlight();
        if (this.is_multiple) {
          this.result_deactivate(high);
        } else {
          this.search_results.find(".result-selected").removeClass("result-selected");
          this.result_single_selected = high;
          this.selected_item.removeClass("chzn-default");
        }
        high.addClass("result-selected");
        position = high_id.substr(high_id.lastIndexOf("_") + 1);
        item = this.results_data[position];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.selected_item.find("span").first().text(item.text);
          if (this.allow_single_deselect) {
            this.single_deselect_control_build();
          }
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val("");
        if (this.is_multiple || this.form_field_jq.val() !== this.current_value) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_value = this.form_field_jq.val();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.result_activate = function(el) {
      return el.addClass("active-result");
    };

    Chosen.prototype.result_deactivate = function(el) {
      return el.removeClass("active-result");
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result, result_data;

      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        result = $("#" + this.container_id + "_o_" + pos);
        result.removeClass("result-selected").addClass("active-result").show();
        this.result_clear_highlight();
        this.winnow_results();
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
        return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
    };

    Chosen.prototype.winnow_results = function() {
      var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref1;

      this.no_results_clear();
      results = 0;
      searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      _ref1 = this.results_data;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        option = _ref1[_i];
        if (!option.disabled && !option.empty) {
          if (option.group) {
            $('#' + option.dom_id).css('display', 'none');
          } else if (!(this.is_multiple && option.selected)) {
            found = false;
            result_id = option.dom_id;
            result = $("#" + result_id);
            if (regex.test(option.html)) {
              found = true;
              results += 1;
            } else if (this.enable_split_word_search && (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0)) {
              parts = option.html.replace(/\[|\]/g, "").split(" ");
              if (parts.length) {
                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                  part = parts[_j];
                  if (!(regex.test(part))) {
                    continue;
                  }
                  found = true;
                  results += 1;
                }
              }
            }
            if (found) {
              if (searchText.length) {
                startpos = option.html.search(zregex);
                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              } else {
                text = option.html;
              }
              result.html(text);
              this.result_activate(result);
              if (option.group_array_index != null) {
                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
              }
            } else {
              if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                this.result_clear_highlight();
              }
              this.result_deactivate(result);
            }
          }
        }
      }
      if (results < 1 && searchText.length) {
        return this.no_results(searchText);
      } else {
        return this.winnow_results_set_highlight();
      }
    };

    Chosen.prototype.winnow_results_clear = function() {
      var li, lis, _i, _len, _results;

      this.search_field.val("");
      lis = this.search_results.find("li");
      _results = [];
      for (_i = 0, _len = lis.length; _i < _len; _i++) {
        li = lis[_i];
        li = $(li);
        if (li.hasClass("group-result")) {
          _results.push(li.css('display', 'auto'));
        } else if (!this.is_multiple || !li.hasClass("result-selected")) {
          _results.push(this.result_activate(li));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;

      if (!this.result_highlight) {
        selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
        do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
        if (do_high != null) {
          return this.result_do_highlight(do_high);
        }
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;

      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var first_active, next_sib;

      if (!this.result_highlight) {
        first_active = this.search_results.find("li.active-result").first();
        if (first_active) {
          this.result_do_highlight($(first_active));
        }
      } else if (this.results_showing) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          this.result_do_highlight(next_sib);
        }
      }
      if (!this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;

      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;

      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref1;

      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          return this.backstroke_length = this.search_field.val().length;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          return this.mouse_on_container = false;
        case 13:
          return evt.preventDefault();
        case 38:
          evt.preventDefault();
          return this.keyup_arrow();
        case 40:
          return this.keydown_arrow();
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var dd_top, div, h, style, style_block, styles, w, _i, _len;

      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        if (w > this.f_width - 10) {
          w = this.f_width - 10;
        }
        this.search_field.css({
          'width': w + 'px'
        });
        dd_top = this.container.height();
        return this.dropdown.css({
          "top": dd_top + "px"
        });
      }
    };

    Chosen.prototype.generate_random_id = function() {
      var string;

      string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
      while ($("#" + string).length > 0) {
        string += this.generate_random_char();
      }
      return string;
    };

    return Chosen;

  })(AbstractChosen);

  exports.Chosen = Chosen;

  SelectParser = (function() {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref1, _results;

      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: group.label,
        children: 0,
        disabled: group.disabled
      });
      _ref1 = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        option = _ref1[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref1;

    parser = new SelectParser();
    _ref1 = select.childNodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

}).call(this);

})(window)
},{"jquery-browserify":11}],80:[function(require,module,exports){
(function(){var _ = require('underscore');
var jsyaml = require('js-yaml');
var queue = require('queue-async');

var Backbone = require('backbone');
var File = require('../models/file');
var Folder = require('../models/folder');

var cookie = require('../cookie');
var util = require('../util');
var ignore = require('ignore');

module.exports = Backbone.Collection.extend({
  model: function(attributes, options) {
    // TODO: handle 'symlink' and 'submodule' type
    // TODO: coerce tree/folder to a single type
    switch(attributes.type) {
      case 'tree':
        return new Folder(attributes, options);
        break;
      case 'blob':
        return new File(attributes, options);
        break;
      default:
        return new File(attributes, options);
        break;
    }
  },

  initialize: function(models, options) {
    _.bindAll(this);

    this.repo = options.repo;
    this.branch = options.branch;
    this.sha = options.sha;

    // Sort files reverse alphabetically if path begins with '_posts/'
    this.comparator = function(a, b) {
      var typeA = a.get('type');
      var typeB = b.get('type');

      var pathA = a.get('path');
      var pathB = b.get('path');

      var regex = /^_posts\/.*$/

      if (typeA === typeB && typeA === 'file' && regex.test(pathA) && regex.test(pathB)) {
        // Reverse alphabetical
        return pathA < pathB ? 1 : -1;
      } else if (typeA === typeB) {
        // Alphabetical
        return pathA < pathB ? -1 : 1;
      } else {
        switch(typeA) {
          case 'tree':
          case 'folder':
            return -1;
            break;
          case 'file':
            return typeB === 'folder' || typeB === 'tree' ? 1 : -1;
            break;
        }
      }
    };
  },

  parse: function(resp, options) {
    return _.map(resp.tree, (function(file) {
      return  _.extend(file, {
        branch: this.branch,
        collection: this,
        repo: this.repo
      })
    }).bind(this));
  },

  parseConfig: function(config, options) {
    var content = config.get('content');

    // Attempt to parse YAML
    try {
      config = jsyaml.safeLoad(content);
    } catch(err) {
      console.log("Error parsing YAML");
      console.log(err);
    }

    if (config && config.prose) {
      // Load _config.yml, set parsed value on collection
      // Extend to capture settings from outside config.prose
      // while allowing override
      this.config = _.extend({
        baseurl: config.baseurl,
        languages: config.languages
      }, config.prose);

      if (config.prose.ignore) {
        this.parseIgnore(config.prose.ignore);
      }

      if (config.prose.metadata) {
        var metadata = config.prose.metadata;

        // Serial queue to not break global scope JSONP callbacks
        var q = queue(1);

        _.each(metadata, function(raw, key) {
          q.defer(function(cb) {
            var subq = queue();
            var defaults;

            if (_.isObject(raw)) {
              defaults = raw;

              _.each(defaults, function(value, key) {
                var regex = /^https?:\/\//;

                // Parse JSON URL values
                if (value && value.field && value.field.options &&
                    _.isString(value.field.options) &&
                    regex.test(value.field.options)) {

                  subq.defer(function(cb) {
                    $.ajax({
                      cache: true,
                      dataType: 'jsonp',
                      jsonp: false,
                      jsonpCallback: value.field.options.split('?callback=')[1] || 'callback',
                      timeout: 5000,
                      url: value.field.options,
                      success: (function(d) {
                        value.field.options = _.compact(d);
                        cb();
                      }).bind(this)
                    });
                  });
                }
              });
            } else if (_.isString(raw)) {
              try {
                defaults = jsyaml.safeLoad(raw);

                if (defaults.date === "CURRENT_DATETIME") {
                  var current = (new Date()).format('Y-m-d H:i');
                  defaults.date = current;
                  raw = raw.replace("CURRENT_DATETIME", current);
                }
              } catch(err) {
                console.log("Error parsing default values.");
                console.log(err);
              }
            }

            subq.awaitAll(function() {
              metadata[key] = defaults;
              cb();
            });
          });
        });

        q.awaitAll((function() {
          // Save parsed config to the collection as it's used accross
          // files of the same collection and shouldn't be re-parsed each time
          this.defaults = metadata;

          if (_.isFunction(options.success)) options.success.apply(this, options.args);
        }).bind(this));
      } else {
        if (_.isFunction(options.success)) options.success.apply(this, options.args);
      }
    } else {
      if (_.isFunction(options.success)) options.success.apply(this, options.args);
    }
  },

  parseIgnore: function(ignorePatterns) {
    var ignoreFilter = ignore().addPattern(ignorePatterns).createFilter();
    this.filteredModel = new Backbone.Collection(this.filter(function(file) {
      return ignoreFilter(file.id);
    }));
  },

  fetch: function(options) {
    options = _.clone(options) || {};

    var success = options.success;
    var args = options.args;

    Backbone.Collection.prototype.fetch.call(this, _.extend(options, {
      success: (function(model, res, options) {
        var config = this.findWhere({ path: '_prose.yml' }) ||
          this.findWhere({ path: '_config.yml' });

        if (config) {
          config.fetch({
            success: (function() {
              this.parseConfig(config, { success: success, args: args });
            }).bind(this)
          });
        } else {
          if (_.isFunction(success)) success.apply(this, args);
        }

      }).bind(this)
    }));
  },

  restore: function(file, options) {
    options = options ? _.clone(options) : {};

    var path = file.filename;
    var success = options.success;

    $.ajax({
      type: 'GET',
      url: file.contents_url,
      headers: {
        Accept: 'application/vnd.github.v3.raw'
      },
      success: (function(res) {
        // initialize new File model with content
        var model = new File({
          branch: this.branch,
          collection: this,
          content: res,
          path: path,
          repo: this.repo
        });

        var name = util.extractFilename(path)[1];
        model.set('placeholder', t('actions.commits.created', { filename: name }));

        // add to collection on save
        model.save({
          success: (function(model, res, options) {
            // Update model attributes and add to collection
            model.set(res.content);
            this.add(model);

            if (_.isFunction(success)) success(model, res, options);
          }).bind(this),
          error: options.error
        });
      }).bind(this),
      error: options.error
    });
  },

  upload: function(file, content, path, options) {
    var success = options.success;

    var extension = file.type.split('/').pop();
    var uid;

    if (!path) {
      uid = file.name;

      if (this.assetsDirectory) {
        path = this.assetsDirectory + '/' + uid;
      } else {
        path = this.model.path ? this.model.path + '/' + uid : uid;
      }
    }

    // If path matches an existing file, confirm the overwrite is intentional
    // then set new content and update the existing file
    var model = this.findWhere({ path: path });

    if (model) {
      // TODO: confirm overwrite with UI prompt
      model.set('content', content);
      model.set('placeholder', t('actions.commits.updated', { filename: file.name }));
    } else {
      // initialize new File model with content
      model = new File({
        branch: this.branch,
        collection: this,
        content: content,
        path: path,
        repo: this.repo
      });

      model.set('placeholder', t('actions.commits.created', { filename: file.name }));
    }

    // add to collection on save
    model.save({
      success: (function(model, res, options) {
        // Update model attributes and add to collection
        model.set(res.content);
        this.add(model);

        if (_.isFunction(success)) success(model, res, options);
      }).bind(this),
      error: options.error
    });
  },

  url: function() {
    return this.repo.url() + '/git/trees/' + this.sha + '?recursive=1';
  }
});

})()
},{"../models/file":18,"../cookie":3,"../models/folder":63,"../util":28,"underscore":13,"js-yaml":44,"queue-async":47,"backbone":12,"ignore":101}],101:[function(require,module,exports){
'use strict';

module.exports = ignore;
ignore.Ignore = Ignore;

var EE = require('events').EventEmitter;
var node_util = require('util');
var node_fs = require('fs');

function ignore(options) {
  return new Ignore(options);
}

var exists = node_fs.existsSync ?
    function(file) {
      return node_fs.existsSync(file);
  } :

  // if node <= 0.6, there's no fs.existsSync method.
  function(file) {
    try {
      node_fs.statSync(file);
      return true;
    } catch (e) {
      return false;
    }
  };

// Select the first existing file of the file list
ignore.select = function(files) {
  var selected;

  files.some(function(file) {
    if (exists(file)) {
      selected = file;
      return true;
    }
  });

  return selected;
};


// @param {Object} options
// - ignore: {Array}
// - twoGlobstars: {boolean=false} enable pattern `'**'` (two consecutive asterisks), default to `false`.
//      If false, ignore patterns with two globstars will be omitted
// - matchCase: {boolean=} case sensitive.
//      By default, git is case-insensitive
function Ignore(options) {
  options = options || {};

  this.options = options;
  this._patterns = [];
  this._rules = [];
  this._ignoreFiles = [];

  options.ignore = options.ignore || [
    // Some files or directories which we should ignore for most cases.
    '.git',
    '.svn',
    '.DS_Store'
  ];

  this.addPattern(options.ignore);
}

// Events:
// 'warn': , 
//      will warn when encounter '`**`' (two consecutive asterisks)
//      which is not compatible with all platforms (not works on Mac OS for example)
node_util.inherits(Ignore, EE);

function makeArray(subject) {
  return Array.isArray(subject) ?
    subject :
    subject === undefined || subject === null ?
    [] :
    [subject];
}


// @param {Array.<string>|string} pattern
Ignore.prototype.addPattern = function(pattern) {
  makeArray(pattern).forEach(this._addPattern, this);
  return this;
};


Ignore.prototype._addPattern = function(pattern) {
  if (this._simpleTest(pattern)) {
    var rule = this._createRule(pattern);
    this._rules.push(rule);
  }
};


Ignore.prototype.filter = function(paths) {
  return paths.filter(this._filter, this);
};


Ignore.prototype._simpleTest = function(pattern) {
  var pass =
  // Whitespace dirs are allowed, so only filter blank pattern.
  pattern &&
  // And not start with a '#'
  pattern.indexOf('#') !== 0 &&

  !~this._patterns.indexOf(pattern);

  this._patterns.push(pattern);

  if (~pattern.indexOf('**')) {
    this.emit('warn', {
      code: 'WGLOBSTARS',
      data: {
        origin: pattern
      },
      message: '`**` found, which is not compatible cross all platforms.'
    });

    if (!this.options.twoGlobstars) {
      return false;
    }
  }

  return pass;
};

var REGEX_LEADING_EXCLAMATION = /^\\\!/;
var REGEX_LEADING_HASH = /^\\#/;

Ignore.prototype._createRule = function(pattern) {
  var rule_object = {
    origin: pattern
  };

  var match_start;

  if (pattern.indexOf('!') === 0) {
    rule_object.negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern
    .replace(REGEX_LEADING_EXCLAMATION, '!')
    .replace(REGEX_LEADING_HASH, '#');

  rule_object.pattern = pattern;

  rule_object.regex = this.makeRegex(pattern);

  return rule_object;
};

// > If the pattern ends with a slash, it is removed for the purpose of the following description, but it would only find a match with a directory. In other words, foo/ will match a directory foo and paths underneath it, but will not match a regular file or a symbolic link foo (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
var REPLACERS = [

  // Escape metacharacters 
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings: 
  // > - the backslash \, 
  // > - the caret ^, 
  // > - the dollar sign $, 
  // > - the period or dot ., 
  // > - the vertical bar or pipe symbol |, 
  // > - the question mark ?, 
  // > - the asterisk or star *, 
  // > - the plus sign +, 
  // > - the opening parenthesis (, 
  // > - the closing parenthesis ), 
  // > - and the opening square bracket [, 
  // > - the opening curly brace {, 
  // > These special characters are often called "metacharacters".
  [
    /[\\\^$.|?*+()\[{]/g,
    function(match) {
      return '\\' + match;
    }
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname. For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname 
    /^\//,
    '^'
  ],

  [
    /\//g,
    '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories. For example, "**/foo" matches file or directory "foo" anywhere, the same as pattern "foo". "**/foo/bar" matches file or directory "bar" anywhere that is directly under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    // just remove it
    ''
  ],

  // 'f'
  // matches
  // - /f(end)
  // - /f/
  // - (start)f(end)
  // - (start)f/
  // doesn't match
  // - oof
  // - foo
  // pseudo:
  // -> (^|/)f(/|$)

  // ending
  [
    // 'js' will not match 'js.'
    /(?:[^*\/])$/,
    function(match) {
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      return match + '(?=$|\\/)';
    }
  ],

  // starting
  [
    // there will be no leading '/' (which has been replaced by the second replacer)
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^\^])/,
    '(?:^|\\/)'
  ],

  // two globstars
  [
    // > A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
    // '/**/'
    /\/\\\*\\\*\//g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer
    '(?:\\/[^\\/]+)*\\/'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip
    /(^|[^\\]+)\\\*(?=.+)/g,
    function(match, p1) {
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      return p1 + '[^\\/]*';
    }
  ],

  // ending wildcard
  [
    /\\\*$/,
    // simply remove it
    ''
  ],

  [
    /\\\\\\/g,
    '\\'
  ]
];


// @param {pattern}
Ignore.prototype.makeRegex = function(pattern) {
  var source = REPLACERS.reduce(function(prev, current) {
    return prev.replace(current[0], current[1]);

  }, pattern);

  return new RegExp(source, this.options.matchCase ? '' : 'i');
};


Ignore.prototype._filter = function(path) {
  var rules = this._rules;
  var i = 0;
  var length = rules.length;
  var matched;
  var rule;

  for (; i < length; i++) {
    rule = rules[i];

    // if matched = true, then we only test negative rules
    // if matched = false, then we test non-negative rules
    if (!(matched ^ rule.negative)) {
      matched = rule.negative ^ rule.regex.test(path);

    } else {
      continue;
    }
  }

  return !matched;
};


Ignore.prototype.createFilter = function() {
  var self = this;

  return function(path) {
    return self._filter(path);
  };
};


// @param {Array.<path>|path} a
Ignore.prototype.addIgnoreFile = function(files) {
  makeArray(files).forEach(this._addIgnoreFile, this);
  return this;
};


Ignore.prototype._addIgnoreFile = function(file) {
  if (this._checkRuleFile(file)) {
    this._ignoreFiles.push(file);

    var content;

    try {
      content = node_fs.readFileSync(file);
    } catch (e) {}

    if (content) {
      this.addPattern(content.toString().split(/\r?\n/));
    }
  }
};


Ignore.prototype._checkRuleFile = function(file) {
  return file !== '.' &&
    file !== '..' && !~this._ignoreFiles.indexOf(file);
};
},{"events":102,"util":103,"fs":81}],82:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');

module.exports = Backbone.View.extend({
  tagName: 'option',

  initialize: function(options) {
    this.model = options.model;
    this.repo = options.repo;
    this.branch = options.branch;
  },

  render: function() {
    this.$el.val('#' + [ this.repo.get('owner').login, this.repo.get('name'), 'tree', this.model.get('name') ].join('/'));
    this.el.selected = this.branch && this.branch === this.model.get('name');

    this.$el.html(this.model.get('name'));

    return this;
  }
});

},{"jquery-browserify":11,"backbone":12,"underscore":13}],84:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":70}],104:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],102:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":104}],103:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":102}],105:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":103,"buffer":106}],85:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var YAML_NULL_MAP = {
  '~'    : true,
  'null' : true,
  'Null' : true,
  'NULL' : true
};


function resolveYamlNull(object /*, explicit*/) {
  return YAML_NULL_MAP[object] ? null : NIL;
}


module.exports = new Type('tag:yaml.org,2002:null', {
  loader: {
    kind: 'string',
    resolver: resolveYamlNull
  },
  dumper: {
    kind: 'null',
    defaultStyle: 'lowercase',
    representer: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; },
    }
  }
});

},{"../common":70,"../type":71}],86:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var YAML_IMPLICIT_BOOLEAN_MAP = {
  'true'  : true,
  'True'  : true,
  'TRUE'  : true,
  'false' : false,
  'False' : false,
  'FALSE' : false
};

var YAML_EXPLICIT_BOOLEAN_MAP = {
  'true'  : true,
  'True'  : true,
  'TRUE'  : true,
  'false' : false,
  'False' : false,
  'FALSE' : false,
  'y'     : true,
  'Y'     : true,
  'yes'   : true,
  'Yes'   : true,
  'YES'   : true,
  'n'     : false,
  'N'     : false,
  'no'    : false,
  'No'    : false,
  'NO'    : false,
  'on'    : true,
  'On'    : true,
  'ON'    : true,
  'off'   : false,
  'Off'   : false,
  'OFF'   : false
};


function resolveYamlBoolean(object, explicit) {
  if (explicit) {
    if (YAML_EXPLICIT_BOOLEAN_MAP.hasOwnProperty(object)) {
      return YAML_EXPLICIT_BOOLEAN_MAP[object];
    } else {
      return NIL;
    }
  } else {
    if (YAML_IMPLICIT_BOOLEAN_MAP.hasOwnProperty(object)) {
      return YAML_IMPLICIT_BOOLEAN_MAP[object];
    } else {
      return NIL;
    }
  }
}


module.exports = new Type('tag:yaml.org,2002:bool', {
  loader: {
    kind: 'string',
    resolver: resolveYamlBoolean
  },
  dumper: {
    kind: 'boolean',
    defaultStyle: 'lowercase',
    representer: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    }
  }
});

},{"../common":70,"../type":71}],87:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var YAML_INTEGER_PATTERN = new RegExp(
  '^(?:[-+]?0b[0-1_]+' +
  '|[-+]?0[0-7_]+' +
  '|[-+]?(?:0|[1-9][0-9_]*)' +
  '|[-+]?0x[0-9a-fA-F_]+' +
  '|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$');


function resolveYamlInteger(object /*, explicit*/) {
  var value, sign, base, digits;

  if (!YAML_INTEGER_PATTERN.test(object)) {
    return NIL;
  }

  value  = object.replace(/_/g, '');
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('0' === value) {
    return 0;

  } else if (/^0b/.test(value)) {
    return sign * parseInt(value.slice(2), 2);

  } else if (/^0x/.test(value)) {
    return sign * parseInt(value, 16);

  } else if ('0' === value[0]) {
    return sign * parseInt(value, 8);

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseInt(value, 10);
  }
}


module.exports = new Type('tag:yaml.org,2002:int', {
  loader: {
    kind: 'string',
    resolver: resolveYamlInteger
  },
  dumper: {
    kind: 'integer',
    defaultStyle: 'decimal',
    representer: {
      binary:      function (object) { return '0b' + object.toString(2); },
      octal:       function (object) { return '0'  + object.toString(8); },
      decimal:     function (object) { return        object.toString(10); },
      hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
    },
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  }
});

},{"../common":70,"../type":71}],88:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');


function resolveYamlFloat(object /*, explicit*/) {
  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(object)) {
    return NIL;
  }

  value  = object.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}


function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else {
    return object.toString(10);
  }
}


module.exports = new Type('tag:yaml.org,2002:float', {
  loader: {
    kind: 'string',
    resolver: resolveYamlFloat
  },
  dumper: {
    kind: 'float',
    defaultStyle: 'lowercase',
    representer: representYamlFloat
  }
});

},{"../common":70,"../type":71}],89:[function(require,module,exports){
'use strict';


var Type = require('../type');


module.exports = new Type('tag:yaml.org,2002:str', {
  loader: {
    kind: 'string'
  }
});

},{"../type":71}],90:[function(require,module,exports){
'use strict';


var Type = require('../type');


module.exports = new Type('tag:yaml.org,2002:seq', {
  loader: {
    kind: 'array'
  }
});

},{"../type":71}],91:[function(require,module,exports){
'use strict';


var Type = require('../type');


module.exports = new Type('tag:yaml.org,2002:map', {
  loader: {
    kind: 'object'
  }
});

},{"../type":71}],92:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute


function resolveYamlTimestamp(object /*, explicit*/) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, data;

  match = YAML_TIMESTAMP_REGEXP.exec(object);

  if (null === match) {
    return NIL;
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  data = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    data.setTime(data.getTime() - delta);
  }

  return data;
}


function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}


module.exports = new Type('tag:yaml.org,2002:timestamp', {
  loader: {
    kind: 'string',
    resolver: resolveYamlTimestamp
  },
  dumper: {
    kind: 'object',
    instanceOf: Date,
    representer: representYamlTimestamp
  }
});

},{"../common":70,"../type":71}],93:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


function resolveYamlMerge(object /*, explicit*/) {
  return '<<' === object ? object : NIL;
}


module.exports = new Type('tag:yaml.org,2002:merge', {
  loader: {
    kind: 'string',
    resolver: resolveYamlMerge
  }
});

},{"../common":70,"../type":71}],94:[function(require,module,exports){
(function(){// Modified from:
// https://raw.github.com/kanaka/noVNC/d890e8640f20fba3215ba7be8e0ff145aeb8c17c/include/base64.js

'use strict';


var NodeBuffer = require('buffer').Buffer; // A trick for browserified version.
var common     = require('../common');
var NIL        = common.NIL;
var Type       = require('../type');



var BASE64_PADDING = '=';

var BASE64_BINTABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1,  0, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
];

var BASE64_CHARTABLE =
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');


function resolveYamlBinary(object /*, explicit*/) {
  var value, code, idx = 0, result = [], leftbits, leftdata;

  leftbits = 0; // number of bits decoded, but yet to be appended
  leftdata = 0; // bits decoded, but yet to be appended

  // Convert one by one.
  for (idx = 0; idx < object.length; idx += 1) {
    code = object.charCodeAt(idx);
    value = BASE64_BINTABLE[code & 0x7F];

    // Skip LF(NL) || CR
    if (0x0A !== code && 0x0D !== code) {
      // Fail on illegal characters
      if (-1 === value) {
        return NIL;
      }

      // Collect data into leftdata, update bitcount
      leftdata = (leftdata << 6) | value;
      leftbits += 6;

      // If we have 8 or more bits, append 8 bits to the result
      if (leftbits >= 8) {
        leftbits -= 8;

        // Append if not padding.
        if (BASE64_PADDING !== object.charAt(idx)) {
          result.push((leftdata >> leftbits) & 0xFF);
        }

        leftdata &= (1 << leftbits) - 1;
      }
    }
  }

  // If there are any bits left, the base64 string was corrupted
  if (leftbits) {
    return NIL;
  } else {
    return new NodeBuffer(result);
  }
}


function representYamlBinary(object /*, style*/) {
  var result = '', index, length, rest;

  // Convert every three bytes to 4 ASCII characters.
  for (index = 0, length = object.length - 2; index < length; index += 3) {
    result += BASE64_CHARTABLE[object[index + 0] >> 2];
    result += BASE64_CHARTABLE[((object[index + 0] & 0x03) << 4) + (object[index + 1] >> 4)];
    result += BASE64_CHARTABLE[((object[index + 1] & 0x0F) << 2) + (object[index + 2] >> 6)];
    result += BASE64_CHARTABLE[object[index + 2] & 0x3F];
  }

  rest = object.length % 3;

  // Convert the remaining 1 or 2 bytes, padding out to 4 characters.
  if (0 !== rest) {
    index = object.length - rest;
    result += BASE64_CHARTABLE[object[index + 0] >> 2];

    if (2 === rest) {
      result += BASE64_CHARTABLE[((object[index + 0] & 0x03) << 4) + (object[index + 1] >> 4)];
      result += BASE64_CHARTABLE[(object[index + 1] & 0x0F) << 2];
      result += BASE64_PADDING;
    } else {
      result += BASE64_CHARTABLE[(object[index + 0] & 0x03) << 4];
      result += BASE64_PADDING + BASE64_PADDING;
    }
  }

  return result;
}


module.exports = new Type('tag:yaml.org,2002:binary', {
  loader: {
    kind: 'string',
    resolver: resolveYamlBinary
  },
  dumper: {
    kind: 'object',
    instanceOf: NodeBuffer,
    representer: representYamlBinary
  }
});

})()
},{"buffer":106,"../common":70,"../type":71}],95:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;


function resolveYamlOmap(object /*, explicit*/) {
  var objectKeys = [], index, length, pair, pairKey, pairHasKey;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return NIL;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return NIL;
        }
      }
    }

    if (!pairHasKey) {
      return NIL;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return NIL;
    }
  }

  return object;
}


module.exports = new Type('tag:yaml.org,2002:omap', {
  loader: {
    kind: 'array',
    resolver: resolveYamlOmap
  }
});

},{"../common":70,"../type":71}],96:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var _toString = Object.prototype.toString;


function resolveYamlPairs(object /*, explicit*/) {
  var index, length, pair, keys, result;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return NIL;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return NIL;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}


module.exports = new Type('tag:yaml.org,2002:pairs', {
  loader: {
    kind: 'array',
    resolver: resolveYamlPairs
  }
});

},{"../common":70,"../type":71}],97:[function(require,module,exports){
'use strict';


var NIL  = require('../common').NIL;
var Type = require('../type');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


function resolveYamlSet(object /*, explicit*/) {
  var key;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return NIL;
      }
    }
  }

  return object;
}


module.exports = new Type('tag:yaml.org,2002:set', {
  loader: {
    kind: 'object',
    resolver: resolveYamlSet
  }
});

},{"../common":70,"../type":71}],98:[function(require,module,exports){
'use strict';


var Type = require('../../type');


function resolveJavascriptUndefined(/*object, explicit*/) {
  var undef;

  return undef;
}


function representJavascriptUndefined(/*object, explicit*/) {
  return '';
}


module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  loader: {
    kind: 'string',
    resolver: resolveJavascriptUndefined
  },
  dumper: {
    kind: 'undefined',
    representer: representJavascriptUndefined
  }
});

},{"../../type":71}],99:[function(require,module,exports){
(function(){'use strict';


var NIL  = require('../../common').NIL;
var Type = require('../../type');


function resolveJavascriptRegExp(object /*, explicit*/) {
  var regexp = object,
      tail   = /\/([gim]*)$/.exec(object),
      modifiers;

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0] && tail && 4 >= tail[0].length) {
    regexp = regexp.slice(1, regexp.length - tail[0].length);
    modifiers = tail[1];
  }

  try {
    return new RegExp(regexp, modifiers);
  } catch (error) {
    return NIL;
  }
}


function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}


module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  loader: {
    kind: 'string',
    resolver: resolveJavascriptRegExp
  },
  dumper: {
    kind: 'object',
    instanceOf: RegExp,
    representer: representJavascriptRegExp
  }
});

})()
},{"../../common":70,"../../type":71}],83:[function(require,module,exports){
var $ = require('jquery-browserify');
var _ = require('underscore');
var Backbone = require('backbone');
var templates = require('../../../../dist/templates');
var util = require('../../../util');

module.exports = Backbone.View.extend({
  template: templates.sidebar.li.commit,

  tagName: 'li',

  className: 'item',

  events: {
    'mouseenter .removed': 'eventMessage',
    'mouseleave .removed': 'eventMessage',
    'click .removed': 'restore'
  },

  initialize: function(options) {
    var file = options.file;

    this.branch = options.branch;
    this.file = file;
    this.files = options.repo.branches.findWhere({ name: options.branch }).files;
    this.repo = options.repo;
    this.view  = options.view;
  },

  render: function() {
    var file = this.file;
    var binary = util.isBinary(file.filename);

    var data = {
      branch: this.branch,
      file: file,
      mode: binary ? 'tree' : 'edit',
      path: binary ?
        util.extractFilename(file.filename)[0] : file.filename,
      repo: this.repo.toJSON(),
      status: file.status
    };

    var title = file.status.charAt(0).toUpperCase() + file.status.slice(1) +
      ': ' + file.filename;

    this.$el.attr('title', title)
      .html(_.template(this.template, data, { variable: 'data' }));

    return this;
  },

  message: function(message) {
    this.$el.find('.message').html(message);
  },

  eventMessage: function(e) {
    switch(e.type) {
      case 'mouseenter':
        this.message(t('sidebar.repo.history.actions.restore'));
        break;
      case 'mouseleave':
        this.message(this.file.filename);
        break;
    }

    return false;
  },

  state: function(state) {
    // TODO: Set data-state attribute to toggle icon in CSS?
    // this.$el.attr('data-state', state);

    var $icon = this.$el.find('.ico');
    $icon.removeClass('added modified renamed removed saving checkmark error')
      .addClass(state);
  },

  restore: function(e) {
    var path = this.file.filename;

    // Spinning icon
    this.message(t('actions.restore.restoring') + ' ' + path);
    this.state('saving');

    this.files.restore(this.file, {
      success: (function(model, res, options) {
        this.message(t('actions.restore.restored') + ': ' + path);
        this.state('checkmark');

        this.$el
          .attr('title', t('actions.restore.restored') + ': ' + this.file.filename);

        this.$el.find('a').removeClass('removed');

        // Re-render Files view once collection has updated
        this.view.files.render();
      }).bind(this),
      error: (function(model, xhr, options) {
        // Log actual error message
        this.message(['Error', xhr.status, xhr.statusText].join(' '));
        this.state('error');
      }).bind(this)
    });

    return false;
  }
});

},{"../../../../dist/templates":14,"../../../util":28,"jquery-browserify":11,"backbone":12,"underscore":13}],107:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],106:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":105,"./buffer_ieee754":107,"base64-js":108}],108:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],100:[function(require,module,exports){
'use strict';


var esprima = require('esprima');


var NIL  = require('../../common').NIL;
var Type = require('../../type');


function resolveJavascriptFunction(object /*, explicit*/) {
  /*jslint evil:true*/

  try {
    var source = '(' + object + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return NIL;
    }

    ast.body[0].expression.params.forEach(function (param) {
      params.push(param.name);
    });

    body = ast.body[0].expression.body.range;

    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    return new Function(params, source.slice(body[0]+1, body[1]-1));
  } catch (err) {
    return NIL;
  }
}


function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}


module.exports = new Type('tag:yaml.org,2002:js/function', {
  loader: {
    kind: 'string',
    resolver: resolveJavascriptFunction
  },
  dumper: {
    kind: 'function',
    representer: representJavascriptFunction,
  }
});

},{"../../common":70,"../../type":71,"esprima":109}],109:[function(require,module,exports){
(function(){/*
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwError: true, createLiteral: true, generateStatement: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        buffer,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function sliceSource(from, to) {
        return source.slice(from, to);
    }

    if (typeof 'esprima'[0] === 'undefined') {
        sliceSource = function sliceArraySource(from, to) {
            return source.slice(from, to).join('');
        };
    }

    function isDecimalDigit(ch) {
        return '0123456789'.indexOf(ch) >= 0;
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === ' ') || (ch === '\u0009') || (ch === '\u000B') ||
            (ch === '\u000C') || (ch === '\u00A0') ||
            (ch.charCodeAt(0) >= 0x1680 &&
             '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === '\n' || ch === '\r' || ch === '\u2028' || ch === '\u2029');
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));
    }

    function isIdentifierPart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch >= '0') && (ch <= '9')) ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {

        // Future reserved words.
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        }

        return false;
    }

    function isStrictModeReservedWord(id) {
        switch (id) {

        // Strict Mode reserved words.
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        }

        return false;
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        var keyword = false;
        switch (id.length) {
        case 2:
            keyword = (id === 'if') || (id === 'in') || (id === 'do');
            break;
        case 3:
            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
            break;
        case 4:
            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');
            break;
        case 5:
            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');
            break;
        case 6:
            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');
            break;
        case 7:
            keyword = (id === 'default') || (id === 'finally');
            break;
        case 8:
            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');
            break;
        case 10:
            keyword = (id === 'instanceof');
            break;
        }

        if (keyword) {
            return true;
        }

        switch (id) {
        // Future reserved words.
        // 'const' is specialized as Keyword in V8.
        case 'const':
            return true;

        // For compatiblity to SpiderMonkey and ES.next
        case 'yield':
        case 'let':
            return true;
        }

        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        return isFutureReservedWord(id);
    }

    // 7.4 Comments

    function skipComment() {
        var ch, blockComment, lineComment;

        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    lineComment = false;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            ++index;
                            blockComment = false;
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    index += 2;
                    lineComment = true;
                } else if (ch === '*') {
                    index += 2;
                    blockComment = true;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanIdentifier() {
        var ch, start, id, restore;

        ch = source[index];
        if (!isIdentifierStart(ch)) {
            return;
        }

        start = index;
        if (ch === '\\') {
            ++index;
            if (source[index] !== 'u') {
                return;
            }
            ++index;
            restore = index;
            ch = scanHexEscape('u');
            if (ch) {
                if (ch === '\\' || !isIdentifierStart(ch)) {
                    return;
                }
                id = ch;
            } else {
                index = restore;
                id = 'u';
            }
        } else {
            id = source[index++];
        }

        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }
            if (ch === '\\') {
                ++index;
                if (source[index] !== 'u') {
                    return;
                }
                ++index;
                restore = index;
                ch = scanHexEscape('u');
                if (ch) {
                    if (ch === '\\' || !isIdentifierPart(ch)) {
                        return;
                    }
                    id += ch;
                } else {
                    index = restore;
                    id += 'u';
                }
            } else {
                id += source[index++];
            }
        }

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            return {
                type: Token.Identifier,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (isKeyword(id)) {
            return {
                type: Token.Keyword,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.1 Null Literals

        if (id === 'null') {
            return {
                type: Token.NullLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.2 Boolean Literals

        if (id === 'true' || id === 'false') {
            return {
                type: Token.BooleanLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        return {
            type: Token.Identifier,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        // Check for most common single-character punctuators.

        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Dot (.) can also start a floating-point number, hence the need
        // to check the next character.

        ch2 = source[index + 1];
        if (ch1 === '.' && !isDecimalDigit(ch2)) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Peek more characters.

        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '===',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '!==',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 2-character punctuators: <= >= == != ++ -- << >> && ||
        // += -= *= %= &= |= ^= /=

        if (ch2 === '=') {
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            if ('+-<>&|'.indexOf(ch2) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // The remaining 1-character punctuators.

        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    }

    // 7.8.3 Numeric Literals

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isHexDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (number.length <= 2) {
                        // only 0x
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 16),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                } else if (isOctalDigit(ch)) {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isOctalDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 8),
                        octal: true,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (isDecimalDigit(ch)) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === '.') {
            number += source[index++];
            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }

            ch = source[index];
            if (isDecimalDigit(ch)) {
                number += source[index++];
                while (index < length) {
                    ch = source[index];
                    if (!isDecimalDigit(ch)) {
                        break;
                    }
                    number += source[index++];
                }
            } else {
                ch = 'character ' + ch;
                if (index >= length) {
                    ch = '<end>';
                }
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (index < length) {
            ch = source[index];
            if (isIdentifierStart(ch)) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch)) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch)) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        buffer = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                } else if (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        str += '\\u';
                        for (; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch, token;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        token = scanPunctuator();
        if (typeof token !== 'undefined') {
            return token;
        }

        ch = source[index];

        if (ch === '\'' || ch === '"') {
            return scanStringLiteral();
        }

        if (ch === '.' || isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        token = scanIdentifier();
        if (typeof token !== 'undefined') {
            return token;
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function lex() {
        var token;

        if (buffer) {
            index = buffer.range[1];
            lineNumber = buffer.lineNumber;
            lineStart = buffer.lineStart;
            token = buffer;
            buffer = null;
            return token;
        }

        buffer = null;
        return advance();
    }

    function lookahead() {
        var pos, line, start;

        if (buffer !== null) {
            return buffer;
        }

        pos = index;
        line = lineNumber;
        start = lineStart;
        buffer = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return buffer;
    }

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    return args[index] || '';
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        var token = lookahead();
        return token.type === Token.Punctuator && token.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        var token = lookahead();
        return token.type === Token.Keyword && token.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var token = lookahead(),
            op = token.value;

        if (token.type !== Token.Punctuator) {
            return false;
        }
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var token, line;

        // Catch the very common case first.
        if (source[index] === ';') {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        token = lookahead();
        if (token.type !== Token.EOF && !match('}')) {
            throwUnexpected(token);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return {
            type: Syntax.ArrayExpression,
            elements: elements
        };
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body;

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: null,
            params: param,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseObjectPropertyKey() {
        var token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseObjectProperty() {
        var token, key, id, param;

        token = lookahead();

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                return {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction([]),
                    kind: 'get'
                };
            } else if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead();
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    return {
                        type: Syntax.Property,
                        key: key,
                        value: parsePropertyFunction([]),
                        kind: 'set'
                    };
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    return {
                        type: Syntax.Property,
                        key: key,
                        value: parsePropertyFunction(param, token),
                        kind: 'set'
                    };
                }
            } else {
                expect(':');
                return {
                    type: Syntax.Property,
                    key: id,
                    value: parseAssignmentExpression(),
                    kind: 'init'
                };
            }
        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            return {
                type: Syntax.Property,
                key: key,
                value: parseAssignmentExpression(),
                kind: 'init'
            };
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
            if (Object.prototype.hasOwnProperty.call(map, name)) {
                if (map[name] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[name] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[name] |= kind;
            } else {
                map[name] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return {
            type: Syntax.ObjectExpression,
            properties: properties
        };
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var token = lookahead(),
            type = token.type;

        if (type === Token.Identifier) {
            return {
                type: Syntax.Identifier,
                name: lex().value
            };
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(lex());
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                return {
                    type: Syntax.ThisExpression
                };
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
        }

        if (type === Token.BooleanLiteral) {
            lex();
            token.value = (token.value === 'true');
            return createLiteral(token);
        }

        if (type === Token.NullLiteral) {
            lex();
            token.value = null;
            return createLiteral(token);
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            return createLiteral(scanRegExp());
        }

        return throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var expr;

        expectKeyword('new');

        expr = {
            type: Syntax.NewExpression,
            callee: parseLeftHandSideExpression(),
            'arguments': []
        };

        if (match('(')) {
            expr['arguments'] = parseArguments();
        }

        return expr;
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }


    function parseLeftHandSideExpression() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(), token;

        token = lookahead();
        if (token.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: lex().value,
                argument: expr,
                prefix: false
            };
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        token = lookahead();
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: token.value,
                argument: expr,
                prefix: true
            };
            return expr;
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression(),
                prefix: true
            };
            return expr;
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression(),
                prefix: true
            };
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    // 11.5 Multiplicative Operators

    function parseMultiplicativeExpression() {
        var expr = parseUnaryExpression();

        while (match('*') || match('/') || match('%')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseUnaryExpression()
            };
        }

        return expr;
    }

    // 11.6 Additive Operators

    function parseAdditiveExpression() {
        var expr = parseMultiplicativeExpression();

        while (match('+') || match('-')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseMultiplicativeExpression()
            };
        }

        return expr;
    }

    // 11.7 Bitwise Shift Operators

    function parseShiftExpression() {
        var expr = parseAdditiveExpression();

        while (match('<<') || match('>>') || match('>>>')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseAdditiveExpression()
            };
        }

        return expr;
    }
    // 11.8 Relational Operators

    function parseRelationalExpression() {
        var expr, previousAllowIn;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        expr = parseShiftExpression();

        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseShiftExpression()
            };
        }

        state.allowIn = previousAllowIn;
        return expr;
    }

    // 11.9 Equality Operators

    function parseEqualityExpression() {
        var expr = parseRelationalExpression();

        while (match('==') || match('!=') || match('===') || match('!==')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseRelationalExpression()
            };
        }

        return expr;
    }

    // 11.10 Binary Bitwise Operators

    function parseBitwiseANDExpression() {
        var expr = parseEqualityExpression();

        while (match('&')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '&',
                left: expr,
                right: parseEqualityExpression()
            };
        }

        return expr;
    }

    function parseBitwiseXORExpression() {
        var expr = parseBitwiseANDExpression();

        while (match('^')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '^',
                left: expr,
                right: parseBitwiseANDExpression()
            };
        }

        return expr;
    }

    function parseBitwiseORExpression() {
        var expr = parseBitwiseXORExpression();

        while (match('|')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '|',
                left: expr,
                right: parseBitwiseXORExpression()
            };
        }

        return expr;
    }

    // 11.11 Binary Logical Operators

    function parseLogicalANDExpression() {
        var expr = parseBitwiseORExpression();

        while (match('&&')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '&&',
                left: expr,
                right: parseBitwiseORExpression()
            };
        }

        return expr;
    }

    function parseLogicalORExpression() {
        var expr = parseLogicalANDExpression();

        while (match('||')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '||',
                left: expr,
                right: parseLogicalANDExpression()
            };
        }

        return expr;
    }

    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent;

        expr = parseLogicalORExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');

            expr = {
                type: Syntax.ConditionalExpression,
                test: expr,
                consequent: consequent,
                alternate: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr;

        token = lookahead();
        expr = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            expr = {
                type: Syntax.AssignmentExpression,
                operator: lex().value,
                left: expr,
                right: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr = parseAssignmentExpression();

        if (match(',')) {
            expr = {
                type: Syntax.SequenceExpression,
                expressions: [ expr ]
            };

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

        }
        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        expect('{');

        block = parseStatementList();

        expect('}');

        return {
            type: Syntax.BlockStatement,
            body: block
        };
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseVariableDeclaration(kind) {
        var id = parseVariableIdentifier(),
            init = null;

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
        };
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: 'var'
        };
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
        };
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');

        return {
            type: Syntax.EmptyStatement
        };
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
        };
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return {
            type: Syntax.WhileStatement,
            test: test,
            body: body
        };
    }

    function parseForVariableDeclaration() {
        var token = lex();

        return {
            type: Syntax.VariableDeclaration,
            declarations: parseVariableDeclarationList(),
            kind: token.value
        };
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        if (typeof left === 'undefined') {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        }

        return {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: false
        };
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var token, label = null;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source[index] === ';') {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return {
            type: Syntax.ContinueStatement,
            label: label
        };
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var token, label = null;

        expectKeyword('break');

        // Optimize the most common form: 'break;'.
        if (source[index] === ';') {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return {
            type: Syntax.BreakStatement,
            label: label
        };
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var token, argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source[index] === ' ') {
            if (isIdentifierStart(source[index + 1])) {
                argument = parseExpression();
                consumeSemicolon();
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            }
        }

        if (peekLineTerminator()) {
            return {
                type: Syntax.ReturnStatement,
                argument: null
            };
        }

        if (!match(';')) {
            token = lookahead();
            if (!match('}') && token.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return {
            type: Syntax.ReturnStatement,
            argument: argument
        };
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return {
            type: Syntax.WithStatement,
            object: object,
            body: body
        };
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            statement;

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            if (typeof statement === 'undefined') {
                break;
            }
            consequent.push(statement);
        }

        return {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
        };
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
        };
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ThrowStatement,
            argument: argument
        };
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param;

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead());
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');

        return {
            type: Syntax.CatchClause,
            param: param,
            body: parseBlock()
        };
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return {
            type: Syntax.TryStatement,
            block: block,
            guardedHandlers: [],
            handlers: handlers,
            finalizer: finalizer
        };
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return {
            type: Syntax.DebuggerStatement
        };
    }

    // 12 Statements

    function parseStatement() {
        var token = lookahead(),
            expr,
            labeledBody;

        if (token.type === Token.EOF) {
            throwUnexpected(token);
        }

        if (token.type === Token.Punctuator) {
            switch (token.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[expr.name] = true;
            labeledBody = parseStatement();
            delete state.labelSet[expr.name];

            return {
                type: Syntax.LabeledStatement,
                label: expr,
                body: labeledBody
            };
        }

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expect('{');

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return {
            type: Syntax.BlockStatement,
            body: sourceElements
        };
    }

    function parseFunctionDeclaration() {
        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;

        expectKeyword('function');
        token = lookahead();
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead();
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    // 14 Program

    function parseSourceElement() {
        var token = lookahead();

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(token.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (token.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var program;
        strict = false;
        program = {
            type: Syntax.Program,
            body: parseSourceElements()
        };
        return program;
    }

    // The following functions are needed only when the option to preserve
    // the comments is active.

    function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (extra.comments.length > 0) {
            if (extra.comments[extra.comments.length - 1].range[1] > start) {
                return;
            }
        }

        extra.comments.push({
            type: type,
            value: value,
            range: [start, end],
            loc: loc
        });
    }

    function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;

        comment = '';
        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    lineComment = false;
                    addComment('Line', comment, start, index - 1, loc);
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = '';
                } else if (index >= length) {
                    lineComment = false;
                    comment += ch;
                    loc.end = {
                        line: lineNumber,
                        column: length - lineStart
                    };
                    addComment('Line', comment, start, length, loc);
                } else {
                    comment += ch;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                        comment += '\r\n';
                    } else {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    comment += ch;
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            comment = comment.substr(0, comment.length - 1);
                            blockComment = false;
                            ++index;
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                            comment = '';
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    start = index;
                    index += 2;
                    lineComment = true;
                    if (index >= length) {
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        lineComment = false;
                        addComment('Line', comment, start, index, loc);
                    }
                } else if (ch === '*') {
                    start = index;
                    index += 2;
                    blockComment = true;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - 2
                        }
                    };
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function filterCommentLocation() {
        var i, entry, comment, comments = [];

        for (i = 0; i < extra.comments.length; ++i) {
            entry = extra.comments[i];
            comment = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                comment.range = entry.range;
            }
            if (extra.loc) {
                comment.loc = entry.loc;
            }
            comments.push(comment);
        }

        extra.comments = comments;
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = sliceSource(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        // Pop the previous token, which is likely '/' or '/='
        if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === 'Punctuator') {
                if (token.value === '/' || token.value === '/=') {
                    extra.tokens.pop();
                }
            }
        }

        extra.tokens.push({
            type: 'RegularExpression',
            value: regex.literal,
            range: [pos, index],
            loc: loc
        });

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function createLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value
        };
    }

    function createRawLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value,
            raw: sliceSource(token.range[0], token.range[1])
        };
    }

    function createLocationMarker() {
        var marker = {};

        marker.range = [index, index];
        marker.loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        marker.end = function () {
            this.range[1] = index;
            this.loc.end.line = lineNumber;
            this.loc.end.column = index - lineStart;
        };

        marker.applyGroup = function (node) {
            if (extra.range) {
                node.groupRange = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.groupLoc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        marker.apply = function (node) {
            if (extra.range) {
                node.range = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        return marker;
    }

    function trackGroupExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();
        expect('(');

        expr = parseExpression();

        expect(')');

        marker.end();
        marker.applyGroup(expr);

        return expr;
    }

    function trackLeftHandSideExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function trackLeftHandSideExpressionAllowCall() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
                marker.end();
                marker.apply(expr);
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function filterGroup(node) {
        var n, i, entry;

        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};
        for (i in node) {
            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
                entry = node[i];
                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
                    n[i] = entry;
                } else {
                    n[i] = filterGroup(entry);
                }
            }
        }
        return n;
    }

    function wrapTrackingFunction(range, loc) {

        return function (parseFunction) {

            function isBinary(node) {
                return node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            function visit(node) {
                var start, end;

                if (isBinary(node.left)) {
                    visit(node.left);
                }
                if (isBinary(node.right)) {
                    visit(node.right);
                }

                if (range) {
                    if (node.left.groupRange || node.right.groupRange) {
                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                        node.range = [start, end];
                    } else if (typeof node.range === 'undefined') {
                        start = node.left.range[0];
                        end = node.right.range[1];
                        node.range = [start, end];
                    }
                }
                if (loc) {
                    if (node.left.groupLoc || node.right.groupLoc) {
                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                        node.loc = {
                            start: start,
                            end: end
                        };
                    } else if (typeof node.loc === 'undefined') {
                        node.loc = {
                            start: node.left.loc.start,
                            end: node.right.loc.end
                        };
                    }
                }
            }

            return function () {
                var marker, node;

                skipComment();

                marker = createLocationMarker();
                node = parseFunction.apply(null, arguments);
                marker.end();

                if (range && typeof node.range === 'undefined') {
                    marker.apply(node);
                }

                if (loc && typeof node.loc === 'undefined') {
                    marker.apply(node);
                }

                if (isBinary(node)) {
                    visit(node);
                }

                return node;
            };
        };
    }

    function patch() {

        var wrapTracking;

        if (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        if (extra.raw) {
            extra.createLiteral = createLiteral;
            createLiteral = createRawLiteral;
        }

        if (extra.range || extra.loc) {

            extra.parseGroupExpression = parseGroupExpression;
            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
            parseGroupExpression = trackGroupExpression;
            parseLeftHandSideExpression = trackLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseAdditiveExpression = parseAdditiveExpression;
            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
            extra.parseBitwiseORExpression = parseBitwiseORExpression;
            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseEqualityExpression = parseEqualityExpression;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseLogicalANDExpression = parseLogicalANDExpression;
            extra.parseLogicalORExpression = parseLogicalORExpression;
            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseRelationalExpression = parseRelationalExpression;
            extra.parseStatement = parseStatement;
            extra.parseShiftExpression = parseShiftExpression;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;

            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
            parseStatement = wrapTracking(extra.parseStatement);
            parseShiftExpression = wrapTracking(extra.parseShiftExpression);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }

        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.skipComment === 'function') {
            skipComment = extra.skipComment;
        }

        if (extra.raw) {
            createLiteral = extra.createLiteral;
        }

        if (extra.range || extra.loc) {
            parseAdditiveExpression = extra.parseAdditiveExpression;
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
            parseBitwiseORExpression = extra.parseBitwiseORExpression;
            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseEqualityExpression = extra.parseEqualityExpression;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseGroupExpression = extra.parseGroupExpression;
            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
            parseLogicalANDExpression = extra.parseLogicalANDExpression;
            parseLogicalORExpression = extra.parseLogicalORExpression;
            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parsePostfixExpression = extra.parsePostfixExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseRelationalExpression = extra.parseRelationalExpression;
            parseStatement = extra.parseStatement;
            parseShiftExpression = extra.parseShiftExpression;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
        }

        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    function stringToArray(str) {
        var length = str.length,
            result = [],
            i;
        for (i = 0; i < length; ++i) {
            result[i] = str.charAt(i);
        }
        return result;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        buffer = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.raw = (typeof options.raw === 'boolean') && options.raw;
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }

                // Force accessing the characters via an array.
                if (typeof source[0] === 'undefined') {
                    source = stringToArray(code);
                }
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.range || extra.loc) {
                program.body = filterGroup(program.body);
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with package.json.
    exports.version = '1.0.4';

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

})()
},{}]},{},[6])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxkaXN0XFxlbi5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFx0cmFuc2xhdGlvbnNcXGxvY2FsZXMuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxjb29raWUuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxjb25maWcuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxib290LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG9hdXRoLmpzb24iLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcXVlcnktYnJvd3NlcmlmeVxcbGliXFxqcXVlcnkuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcZGlzdFxcdGVtcGxhdGVzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcdW5kZXJzY29yZVxcdW5kZXJzY29yZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHJvdXRlci5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHN0YXR1cy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxqc29uZm9ybWZvcm1hdC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFx2ZW5kb3JcXGxpcXVpZC5wYXRjaC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHVwbG9hZC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxub3RpZmljYXRpb24uanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxtb2RlbHNcXHVzZXIuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxiYWNrYm9uZVxcYmFja2JvbmUuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx1dGlsLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdG9vbGJhclxcbWFya2Rvd24uanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxjb2xsZWN0aW9uc1xcb3Jncy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXG1vZGVsc1xccmVwby5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxhcHAuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx2aWV3c1xcc3RhcnQuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx2aWV3c1xccHJvZmlsZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXG1vZGVsc1xcZmlsZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzZWFyY2guanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx2aWV3c1xccmVwb3MuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxjb2xsZWN0aW9uc1xcdXNlcnMuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx2aWV3c1xcZG9jdW1lbnRhdGlvbi5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxyZXBvLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGNob29zZWxhbmd1YWdlLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGZpbGUuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxjb2xsZWN0aW9uc1xccmVwb3MuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxtYXJrZWRcXGxpYlxcbWFya2VkLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xccXVldWUtYXN5bmNcXHF1ZXVlLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xca2V5bWFzdGVyXFxrZXltYXN0ZXIuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxkaWZmXFxkaWZmLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcY2hyb25vXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcY2hyb25vXFxsaWJcXGNocm9uby5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXG1vZGVsc1xcb3JnLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcY29sbGVjdGlvbnNcXGJyYW5jaGVzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGxvYWRlci5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxuYXYuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFx2aWV3c1xcc2lkZWJhci5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXGNvbGxlY3Rpb25zXFxjb21taXRzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGhlYWRlci5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxmaWxlcy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxtb2RhbC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFx0b29sYmFyLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXG1ldGFkYXRhLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcZGVlcG1lcmdlXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzaWRlYmFyXFxvcmdzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGxpXFxyZXBvLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcbW9kZWxzXFxicmFuY2guanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXGNvbW1vbi5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcZXhjZXB0aW9uLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcbW9kZWxzXFxmb2xkZXIuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcYXBwXFxtb2RlbHNcXGNvbW1pdC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzb24tZm9ybVxcbGliXFxqc29uZm9ybS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1yZXNvbHZlXFxidWlsdGluXFxmcy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzaWRlYmFyXFxicmFuY2hlcy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzaWRlYmFyXFxoaXN0b3J5LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXHNpZGViYXJcXGRyYWZ0cy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzaWRlYmFyXFxzYXZlLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXHNpZGViYXJcXHNldHRpbmdzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGxpXFxmaWxlLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXGxpXFxmb2xkZXIuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHNjaGVtYS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxccmVxdWlyZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcbG9hZGVyLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxkdW1wZXIuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHNjaGVtYVxcanNvbi5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcc2NoZW1hXFxmYWlsc2FmZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcc2NoZW1hXFxkZWZhdWx0X3NhZmUuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHNjaGVtYVxcZGVmYXVsdF9mdWxsLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxzY2hlbWFcXGNvcmUuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxjaG9zZW4tanF1ZXJ5LWJyb3dzZXJpZnlcXGluZGV4LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcY29sbGVjdGlvbnNcXGZpbGVzLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcaWdub3JlXFxpbmRleC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxhcHBcXHZpZXdzXFxzaWRlYmFyXFxicmFuY2guanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXG1hcmsuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGluc2VydC1tb2R1bGUtZ2xvYmFsc1xcbm9kZV9tb2R1bGVzXFxwcm9jZXNzXFxicm93c2VyLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXJlc29sdmVcXGJ1aWx0aW5cXGV2ZW50cy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1yZXNvbHZlXFxidWlsdGluXFx1dGlsLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXJlc29sdmVcXGJ1aWx0aW5cXGFzc2VydC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcbnVsbC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcYm9vbC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcaW50LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxmbG9hdC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcc3RyLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxzZXEuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXG1hcC5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcdGltZXN0YW1wLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxtZXJnZS5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcYmluYXJ5LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxvbWFwLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxwYWlycy5qcyIsIkM6XFxVc2Vyc1xcRktcXERvY3VtZW50c1xcR2l0SHViXFxFYXRlcm5pdHktRGF0YWJhc2VcXHByb3NlXFxub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcc2V0LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxqc1xcdW5kZWZpbmVkLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxqc1xccmVnZXhwLmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXGFwcFxcdmlld3NcXHNpZGViYXJcXGxpXFxjb21taXQuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcmVzb2x2ZVxcbm9kZV9tb2R1bGVzXFxidWZmZXItYnJvd3NlcmlmeVxcYnVmZmVyX2llZWU3NTQuanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcmVzb2x2ZVxcbm9kZV9tb2R1bGVzXFxidWZmZXItYnJvd3NlcmlmeVxcaW5kZXguanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcmVzb2x2ZVxcbm9kZV9tb2R1bGVzXFxidWZmZXItYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxiYXNlNjQtanNcXGxpYlxcYjY0LmpzIiwiQzpcXFVzZXJzXFxGS1xcRG9jdW1lbnRzXFxHaXRIdWJcXEVhdGVybml0eS1EYXRhYmFzZVxccHJvc2VcXG5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxqc1xcZnVuY3Rpb24uanMiLCJDOlxcVXNlcnNcXEZLXFxEb2N1bWVudHNcXEdpdEh1YlxcRWF0ZXJuaXR5LURhdGFiYXNlXFxwcm9zZVxcbm9kZV9tb2R1bGVzXFxqcy15YW1sXFxub2RlX21vZHVsZXNcXGVzcHJpbWFcXGVzcHJpbWEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JuU0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3NDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5b0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalhBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3plQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hnSEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XCJsb2dpblwiOlwiQXV0aG9yaXplIG9uIEdpdEh1YlwiLFwiZG9jaGVhZGVyXCI6e1wiZWRpdGluZ1wiOlwiRWRpdGluZ1wiLFwiZXJyb3JcIjpcIkVycm9yXCIsXCJwcmV2aWV3XCI6XCJQcmV2aWV3aW5nXCJ9LFwibmF2aWdhdGlvblwiOntcIm5ld0ZpbGVcIjpcIk5ldyBGaWxlXCIsXCJlZGl0XCI6XCJFZGl0XCIsXCJwcmV2aWV3XCI6XCJQcmV2aWV3XCIsXCJzZXR0aW5nc1wiOlwiU2V0dGluZ3NcIixcIm1ldGFcIjpcIk1ldGEgRGF0YVwiLFwic2F2ZVwiOlwiU2F2ZVwiLFwibG9naW5cIjpcIkF1dGhvcml6ZSB3aXRoIEdpdEh1YlwiLFwiYWJvdXRcIjpcIkFib3V0XCIsXCJkZXZlbG9wXCI6XCJEZXZlbG9wZXJzXCIsXCJsb2dvdXRcIjpcIkxvZ291dFwiLFwibGFuZ3VhZ2VcIjpcIkxhbmd1YWdlXCJ9LFwidG9vbGJhclwiOntcImhlYWRpbmdcIjpcIkhlYWRpbmdcIixcInN1YkhlYWRpbmdcIjpcIlN1YiBIZWFkaW5nXCIsXCJsaW5rXCI6XCJJbnNlcnQgTGlua1wiLFwiaW1hZ2VcIjpcIkluc2VydCBJbWFnZVwiLFwiYm9sZFwiOlwiQm9sZFwiLFwiaXRhbGljXCI6XCJJdGFsaWNcIixcImJsb2NrcXVvdGVcIjpcIkJsb2NrcXVvdGVcIixcImxpc3RcIjpcIkxpc3RcIixcIm51bWJlcmVkbGlzdFwiOlwiTnVtYmVyZWQgTGlzdFwiLFwiaGVscFwiOlwiSGVscFwifSxcImhlYWRpbmdcIjp7XCJleHBsb3JlXCI6XCJFeHBsb3JlIFByb2plY3RzXCJ9LFwiYWN0aW9uc1wiOntcInVuc2F2ZWRcIjpcIllvdSBoYXZlIHVuc2F2ZWQgQ2hhbmdlcy4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGxlYXZlP1wiLFwiZHJhZnRcIjp7XCJ0b1Bvc3RcIjpcIkRyYWZ0IHRvIFBvc3RcIixcInRvUG9zdEluZm9cIjpcIkNvbnZlcnQgdGhpcyBkcmFmdCBpbnRvIGEgcHVibGlzaGVkIHBvc3RcIn0sXCJwdWJsaXNoaW5nXCI6e1wicHVibGlzaFwiOlwiUHVibGlzaFwiLFwicHVibGlzaEluZm9cIjpcIlRoaXMgcG9zdCB3aWxsIGJlIHB1Ymxpc2hlZCB0aGUgbmV4dCB0aW1lIHlvdSBzYXZlXCIsXCJwdWJsaXNoZWRcIjpcIlB1Ymxpc2hlZFwiLFwidW5wdWJsaXNoXCI6XCJVbnB1Ymxpc2hcIixcInVucHVibGlzaGVkXCI6XCJVbnB1Ymxpc2hlZFwiLFwidW5wdWJsaXNoSW5mb1wiOlwiVGhpcyBwb3N0IHdpbGwgYmUgdW5wdWJsaXNoZWQgdGhlIG5leHQgdGltZSB5b3Ugc2F2ZVwifSxcImNoYW5nZVwiOntcIm5vQ2hhbmdlXCI6XCJObyBDaGFuZ2VzXCIsXCJzdWJtaXRcIjpcIkNoYW5nZXMgdG8gU3VibWl0XCIsXCJzYXZlXCI6XCJDaGFuZ2VzIHRvIFNhdmVcIn0sXCJkZWxldGVcIjp7XCJ0aXRsZVwiOlwiRGVsZXRlXCIsXCJ3YXJuXCI6XCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgZmlsZT9cIixcImVycm9yXCI6XCJFcnJvciBkdXJpbmcgZGVsZXRpb24uIFBsZWFzZSB3YWl0IDMwIHNlY29uZHMgYW5kIHRyeSBhZ2Fpbi5cIn0sXCJ1cGxvYWRcIjp7XCJ1cGxvYWRpbmdcIjpcIlVwbG9hZGluZyB7ZmlsZX1cIixcInVwbG9hZGVkXCI6XCJVcGxvYWRlZCB7ZmlsZX1cIn0sXCJzYXZlXCI6e1widGl0bGVcIjpcIlNhdmVcIixcInNhdmVkXCI6XCJTYXZlZFwiLFwic2F2aW5nXCI6XCJTYXZpbmdcIixcInBhdGNoXCI6XCJTdWJtaXR0aW5nIFJlcXVlc3RcIixcImZpbGVOYW1lRXJyb3JcIjpcIk5lZWRzIGEgRmlsZW5hbWVcIixcInN1Ym1pc3Npb25cIjpcIlJlcXVlc3QgU3VibWl0dGVkXCIsXCJtZXRhRXJyb3JcIjpcIkVycm9yISBNZXRhZGF0YSBub3QgRm91bmRcIixcImZpbGVOYW1lRXhpc3RzXCI6XCJBIGZpbGVuYW1lIHdpdGggdGhpcyBwYXRoIGFscmVhZHkgZXhpc3RzXCJ9LFwiZXJyb3JcIjpcIkVycm9yLiBUcnkgYWdhaW4gaW4gMzAgU2Vjb25kc1wiLFwicmVzdG9yZVwiOntcInJlc3RvcmluZ1wiOlwiUmVzdG9yaW5nXCIsXCJyZXN0b3JlZFwiOlwiUmVzdG9yZWRcIn0sXCJjb21taXRzXCI6e1wiY3JlYXRlZFwiOlwiQ3JlYXRlZCB7ZmlsZW5hbWV9XCIsXCJ1cGRhdGVkXCI6XCJVcGRhdGVkIHtmaWxlbmFtZX1cIixcImRlbGV0ZWRcIjpcIkRlbGV0ZWQge2ZpbGVuYW1lfVwiLFwidG9EcmFmdFwiOlwiQ3JlYXRlZCBkcmFmdCBvZiB7ZmlsZW5hbWV9XCIsXCJmcm9tRHJhZnRcIjpcIkNyZWF0ZWQgcG9zdCBmcm9tIGEgZHJhZnQgb2Yge2ZpbGVuYW1lfVwifX0sXCJsb2FkaW5nXCI6e1wicmVwb3NcIjpcIkxvYWRpbmcgUHJvZmlsZVwiLFwicmVwb1wiOlwiTG9hZGluZyBQcm9qZWN0XCIsXCJmaWxlXCI6XCJMb2FkaW5nIEZpbGVcIixcInByZXZpZXdcIjpcIlByZXZpZXdpbmcgRmlsZVwiLFwiY3JlYXRpbmdcIjpcIkNyZWF0aW5nIG5ldyBwb3N0XCJ9LFwibW9kYWxcIjp7XCJlcnJvckhlYWRpbmdcIjpcIkVycm9yXCIsXCJjb25maXJtXCI6XCJHb3QgaXRcIn0sXCJtYWluXCI6e1wic3RhcnRcIjp7XCJjb250ZW50XCI6XCJQcm9zZSBpcyBhIGNvbnRlbnQgZWRpdG9yIGZvciBHaXRIdWIgZGVzaWduZWQgZm9yIG1hbmFnaW5nIHdlYnNpdGVzLlwiLFwibGVhcm5cIjpcIkxlYXJuIG1vcmVcIn0sXCJyZXBvc1wiOntcImZpbHRlclwiOlwiRmlsdGVyIFByb2plY3RzXCIsXCJyZXBvXCI6XCJWaWV3IFByb2plY3RcIixcInNpdGVcIjpcIlZpZXcgU2l0ZVwiLFwic2hhcmVkRnJvbVwiOlwiU2hhcmVkIGZyb20gYW4gYWNjb3VudFwiLFwiZm9ya2VkRnJvbVwiOlwiRm9ya2VkIGZyb20gYW5vdGhlciBwcm9qZWN0XCJ9LFwicmVwb1wiOntcImZpbHRlclwiOlwiRmlsdGVyIEZpbGVzXCIsXCJlZGl0XCI6XCJFZGl0XCIsXCJkZWxldGVcIjpcIkRlbGV0ZSB0aGlzIEZpbGVcIn0sXCJuZXdcIjp7XCJib2R5XCI6XCIjIyBBIE5ldyBQb3N0XFxuXFxuRW50ZXIgdGV4dCBpbiBbTWFya2Rvd25dKGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vKS4gVXNlIHRoZSB0b29sYmFyIGFib3ZlLCBvciBjbGljayB0aGUgKio/KiogYnV0dG9uIGZvciBmb3JtYXR0aW5nIGhlbHAuXFxuXCJ9LFwiZmlsZVwiOntcIm5vVGl0bGVcIjpcIlVudGl0bGVkXCIsXCJtZXRhVGl0bGVcIjpcIlJldmlldyB5b3VyIGNoYW5nZXM6XCIsXCJyYXdNZXRhXCI6XCJSYXcgTWV0YWRhdGFcIixcIm1ldGFEZXNjcmlwdGlvblwiOlwiQWRkaXRpb25zIGFyZSBoaWdobGlnaHRlZCBpbiBncmVlbi4gRGVsZXRpb25zIGFyZSBjcm9zc2VkIG91dC5cIixcImJhY2tcIjpcIkRvbmVcIixcImNyZWF0ZU1ldGFcIjpcIkNyZWF0ZSBOZXdcIn0sXCJ1cGdyYWRlXCI6e1wiY29udGVudFwiOlwiUHJvc2UgcmVxdWlyZXMgZmVhdHVyZXMgbm90IGF2YWlsYWJsZSB0byB5b3VyIGJyb3dzZXJcIixcImRvd25sb2FkXCI6XCJEb3dubG9hZCBhIE1vZGVybiBCcm93c2VyXCJ9fSxcIm5vdGlmaWNhdGlvblwiOntcImxvZ2luRGVzY3JpcHRpb25cIjpcIlBsZWFzZSBsb2dpbiB3aXRoIHlvdXIgR2l0SHViIGFjY291bnQgdG8gYWNjZXNzIHRoYXQgcHJvamVjdC5cIixcImNyZWF0ZVwiOlwiQ3JlYXRlIGl0XCIsXCJob21lXCI6XCJCYWNrIHRvIE1haW4gUGFnZVwiLFwiYmFja1wiOlwiR28gQmFja1wiLFwiZ2l0aHViU3RhdHVzXCI6XCJTdGF0dXMgb24gR2l0SHViICh7c3RhdHVzfSlcIixcImVycm9yXCI6e1wibGFiZWxcIjpcIkVycm9yXCIsXCJnaXRodWJcIjpcIkVycm9yIHdoaWxlIGxvYWRpbmcgZGF0YSBmcm9tIEdpdEh1Yi4gVGhpcyBtaWdodCBiZSBhIHRlbXBvcmFyeSBpc3N1ZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIixcImV4aXN0c1wiOlwiVGhpcyBmaWxlIGRvZXMgbm90IGV4aXN0XCIsXCJub3RGb3VuZFwiOlwiUGFnZSBub3QgRm91bmRcIn19LFwic2lkZWJhclwiOntcInJlcG9zXCI6e1wiZ3JvdXBzXCI6XCJHcm91cHNcIn0sXCJyZXBvXCI6e1wiYnJhbmNoXCI6XCJTd2l0Y2ggQnJhbmNoXCIsXCJkcmFmdHNcIjpcIlZpZXcgRHJhZnRzXCIsXCJoaXN0b3J5XCI6e1wibGFiZWxcIjpcIk1vc3QgUmVjZW50IEhpc3RvcnlcIixcImFjdGlvbnNcIjp7XCJyZXN0b3JlXCI6XCJSZXN0b3JlP1wifX0sXCJjcmVhdGVcIjpcIkNyZWF0ZSBOZXcgRmlsZVwifSxcInNhdmVcIjp7XCJsYWJlbFwiOlwiRGVzY3JpYmUgeW91ciBDaGFuZ2VzXCIsXCJjYW5jZWxcIjpcIkNhbmNlbFwiLFwic2F2ZVwiOlwiQ29tbWl0XCIsXCJzdWJtaXRcIjpcIlN1Ym1pdCBDaGFuZ2UgUmVxdWVzdFwifSxcInNldHRpbmdzXCI6e1widGl0bGVcIjpcIk9wdGlvbnNcIixcImZpbGVJbnB1dExhYmVsXCI6XCJGaWxlIFBhdGhcIixcImRlbGV0ZVwiOlwiRGVsZXRlIFRoaXMgRmlsZVwiLFwidHJhbnNsYXRlXCI6XCJUcmFuc2xhdGUgdG9cIixcImRyYWZ0XCI6XCJDcmVhdGUgRHJhZnRcIn19LFwiZGlhbG9nc1wiOntcImxpbmtcIjp7XCJ0aXRsZVwiOlwiSW5zZXJ0IExpbmtcIixcImluc2VydExvY2FsXCI6XCJJbnNlcnQgYSBMb2NhbCBMaW5rXCIsXCJpbnNlcnRcIjpcIkluc2VydFwiLFwiaHJlZlBsYWNlaG9sZGVyXCI6XCJMaW5rIFVSTFwiLFwidGV4dFBsYWNlaG9sZGVyXCI6XCJMaW5rIE5hbWVcIixcInRpdGxlUGxhY2Vob2xkZXJcIjpcIlRpdGxlIChvcHRpb25hbClcIixcImluc2VydFBsYWNlaG9sZGVyXCI6XCJJbnNlcnQgYSBsb2NhbCBsaW5rXCJ9LFwibWVkaWFcIjp7XCJ0aXRsZVwiOlwiSW5zZXJ0IEltYWdlXCIsXCJiYWNrXCI6XCJCYWNrXCIsXCJocmVmUGxhY2Vob2xkZXJcIjpcIkltYWdlIFVSTFwiLFwiYWx0UGxhY2Vob2xkZXJcIjpcIkFsdCB0ZXh0IChvcHRpb25hbClcIixcImRlc2NyaXB0aW9uXCI6XCJVcGxvYWQgaW1hZ2VzIGJ5IERyYWdnaW5nICZhbXA7IERyb3BwaW5nIG9yIDwvYnI+XFxue2lucHV0fSA8YT5zZWxlY3Rpbmcgb25lPC9hPlxcblwiLFwiaGVscFwiOlwiSW1hZ2VzIHVwbG9hZGVkIGFyZSBhZGRlZCB0byB0aGUgY3VycmVudCBkaXJlY3Rvcnkgb3Igb25lIHNwZWNpZmllZCBpbiB0aGUgSW1hZ2UgVVJMIHBhdGggYWJvdmUuXCIsXCJoZWxwTWVkaWFcIjpcIkltYWdlcyB1cGxvYWRlZCBhcmUgYWRkZWQgdG8gdGhlICdDaG9vc2UgRXhpc3RpbmcnIGRpcmVjdG9yeSBvciBvbmUgc3BlY2lmaWVkIGluIHRoZSBJbWFnZSBVUkwgZmllbGQuXCIsXCJjaG9vc2VcIjpcIkNob29zZSBFeGlzdGluZ1wifSxcImhlbHBcIjp7XCJibG9ja0VsZW1lbnRzXCI6e1widGl0bGVcIjpcIkJsb2NrIEVsZW1lbnRzXCIsXCJjb250ZW50XCI6e1wicGFyYWdyYXBoc1wiOntcInRpdGxlXCI6XCJQYXJhZ3JhcGhzICZhbXA7IEJyZWFrc1wiLFwiY29udGVudFwiOlwiPHA+VG8gY3JlYXRlIGEgcGFyYWdyYXBoLCBzaW1wbHkgY3JlYXRlIGEgYmxvY2sgb2YgdGV4dCB0aGF0IGlzIHNlcGFyYXRlZCBieSBvbmUgb3IgbW9yZSBibGFuayBsaW5lcy4gQmxvY2tzIG9mIHRleHQgc2VwYXJhdGVkIGJ5IG9uZSBvciBtb3JlIGJsYW5rIGxpbmVzIHdpbGwgYmUgcGFyc2VkIGFzIHBhcmFncmFwaHMuPC9wPjxwPklmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGxpbmUgYnJlYWssIGVuZCBhIGxpbmUgd2l0aCB0d28gb3IgbW9yZSBzcGFjZXMsIHRoZW4gaGl0IFJldHVybi9FbnRlci48L3A+XFxuXCJ9LFwiaGVhZGVyc1wiOntcInRpdGxlXCI6XCJIZWFkZXJzXCIsXCJjb250ZW50XCI6XCI8cD5NYXJrZG93biBzdXBwb3J0cyB0d28gaGVhZGVyIGZvcm1hdHMuIFRoZSB3aWtpIGVkaXRvciB1c2VzIHRoZSAmbGRxdW87YXR4JnJzcXVvOy1zdHlsZSBoZWFkZXJzLiBTaW1wbHkgcHJlZml4IHlvdXIgaGVhZGVyIHRleHQgd2l0aCB0aGUgbnVtYmVyIG9mIDxjb2RlPiM8L2NvZGU+IGNoYXJhY3RlcnMgdG8gc3BlY2lmeSBoZWFkaW5nIGRlcHRoLiBGb3IgZXhhbXBsZTogPGNvZGU+IyBIZWFkZXIgMTwvY29kZT4sIDxjb2RlPiMjIEhlYWRlciAyPC9jb2RlPiBhbmQgPGNvZGU+IyMjIEhlYWRlciAzPC9jb2RlPiB3aWxsIGJlIHByb2dyZXNzaXZlbHkgc21hbGxlciBoZWFkZXJzLiBZb3UgbWF5IGVuZCB5b3VyIGhlYWRlcnMgd2l0aCBhbnkgbnVtYmVyIG9mIGhhc2hlcy48L3A+XFxuXCJ9LFwiYmxvY2txdW90ZXNcIjp7XCJ0aXRsZVwiOlwiQmxvY2txdW90ZXNcIixcImNvbnRlbnRcIjpcIjxwPk1hcmtkb3duIGNyZWF0ZXMgYmxvY2txdW90ZXMgZW1haWwtc3R5bGUgYnkgcHJlZml4aW5nIGVhY2ggbGluZSB3aXRoIHRoZSA8Y29kZT4mZ3Q7PC9jb2RlPi4gVGhpcyBsb29rcyBiZXN0IGlmIHlvdSBkZWNpZGUgdG8gaGFyZC13cmFwIHRleHQgYW5kIHByZWZpeCBlYWNoIGxpbmUgd2l0aCBhIDxjb2RlPiZndDs8L2NvZGU+IGNoYXJhY3RlciwgYnV0IE1hcmtkb3duIHN1cHBvcnRzIGp1c3QgcHV0dGluZyA8Y29kZT4mZ3Q7PC9jb2RlPiBiZWZvcmUgeW91ciBwYXJhZ3JhcGguPC9wPlxcblwifSxcImxpc3RzXCI6e1widGl0bGVcIjpcIkxpc3RzXCIsXCJjb250ZW50XCI6XCI8cD5NYXJrZG93biBzdXBwb3J0cyBib3RoIG9yZGVyZWQgYW5kIHVub3JkZXJlZCBsaXN0cy4gVG8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdCwgc2ltcGx5IHByZWZpeCBlYWNoIGxpbmUgd2l0aCBhIG51bWJlciAoYW55IG51bWJlciB3aWxsIGRvICZtZGFzaDsgdGhpcyBpcyB3aHkgdGhlIGVkaXRvciBvbmx5IHVzZXMgb25lIG51bWJlci4pIFRvIGNyZWF0ZSBhbiB1bm9yZGVyZWQgbGlzdCwgeW91IGNhbiBwcmVmaXggZWFjaCBsaW5lIHdpdGggPGNvZGU+KjwvY29kZT4sIDxjb2RlPis8L2NvZGU+IG9yIDxjb2RlPi08L2NvZGU+LjwvcD4gTGlzdCBpdGVtcyBjYW4gY29udGFpbiBtdWx0aXBsZSBwYXJhZ3JhcGhzLCBob3dldmVyIGVhY2ggcGFyYWdyYXBoIG11c3QgYmUgaW5kZW50ZWQgYnkgYXQgbGVhc3QgNCBzcGFjZXMgb3IgYSB0YWIuXFxuXCJ9LFwiY29kZUJsb2Nrc1wiOntcInRpdGxlXCI6XCJDb2RlIEJsb2Nrc1wiLFwiY29udGVudFwiOlwiPHA+TWFya2Rvd24gd3JhcHMgY29kZSBibG9ja3MgaW4gcHJlLWZvcm1hdHRlZCB0YWdzIHRvIHByZXNlcnZlIGluZGVudGF0aW9uIGluIHlvdXIgY29kZSBibG9ja3MuIFRvIGNyZWF0ZSBhIGNvZGUgYmxvY2ssIGluZGVudCB0aGUgZW50aXJlIGJsb2NrIGJ5IGF0IGxlYXN0IDQgc3BhY2VzIG9yIG9uZSB0YWIuIE1hcmtkb3duIHdpbGwgc3RyaXAgdGhlIGV4dHJhIGluZGVudGF0aW9uIHlvdSZyc3F1bzt2ZSBhZGRlZCB0byB0aGUgY29kZSBibG9jay48L3A+XFxuXCJ9LFwiaG9yaXpvbnRhbFJ1bGVzXCI6e1widGl0bGVcIjpcIkhvcml6b250YWwgUnVsZXNcIixcImNvbnRlbnRcIjpcIjxwPkhvcml6b250YWwgcnVsZXMgYXJlIGNyZWF0ZWQgYnkgcGxhY2luZyB0aHJlZSBvciBtb3JlIGh5cGhlbnMsIGFzdGVyaXNrcyBvciB1bmRlcnNjb3JlcyBvbiBhIGxpbmUgYnkgdGhlbXNlbHZlcy4gU3BhY2VzIGFyZSBhbGxvd2VkIGJldHdlZW4gdGhlIGh5cGhlbnMsIGFzdGVyaXNrcyBvciB1bmRlcnNjb3Jlcy48L3A+XFxuXCJ9fX0sXCJzcGFuRWxlbWVudHNcIjp7XCJ0aXRsZVwiOlwiU3BhbiBFbGVtZW50c1wiLFwiY29udGVudFwiOntcImxpbmtzXCI6e1widGl0bGVcIjpcIkxpbmtzXCIsXCJjb250ZW50XCI6XCI8cD5NYXJrZG93biBoYXMgdHdvIHR5cGVzIG9mIGxpbmtzOiA8c3Ryb25nPmlubGluZTwvc3Ryb25nPiBhbmQgPHN0cm9uZz5yZWZlcmVuY2U8L3N0cm9uZz4uIEZvciBib3RoIHR5cGVzIG9mIGxpbmtzLCB0aGUgdGV4dCB5b3Ugd2FudCB0byBkaXNwbGF5IHRvIHRoZSB1c2VyIGlzIHBsYWNlZCBpbiBzcXVhcmUgYnJhY2tldHMuIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB5b3VyIGxpbmsgdG8gZGlzcGxheSB0aGUgdGV4dCAmbGRxdW87R2l0SHViJnJkcXVvOywgeW91IHdyaXRlIDxjb2RlPltHaXRIdWJdPC9jb2RlPi48L3A+PHA+VG8gY3JlYXRlIGFuIGlubGluZSBsaW5rLCBjcmVhdGUgYSBzZXQgb2YgcGFyZW50aGVzZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGJyYWNrZXRzIGFuZCB3cml0ZSB5b3VyIFVSTCB3aXRoaW4gdGhlIHBhcmVudGhlc2VzLiAoZS5nLiwgPGNvZGU+W0dpdEh1Yl0oaHR0cDovL2dpdGh1Yi5jb20vKTwvY29kZT4pLiBSZWxhdGl2ZSBwYXRocyBhcmUgYWxsb3dlZCBpbiBpbmxpbmUgbGlua3MuPC9wPjxwPlRvIGNyZWF0ZSBhIHJlZmVyZW5jZSBsaW5rLCB1c2UgdHdvIHNldHMgb2Ygc3F1YXJlIGJyYWNrZXRzLiA8Y29kZT5bbXkgaW50ZXJuYWwgbGlua11baW50ZXJuYWwtcmVmXTwvY29kZT4gd2lsbCBsaW5rIHRvIHRoZSBpbnRlcm5hbCByZWZlcmVuY2UgPGNvZGU+aW50ZXJuYWwtcmVmPC9jb2RlPi48L3A+XFxuXCJ9LFwiZW1waGFzaXNcIjp7XCJ0aXRsZVwiOlwiRW1waGFzaXNcIixcImNvbnRlbnRcIjpcIjxwPkFzdGVyaXNrcyAoPGNvZGU+KjwvY29kZT4pIGFuZCB1bmRlcnNjb3JlcyAoPGNvZGU+XzwvY29kZT4pIGFyZSB0cmVhdGVkIGFzIGVtcGhhc2lzIGFuZCBhcmUgd3JhcHBlZCB3aXRoIGFuIDxjb2RlPiZsdDtlbSZndDs8L2NvZGU+IHRhZywgd2hpY2ggdXN1YWxseSBkaXNwbGF5cyBhcyBpdGFsaWNzIGluIG1vc3QgYnJvd3NlcnMuIERvdWJsZSBhc3Rlcmlza3MgKDxjb2RlPioqPC9jb2RlPikgb3IgZG91YmxlIHVuZGVyc2NvcmVzICg8Y29kZT5fXzwvY29kZT4pIGFyZSB0cmVhdGVkIGFzIGJvbGQgdXNpbmcgdGhlIDxjb2RlPiZsdDtzdHJvbmcmZ3Q7PC9jb2RlPiB0YWcuIFRvIGNyZWF0ZSBpdGFsaWMgb3IgYm9sZCB0ZXh0LCBzaW1wbHkgd3JhcCB5b3VyIHdvcmRzIGluIHNpbmdsZS9kb3VibGUgYXN0ZXJpc2tzL3VuZGVyc2NvcmVzLiBGb3IgZXhhbXBsZSwgPGNvZGU+KipNeSBkb3VibGUgZW1waGFzaXMgdGV4dCoqPC9jb2RlPiBiZWNvbWVzIDxzdHJvbmc+TXkgZG91YmxlIGVtcGhhc2lzIHRleHQ8L3N0cm9uZz4sIGFuZCA8Y29kZT4qTXkgc2luZ2xlIGVtcGhhc2lzIHRleHQqPC9jb2RlPiBiZWNvbWVzIDxlbT5NeSBzaW5nbGUgZW1waGFzaXMgdGV4dDwvZW0+LjwvcD5cXG5cIn0sXCJjb2RlXCI6e1widGl0bGVcIjpcIkNvZGVcIixcImNvbnRlbnRcIjpcIjxwPlRvIGNyZWF0ZSBpbmxpbmUgc3BhbnMgb2YgY29kZSwgc2ltcGx5IHdyYXAgdGhlIGNvZGUgaW4gYmFja3RpY2tzICg8Y29kZT5gPC9jb2RlPikuIE1hcmtkb3duIHdpbGwgdHVybiA8Y29kZT5gbXlGdW5jdGlvbmA8L2NvZGU+IGludG8gPGNvZGU+bXlGdW5jdGlvbjwvY29kZT4uPC9wPlxcblwifSxcImltYWdlc1wiOntcInRpdGxlXCI6XCJJbWFnZXNcIixcImNvbnRlbnRcIjpcIjxwPk1hcmtkb3duIGltYWdlIHN5bnRheCBsb29rcyBhIGxvdCBsaWtlIHRoZSBzeW50YXggZm9yIGxpbmtzOyBpdCBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBzeW50YXggcHJlY2VkZWQgYnkgYW4gZXhjbGFtYXRpb24gcG9pbnQgKDxjb2RlPiE8L2NvZGU+KS4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIGxpbmsgdG8gYW4gaW1hZ2UgYXQgPGNvZGU+aHR0cDovL2dpdGh1Yi5jb20vdW5pY29ybi5wbmc8L2NvZGU+IHdpdGggdGhlIGFsdGVybmF0ZSB0ZXh0IDxjb2RlPk15IFVuaWNvcm48L2NvZGU+LCB5b3Ugd291bGQgd3JpdGUgPGNvZGU+IVtNeSBVbmljb3JuXShodHRwOi8vZ2l0aHViLmNvbS91bmljb3JuLnBuZyk8L2NvZGU+LjwvcD5cXG5cIn19fSxcIm1pc2NlbGxhbmVvdXNcIjp7XCJ0aXRsZVwiOlwiTWlzY2VsbGFuZW91c1wiLFwiY29udGVudFwiOntcImF1dG9tYXRpY0xpbmtzXCI6e1widGl0bGVcIjpcIkF1dG9tYXRpYyBMaW5rc1wiLFwiY29udGVudFwiOlwiPHA+SWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbGluayB0aGF0IGRpc3BsYXlzIHRoZSBhY3R1YWwgVVJMLCBNYXJrZG93biBhbGxvd3MgeW91IHRvIHF1aWNrbHkgd3JhcCB0aGUgVVJMIGluIDxjb2RlPiZsdDs8L2NvZGU+IGFuZCA8Y29kZT4mZ3Q7PC9jb2RlPiB0byBkbyBzby4gRm9yIGV4YW1wbGUsIHRoZSBsaW5rIDxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPmh0dHA6Ly9naXRodWIuY29tLzwvYT4gaXMgZWFzaWx5IHByb2R1Y2VkIGJ5IHdyaXRpbmcgPGNvZGU+Jmx0O2h0dHA6Ly9naXRodWIuY29tLyZndDs8L2NvZGU+LjwvcD5cXG5cIn0sXCJlc2NhcGluZ1wiOntcInRpdGxlXCI6XCJFc2NhcGluZ1wiLFwiY29udGVudFwiOlwiPHA+SWYgeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lhbCBNYXJrZG93biBjaGFyYWN0ZXIgaW4geW91ciBkb2N1bWVudCAoc3VjaCBhcyBkaXNwbGF5aW5nIGxpdGVyYWwgYXN0ZXJpc2tzKSwgeW91IGNhbiBlc2NhcGUgdGhlIGNoYXJhY3RlciB3aXRoIHRoZSBiYWNrc2xhc2ggKDxjb2RlPlxcXFxcXFxcPC9jb2RlPikuIE1hcmtkb3duIHdpbGwgaWdub3JlIHRoZSBjaGFyYWN0ZXIgZGlyZWN0bHkgYWZ0ZXIgYSBiYWNrc2xhc2guPC9wPlxcblwifX19fX0sXCJjaG9vc2VsYW5ndWFnZVwiOntcInRpdGxlXCI6XCJDaG9vc2UgYSBMYW5ndWFnZVwiLFwiZGVzY3JpcHRpb25cIjpcIlByb3NlIGlzIGEgdHJhbnNsYXRlZCBhcHBsaWNhdGlvbi4gSWYgeW91IGRvbid0IHNlZSB5b3VyIGxhbmd1YWdlIGluIHRoZSBsaXN0LCB0aGVyZSBhcmUgc3BlbGxpbmcgZXJyb3JzLCBvciB0cmFuc2xhdGlvbnMgYXJlIG1pc3NpbmcsIGNvbnNpZGVyIDxhIGhyZWY9J2h0dHBzOi8vd3d3LnRyYW5zaWZleC5jb20vcHJvamVjdHMvcC9wcm9zZSc+Y29udHJpYnV0aW5nIHRyYW5zbGF0aW9ucyB0byB0aGUgcHJvamVjdDwvYT4uXFxuXCJ9LFwiYWJvdXRcIjp7XCJjb250ZW50XCI6XCIjIEFib3V0XFxuUHJvc2UgcHJvdmlkZXMgYSBiZWF0aWZ1bGx5IHNpbXBsZSBjb250ZW50IGF1dGhvcmluZyBlbnZpcm9ubWVudCBmb3JcXG5bQ01TLWZyZWUgd2Vic2l0ZXNdKGh0dHA6Ly9kZXZlbG9wbWVudHNlZWQub3JnL2Jsb2cvMjAxMi8wNy8yNy9idWlsZC1jbXMtZnJlZS13ZWJzaXRlcy8pLlxcbkl0J3MgYSB3ZWItYmFzZWQgaW50ZXJmYWNlIGZvciBtYW5hZ2luZyBjb250ZW50IG9uXFxuW0dpdEh1Yl0oaHR0cDovL2dpdGh1Yi5jb20pLiBVc2UgaXQgdG8gY3JlYXRlLCBlZGl0LCBhbmQgZGVsZXRlIGZpbGVzLFxcbmFuZCBzYXZlIHlvdXIgY2hhbmdlcyBkaXJlY3RseSB0byBHaXRIdWIuIEhvc3QgeW91ciB3ZWJzaXRlIG9uXFxuW0dpdEh1YiBQYWdlc10oaHR0cDovL3BhZ2VzLmdpdGh1Yi5jb20pIGZvciBmcmVlLCBvciBzZXQgdXAgeW91ciBvd25cXG5bR2l0SHViIHdlYmhvb2sgc2VydmVyXShodHRwOi8vZGV2ZWxvcG1lbnRzZWVkLm9yZy9ibG9nLzIwMTMvMDUvMDEvaW50cm9kdWNpbmctamVreWxsLWhvb2svKS5cXG5cXG5Qcm9zZSBoYXMgYWR2YW5jZWQgc3VwcG9ydCBmb3IgW0pla3lsbF0oaHR0cDovL2pla3lsbHJiLmNvbS8pIHNpdGVzIGFuZFxcblttYXJrZG93biBjb250ZW50XShodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duLykuXFxuUHJvc2UgZGV0ZWN0cyBtYXJrZG93biBwb3N0cyBpbiBKZWt5bGwgc2l0ZXMgYW5kIHByb3ZpZGVzIHN5bnRheFxcbmhpZ2hsaWdodGluZywgYSBmb3JtYXR0aW5nIHRvb2xiYXIsIGFuZCBkcmFmdCBwcmV2aWV3cyBpbiB0aGUgc2l0ZSdzXFxuZnVsbCBsYXlvdXQuXFxuXFxuRGV2ZWxvcGVycyBjYW4gY29uZmlndXJlIEpla3lsbCBzaXRlcyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGVzZSBhbmRcXG5tYW55IG1vcmUgZmVhdHVyZXMgdGhhdCBjdXN0b21pemUgdGhlIGNvbnRlbnQgZWRpdGluZyBleHBlcmllbmNlLlxcblxcbiMjIENvbmZpZ3VyaW5nXFxuXFxuUHJvc2UgY2FuIGJlIGNvbmZpZ3VyZWQgcGVyIHJlcG9zaXRvcnkgd2l0aCBhZGRpdGlvbmFsIG1ldGFkYXRhIGluIGFcXG5KZWt5bGwgc2l0ZSdzIGBfY29uZmlnLnltbGAgZmlsZSBvciBhIHNlcGFyYXRlIGBwcm9zZS55bWxgIGZpbGUuIFdlIG9mZmVyXFxuUHJvc2UuaW8gYXMgYSBob3N0ZWQgc2VydmljZSBmb3IgdGhlIGxhdGVzdCB2ZXJzaW9uLCBvciB5b3UgY2FuIGRvd25sb2FkXFxudGhlIHNvdXJjZSBjb2RlIGFuZCBob3N0IGl0IG9uIHlvdXIgb3duLiBGb3IgZm9yIGRldmVsb3BlciBkb2N1bWVudGF0aW9uLFxcbnNlZSBbdGhlIHdpa2kgcGFnZSBvbiBHaXRIdWJdKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9zZS9wcm9zZS93aWtpKS5cXG5cXG4jIyBEZXZlbG9waW5nXFxuXFxuUHJvc2UgaXMgYW4gb3BlbiBzb3VyY2UgcHJvamVjdC4gV2UgZW5jb3VyYWdlIHlvdSB0byBjb250cmlidXRlIGFuZFxcbmhlbHAgdXMgaW1wcm92ZSB0aGlzIGFwcGxpY2F0aW9uIG9yIGFkYXB0IGl0IHRvIHlvdXIgbmVlZHMuIEZvclxcbmluc3RydWN0aW9ucyBvbiBkZXZlbG9waW5nIFByb3NlLCBzZWUgdGhlXFxuW1Byb3NlIGNvbnRyaWJ1dGluZyBndWlkZWxpbmVzXShodHRwczovL2dpdGh1Yi5jb20vcHJvc2UvcHJvc2UvYmxvYi9naC1wYWdlcy9DT05UUklCVVRJTkcubWQpLlxcblxcbiMjIEdldHRpbmcgSGVscFxcblxcbldlIGRvIG5vdCBvZmZlciBzdXBwb3J0IGZvciBQcm9zZSBhdCB0aGlzIHRpbWUsIGhvd2V2ZXIgaWYgeW91IGFyZSBhXFxuY29udGVudCBlZGl0b3IgdXNpbmcgUHJvc2UsIHlvdSBzaG91bGQgY29udGFjdCB0aGUgZGV2ZWxvcGVyIHdobyBnYXZlXFxueW91IGFjY2VzcyB0byBpdC4gVG8gcmVwb3J0IHRlY2huaWNhbCBwcm9ibGVtcyB3aXRoIFByb3NlLCBwbGVhc2VcXG5bZmlsZSBhbiBpc3N1ZSBvbiBHaXRIdWJdKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9zZS9wcm9zZS9pc3N1ZXMpLlxcblxcbiMjIENyZWRpdHNcXG5cXG5Qcm9zZSBpcyBkZXZlbG9wZWQgYW5kIG1haW50YWluZWQgYnlcXG5bRGV2ZWxvcG1lbnQgU2VlZF0oaHR0cDovL2RldmVsb3BtZW50c2VlZC5vcmcpLCBhIGNyZWF0aXZlIGRhdGFcXG52aXN1YWxpemF0aW9uIGFuZCBtYXBwaW5nIHRlYW0gYmFzZWQgaW4gV2FzaGluZ3RvbiwgREMuXFxuXCJ9fTsiLCIvLyBBdXRvbWF0aWNhbGx5IEdlbmVyYXRlZFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBbe1wibmFtZVwiOlwiQ2hpbmVzZVwiLFwiY29kZVwiOlwiemhcIn0se1wibmFtZVwiOlwiRHV0Y2hcIixcImNvZGVcIjpcIm5sXCJ9LHtcIm5hbWVcIjpcIkVuZ2xpc2hcIixcImNvZGVcIjpcImVuXCJ9LHtcIm5hbWVcIjpcIkZyZW5jaFwiLFwiY29kZVwiOlwiZnJcIn0se1wibmFtZVwiOlwiR2VybWFuXCIsXCJjb2RlXCI6XCJkZVwifSx7XCJuYW1lXCI6XCJIZWJyZXcgKElzcmFlbClcIixcImNvZGVcIjpcImhlLUlMXCJ9LHtcIm5hbWVcIjpcIkl0YWxpYW5cIixcImNvZGVcIjpcIml0XCJ9LHtcIm5hbWVcIjpcIlBvcnR1Z3Vlc2UgKEJyYXppbClcIixcImNvZGVcIjpcInB0LUJSXCJ9LHtcIm5hbWVcIjpcIlJvbWFuaWFuXCIsXCJjb2RlXCI6XCJyb1wifSx7XCJuYW1lXCI6XCJSdXNzaWFuXCIsXCJjb2RlXCI6XCJydVwifSx7XCJuYW1lXCI6XCJTcGFuaXNoXCIsXCJjb2RlXCI6XCJlc1wifSx7XCJuYW1lXCI6XCJTd2VkaXNoXCIsXCJjb2RlXCI6XCJzdlwifSx7XCJuYW1lXCI6XCJWaWV0bmFtZXNlXCIsXCJjb2RlXCI6XCJ2aVwifV07IiwiZnVuY3Rpb24gdHJ5UGFyc2Uob2JqKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKG9iaik7XHJcbiAgfSBjYXRjaChlKSB7fVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkob2JqKSB7XHJcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFKU09OLnN0cmluZ2lmeSkgcmV0dXJuIG9iajtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxufVxyXG5cclxudmFyIGNvb2tpZSA9IHt9O1xyXG5cclxuY29va2llLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4pIHtcclxuICB2YXIgcGFpciA9IGVzY2FwZShuYW1lKSArICc9JyArIGVzY2FwZSh0cnlTdHJpbmdpZnkodmFsdWUpKTtcclxuXHJcbiAgaWYgKCEhZXhwaXJlcykge1xyXG4gICAgaWYgKGV4cGlyZXMuY29uc3RydWN0b3IgPT09IE51bWJlcikgcGFpciArPSAnO21heC1hZ2U9JyArIGV4cGlyZXM7XHJcbiAgICBlbHNlIGlmIChleHBpcmVzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHBhaXIgKz0gJztleHBpcmVzPScgKyBleHBpcmVzO1xyXG4gICAgZWxzZSBpZiAoZXhwaXJlcy5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkgIHBhaXIgKz0gJztleHBpcmVzPScgKyBleHBpcmVzLnRvVVRDU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBwYWlyICs9ICc7cGF0aD0nICsgKCghIXBhdGgpID8gcGF0aCA6ICcvJyk7XHJcbiAgaWYoISFkb21haW4pIHBhaXIgKz0gJztkb21haW49JyArIGRvbWFpbjtcclxuXHJcbiAgZG9jdW1lbnQuY29va2llID0gcGFpcjtcclxuICByZXR1cm4gY29va2llO1xyXG59O1xyXG5cclxuY29va2llLnNldE9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgZXhwaXJlLCBwYXRoLCBkb21haW4pIHtcclxuICBmb3IodmFyIGtleSBpbiBvYmplY3QpIGNvb2tpZS5zZXQoa2V5LCBvYmplY3Rba2V5XSwgZXhwaXJlcywgcGF0aCwgZG9tYWluKTtcclxuICByZXR1cm4gY29va2llO1xyXG59O1xyXG5cclxuY29va2llLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICB2YXIgb2JqID0gY29va2llLmdldE9iamVjdCgpO1xyXG4gIHJldHVybiBvYmpbbmFtZV07XHJcbn07XHJcblxyXG5jb29raWUuZ2V0T2JqZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHBhaXJzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KC87XFxzPy9pKTtcclxuICB2YXIgb2JqZWN0ID0ge307XHJcbiAgdmFyIHBhaXI7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gcGFpcnMpIHtcclxuICAgIGlmICh0eXBlb2YgcGFpcnNbaV0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICBpZiAocGFpci5sZW5ndGggPD0gMSkgY29udGludWU7XHJcbiAgICAgIG9iamVjdFt1bmVzY2FwZShwYWlyWzBdKV0gPSB0cnlQYXJzZSh1bmVzY2FwZShwYWlyWzFdKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqZWN0O1xyXG59O1xyXG5cclxuY29va2llLnVuc2V0ID0gZnVuY3Rpb24obmFtZSkge1xyXG4gIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XHJcbiAgZG9jdW1lbnQuY29va2llID0gbmFtZSArICc9OyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7XHJcbiAgcmV0dXJuIGNvb2tpZTtcclxufTtcclxuXHJcbmNvb2tpZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBvYmogPSBjb29raWUuZ2V0T2JqZWN0KCk7XHJcbiAgZm9yKHZhciBrZXkgaW4gb2JqKSBjb29raWUudW5zZXQoa2V5KTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb29raWU7XHJcbiIsInZhciBjb29raWUgPSByZXF1aXJlKCcuL2Nvb2tpZScpO1xyXG52YXIgb2F1dGggPSByZXF1aXJlKCcuLi9vYXV0aC5qc29uJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBhcGk6IG9hdXRoLmFwaSB8fCAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbScsXHJcbiAgYXBpU3RhdHVzOiBvYXV0aC5zdGF0dXMgfHwgJ2h0dHBzOi8vc3RhdHVzLmdpdGh1Yi5jb20vYXBpL3N0YXR1cy5qc29uJyxcclxuICBzaXRlOiBvYXV0aC5zaXRlIHx8ICdodHRwczovL2dpdGh1Yi5jb20nLFxyXG4gIGlkOiBvYXV0aC5jbGllbnRJZCxcclxuICB1cmw6IG9hdXRoLmdhdGVrZWVwZXJVcmwsXHJcbiAgdXNlcm5hbWU6IGNvb2tpZS5nZXQoJ3VzZXJuYW1lJyksXHJcbiAgYXV0aDogJ29hdXRoJ1xyXG59O1xyXG4iLCIoZnVuY3Rpb24oKXt2YXIgTE9DQUxFUyA9IHJlcXVpcmUoJy4uL3RyYW5zbGF0aW9ucy9sb2NhbGVzJyk7XHJcbnZhciBlbiA9IHJlcXVpcmUoJy4uL2Rpc3QvZW4uanMnKTtcclxuXHJcbi8vIFNldCBsb2NhbGUgYXMgZ2xvYmFsIHZhcmlhYmxlXHJcbndpbmRvdy5sb2NhbGUuZW4gPSBlbjtcclxud2luZG93LmxvY2FsZS5jdXJyZW50KCdlbicpO1xyXG53aW5kb3cuYXBwID0ge307XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgUm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcclxudmFyIFVzZXIgPSByZXF1aXJlKCcuL21vZGVscy91c2VyJyk7XHJcbnZhciBOb3RpZmljYXRpb25WaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9ub3RpZmljYXRpb24nKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuL2Nvb2tpZScpO1xyXG52YXIgYXV0aCA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XHJcbnZhciBzdGF0dXMgPSByZXF1aXJlKCcuL3N0YXR1cycpO1xyXG5cclxuLy8gU2V0IHVwIHRyYW5zbGF0aW9uc1xyXG52YXIgc2V0TGFuZ3VhZ2UgPSAoY29va2llLmdldCgnbGFuZycpKSA/IHRydWUgOiBmYWxzZTtcclxuXHJcbi8vIENoZWNrIGlmIHRoZSBicm93c2VycyBsYW5ndWFnZSBpcyBzdXBwb3J0ZWRcclxuaWYgKHNldExhbmd1YWdlKSBhcHAubG9jYWxlID0gY29va2llLmdldCgnbGFuZycpO1xyXG5cclxuaWYgKGFwcC5sb2NhbGUgJiYgYXBwLmxvY2FsZSAhPT0gJ2VuJykge1xyXG4gICQuZ2V0SlNPTignLi90cmFuc2xhdGlvbnMvbG9jYWxlcy8nICsgYXBwLmxvY2FsZSArICcuanNvbicsIGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgd2luZG93LmxvY2FsZVthcHAubG9jYWxlXSA9IHJlc3VsdDtcclxuICAgIHdpbmRvdy5sb2NhbGUuY3VycmVudChhcHAubG9jYWxlKTtcclxuICB9KTtcclxufVxyXG5cclxudmFyIHVzZXIgPSBuZXcgVXNlcigpO1xyXG5cclxudXNlci5hdXRoZW50aWNhdGUoe1xyXG4gIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSB7XHJcbiAgICAgIC8vIFNldCBPQXV0aCBoZWFkZXIgZm9yIGFsbCBDT1JTIHJlcXVlc3RzXHJcbiAgICAgICQuYWpheFNldHVwKHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGNvbmZpZy5hdXRoID09PSAnb2F1dGgnID9cclxuICAgICAgICAgICAgJ3Rva2VuICcgKyBjb29raWUuZ2V0KCdvYXV0aC10b2tlbicpIDpcclxuICAgICAgICAgICAgJ0Jhc2ljICcgKyBCYXNlNjQuZW5jb2RlKGNvbmZpZy51c2VybmFtZSArICc6JyArIGNvbmZpZy5wYXNzd29yZClcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU2V0IGFuICdhdXRoZW50aWNhdGVkJyBjbGFzcyB0byAjcHJvc2VcclxuICAgICAgJCgnI3Byb3NlJykuYWRkQ2xhc3MoJ2F1dGhlbnRpY2F0ZWQnKTtcclxuXHJcbiAgICAgIC8vIFNldCBVc2VyIG1vZGVsIGlkIGFuZCBsb2dpbiBmcm9tIGNvb2tpZXNcclxuICAgICAgdmFyIGlkID0gY29va2llLmdldCgnaWQnKTtcclxuICAgICAgaWYgKGlkKSB1c2VyLnNldCgnaWQnLCBpZCk7XHJcblxyXG4gICAgICB2YXIgbG9naW4gPSBjb29raWUuZ2V0KCdsb2dpbicpO1xyXG4gICAgICBpZiAobG9naW4pIHVzZXIuc2V0KCdsb2dpbicsIGxvZ2luKTtcclxuXHJcbiAgICAgIHVzZXIuZmV0Y2goe1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgIC8vIFNldCBhdXRoZW50aWNhdGVkIHVzZXIgaWQgYW5kIGxvZ2luIGNvb2tpZXNcclxuICAgICAgICAgIGNvb2tpZS5zZXQoJ2lkJywgdXNlci5nZXQoJ2lkJykpO1xyXG4gICAgICAgICAgY29va2llLnNldCgnbG9naW4nLCB1c2VyLmdldCgnbG9naW4nKSk7XHJcblxyXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSByb3V0ZXJcclxuICAgICAgICAgIHdpbmRvdy5yb3V0ZXIgPSBuZXcgUm91dGVyKHsgdXNlcjogbW9kZWwgfSk7XHJcblxyXG4gICAgICAgICAgLy8gU3RhcnQgcmVzcG9uZGluZyB0byByb3V0ZXNcclxuICAgICAgICAgIEJhY2tib25lLmhpc3Rvcnkuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICB2YXIgYXBpU3RhdHVzID0gc3RhdHVzLmdpdGh1YkFwaShmdW5jdGlvbihyZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBOb3RpZmljYXRpb25WaWV3KHtcclxuICAgICAgICAgICAgICAnbWVzc2FnZSc6IHQoJ25vdGlmaWNhdGlvbi5lcnJvci5naXRodWInKSxcclxuICAgICAgICAgICAgICAnb3B0aW9ucyc6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogdCgnbm90aWZpY2F0aW9uLmJhY2snKSxcclxuICAgICAgICAgICAgICAgICAgJ2xpbmsnOiAnLydcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICd0aXRsZSc6IHQoJ25vdGlmaWNhdGlvbi5naXRodWJTdGF0dXMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAnbGluayc6ICcvL3N0YXR1cy5naXRodWIuY29tJyxcclxuICAgICAgICAgICAgICAgICAgJ2NsYXNzTmFtZSc6IHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgJCgnI3Byb3NlJykuaHRtbChlcnJvci5yZW5kZXIoKS5lbCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHVwZ3JhZGUgPSBuZXcgTm90aWZpY2F0aW9uVmlldyh7XHJcbiAgICAgICAgJ21lc3NhZ2UnOiB0KCdtYWluLnVwZ3JhZGUuY29udGVudCcpLFxyXG4gICAgICAgICdvcHRpb25zJzogW3tcclxuICAgICAgICAgICd0aXRsZSc6IHQoJ21haW4udXBncmFkZS5kb3dubG9hZCcpLFxyXG4gICAgICAgICAgJ2xpbmsnOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9pbnRsL2VuL2Nocm9tZS9icm93c2VyJ1xyXG4gICAgICAgIH1dXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJCgnI3Byb3NlJykuaHRtbCh1cGdyYWRlLnJlbmRlcigpLmVsKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGVycm9yOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIEluaXRpYWxpemUgcm91dGVyXHJcbiAgICB3aW5kb3cucm91dGVyID0gbmV3IFJvdXRlcigpO1xyXG5cclxuICAgIC8vIFN0YXJ0IHJlc3BvbmRpbmcgdG8gcm91dGVzXHJcbiAgICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KCk7XHJcbiAgfVxyXG59KTtcclxuXG59KSgpIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiYXBpXCI6IFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbVwiLFxyXG4gIFwic2l0ZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbVwiLFxyXG4gIFwiY2xpZW50SWRcIjogXCJkYTQyOTU0MTk2NGUzMzAyYzYyZlwiLFxyXG4gIFwiZ2F0ZWtlZXBlclVybFwiOiBcImh0dHBzOi8vZWRiLXByb3NlLWdhdGVrZWVwZXIuaGVyb2t1YXBwLmNvbVwiXHJcbn1cclxuICIsIihmdW5jdGlvbigpey8vIFVzZXMgTm9kZSwgQU1EIG9yIGJyb3dzZXIgZ2xvYmFscyB0byBjcmVhdGUgYSBtb2R1bGUuXG5cbi8vIElmIHlvdSB3YW50IHNvbWV0aGluZyB0aGF0IHdpbGwgd29yayBpbiBvdGhlciBzdHJpY3RlciBDb21tb25KUyBlbnZpcm9ubWVudHMsXG4vLyBvciBpZiB5b3UgbmVlZCB0byBjcmVhdGUgYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzZWUgY29tbW9uSnNTdHJpY3QuanNcblxuLy8gRGVmaW5lcyBhIG1vZHVsZSBcInJldHVybkV4cG9ydHNcIiB0aGF0IGRlcGVuZHMgYW5vdGhlciBtb2R1bGUgY2FsbGVkIFwiYlwiLlxuLy8gTm90ZSB0aGF0IHRoZSBuYW1lIG9mIHRoZSBtb2R1bGUgaXMgaW1wbGllZCBieSB0aGUgZmlsZSBuYW1lLiBJdCBpcyBiZXN0XG4vLyBpZiB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZXhwb3J0ZWQgZ2xvYmFsIGhhdmUgbWF0Y2hpbmcgbmFtZXMuXG5cbi8vIElmIHRoZSAnYicgbW9kdWxlIGFsc28gdXNlcyB0aGlzIHR5cGUgb2YgYm9pbGVycGxhdGUsIHRoZW5cbi8vIGluIHRoZSBicm93c2VyLCBpdCB3aWxsIGNyZWF0ZSBhIGdsb2JhbCAuYiB0aGF0IGlzIHVzZWQgYmVsb3cuXG5cbi8vIElmIHlvdSBkbyBub3Qgd2FudCB0byBzdXBwb3J0IHRoZSBicm93c2VyIGdsb2JhbCBwYXRoLCB0aGVuIHlvdVxuLy8gY2FuIHJlbW92ZSB0aGUgYHJvb3RgIHVzZSBhbmQgdGhlIHBhc3NpbmcgYHRoaXNgIGFzIHRoZSBmaXJzdCBhcmcgdG9cbi8vIHRoZSB0b3AgZnVuY3Rpb24uXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7LyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjguMVxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEyIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IFRodSBBdWcgMzAgMjAxMiAxNzoxNzoyMiBHTVQtMDQwMCAoRWFzdGVybiBEYXlsaWdodCBUaW1lKVxuICovXG5yZXR1cm4gKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcbnZhclxuXHQvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcblx0cm9vdGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcblx0cmVhZHlMaXN0LFxuXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuXHRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kLFxuXG5cdC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gc29tZSBjb3JlIG1ldGhvZHNcblx0Y29yZV9wdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2gsXG5cdGNvcmVfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdGNvcmVfaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLFxuXHRjb3JlX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0Y29yZV9oYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuXHRjb3JlX3RyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5ICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgbWF0Y2hpbmcgbnVtYmVyc1xuXHRjb3JlX3BudW0gPSAvW1xcLStdPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdW1xcLStdP1xcZCt8KS8uc291cmNlLFxuXG5cdC8vIFVzZWQgZm9yIGRldGVjdGluZyBhbmQgdHJpbW1pbmcgd2hpdGVzcGFjZVxuXHRjb3JlX3Jub3R3aGl0ZSA9IC9cXFMvLFxuXHRjb3JlX3JzcGFjZSA9IC9cXHMrLyxcblxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1AgKGhlcmUncyBsb29raW5nIGF0IHlvdSwgU2FmYXJpIDUuMCBhbmQgSUUpXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0cnF1aWNrRXhwciA9IC9eKD86W14jPF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKikkKS8sXG5cblx0Ly8gTWF0Y2ggYSBzdGFuZGFsb25lIHRhZ1xuXHRyc2luZ2xlVGFnID0gL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvLFxuXG5cdC8vIEpTT04gUmVnRXhwXG5cdHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC8sXG5cdHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcblx0cnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZyxcblx0cnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXHJcXG5dKlwifHRydWV8ZmFsc2V8bnVsbHwtPyg/OlxcZFxcZCpcXC58KVxcZCsoPzpbZUVdW1xcLStdP1xcZCt8KS9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gKCBsZXR0ZXIgKyBcIlwiICkudG9VcHBlckNhc2UoKTtcblx0fSxcblxuXHQvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuXHRET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XG5cdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHR9IGVsc2UgaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyB3ZSdyZSBoZXJlIGJlY2F1c2UgcmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIGluIG9sZElFXG5cdFx0XHQvLyB3aGljaCBpcyBnb29kIGVub3VnaCBmb3IgdXMgdG8gY2FsbCB0aGUgZG9tIHJlYWR5IVxuXHRcdFx0ZG9jdW1lbnQuZGV0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIERPTUNvbnRlbnRMb2FkZWQgKTtcblx0XHRcdGpRdWVyeS5yZWFkeSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuXHRjbGFzczJ0eXBlID0ge307XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cdGluaXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW0sIHJldCwgZG9jO1xuXG5cdFx0Ly8gSGFuZGxlICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSAkKERPTUVsZW1lbnQpXG5cdFx0aWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3IuY2hhckF0KDApID09PSBcIjxcIiAmJiBzZWxlY3Rvci5jaGFyQXQoIHNlbGVjdG9yLmxlbmd0aCAtIDEgKSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cdFx0XHRcdFx0ZG9jID0gKCBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50ICk7XG5cblx0XHRcdFx0XHQvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBqUXVlcnkucGFyc2VIVE1MKCBtYXRjaFsxXSwgZG9jLCB0cnVlICk7XG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuYXR0ci5jYWxsKCBzZWxlY3RvciwgY29udGV4dCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIHRoaXMsIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkICE9PSBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RqUXVlcnkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBpbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogXCIxLjguMVwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0Ly8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcblx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBjb3JlX3NsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtID09IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4gYSAnY2xlYW4nIGFycmF5XG5cdFx0XHR0aGlzLnRvQXJyYXkoKSA6XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3Rcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIHRoaXMubGVuZ3RoICsgbnVtIF0gOiB0aGlzWyBudW0gXSApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zLCBuYW1lLCBzZWxlY3RvciApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdGlmICggbmFtZSA9PT0gXCJmaW5kXCIgKSB7XG5cdFx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgKCB0aGlzLnNlbGVjdG9yID8gXCIgXCIgOiBcIlwiICkgKyBzZWxlY3Rvcjtcblx0XHR9IGVsc2UgaWYgKCBuYW1lICkge1xuXHRcdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArIFwiLlwiICsgbmFtZSArIFwiKFwiICsgc2VsZWN0b3IgKyBcIilcIjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdHJlYWR5OiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRcdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHRpID0gK2k7XG5cdFx0cmV0dXJuIGkgPT09IC0xID9cblx0XHRcdHRoaXMuc2xpY2UoIGkgKSA6XG5cdFx0XHR0aGlzLnNsaWNlKCBpLCBpICsgMSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGNvcmVfc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0XCJzbGljZVwiLCBjb3JlX3NsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSkpO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IGNvcmVfcHVzaCxcblx0c29ydDogW10uc29ydCxcblx0c3BsaWNlOiBbXS5zcGxpY2Vcbn07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmpRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGxlbmd0aCA9PT0gaSApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdC0taTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0bm9Db25mbGljdDogZnVuY3Rpb24oIGRlZXAgKSB7XG5cdFx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LiQgPSBfJDtcblx0XHR9XG5cblx0XHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSxcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdFx0aWYgKCAhZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHksIDEgKTtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImFycmF5XCI7XG5cdH0sXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KG9iaikgKSAmJiBpc0Zpbml0ZSggb2JqICk7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqID09IG51bGwgP1xuXHRcdFx0U3RyaW5nKCBvYmogKSA6XG5cdFx0XHRjbGFzczJ0eXBlWyBjb3JlX3RvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCI7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBNdXN0IGJlIGFuIE9iamVjdC5cblx0XHQvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuXHRcdGlmICggIW9iaiB8fCBqUXVlcnkudHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhY29yZV9oYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcblx0XHRcdFx0IWNvcmVfaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHQvLyBJRTgsOSBXaWxsIHRocm93IGV4Y2VwdGlvbnMgb24gY2VydGFpbiBob3N0IG9iamVjdHMgIzk4OTdcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblxuXHRcdHZhciBrZXk7XG5cdFx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgY29yZV9oYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdC8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG5cdC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCwgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0Ly8gc2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5cdHBhcnNlSFRNTDogZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIHNjcmlwdHMgKSB7XG5cdFx0dmFyIHBhcnNlZDtcblx0XHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0c2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0XHRjb250ZXh0ID0gMDtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBTaW5nbGUgdGFnXG5cdFx0aWYgKCAocGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICkpICkge1xuXHRcdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHRcdH1cblxuXHRcdHBhcnNlZCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyA/IG51bGwgOiBbXSApO1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLFxuXHRcdFx0KHBhcnNlZC5jYWNoZWFibGUgPyBqUXVlcnkuY2xvbmUoIHBhcnNlZC5mcmFnbWVudCApIDogcGFyc2VkLmZyYWdtZW50KS5jaGlsZE5vZGVzICk7XG5cdH0sXG5cblx0cGFyc2VKU09OOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgKElFIGNhbid0IGhhbmRsZSBpdClcblx0XHRkYXRhID0galF1ZXJ5LnRyaW0oIGRhdGEgKTtcblxuXHRcdC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuXHRcdGlmICggd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LkpTT04ucGFyc2UoIGRhdGEgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGluY29taW5nIGRhdGEgaXMgYWN0dWFsIEpTT05cblx0XHQvLyBMb2dpYyBib3Jyb3dlZCBmcm9tIGh0dHA6Ly9qc29uLm9yZy9qc29uMi5qc1xuXHRcdGlmICggcnZhbGlkY2hhcnMudGVzdCggZGF0YS5yZXBsYWNlKCBydmFsaWRlc2NhcGUsIFwiQFwiIClcblx0XHRcdC5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIFwiXVwiIClcblx0XHRcdC5yZXBsYWNlKCBydmFsaWRicmFjZXMsIFwiXCIpKSApIHtcblxuXHRcdFx0cmV0dXJuICggbmV3IEZ1bmN0aW9uKCBcInJldHVybiBcIiArIGRhdGEgKSApKCk7XG5cblx0XHR9XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgSlNPTjogXCIgKyBkYXRhICk7XG5cdH0sXG5cblx0Ly8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuXHRwYXJzZVhNTDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0dmFyIHhtbCwgdG1wO1xuXHRcdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcblx0XHRcdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhICwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0XHR9IGVsc2UgeyAvLyBJRVxuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gXCJmYWxzZVwiO1xuXHRcdFx0XHR4bWwubG9hZFhNTCggZGF0YSApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdFx0fVxuXHRcdHJldHVybiB4bWw7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHQvLyBXb3JrYXJvdW5kcyBiYXNlZCBvbiBmaW5kaW5ncyBieSBKaW0gRHJpc2NvbGxcblx0Ly8gaHR0cDovL3dlYmxvZ3MuamF2YS5uZXQvYmxvZy9kcmlzY29sbC9hcmNoaXZlLzIwMDkvMDkvMDgvZXZhbC1qYXZhc2NyaXB0LWdsb2JhbC1jb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSAmJiBjb3JlX3Jub3R3aGl0ZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHQvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0Ly8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XG5cdFx0XHQvLyByYXRoZXIgdGhhbiBqUXVlcnkgaW4gRmlyZWZveFxuXHRcdFx0KCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0d2luZG93WyBcImV2YWxcIiBdLmNhbGwoIHdpbmRvdywgZGF0YSApO1xuXHRcdFx0fSApKCBkYXRhICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0XHRpc09iaiA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0Z1bmN0aW9uKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9ialsgbmFtZSBdLCBhcmdzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9ialsgaSsrIF0sIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBuYW1lIF0sIG5hbWUsIG9ialsgbmFtZSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSsrIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcblx0dHJpbTogY29yZV90cmltICYmICFjb3JlX3RyaW0uY2FsbChcIlxcdUZFRkZcXHhBMFwiKSA/XG5cdFx0ZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdGNvcmVfdHJpbS5jYWxsKCB0ZXh0ICk7XG5cdFx0fSA6XG5cblx0XHQvLyBPdGhlcndpc2UgdXNlIG91ciBvd24gdHJpbW1pbmcgZnVuY3Rpb25hbGl0eVxuXHRcdGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHR0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0XHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciB0eXBlLFxuXHRcdFx0cmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHQvLyBUaGUgd2luZG93LCBzdHJpbmdzIChhbmQgZnVuY3Rpb25zKSBhbHNvIGhhdmUgJ2xlbmd0aCdcblx0XHRcdC8vIFR3ZWFrZWQgbG9naWMgc2xpZ2h0bHkgdG8gaGFuZGxlIEJsYWNrYmVycnkgNC43IFJlZ0V4cCBpc3N1ZXMgIzY5MzBcblx0XHRcdHR5cGUgPSBqUXVlcnkudHlwZSggYXJyICk7XG5cblx0XHRcdGlmICggYXJyLmxlbmd0aCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwicmVnZXhwXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBhcnIgKSApIHtcblx0XHRcdFx0Y29yZV9wdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHZhciBsZW47XG5cblx0XHRpZiAoIGFyciApIHtcblx0XHRcdGlmICggY29yZV9pbmRleE9mICkge1xuXHRcdFx0XHRyZXR1cm4gY29yZV9pbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0aSA9IGkgPyBpIDwgMCA/IE1hdGgubWF4KCAwLCBsZW4gKyBpICkgOiBpIDogMDtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdC8vIFNraXAgYWNjZXNzaW5nIGluIHNwYXJzZSBhcnJheXNcblx0XHRcdFx0aWYgKCBpIGluIGFyciAmJiBhcnJbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGwgPSBzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aCxcblx0XHRcdGogPSAwO1xuXG5cdFx0aWYgKCB0eXBlb2YgbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGZvciAoIDsgaiA8IGw7IGorKyApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKCBzZWNvbmRbal0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludiApIHtcblx0XHR2YXIgcmV0VmFsLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRpbnYgPSAhIWludjtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0cmV0VmFsID0gISFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBpbnYgIT09IHJldFZhbCApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgdmFsdWUsIGtleSxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHQvLyBqcXVlcnkgb2JqZWN0cyBhcmUgdHJlYXRlZCBhcyBhcnJheXNcblx0XHRcdGlzQXJyYXkgPSBlbGVtcyBpbnN0YW5jZW9mIGpRdWVyeSB8fCBsZW5ndGggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmICggKCBsZW5ndGggPiAwICYmIGVsZW1zWyAwIF0gJiYgZWxlbXNbIGxlbmd0aCAtMSBdICkgfHwgbGVuZ3RoID09PSAwIHx8IGpRdWVyeS5pc0FycmF5KCBlbGVtcyApICkgO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBrZXkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBrZXkgXSwga2V5LCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0WyByZXQubGVuZ3RoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gcmV0LmNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0LCBhcmdzLmNvbmNhdCggY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBwcm94eS5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0Ly8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG5cdC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHBhc3MgKSB7XG5cdFx0dmFyIGV4ZWMsXG5cdFx0XHRidWxrID0ga2V5ID09IG51bGwsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0XHRpZiAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCAxLCBlbXB0eUdldCwgdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdGNoYWluYWJsZSA9IDE7XG5cblx0XHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBPcHRpb25hbGx5LCBmdW5jdGlvbiB2YWx1ZXMgZ2V0IGV4ZWN1dGVkIGlmIGV4ZWMgaXMgdHJ1ZVxuXHRcdFx0ZXhlYyA9IHBhc3MgPT09IHVuZGVmaW5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBidWxrICkge1xuXHRcdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgb25seSBpdGVyYXRlIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0XHRpZiAoIGV4ZWMgKSB7XG5cdFx0XHRcdFx0ZXhlYyA9IGZuO1xuXHRcdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhlYy5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB0aGV5IHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdFx0Zm4gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIGV4ZWMgPyB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApIDogdmFsdWUsIHBhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFpbmFibGUgPSAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdFx0ZWxlbXMgOlxuXG5cdFx0XHQvLyBHZXRzXG5cdFx0XHRidWxrID9cblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRcdGxlbmd0aCA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiBlbXB0eUdldDtcblx0fSxcblxuXHRub3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCk7XG5cdH1cbn0pO1xuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gd2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHRzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHksIDEgKTtcblxuXHRcdC8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWRcblx0XHR9IGVsc2UgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGpRdWVyeS5yZWFkeSwgZmFsc2UgKTtcblxuXHRcdC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLCBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcblx0XHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBET01Db250ZW50TG9hZGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib25sb2FkXCIsIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0XHQvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcblx0XHRcdC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcblx0XHRcdHZhciB0b3AgPSBmYWxzZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9wID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0XHRcdH0gY2F0Y2goZSkge31cblxuXHRcdFx0aWYgKCB0b3AgJiYgdG9wLmRvU2Nyb2xsICkge1xuXHRcdFx0XHQoZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuaXNSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0XHRcdFx0XHRcdFx0dG9wLmRvU2Nyb2xsKFwibGVmdFwiKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgNTAgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdFx0XHRcdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG4vLyBBbGwgalF1ZXJ5IG9iamVjdHMgc2hvdWxkIHBvaW50IGJhY2sgdG8gdGhlc2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xuLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxudmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5zcGxpdCggY29yZV9yc3BhY2UgKSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHQoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblx0XHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcblx0XHRmaXJpbmdTdGFydCxcblx0XHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcblx0XHRmaXJpbmdMZW5ndGgsXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCxcblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0bWVtb3J5ID0gb3B0aW9ucy5tZW1vcnkgJiYgZGF0YTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIHN0YWNrICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICYmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ29udHJvbCBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0XG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTE7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGxvY2tlZD9cblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0aWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xualF1ZXJ5LmV4dGVuZCh7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFjdGlvbiA9IHR1cGxlWyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0Zm4gPSBmbnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKCBqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSA/XG5cdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIGFjdGlvbiArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gbmV3RGVmZXIgOiB0aGlzLCBbIHJldHVybmVkIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IDpcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgYWN0aW9uIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsxXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXSA9IGxpc3QuZmlyZVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBsaXN0LmZpcmU7XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9KTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IGNvcmVfc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29yZV9zbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0IClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59KTtcbmpRdWVyeS5zdXBwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBzdXBwb3J0LFxuXHRcdGFsbCxcblx0XHRhLFxuXHRcdHNlbGVjdCxcblx0XHRvcHQsXG5cdFx0aW5wdXQsXG5cdFx0ZnJhZ21lbnQsXG5cdFx0ZXZlbnROYW1lLFxuXHRcdGksXG5cdFx0aXNTdXBwb3J0ZWQsXG5cdFx0Y2xpY2tGbixcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdC8vIFByZWxpbWluYXJ5IHRlc3RzXG5cdGRpdi5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIsIFwidFwiICk7XG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXG5cdGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWyAwIF07XG5cdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweDtmbG9hdDpsZWZ0O29wYWNpdHk6LjVcIjtcblxuXHQvLyBDYW4ndCBnZXQgYmFzaWMgdGVzdCBzdXBwb3J0XG5cdGlmICggIWFsbCB8fCAhYWxsLmxlbmd0aCB8fCAhYSApIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHQvLyBGaXJzdCBiYXRjaCBvZiBzdXBwb3J0cyB0ZXN0c1xuXHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuXHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikgKTtcblx0aW5wdXQgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVsgMCBdO1xuXG5cdHN1cHBvcnQgPSB7XG5cdFx0Ly8gSUUgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIC5pbm5lckhUTUwgaXMgdXNlZFxuXHRcdGxlYWRpbmdXaGl0ZXNwYWNlOiAoIGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzICksXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuXHRcdC8vIElFIHdpbGwgaW5zZXJ0IHRoZW0gaW50byBlbXB0eSB0YWJsZXNcblx0XHR0Ym9keTogIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuXHRcdC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcblx0XHRodG1sU2VyaWFsaXplOiAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLFxuXG5cdFx0Ly8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuXHRcdC8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpXG5cdFx0c3R5bGU6IC90b3AvLnRlc3QoIGEuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXG5cdFx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0XHRocmVmTm9ybWFsaXplZDogKCBhLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiL2FcIiApLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgZWxlbWVudCBvcGFjaXR5IGV4aXN0c1xuXHRcdC8vIChJRSB1c2VzIGZpbHRlciBpbnN0ZWFkKVxuXHRcdC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcblx0XHRvcGFjaXR5OiAvXjAuNS8udGVzdCggYS5zdHlsZS5vcGFjaXR5ICksXG5cblx0XHQvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXG5cdFx0Ly8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuXHRcdGNzc0Zsb2F0OiAhIWEuc3R5bGUuY3NzRmxvYXQsXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIGEgY2hlY2tib3hcblx0XHQvLyB0aGF0IGl0IGRlZmF1bHRzIHRvIFwib25cIi5cblx0XHQvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIFwiXCIgaW5zdGVhZClcblx0XHRjaGVja09uOiAoIGlucHV0LnZhbHVlID09PSBcIm9uXCIgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGEgc2VsZWN0ZWQtYnktZGVmYXVsdCBvcHRpb24gaGFzIGEgd29ya2luZyBzZWxlY3RlZCBwcm9wZXJ0eS5cblx0XHQvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKVxuXHRcdG9wdFNlbGVjdGVkOiBvcHQuc2VsZWN0ZWQsXG5cblx0XHQvLyBUZXN0IHNldEF0dHJpYnV0ZSBvbiBjYW1lbENhc2UgY2xhc3MuIElmIGl0IHdvcmtzLCB3ZSBuZWVkIGF0dHJGaXhlcyB3aGVuIGRvaW5nIGdldC9zZXRBdHRyaWJ1dGUgKGllNi83KVxuXHRcdGdldFNldEF0dHJpYnV0ZTogZGl2LmNsYXNzTmFtZSAhPT0gXCJ0XCIsXG5cblx0XHQvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSgjNjc0Mylcblx0XHRlbmN0eXBlOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGUsXG5cblx0XHQvLyBNYWtlcyBzdXJlIGNsb25pbmcgYW4gaHRtbDUgZWxlbWVudCBkb2VzIG5vdCBjYXVzZSBwcm9ibGVtc1xuXHRcdC8vIFdoZXJlIG91dGVySFRNTCBpcyB1bmRlZmluZWQsIHRoaXMgc3RpbGwgd29ya3Ncblx0XHRodG1sNUNsb25lOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibmF2XCIpLmNsb25lTm9kZSggdHJ1ZSApLm91dGVySFRNTCAhPT0gXCI8Om5hdj48LzpuYXY+XCIsXG5cblx0XHQvLyBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCBERVBSRUNBVEVEIGluIDEuOCBzaW5jZSB3ZSBkb24ndCBzdXBwb3J0IFF1aXJrcyBNb2RlXG5cdFx0Ym94TW9kZWw6ICggZG9jdW1lbnQuY29tcGF0TW9kZSA9PT0gXCJDU1MxQ29tcGF0XCIgKSxcblxuXHRcdC8vIFdpbGwgYmUgZGVmaW5lZCBsYXRlclxuXHRcdHN1Ym1pdEJ1YmJsZXM6IHRydWUsXG5cdFx0Y2hhbmdlQnViYmxlczogdHJ1ZSxcblx0XHRmb2N1c2luQnViYmxlczogZmFsc2UsXG5cdFx0ZGVsZXRlRXhwYW5kbzogdHJ1ZSxcblx0XHRub0Nsb25lRXZlbnQ6IHRydWUsXG5cdFx0aW5saW5lQmxvY2tOZWVkc0xheW91dDogZmFsc2UsXG5cdFx0c2hyaW5rV3JhcEJsb2NrczogZmFsc2UsXG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodDogdHJ1ZSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogdHJ1ZSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmYWxzZVxuXHR9O1xuXG5cdC8vIE1ha2Ugc3VyZSBjaGVja2VkIHN0YXR1cyBpcyBwcm9wZXJseSBjbG9uZWRcblx0aW5wdXQuY2hlY2tlZCA9IHRydWU7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSBpbnB1dC5jbG9uZU5vZGUoIHRydWUgKS5jaGVja2VkO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcblx0Ly8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBUZXN0IHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRlbGV0ZSBhbiBleHBhbmRvIGZyb20gYW4gZWxlbWVudFxuXHQvLyBGYWlscyBpbiBJbnRlcm5ldCBFeHBsb3JlclxuXHR0cnkge1xuXHRcdGRlbGV0ZSBkaXYudGVzdDtcblx0fSBjYXRjaCggZSApIHtcblx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0fVxuXG5cdGlmICggIWRpdi5hZGRFdmVudExpc3RlbmVyICYmIGRpdi5hdHRhY2hFdmVudCAmJiBkaXYuZmlyZUV2ZW50ICkge1xuXHRcdGRpdi5hdHRhY2hFdmVudCggXCJvbmNsaWNrXCIsIGNsaWNrRm4gPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENsb25pbmcgYSBub2RlIHNob3VsZG4ndCBjb3B5IG92ZXIgYW55XG5cdFx0XHQvLyBib3VuZCBldmVudCBoYW5kbGVycyAoSUUgZG9lcyB0aGlzKVxuXHRcdFx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHR9KTtcblx0XHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuZmlyZUV2ZW50KFwib25jbGlja1wiKTtcblx0XHRkaXYuZGV0YWNoRXZlbnQoIFwib25jbGlja1wiLCBjbGlja0ZuICk7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBhIHJhZGlvIG1haW50YWlucyBpdHMgdmFsdWVcblx0Ly8gYWZ0ZXIgYmVpbmcgYXBwZW5kZWQgdG8gdGhlIERPTVxuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcblxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXG5cdC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0ZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYubGFzdENoaWxkICk7XG5cblx0Ly8gV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGZyYWdtZW50LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIENoZWNrIGlmIGEgZGlzY29ubmVjdGVkIGNoZWNrYm94IHdpbGwgcmV0YWluIGl0cyBjaGVja2VkXG5cdC8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpXG5cdHN1cHBvcnQuYXBwZW5kQ2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cblx0ZnJhZ21lbnQucmVtb3ZlQ2hpbGQoIGlucHV0ICk7XG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBUZWNobmlxdWUgZnJvbSBKdXJpeSBaYXl0c2V2XG5cdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2RldGVjdGluZy1ldmVudC1zdXBwb3J0LXdpdGhvdXQtYnJvd3Nlci1zbmlmZmluZy9cblx0Ly8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBjYXNlIHdoZXJlIG5vbi1zdGFuZGFyZCBldmVudCBzeXN0ZW1zXG5cdC8vIGFyZSB1c2VkLCBuYW1lbHkgaW4gSUUuIFNob3J0LWNpcmN1aXRpbmcgaGVyZSBoZWxwcyB1cyB0b1xuXHQvLyBhdm9pZCBhbiBldmFsIGNhbGwgKGluIHNldEF0dHJpYnV0ZSkgd2hpY2ggY2FuIGNhdXNlIENTUFxuXHQvLyB0byBnbyBoYXl3aXJlLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUFxuXHRpZiAoIGRpdi5hdHRhY2hFdmVudCApIHtcblx0XHRmb3IgKCBpIGluIHtcblx0XHRcdHN1Ym1pdDogdHJ1ZSxcblx0XHRcdGNoYW5nZTogdHJ1ZSxcblx0XHRcdGZvY3VzaW46IHRydWVcblx0XHR9KSB7XG5cdFx0XHRldmVudE5hbWUgPSBcIm9uXCIgKyBpO1xuXHRcdFx0aXNTdXBwb3J0ZWQgPSAoIGV2ZW50TmFtZSBpbiBkaXYgKTtcblx0XHRcdGlmICggIWlzU3VwcG9ydGVkICkge1xuXHRcdFx0XHRkaXYuc2V0QXR0cmlidXRlKCBldmVudE5hbWUsIFwicmV0dXJuO1wiICk7XG5cdFx0XHRcdGlzU3VwcG9ydGVkID0gKCB0eXBlb2YgZGl2WyBldmVudE5hbWUgXSA9PT0gXCJmdW5jdGlvblwiICk7XG5cdFx0XHR9XG5cdFx0XHRzdXBwb3J0WyBpICsgXCJCdWJibGVzXCIgXSA9IGlzU3VwcG9ydGVkO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJ1biB0ZXN0cyB0aGF0IG5lZWQgYSBib2R5IGF0IGRvYyByZWFkeVxuXHRqUXVlcnkoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRhaW5lciwgZGl2LCB0ZHMsIG1hcmdpbkRpdixcblx0XHRcdGRpdlJlc2V0ID0gXCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW47XCIsXG5cdFx0XHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXG5cdFx0aWYgKCAhYm9keSApIHtcblx0XHRcdC8vIFJldHVybiBmb3IgZnJhbWVzZXQgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBib2R5XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwidmlzaWJpbGl0eTpoaWRkZW47Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDtwb3NpdGlvbjpzdGF0aWM7dG9wOjA7bWFyZ2luLXRvcDoxcHhcIjtcblx0XHRib2R5Lmluc2VydEJlZm9yZSggY29udGFpbmVyLCBib2R5LmZpcnN0Q2hpbGQgKTtcblxuXHRcdC8vIENvbnN0cnVjdCB0aGUgdGVzdCBlbGVtZW50XG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB0aGV5IGFyZSBzZXRcblx0XHQvLyB0byBkaXNwbGF5Om5vbmUgYW5kIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB2aXNpYmxlIHRhYmxlIGNlbGxzIGluIGFcblx0XHQvLyB0YWJsZSByb3c7IGlmIHNvLCBvZmZzZXRXaWR0aC9IZWlnaHQgYXJlIG5vdCByZWxpYWJsZSBmb3IgdXNlIHdoZW5cblx0XHQvLyBkZXRlcm1pbmluZyBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIGhpZGRlbiBkaXJlY3RseSB1c2luZ1xuXHRcdC8vIGRpc3BsYXk6bm9uZSAoaXQgaXMgc3RpbGwgc2FmZSB0byB1c2Ugb2Zmc2V0cyBpZiBhIHBhcmVudCBlbGVtZW50IGlzXG5cdFx0Ly8gaGlkZGVuOyBkb24gc2FmZXR5IGdvZ2dsZXMgYW5kIHNlZSBidWcgIzQ1MTIgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlxuXHRcdC8vIChvbmx5IElFIDggZmFpbHMgdGhpcyB0ZXN0KVxuXHRcdGRpdi5pbm5lckhUTUwgPSBcIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcblx0XHR0ZHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKTtcblx0XHR0ZHNbIDAgXS5zdHlsZS5jc3NUZXh0ID0gXCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7ZGlzcGxheTpub25lXCI7XG5cdFx0aXNTdXBwb3J0ZWQgPSAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuXG5cdFx0dGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0dGRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgZW1wdHkgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHRcblx0XHQvLyAoSUUgPD0gOCBmYWlsIHRoaXMgdGVzdClcblx0XHRzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IGlzU3VwcG9ydGVkICYmICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XG5cblx0XHQvLyBDaGVjayBib3gtc2l6aW5nIGFuZCBtYXJnaW4gYmVoYXZpb3Jcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MXB4O2JvcmRlcjoxcHg7ZGlzcGxheTpibG9jazt3aWR0aDo0cHg7bWFyZ2luLXRvcDoxJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MSU7XCI7XG5cdFx0c3VwcG9ydC5ib3hTaXppbmcgPSAoIGRpdi5vZmZzZXRXaWR0aCA9PT0gNCApO1xuXHRcdHN1cHBvcnQuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQgPSAoIGJvZHkub2Zmc2V0VG9wICE9PSAxICk7XG5cblx0XHQvLyBOT1RFOiBUbyBhbnkgZnV0dXJlIG1haW50YWluZXIsIHdlJ3ZlIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlXG5cdFx0Ly8gYmVjYXVzZSBqc2RvbSBvbiBub2RlLmpzIHdpbGwgYnJlYWsgd2l0aG91dCBpdC5cblx0XHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdFx0c3VwcG9ydC5waXhlbFBvc2l0aW9uID0gKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICkgfHwge30gKS50b3AgIT09IFwiMSVcIjtcblx0XHRcdHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiBGb3IgbW9yZVxuXHRcdFx0Ly8gaW5mbyBzZWUgYnVnICMzMzMzXG5cdFx0XHQvLyBGYWlscyBpbiBXZWJLaXQgYmVmb3JlIEZlYiAyMDExIG5pZ2h0bGllc1xuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHRtYXJnaW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9IGRpdlJlc2V0O1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBtYXJnaW5EaXYgKTtcblx0XHRcdHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCA9XG5cdFx0XHRcdCFwYXJzZUZsb2F0KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYsIG51bGwgKSB8fCB7fSApLm1hcmdpblJpZ2h0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHQvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcblx0XHRcdC8vIGVsZW1lbnRzIHdoZW4gc2V0dGluZyB0aGVpciBkaXNwbGF5IHRvICdpbmxpbmUnIGFuZCBnaXZpbmdcblx0XHRcdC8vIHRoZW0gbGF5b3V0XG5cdFx0XHQvLyAoSUUgPCA4IGRvZXMgdGhpcylcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBkaXZSZXNldCArIFwid2lkdGg6MXB4O3BhZGRpbmc6MXB4O2Rpc3BsYXk6aW5saW5lO3pvb206MVwiO1xuXHRcdFx0c3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gKCBkaXYub2Zmc2V0V2lkdGggPT09IDMgKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudHMgd2l0aCBsYXlvdXQgc2hyaW5rLXdyYXAgdGhlaXIgY2hpbGRyZW5cblx0XHRcdC8vIChJRSA2IGRvZXMgdGhpcylcblx0XHRcdGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0ZGl2LnN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCI8ZGl2PjwvZGl2PlwiO1xuXHRcdFx0ZGl2LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjVweFwiO1xuXHRcdFx0c3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzID0gKCBkaXYub2Zmc2V0V2lkdGggIT09IDMgKTtcblxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnpvb20gPSAxO1xuXHRcdH1cblxuXHRcdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcblx0XHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRjb250YWluZXIgPSBkaXYgPSB0ZHMgPSBtYXJnaW5EaXYgPSBudWxsO1xuXHR9KTtcblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFXG5cdGZyYWdtZW50LnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0YWxsID0gYSA9IHNlbGVjdCA9IG9wdCA9IGlucHV0ID0gZnJhZ21lbnQgPSBkaXYgPSBudWxsO1xuXG5cdHJldHVybiBzdXBwb3J0O1xufSkoKTtcbnZhciByYnJhY2UgPSAvKD86XFx7W1xcc1xcU10qXFx9fFxcW1tcXHNcXFNdKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjYWNoZToge30sXG5cblx0ZGVsZXRlZElkczogW10sXG5cblx0Ly8gUGxlYXNlIHVzZSB3aXRoIGNhdXRpb25cblx0dXVpZDogMCxcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0Ly8gTm9uLWRpZ2l0cyByZW1vdmVkIHRvIG1hdGNoIHJpbmxpbmVqUXVlcnlcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggalF1ZXJ5LmZuLmpxdWVyeSArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIHRocm93IHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMgaWYgeW91XG5cdC8vIGF0dGVtcHQgdG8gYWRkIGV4cGFuZG8gcHJvcGVydGllcyB0byB0aGVtLlxuXHRub0RhdGE6IHtcblx0XHRcImVtYmVkXCI6IHRydWUsXG5cdFx0Ly8gQmFuIGFsbCBvYmplY3RzIGV4Y2VwdCBmb3IgRmxhc2ggKHdoaWNoIGhhbmRsZSBleHBhbmRvcylcblx0XHRcIm9iamVjdFwiOiBcImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiLFxuXHRcdFwiYXBwbGV0XCI6IHRydWVcblx0fSxcblxuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRlbGVtID0gZWxlbS5ub2RlVHlwZSA/IGpRdWVyeS5jYWNoZVsgZWxlbVtqUXVlcnkuZXhwYW5kb10gXSA6IGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XG5cdFx0cmV0dXJuICEhZWxlbSAmJiAhaXNFbXB0eURhdGFPYmplY3QoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSwgcHZ0IC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRoaXNDYWNoZSwgcmV0LFxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblx0XHRcdGdldEJ5TmFtZSA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiLFxuXG5cdFx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdFx0Ly8gY2FuJ3QgR0Mgb2JqZWN0IHJlZmVyZW5jZXMgcHJvcGVybHkgYWNyb3NzIHRoZSBET00tSlMgYm91bmRhcnlcblx0XHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0XHQvLyBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHNvIEdDIGNhbiBvY2N1ciBhdXRvbWF0aWNhbGx5XG5cdFx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdFx0Ly8gdGhlIGNvZGUgdG8gc2hvcnRjdXQgb24gdGhlIHNhbWUgcGF0aCBhcyBhIERPTSBub2RlIHdpdGggbm8gY2FjaGVcblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXk7XG5cblx0XHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHRcdC8vIG9iamVjdCB0aGF0IGhhcyBubyBkYXRhIGF0IGFsbFxuXHRcdGlmICggKCFpZCB8fCAhY2FjaGVbaWRdIHx8ICghcHZ0ICYmICFjYWNoZVtpZF0uZGF0YSkpICYmIGdldEJ5TmFtZSAmJiBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhaWQgKSB7XG5cdFx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIGEgbmV3IHVuaXF1ZSBJRCBmb3IgZWFjaCBlbGVtZW50IHNpbmNlIHRoZWlyIGRhdGFcblx0XHRcdC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuXHRcdFx0aWYgKCBpc05vZGUgKSB7XG5cdFx0XHRcdGVsZW1bIGludGVybmFsS2V5IF0gPSBpZCA9IGpRdWVyeS5kZWxldGVkSWRzLnBvcCgpIHx8ICsralF1ZXJ5LnV1aWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IGludGVybmFsS2V5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdFx0Y2FjaGVbIGlkIF0gPSB7fTtcblxuXHRcdFx0Ly8gQXZvaWRzIGV4cG9zaW5nIGpRdWVyeSBtZXRhZGF0YSBvbiBwbGFpbiBKUyBvYmplY3RzIHdoZW4gdGhlIG9iamVjdFxuXHRcdFx0Ly8gaXMgc2VyaWFsaXplZCB1c2luZyBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKCAhaXNOb2RlICkge1xuXHRcdFx0XHRjYWNoZVsgaWQgXS50b0pTT04gPSBqUXVlcnkubm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0c1xuXHRcdC8vIHNoYWxsb3cgY29waWVkIG92ZXIgb250byB0aGUgZXhpc3RpbmcgY2FjaGVcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRpZiAoIHB2dCApIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0gPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXSwgbmFtZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0uZGF0YSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLmRhdGEsIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcblxuXHRcdC8vIGpRdWVyeSBkYXRhKCkgaXMgc3RvcmVkIGluIGEgc2VwYXJhdGUgb2JqZWN0IGluc2lkZSB0aGUgb2JqZWN0J3MgaW50ZXJuYWwgZGF0YVxuXHRcdC8vIGNhY2hlIGluIG9yZGVyIHRvIGF2b2lkIGtleSBjb2xsaXNpb25zIGJldHdlZW4gaW50ZXJuYWwgZGF0YSBhbmQgdXNlci1kZWZpbmVkXG5cdFx0Ly8gZGF0YS5cblx0XHRpZiAoICFwdnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzQ2FjaGUuZGF0YSApIHtcblx0XHRcdFx0dGhpc0NhY2hlLmRhdGEgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0dGhpc0NhY2hlID0gdGhpc0NhY2hlLmRhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdID0gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgYm90aCBjb252ZXJ0ZWQtdG8tY2FtZWwgYW5kIG5vbi1jb252ZXJ0ZWQgZGF0YSBwcm9wZXJ0eSBuYW1lc1xuXHRcdC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXG5cdFx0aWYgKCBnZXRCeU5hbWUgKSB7XG5cblx0XHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRcdHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xuXG5cdFx0XHQvLyBUZXN0IGZvciBudWxsfHVuZGVmaW5lZCBwcm9wZXJ0eSBkYXRhXG5cdFx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XG5cdFx0XHRcdHJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IHRoaXNDYWNoZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0aWYgKCAhalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGhpc0NhY2hlLCBpLCBsLFxuXG5cdFx0XHRpc05vZGUgPSBlbGVtLm5vZGVUeXBlLFxuXG5cdFx0XHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0XHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXSA6IGpRdWVyeS5leHBhbmRvO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBubyBjYWNoZSBlbnRyeSBmb3IgdGhpcyBvYmplY3QsIHRoZXJlIGlzIG5vXG5cdFx0Ly8gcHVycG9zZSBpbiBjb250aW51aW5nXG5cdFx0aWYgKCAhY2FjaGVbIGlkIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuYW1lICkge1xuXG5cdFx0XHR0aGlzQ2FjaGUgPSBwdnQgPyBjYWNoZVsgaWQgXSA6IGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRcdGlmICggdGhpc0NhY2hlICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG5cdFx0XHRcdGlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHQvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzXG5cdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVtpXSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0IGluIHRoZSBjYWNoZSwgd2Ugd2FudCB0byBjb250aW51ZVxuXHRcdFx0XHQvLyBhbmQgbGV0IHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmIGdldCBkZXN0cm95ZWRcblx0XHRcdFx0aWYgKCAhKCBwdnQgPyBpc0VtcHR5RGF0YU9iamVjdCA6IGpRdWVyeS5pc0VtcHR5T2JqZWN0ICkoIHRoaXNDYWNoZSApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdGlmICggIXB2dCApIHtcblx0XHRcdGRlbGV0ZSBjYWNoZVsgaWQgXS5kYXRhO1xuXG5cdFx0XHQvLyBEb24ndCBkZXN0cm95IHRoZSBwYXJlbnQgY2FjaGUgdW5sZXNzIHRoZSBpbnRlcm5hbCBkYXRhIG9iamVjdFxuXHRcdFx0Ly8gaGFkIGJlZW4gdGhlIG9ubHkgdGhpbmcgbGVmdCBpbiBpdFxuXHRcdFx0aWYgKCAhaXNFbXB0eURhdGFPYmplY3QoIGNhY2hlWyBpZCBdICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZXN0cm95IHRoZSBjYWNoZVxuXHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggWyBlbGVtIF0sIHRydWUgKTtcblxuXHRcdC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgY2FjaGUgIT0gY2FjaGUud2luZG93ICkge1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBpZCBdO1xuXG5cdFx0Ly8gV2hlbiBhbGwgZWxzZSBmYWlscywgbnVsbFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWNoZVsgaWQgXSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xuXHRhY2NlcHREYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbm9EYXRhID0gZWxlbS5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdC8vIG5vZGVzIGFjY2VwdCBkYXRhIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkOyByZWplY3Rpb24gY2FuIGJlIGNvbmRpdGlvbmFsXG5cdFx0cmV0dXJuICFub0RhdGEgfHwgbm9EYXRhICE9PSB0cnVlICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NpZFwiKSA9PT0gbm9EYXRhO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBwYXJ0cywgcGFydCwgYXR0ciwgbmFtZSwgbCxcblx0XHRcdGVsZW0gPSB0aGlzWzBdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhID0gbnVsbDtcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0galF1ZXJ5LmRhdGEoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0YXR0ciA9IGVsZW0uYXR0cmlidXRlcztcblx0XHRcdFx0XHRmb3IgKCBsID0gYXR0ci5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gYXR0cltpXS5uYW1lO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnN1YnN0cmluZyg1KSApO1xuXG5cdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kYXRhKCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiwgMiApO1xuXHRcdHBhcnRzWzFdID0gcGFydHNbMV0gPyBcIi5cIiArIHBhcnRzWzFdIDogXCJcIjtcblx0XHRwYXJ0ID0gcGFydHNbMV0gKyBcIiFcIjtcblxuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZGF0YSA9IHRoaXMudHJpZ2dlckhhbmRsZXIoIFwiZ2V0RGF0YVwiICsgcGFydCwgWyBwYXJ0c1swXSBdICk7XG5cblx0XHRcdFx0Ly8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XG5cdFx0XHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBwYXJ0c1sxXSA/XG5cdFx0XHRcdFx0dGhpcy5kYXRhKCBwYXJ0c1swXSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRwYXJ0c1sxXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXG5cdFx0XHRcdHNlbGYudHJpZ2dlckhhbmRsZXIoIFwic2V0RGF0YVwiICsgcGFydCwgcGFydHMgKTtcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0c2VsZi50cmlnZ2VySGFuZGxlciggXCJjaGFuZ2VEYXRhXCIgKyBwYXJ0LCBwYXJ0cyApO1xuXHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCBmYWxzZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHR2YXIgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kMVwiICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtLCBrZXksIGRhdGEgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG4vLyBjaGVja3MgYSBjYWNoZSBvYmplY3QgZm9yIGVtcHRpbmVzc1xuZnVuY3Rpb24gaXNFbXB0eURhdGFPYmplY3QoIG9iaiApIHtcblx0dmFyIG5hbWU7XG5cdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXG5cdFx0Ly8gaWYgdGhlIHB1YmxpYyBkYXRhIG9iamVjdCBpcyBlbXB0eSwgdGhlIHByaXZhdGUgaXMgc3RpbGwgZW1wdHlcblx0XHRpZiAoIG5hbWUgPT09IFwiZGF0YVwiICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvYmpbbmFtZV0gKSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoIG5hbWUgIT09IFwidG9KU09OXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5qUXVlcnkuZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0XHRcdHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArIFwicXVldWVcIiwgdHJ1ZSApO1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwga2V5LCB0cnVlICk7XG5cdFx0XHR9KVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9KTtcblx0fSxcblx0Ly8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuXHQvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5cdGRlbGF5OiBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0XHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBqUXVlcnkuX2RhdGEoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0pO1xudmFyIG5vZGVIb29rLCBib29sSG9vaywgZml4U3BlY2lmaWVkLFxuXHRyY2xhc3MgPSAvW1xcdFxcclxcbl0vZyxcblx0cnJldHVybiA9IC9cXHIvZyxcblx0cnR5cGUgPSAvXig/OmJ1dHRvbnxpbnB1dCkkL2ksXG5cdHJmb2N1c2FibGUgPSAvXig/OmJ1dHRvbnxpbnB1dHxvYmplY3R8c2VsZWN0fHRleHRhcmVhKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eYSg/OnJlYXwpJC9pLFxuXHRyYm9vbGVhbiA9IC9eKD86YXV0b2ZvY3VzfGF1dG9wbGF5fGFzeW5jfGNoZWNrZWR8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWR8c2VsZWN0ZWQpJC9pLFxuXHRnZXRTZXRBdHRyaWJ1dGUgPSBqUXVlcnkuc3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB0cnkvY2F0Y2ggaGFuZGxlcyBjYXNlcyB3aGVyZSBJRSBiYWxrcyAoc3VjaCBhcyByZW1vdmluZyBhIHByb3BlcnR5IG9uIHdpbmRvdylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXNbIG5hbWUgXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0ZGVsZXRlIHRoaXNbIG5hbWUgXTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGksIGwsIGVsZW0sXG5cdFx0XHRzZXRDbGFzcywgYywgY2w7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaiwgdGhpcy5jbGFzc05hbWUpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCggY29yZV9yc3BhY2UgKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0aWYgKCAhZWxlbS5jbGFzc05hbWUgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldENsYXNzID0gXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjID0gMCwgY2wgPSBjbGFzc05hbWVzLmxlbmd0aDsgYyA8IGNsOyBjKysgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggIX5zZXRDbGFzcy5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZXNbIGMgXSArIFwiIFwiICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0Q2xhc3MgKz0gY2xhc3NOYW1lc1sgYyBdICsgXCIgXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0galF1ZXJ5LnRyaW0oIHNldENsYXNzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgcmVtb3ZlcywgY2xhc3NOYW1lLCBlbGVtLCBjLCBjbCwgaSwgbDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHx8IHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZW1vdmVzID0gKCB2YWx1ZSB8fCBcIlwiICkuc3BsaXQoIGNvcmVfcnNwYWNlICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtLmNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRcdC8vIGxvb3Agb3ZlciBlYWNoIGl0ZW0gaW4gdGhlIHJlbW92YWwgbGlzdFxuXHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IHJlbW92ZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSB1bnRpbCB0aGVyZSBpcyBub3RoaW5nIHRvIHJlbW92ZSxcblx0XHRcdFx0XHRcdHdoaWxlICggY2xhc3NOYW1lLmluZGV4T2YoXCIgXCIgKyByZW1vdmVzWyBjIF0gKyBcIiBcIikgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoIFwiIFwiICsgcmVtb3Zlc1sgYyBdICsgXCIgXCIgLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGNsYXNzTmFtZSApIDogXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNCb29sID0gdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIjtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVZhbCxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoIGNvcmVfcnNwYWNlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdHN0YXRlID0gaXNCb29sID8gc3RhdGUgOiAhc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0c2VsZlsgc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCIgXSggY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRvZ2dsZSB3aG9sZSBjbGFzc05hbWVcblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWwsXG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkodGhpcyk7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIHNlbGYudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gYXR0cmlidXRlcy52YWx1ZSBpcyB1bmRlZmluZWQgaW4gQmxhY2tiZXJyeSA0LjcgYnV0XG5cdFx0XHRcdC8vIHVzZXMgLnZhbHVlLiBTZWUgIzY5MzJcblx0XHRcdFx0dmFyIHZhbCA9IGVsZW0uYXR0cmlidXRlcy52YWx1ZTtcblx0XHRcdFx0cmV0dXJuICF2YWwgfHwgdmFsLnNwZWNpZmllZCA/IGVsZW0udmFsdWUgOiBlbGVtLnRleHQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgaSwgbWF4LCBvcHRpb24sXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0dmFsdWVzID0gW10sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiO1xuXG5cdFx0XHRcdC8vIE5vdGhpbmcgd2FzIHNlbGVjdGVkXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkICYmIChqUXVlcnkuc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT09IG51bGwpICYmXG5cdFx0XHRcdFx0XHRcdCghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZpeGVzIEJ1ZyAjMjU1MSAtLSBzZWxlY3QudmFsKCkgYnJva2VuIGluIElFIGFmdGVyIGZvcm0ucmVzZXQoKVxuXHRcdFx0XHRpZiAoIG9uZSAmJiAhdmFsdWVzLmxlbmd0aCAmJiBvcHRpb25zLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5KCBvcHRpb25zWyBpbmRleCBdICkudmFsKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdGpRdWVyeShlbGVtKS5maW5kKFwib3B0aW9uXCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkodGhpcykudmFsKCksIHZhbHVlcyApID49IDA7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICggIXZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gVW51c2VkIGluIDEuOCwgbGVmdCBpbiBzbyBhdHRyRm4tc3RhYmJlcnMgd29uJ3QgZGllOyByZW1vdmUgaW4gMS45XG5cdGF0dHJGbjoge30sXG5cblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBwYXNzICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHBhc3MgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGpRdWVyeS5mblsgbmFtZSBdICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtIClbIG5hbWUgXSggdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBub3R4bWwgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHwgKCByYm9vbGVhbi50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgbm90eG1sICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBcIlwiICsgdmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiBub3R4bWwgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJldCA9PT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBwcm9wTmFtZSwgYXR0ck5hbWVzLCBuYW1lLCBpc0Jvb2wsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggdmFsdWUgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUuc3BsaXQoIGNvcmVfcnNwYWNlICk7XG5cblx0XHRcdGZvciAoIDsgaSA8IGF0dHJOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0bmFtZSA9IGF0dHJOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbmFtZSApIHtcblx0XHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRpc0Jvb2wgPSByYm9vbGVhbi50ZXN0KCBuYW1lICk7XG5cblx0XHRcdFx0XHQvLyBTZWUgIzk2OTkgZm9yIGV4cGxhbmF0aW9uIG9mIHRoaXMgYXBwcm9hY2ggKHNldHRpbmcgZmlyc3QsIHRoZW4gcmVtb3ZhbClcblx0XHRcdFx0XHQvLyBEbyBub3QgZG8gdGhpcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIChzZWUgIzEwODcwKVxuXHRcdFx0XHRcdGlmICggIWlzQm9vbCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBnZXRTZXRBdHRyaWJ1dGUgPyBuYW1lIDogcHJvcE5hbWUgKTtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRpZiAoIGlzQm9vbCAmJiBwcm9wTmFtZSBpbiBlbGVtICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0Ly8gV2UgY2FuJ3QgYWxsb3cgdGhlIHR5cGUgcHJvcGVydHkgdG8gYmUgY2hhbmdlZCAoc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIGluIElFKVxuXHRcdFx0XHRpZiAoIHJ0eXBlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVycm9yKCBcInR5cGUgcHJvcGVydHkgY2FuJ3QgYmUgY2hhbmdlZFwiICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICFqUXVlcnkuc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiYgalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIikgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxuXHRcdFx0XHRcdC8vIFJlc2V0IHZhbHVlIHRvIGl0J3MgZGVmYXVsdCBpbiBjYXNlIHR5cGUgaXMgc2V0IGFmdGVyIHZhbHVlXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBmb3IgZWxlbWVudCBjcmVhdGlvblxuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gVXNlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBmb3IgYmFjayBjb21wYXRcblx0XHQvLyBVc2UgdGhlIG5vZGVIb29rIGZvciBidXR0b24gZWxlbWVudHMgaW4gSUU2LzcgKCMxOTU0KVxuXHRcdHZhbHVlOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0XHRpZiAoIG5vZGVIb29rICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlSG9vay5nZXQoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmFtZSBpbiBlbGVtID9cblx0XHRcdFx0XHRlbGVtLnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0XHRpZiAoIG5vZGVIb29rICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9lcyBub3QgcmV0dXJuIHNvIHRoYXQgc2V0QXR0cmlidXRlIGlzIGFsc28gdXNlZFxuXHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHR0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuXHRcdHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuXHRcdG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcblx0XHRjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuXHRcdGNlbGxwYWRkaW5nOiBcImNlbGxQYWRkaW5nXCIsXG5cdFx0cm93c3BhbjogXCJyb3dTcGFuXCIsXG5cdFx0Y29sc3BhbjogXCJjb2xTcGFuXCIsXG5cdFx0dXNlbWFwOiBcInVzZU1hcFwiLFxuXHRcdGZyYW1lYm9yZGVyOiBcImZyYW1lQm9yZGVyXCIsXG5cdFx0Y29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZU5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJ0YWJpbmRleFwiKTtcblxuXHRcdFx0XHRyZXR1cm4gYXR0cmlidXRlTm9kZSAmJiBhdHRyaWJ1dGVOb2RlLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIGF0dHJpYnV0ZU5vZGUudmFsdWUsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdC8vIEFsaWduIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuXHRcdC8vIEZhbGwgYmFjayB0byBhdHRyaWJ1dGUgcHJlc2VuY2Ugd2hlcmUgc29tZSBib29sZWFucyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdHZhciBhdHRyTm9kZSxcblx0XHRcdHByb3BlcnR5ID0galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUgKTtcblx0XHRyZXR1cm4gcHJvcGVydHkgPT09IHRydWUgfHwgdHlwZW9mIHByb3BlcnR5ICE9PSBcImJvb2xlYW5cIiAmJiAoIGF0dHJOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpICkgJiYgYXR0ck5vZGUubm9kZVZhbHVlICE9PSBmYWxzZSA/XG5cdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YXIgcHJvcE5hbWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB2YWx1ZSBpcyB0cnVlIHNpbmNlIHdlIGtub3cgYXQgdGhpcyBwb2ludCBpdCdzIHR5cGUgYm9vbGVhbiBhbmQgbm90IGZhbHNlXG5cdFx0XHQvLyBTZXQgYm9vbGVhbiBhdHRyaWJ1dGVzIHRvIHRoZSBzYW1lIG5hbWUgYW5kIHNldCB0aGUgRE9NIHByb3BlcnR5XG5cdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGlmICggcHJvcE5hbWUgaW4gZWxlbSApIHtcblx0XHRcdFx0Ly8gT25seSBzZXQgdGhlIElETCBzcGVjaWZpY2FsbHkgaWYgaXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbi8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlXG5pZiAoICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG5cblx0Zml4U3BlY2lmaWVkID0ge1xuXHRcdG5hbWU6IHRydWUsXG5cdFx0aWQ6IHRydWUsXG5cdFx0Y29vcmRzOiB0cnVlXG5cdH07XG5cblx0Ly8gVXNlIHRoaXMgZm9yIGFueSBhdHRyaWJ1dGUgaW4gSUU2Lzdcblx0Ly8gVGhpcyBmaXhlcyBhbG1vc3QgZXZlcnkgSUU2LzcgaXNzdWVcblx0bm9kZUhvb2sgPSBqUXVlcnkudmFsSG9va3MuYnV0dG9uID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmV0O1xuXHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRyZXR1cm4gcmV0ICYmICggZml4U3BlY2lmaWVkWyBuYW1lIF0gPyByZXQudmFsdWUgIT09IFwiXCIgOiByZXQuc3BlY2lmaWVkICkgP1xuXHRcdFx0XHRyZXQudmFsdWUgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdC8vIFNldCB0aGUgZXhpc3Rpbmcgb3IgY3JlYXRlIGEgbmV3IGF0dHJpYnV0ZSBub2RlXG5cdFx0XHR2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRcdHJldCA9IGRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZU5vZGUoIHJldCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICggcmV0LnZhbHVlID0gdmFsdWUgKyBcIlwiICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFNldCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGF1dG8gaW5zdGVhZCBvZiAwIG9uIGVtcHR5IHN0cmluZyggQnVnICM4MTUwIClcblx0Ly8gVGhpcyBpcyBmb3IgcmVtb3ZhbHNcblx0alF1ZXJ5LmVhY2goWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdLCB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJhdXRvXCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0Ly8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG5cdC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG5cdGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuXHRcdGdldDogbm9kZUhvb2suZ2V0LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdFx0dmFsdWUgPSBcImZhbHNlXCI7XG5cdFx0XHR9XG5cdFx0XHRub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbi8vIFNvbWUgYXR0cmlidXRlcyByZXF1aXJlIGEgc3BlY2lhbCBjYWxsIG9uIElFXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHtcblx0alF1ZXJ5LmVhY2goWyBcImhyZWZcIiwgXCJzcmNcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCAyICk7XG5cdFx0XHRcdHJldHVybiByZXQgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5zdHlsZSApIHtcblx0alF1ZXJ5LmF0dHJIb29rcy5zdHlsZSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gUmV0dXJuIHVuZGVmaW5lZCBpbiB0aGUgY2FzZSBvZiBlbXB0eSBzdHJpbmdcblx0XHRcdC8vIE5vcm1hbGl6ZSB0byBsb3dlcmNhc2Ugc2luY2UgSUUgdXBwZXJjYXNlcyBjc3MgcHJvcGVydHkgbmFtZXNcblx0XHRcdHJldHVybiBlbGVtLnN0eWxlLmNzc1RleHQudG9Mb3dlckNhc2UoKSB8fCB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0uc3R5bGUuY3NzVGV4dCA9IFwiXCIgKyB2YWx1ZSApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gU2FmYXJpIG1pcy1yZXBvcnRzIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHByb3BlcnR5IG9mIGFuIG9wdGlvblxuLy8gQWNjZXNzaW5nIHRoZSBwYXJlbnQncyBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGZpeGVzIGl0XG5pZiAoICFqUXVlcnkuc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMVxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIElFNi83IGNhbGwgZW5jdHlwZSBlbmNvZGluZ1xuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuZW5jdHlwZSApIHtcblx0alF1ZXJ5LnByb3BGaXguZW5jdHlwZSA9IFwiZW5jb2RpbmdcIjtcbn1cblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmlmICggIWpRdWVyeS5zdXBwb3J0LmNoZWNrT24gKSB7XG5cdGpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgaW4gV2Via2l0IFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkudmFsSG9va3NbIHRoaXMgXSwge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUgKSA+PSAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pO1xudmFyIHJmb3JtRWxlbXMgPSAvXig/OnRleHRhcmVhfGlucHV0fHNlbGVjdCkkL2ksXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW15cXC5dKnwpKD86XFwuKC4rKXwpJC8sXG5cdHJob3ZlckhhY2sgPSAvKD86XnxcXHMpaG92ZXIoXFwuXFxTK3wpXFxiLyxcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdGhvdmVySGFjayA9IGZ1bmN0aW9uKCBldmVudHMgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ldmVudC5zcGVjaWFsLmhvdmVyID8gZXZlbnRzIDogZXZlbnRzLnJlcGxhY2UoIHJob3ZlckhhY2ssIFwibW91c2VlbnRlciQxIG1vdXNlbGVhdmUkMVwiICk7XG5cdH07XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGVsZW1EYXRhLCBldmVudEhhbmRsZSwgZXZlbnRzLFxuXHRcdFx0dCwgdG5zLCB0eXBlLCBuYW1lc3BhY2VzLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVPYmpJbiwgaGFuZGxlcnMsIHNwZWNpYWw7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGFsbG93IHBsYWluIG9iamVjdHMgdGhvKVxuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICF0eXBlcyB8fCAhaGFuZGxlciB8fCAhKGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICkpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cztcblx0XHRpZiAoICFldmVudHMgKSB7XG5cdFx0XHRlbGVtRGF0YS5ldmVudHMgPSBldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0aWYgKCAhZXZlbnRIYW5kbGUgKSB7XG5cdFx0XHRlbGVtRGF0YS5oYW5kbGUgPSBldmVudEhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmICghZSB8fCBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUpID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGV2ZW50SGFuZGxlLmVsZW0sIGFyZ3VtZW50cyApIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gQWRkIGVsZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlIGZuIHRvIHByZXZlbnQgYSBtZW1vcnkgbGVhayB3aXRoIElFIG5vbi1uYXRpdmUgZXZlbnRzXG5cdFx0XHRldmVudEhhbmRsZS5lbGVtID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0Ly8galF1ZXJ5KC4uLikuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XG5cdFx0dHlwZXMgPSBqUXVlcnkudHJpbSggaG92ZXJIYWNrKHR5cGVzKSApLnNwbGl0KCBcIiBcIiApO1xuXHRcdGZvciAoIHQgPSAwOyB0IDwgdHlwZXMubGVuZ3RoOyB0KysgKSB7XG5cblx0XHRcdHRucyA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gdG5zWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG5zWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogdG5zWzFdLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXTtcblx0XHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcblx0XHRlbGVtID0gbnVsbDtcblx0fSxcblxuXHRnbG9iYWw6IHt9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIHQsIHRucywgdHlwZSwgb3JpZ1R5cGUsIG5hbWVzcGFjZXMsIG9yaWdDb3VudCxcblx0XHRcdGosIGV2ZW50cywgc3BlY2lhbCwgZXZlbnRUeXBlLCBoYW5kbGVPYmosXG5cdFx0XHRlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0galF1ZXJ5LnRyaW0oIGhvdmVySGFjayggdHlwZXMgfHwgXCJcIiApICkuc3BsaXQoXCIgXCIpO1xuXHRcdGZvciAoIHQgPSAwOyB0IDwgdHlwZXMubGVuZ3RoOyB0KysgKSB7XG5cdFx0XHR0bnMgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG5zWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9IHRuc1syXTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3Rvcj8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGV2ZW50VHlwZSA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0b3JpZ0NvdW50ID0gZXZlbnRUeXBlLmxlbmd0aDtcblx0XHRcdG5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzID8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5zcGxpdChcIi5cIikuc29ydCgpLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbDtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBldmVudFR5cGUubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50VHlwZVsgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQgKCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQgKCAhbmFtZXNwYWNlcyB8fCBuYW1lc3BhY2VzLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0ICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRldmVudFR5cGUuc3BsaWNlKCBqLS0sIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0ZXZlbnRUeXBlLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggZXZlbnRUeXBlLmxlbmd0aCA9PT0gMCAmJiBvcmlnQ291bnQgIT09IGV2ZW50VHlwZS5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGVsZXRlIGVsZW1EYXRhLmhhbmRsZTtcblxuXHRcdFx0Ly8gcmVtb3ZlRGF0YSBhbHNvIGNoZWNrcyBmb3IgZW1wdGluZXNzIGFuZCBjbGVhcnMgdGhlIGV4cGFuZG8gaWYgZW1wdHlcblx0XHRcdC8vIHNvIHVzZSBpdCBpbnN0ZWFkIG9mIGRlbGV0ZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFwiZXZlbnRzXCIsIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gRXZlbnRzIHRoYXQgYXJlIHNhZmUgdG8gc2hvcnQtY2lyY3VpdCBpZiBubyBoYW5kbGVycyBhcmUgYXR0YWNoZWQuXG5cdC8vIE5hdGl2ZSBET00gZXZlbnRzIHNob3VsZCBub3QgYmUgYWRkZWQsIHRoZXkgbWF5IGhhdmUgaW5saW5lIGhhbmRsZXJzLlxuXHRjdXN0b21FdmVudDoge1xuXHRcdFwiZ2V0RGF0YVwiOiB0cnVlLFxuXHRcdFwic2V0RGF0YVwiOiB0cnVlLFxuXHRcdFwiY2hhbmdlRGF0YVwiOiB0cnVlXG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0gJiYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgb2JqZWN0IG9yIGV2ZW50IHR5cGVcblx0XHR2YXIgY2FjaGUsIGV4Y2x1c2l2ZSwgaSwgY3VyLCBvbGQsIG9udHlwZSwgc3BlY2lhbCwgaGFuZGxlLCBldmVudFBhdGgsIGJ1YmJsZVR5cGUsXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBbXTtcblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIhXCIgKSA+PSAwICkge1xuXHRcdFx0Ly8gRXhjbHVzaXZlIGV2ZW50cyB0cmlnZ2VyIG9ubHkgZm9yIHRoZSBleGFjdCBldmVudCAobm8gbmFtZXNwYWNlcylcblx0XHRcdHR5cGUgPSB0eXBlLnNsaWNlKDAsIC0xKTtcblx0XHRcdGV4Y2x1c2l2ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPj0gMCApIHtcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cblx0XHRpZiAoICghZWxlbSB8fCBqUXVlcnkuZXZlbnQuY3VzdG9tRXZlbnRbIHR5cGUgXSkgJiYgIWpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSApIHtcblx0XHRcdC8vIE5vIGpRdWVyeSBoYW5kbGVycyBmb3IgdGhpcyBldmVudCB0eXBlLCBhbmQgaXQgY2FuJ3QgaGF2ZSBpbmxpbmUgaGFuZGxlcnNcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gRXZlbnQsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiID9cblx0XHRcdC8vIGpRdWVyeS5FdmVudCBvYmplY3Rcblx0XHRcdGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID8gZXZlbnQgOlxuXHRcdFx0Ly8gT2JqZWN0IGxpdGVyYWxcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIGV2ZW50ICkgOlxuXHRcdFx0Ly8gSnVzdCB0aGUgZXZlbnQgdHlwZSAoc3RyaW5nKVxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSApO1xuXG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gdHJ1ZTtcblx0XHRldmVudC5leGNsdXNpdmUgPSBleGNsdXNpdmU7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZT8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGw7XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCA/IFwib25cIiArIHR5cGUgOiBcIlwiO1xuXG5cdFx0Ly8gSGFuZGxlIGEgZ2xvYmFsIHRyaWdnZXJcblx0XHRpZiAoICFlbGVtICkge1xuXG5cdFx0XHQvLyBUT0RPOiBTdG9wIHRhdW50aW5nIHRoZSBkYXRhIGNhY2hlOyByZW1vdmUgZ2xvYmFsIGV2ZW50cyBhbmQgYWx3YXlzIGF0dGFjaCB0byBkb2N1bWVudFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGU7XG5cdFx0XHRmb3IgKCBpIGluIGNhY2hlICkge1xuXHRcdFx0XHRpZiAoIGNhY2hlWyBpIF0uZXZlbnRzICYmIGNhY2hlWyBpIF0uZXZlbnRzWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhLCBjYWNoZVsgaSBdLmhhbmRsZS5lbGVtLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgIT0gbnVsbCA/IGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSA6IFtdO1xuXHRcdGRhdGEudW5zaGlmdCggZXZlbnQgKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRldmVudFBhdGggPSBbWyBlbGVtLCBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGUgXV07XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRjdXIgPSByZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApID8gZWxlbSA6IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGZvciAoIG9sZCA9IGVsZW07IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKFsgY3VyLCBidWJibGVUeXBlIF0pO1xuXHRcdFx0XHRvbGQgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCBvbGQgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaChbIG9sZC5kZWZhdWx0VmlldyB8fCBvbGQucGFyZW50V2luZG93IHx8IHdpbmRvdywgYnViYmxlVHlwZSBdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBldmVudFBhdGgubGVuZ3RoICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpOyBpKysgKSB7XG5cblx0XHRcdGN1ciA9IGV2ZW50UGF0aFtpXVswXTtcblx0XHRcdGV2ZW50LnR5cGUgPSBldmVudFBhdGhbaV1bMV07XG5cblx0XHRcdGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXMgYSBiYXJlIEpTIGZ1bmN0aW9uIGFuZCBub3QgYSBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgJiYgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGVsZW0ub3duZXJEb2N1bWVudCwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0ISh0eXBlID09PSBcImNsaWNrXCIgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImFcIiApKSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gQ2FuJ3QgdXNlIGFuIC5pc0Z1bmN0aW9uKCkgY2hlY2sgaGVyZSBiZWNhdXNlIElFNi83IGZhaWxzIHRoYXQgdGVzdC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHQvLyBJRTw5IGRpZXMgb24gZm9jdXMvYmx1ciB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYpXG5cdFx0XHRcdGlmICggb250eXBlICYmIGVsZW1bIHR5cGUgXSAmJiAoKHR5cGUgIT09IFwiZm9jdXNcIiAmJiB0eXBlICE9PSBcImJsdXJcIikgfHwgZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoICE9PSAwKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0b2xkID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIG9sZCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIG9sZCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gb2xkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgfHwgd2luZG93LmV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgY3VyLCByZXQsIHNlbE1hdGNoLCBtYXRjaGVkLCBtYXRjaGVzLCBoYW5kbGVPYmosIHNlbCwgcmVsYXRlZCxcblx0XHRcdGhhbmRsZXJzID0gKCAoalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdKSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0YXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0cnVuX2FsbCA9ICFldmVudC5leGNsdXNpdmUgJiYgIWV2ZW50Lm5hbWVzcGFjZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9LFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW107XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbMF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzIHRoYXQgc2hvdWxkIHJ1biBpZiB0aGVyZSBhcmUgZGVsZWdhdGVkIGV2ZW50c1xuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiAhKGV2ZW50LmJ1dHRvbiAmJiBldmVudC50eXBlID09PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHRmb3IgKCBjdXIgPSBldmVudC50YXJnZXQ7IGN1ciAhPSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIChPTkxZKSBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xuXHRcdFx0XHRcdHNlbE1hdGNoID0ge307XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvcjtcblxuXHRcdFx0XHRcdFx0aWYgKCBzZWxNYXRjaFsgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0c2VsTWF0Y2hbIHNlbCBdID0galF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggc2VsTWF0Y2hbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIG1hdGNoZXM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggaGFuZGxlcnMubGVuZ3RoID4gZGVsZWdhdGVDb3VudCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgbWF0Y2hlczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgaGFuZGxlclF1ZXVlLmxlbmd0aCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTsgaSsrICkge1xuXHRcdFx0bWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSBdO1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBtYXRjaGVkLm1hdGNoZXMubGVuZ3RoICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpOyBqKysgKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IG1hdGNoZWQubWF0Y2hlc1sgaiBdO1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBiZSBub24tZXhjbHVzaXZlIGFuZCBoYXZlIG5vIG5hbWVzcGFjZSwgb3Jcblx0XHRcdFx0Ly8gMikgaGF2ZSBuYW1lc3BhY2UocykgYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggcnVuX2FsbCB8fCAoIWV2ZW50Lm5hbWVzcGFjZSAmJiAhaGFuZGxlT2JqLm5hbWVzcGFjZSkgfHwgZXZlbnQubmFtZXNwYWNlX3JlICYmIGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnJlc3VsdCA9IHJldDtcblx0XHRcdFx0XHRcdGlmICggcmV0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0Ly8gKioqIGF0dHJDaGFuZ2UgYXR0ck5hbWUgcmVsYXRlZE5vZGUgc3JjRWxlbWVudCAgYXJlIG5vdCBub3JtYWxpemVkLCBub24tVzNDLCBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMS44ICoqKlxuXHRwcm9wczogXCJhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcblx0XHRcdFx0ZnJvbUVsZW1lbnQgPSBvcmlnaW5hbC5mcm9tRWxlbWVudDtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcblx0XHRcdFx0ZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBvcmlnaW5hbC50b0VsZW1lbnQgOiBmcm9tRWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSBqUXVlcnkuZXZlbnQuZml4SG9va3NbIGV2ZW50LnR5cGUgXSB8fCB7fSxcblx0XHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0Zm9yICggaSA9IGNvcHkubGVuZ3RoOyBpOyApIHtcblx0XHRcdHByb3AgPSBjb3B5WyAtLWkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gRml4IHRhcmdldCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5ICgjMTkyNSwgSUUgNi83LzggJiBTYWZhcmkyKVxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgU2FmYXJpKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIG1vdXNlL2tleSBldmVudHMsIG1ldGFLZXk9PWZhbHNlIGlmIGl0J3MgdW5kZWZpbmVkICgjMzM2OCwgIzExMzI4OyBJRTYvNy84KVxuXHRcdGV2ZW50Lm1ldGFLZXkgPSAhIWV2ZW50Lm1ldGFLZXk7XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXI/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblxuXHRcdGZvY3VzOiB7XG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSB7XG5cdFx0XHRcdC8vIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIHNwZWNpYWwgY2FzZSBvbiB3aW5kb3dzXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5vbmJlZm9yZXVubG9hZCA9IGV2ZW50SGFuZGxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub25iZWZvcmV1bmxvYWQgPT09IGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHRcdHRoaXMub25iZWZvcmV1bmxvYWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7IHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxuLy8gU29tZSBwbHVnaW5zIGFyZSB1c2luZywgYnV0IGl0J3MgdW5kb2N1bWVudGVkL2RlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZC5cbi8vIFRoZSAxLjcgc3BlY2lhbCBldmVudCBpbnRlcmZhY2Ugc2hvdWxkIHByb3ZpZGUgYWxsIHRoZSBob29rcyBuZWVkZWQgbm93LlxualF1ZXJ5LmV2ZW50LmhhbmRsZSA9IGpRdWVyeS5ldmVudC5kaXNwYXRjaDtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG5cdGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdFx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0gOlxuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdHZhciBuYW1lID0gXCJvblwiICsgdHlwZTtcblxuXHRcdGlmICggZWxlbS5kZXRhY2hFdmVudCApIHtcblxuXHRcdFx0Ly8gIzg1NDUsICM3MDU0LCBwcmV2ZW50aW5nIG1lbW9yeSBsZWFrcyBmb3IgY3VzdG9tIGV2ZW50cyBpbiBJRTYtOCDigJNcblx0XHRcdC8vIGRldGFjaEV2ZW50IG5lZWRlZCBwcm9wZXJ0eSBvbiBlbGVtZW50LCBieSBuYW1lIG9mIHRoYXQgZXZlbnQsIHRvIHByb3Blcmx5IGV4cG9zZSBpdCB0byBHQ1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbVsgbmFtZSBdID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRlbGVtWyBuYW1lIF0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLmRldGFjaEV2ZW50KCBuYW1lLCBoYW5kbGUgKTtcblx0XHR9XG5cdH07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSB8fFxuXHRcdFx0c3JjLmdldFByZXZlbnREZWZhdWx0ICYmIHNyYy5nZXRQcmV2ZW50RGVmYXVsdCgpICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCAhZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZSAoSUUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlIChJRSlcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2Vcbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iaixcblx0XHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmouc2VsZWN0b3I7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3VibWl0QnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExhenktYWRkIGEgc3VibWl0IGhhbmRsZXIgd2hlbiBhIGRlc2NlbmRhbnQgZm9ybSBtYXkgcG90ZW50aWFsbHkgYmUgc3VibWl0dGVkXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCxcblx0XHRcdFx0XHRmb3JtID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSA/IGVsZW0uZm9ybSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCBmb3JtICYmICFqUXVlcnkuX2RhdGEoIGZvcm0sIFwiX3N1Ym1pdF9hdHRhY2hlZFwiICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZm9ybSwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5fc3VibWl0X2J1YmJsZSA9IHRydWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBmb3JtLCBcIl9zdWJtaXRfYXR0YWNoZWRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UgZG9uJ3QgbmVlZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdH0sXG5cblx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8vIElmIGZvcm0gd2FzIHN1Ym1pdHRlZCBieSB0aGUgdXNlciwgYnViYmxlIHRoZSBldmVudCB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCBldmVudC5fc3VibWl0X2J1YmJsZSApIHtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50Ll9zdWJtaXRfYnViYmxlO1xuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9zdWJtaXRcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gSUUgY2hhbmdlIGRlbGVnYXRpb24gYW5kIGNoZWNrYm94L3JhZGlvIGZpeFxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hhbmdlQnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG5cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICkgKSB7XG5cdFx0XHRcdC8vIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2Ugb24gYSBjaGVjay9yYWRpbyB1bnRpbCBibHVyOyB0cmlnZ2VyIGl0IG9uIGNsaWNrXG5cdFx0XHRcdC8vIGFmdGVyIGEgcHJvcGVydHljaGFuZ2UuIEVhdCB0aGUgYmx1ci1jaGFuZ2UgaW4gc3BlY2lhbC5jaGFuZ2UuaGFuZGxlLlxuXHRcdFx0XHQvLyBUaGlzIHN0aWxsIGZpcmVzIG9uY2hhbmdlIGEgc2Vjb25kIHRpbWUgZm9yIGNoZWNrL3JhZGlvIGFmdGVyIGJsdXIuXG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUgPT09IFwiY2hlY2tlZFwiICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9qdXN0X2NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2p1c3RfY2hhbmdlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9qdXN0X2NoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIEFsbG93IHRyaWdnZXJlZCwgc2ltdWxhdGVkIGNoYW5nZSBldmVudHMgKCMxMTUwMClcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcywgZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZWxlZ2F0ZWQgZXZlbnQ7IGxhenktYWRkIGEgY2hhbmdlIGhhbmRsZXIgb24gZGVzY2VuZGFudCBpbnB1dHNcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiYmVmb3JlYWN0aXZhdGUuX2NoYW5nZVwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldDtcblxuXHRcdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggZWxlbS5ub2RlTmFtZSApICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwiX2NoYW5nZV9hdHRhY2hlZFwiICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWxlbSwgXCJjaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNTaW11bGF0ZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIl9jaGFuZ2VfYXR0YWNoZWRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0Ly8gU3dhbGxvdyBuYXRpdmUgY2hhbmdlIGV2ZW50cyBmcm9tIGNoZWNrYm94L3JhZGlvLCB3ZSBhbHJlYWR5IHRyaWdnZXJlZCB0aGVtIGFib3ZlXG5cdFx0XHRpZiAoIHRoaXMgIT09IGVsZW0gfHwgZXZlbnQuaXNTaW11bGF0ZWQgfHwgZXZlbnQuaXNUcmlnZ2VyIHx8IChlbGVtLnR5cGUgIT09IFwicmFkaW9cIiAmJiBlbGVtLnR5cGUgIT09IFwiY2hlY2tib3hcIikgKSB7XG5cdFx0XHRcdHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xuXG5cdFx0XHRyZXR1cm4gIXJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbmlmICggIWpRdWVyeS5zdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGF0dGFjaGVzID0gMCxcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYXR0YWNoZXMrKyA9PT0gMCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggLS1hdHRhY2hlcyA9PT0gMCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHsgLy8gJiYgc2VsZWN0b3IgIT0gbnVsbFxuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRsaXZlOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdGpRdWVyeSggdGhpcy5jb250ZXh0ICkub24oIHR5cGVzLCB0aGlzLnNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRkaWU6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0alF1ZXJ5KCB0aGlzLmNvbnRleHQgKS5vZmYoIHR5cGVzLCB0aGlzLnNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDE/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpc1swXSwgdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHQvLyBTYXZlIHJlZmVyZW5jZSB0byBhcmd1bWVudHMgZm9yIGFjY2VzcyBpbiBjbG9zdXJlXG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR0b2dnbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBGaWd1cmUgb3V0IHdoaWNoIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcblx0XHRcdFx0dmFyIGxhc3RUb2dnbGUgPSAoIGpRdWVyeS5fZGF0YSggdGhpcywgXCJsYXN0VG9nZ2xlXCIgKyBmbi5ndWlkICkgfHwgMCApICUgaTtcblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQsIGxhc3RUb2dnbGUgKyAxICk7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY2xpY2tzIHN0b3Bcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHQvLyBhbmQgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cblx0XHRcdFx0cmV0dXJuIGFyZ3NbIGxhc3RUb2dnbGUgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfHwgZmFsc2U7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gbGluayBhbGwgdGhlIGZ1bmN0aW9ucywgc28gYW55IG9mIHRoZW0gY2FuIHVuYmluZCB0aGlzIGNsaWNrIGhhbmRsZXJcblx0XHR0b2dnbGVyLmd1aWQgPSBndWlkO1xuXHRcdHdoaWxlICggaSA8IGFyZ3MubGVuZ3RoICkge1xuXHRcdFx0YXJnc1sgaSsrIF0uZ3VpZCA9IGd1aWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuY2xpY2soIHRvZ2dsZXIgKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0aWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG5cblx0aWYgKCBya2V5RXZlbnQudGVzdCggbmFtZSApICkge1xuXHRcdGpRdWVyeS5ldmVudC5maXhIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV2ZW50LmtleUhvb2tzO1xuXHR9XG5cblx0aWYgKCBybW91c2VFdmVudC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmZpeEhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXZlbnQubW91c2VIb29rcztcblx0fVxufSk7XG4vKiFcclxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmVcclxuICogIENvcHlyaWdodCAyMDEyIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcclxuICogIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiAgaHR0cDovL3NpenpsZWpzLmNvbS9cclxuICovXHJcbihmdW5jdGlvbiggd2luZG93LCB1bmRlZmluZWQgKSB7XHJcblxyXG52YXIgZGlycnVucyxcclxuXHRjYWNoZWRydW5zLFxyXG5cdGFzc2VydEdldElkTm90TmFtZSxcclxuXHRFeHByLFxyXG5cdGdldFRleHQsXHJcblx0aXNYTUwsXHJcblx0Y29udGFpbnMsXHJcblx0Y29tcGlsZSxcclxuXHRzb3J0T3JkZXIsXHJcblx0aGFzRHVwbGljYXRlLFxyXG5cclxuXHRiYXNlSGFzRHVwbGljYXRlID0gdHJ1ZSxcclxuXHRzdHJ1bmRlZmluZWQgPSBcInVuZGVmaW5lZFwiLFxyXG5cclxuXHRleHBhbmRvID0gKCBcInNpemNhY2hlXCIgKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggXCIuXCIsIFwiXCIgKSxcclxuXHJcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXHJcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHRkb25lID0gMCxcclxuXHRzbGljZSA9IFtdLnNsaWNlLFxyXG5cdHB1c2ggPSBbXS5wdXNoLFxyXG5cclxuXHQvLyBBdWdtZW50IGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxyXG5cdG1hcmtGdW5jdGlvbiA9IGZ1bmN0aW9uKCBmbiwgdmFsdWUgKSB7XHJcblx0XHRmblsgZXhwYW5kbyBdID0gdmFsdWUgfHwgdHJ1ZTtcclxuXHRcdHJldHVybiBmbjtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVDYWNoZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNhY2hlID0ge30sXHJcblx0XHRcdGtleXMgPSBbXTtcclxuXHJcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xyXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcclxuXHRcdFx0aWYgKCBrZXlzLnB1c2goIGtleSApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcclxuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgXSA9IHZhbHVlKTtcclxuXHRcdH0sIGNhY2hlICk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXHJcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXHJcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXHJcblxyXG5cdC8vIFJlZ2V4XHJcblxyXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxyXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXHJcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnNcclxuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFstXFxcXHddfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXHJcblxyXG5cdC8vIExvb3NlbHkgbW9kZWxlZCBvbiBDU1MgaWRlbnRpZmllciBjaGFyYWN0ZXJzXHJcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgKGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzKVxyXG5cdC8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXHJcblxyXG5cdC8vIEFjY2VwdGFibGUgb3BlcmF0b3JzIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xyXG5cdG9wZXJhdG9ycyA9IFwiKFsqXiR8IX5dPz0pXCIsXHJcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICsgd2hpdGVzcGFjZSArXHJcblx0XHRcIiooPzpcIiArIG9wZXJhdG9ycyArIHdoaXRlc3BhY2UgKyBcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIiArIGlkZW50aWZpZXIgKyBcIil8KXwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcclxuXHJcblx0Ly8gUHJlZmVyIGFyZ3VtZW50cyBub3QgaW4gcGFyZW5zL2JyYWNrZXRzLFxyXG5cdC8vICAgdGhlbiBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFuZCBub24tcHNldWRvcyAoZGVub3RlZCBieSA6KSxcclxuXHQvLyAgIHRoZW4gYW55dGhpbmcgZWxzZVxyXG5cdC8vIFRoZXNlIHByZWZlcmVuY2VzIGFyZSBoZXJlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9yc1xyXG5cdC8vICAgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgUFNFVURPIHByZUZpbHRlclxyXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKD86KFsnXFxcIl0pKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXSkqPylcXFxcMnwoW14oKVtcXFxcXV0qfCg/Oig/OlwiICsgYXR0cmlidXRlcyArIFwiKXxbXjpdfFxcXFxcXFxcLikqfC4qKSlcXFxcKXwpXCIsXHJcblxyXG5cdC8vIEZvciBtYXRjaEV4cHIuUE9TIGFuZCBtYXRjaEV4cHIubmVlZHNDb250ZXh0XHJcblx0cG9zID0gXCI6KG50aHxlcXxndHxsdHxmaXJzdHxsYXN0fGV2ZW58b2RkKSg/OlxcXFwoKCg/Oi1cXFxcZCk/XFxcXGQqKVxcXFwpfCkoPz1bXi1dfCQpXCIsXHJcblxyXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcclxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXHJcblxyXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxyXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmPit+XSlcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxyXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXHJcblxyXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xyXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcd1xcLV0rKXwoXFx3Kyl8XFwuKFtcXHdcXC1dKykpJC8sXHJcblxyXG5cdHJub3QgPSAvXjpub3QvLFxyXG5cdHJzaWJsaW5nID0gL1tcXHgyMFxcdFxcclxcblxcZl0qWyt+XS8sXHJcblx0cmVuZHNXaXRoTm90ID0gLzpub3RcXCgkLyxcclxuXHJcblx0cmhlYWRlciA9IC9oXFxkL2ksXHJcblx0cmlucHV0cyA9IC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uL2ksXHJcblxyXG5cdHJiYWNrc2xhc2ggPSAvXFxcXCg/IVxcXFwpL2csXHJcblxyXG5cdG1hdGNoRXhwciA9IHtcclxuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcclxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXHJcblx0XHRcIk5BTUVcIjogbmV3IFJlZ0V4cCggXCJeXFxcXFtuYW1lPVsnXFxcIl0/KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilbJ1xcXCJdP1xcXFxdXCIgKSxcclxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXHJcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXHJcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcclxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fG50aHxsYXN0fGZpcnN0KS1jaGlsZCg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcclxuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcclxuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXHJcblx0XHRcIlBPU1wiOiBuZXcgUmVnRXhwKCBwb3MsIFwiaWdcIiApLFxyXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXHJcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXxcIiArIHBvcywgXCJpXCIgKVxyXG5cdH0sXHJcblxyXG5cdC8vIFN1cHBvcnRcclxuXHJcblx0Ly8gVXNlZCBmb3IgdGVzdGluZyBzb21ldGhpbmcgb24gYW4gZWxlbWVudFxyXG5cdGFzc2VydCA9IGZ1bmN0aW9uKCBmbiApIHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHJldHVybiBmbiggZGl2ICk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0gZmluYWxseSB7XHJcblx0XHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXHJcblx0XHRcdGRpdiA9IG51bGw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xyXG5cdGFzc2VydFRhZ05hbWVOb0NvbW1lbnRzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcclxuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XHJcblx0fSksXHJcblxyXG5cdC8vIENoZWNrIGlmIGdldEF0dHJpYnV0ZSByZXR1cm5zIG5vcm1hbGl6ZWQgaHJlZiBhdHRyaWJ1dGVzXHJcblx0YXNzZXJ0SHJlZk5vdE5vcm1hbGl6ZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcclxuXHRcdHJldHVybiBkaXYuZmlyc3RDaGlsZCAmJiB0eXBlb2YgZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgJiZcclxuXHRcdFx0ZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XHJcblx0fSksXHJcblxyXG5cdC8vIENoZWNrIGlmIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHJldHJpZXZlZCBieSBhdHRyaWJ1dGUgbm9kZXNcclxuXHRhc3NlcnRBdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8c2VsZWN0Pjwvc2VsZWN0PlwiO1xyXG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgZGl2Lmxhc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcclxuXHRcdC8vIElFOCByZXR1cm5zIGEgc3RyaW5nIGZvciBzb21lIGF0dHJpYnV0ZXMgZXZlbiB3aGVuIG5vdCBwcmVzZW50XHJcblx0XHRyZXR1cm4gdHlwZSAhPT0gXCJib29sZWFuXCIgJiYgdHlwZSAhPT0gXCJzdHJpbmdcIjtcclxuXHR9KSxcclxuXHJcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBjYW4gYmUgdHJ1c3RlZFxyXG5cdGFzc2VydFVzYWJsZUNsYXNzTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cdFx0Ly8gT3BlcmEgY2FuJ3QgZmluZCBhIHNlY29uZCBjbGFzc25hbWUgKGluIDkuNilcclxuXHRcdGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2hpZGRlbiBlJz48L2Rpdj48ZGl2IGNsYXNzPSdoaWRkZW4nPjwvZGl2PlwiO1xyXG5cdFx0aWYgKCAhZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgfHwgIWRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTYWZhcmkgMy4yIGNhY2hlcyBjbGFzcyBhdHRyaWJ1dGVzIGFuZCBkb2Vzbid0IGNhdGNoIGNoYW5nZXNcclxuXHRcdGRpdi5sYXN0Q2hpbGQuY2xhc3NOYW1lID0gXCJlXCI7XHJcblx0XHRyZXR1cm4gZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aCA9PT0gMjtcclxuXHR9KSxcclxuXHJcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXHJcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeU5hbWUgcHJpdmlsZWdlcyBmb3JtIGNvbnRyb2xzIG9yIHJldHVybnMgZWxlbWVudHMgYnkgSURcclxuXHRhc3NlcnRVc2FibGVOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHQvLyBJbmplY3QgY29udGVudFxyXG5cdFx0ZGl2LmlkID0gZXhwYW5kbyArIDA7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8YSBuYW1lPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPjxkaXYgbmFtZT0nXCIgKyBleHBhbmRvICsgXCInPjwvZGl2PlwiO1xyXG5cdFx0ZG9jRWxlbS5pbnNlcnRCZWZvcmUoIGRpdiwgZG9jRWxlbS5maXJzdENoaWxkICk7XHJcblxyXG5cdFx0Ly8gVGVzdFxyXG5cdFx0dmFyIHBhc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSAmJlxyXG5cdFx0XHQvLyBidWdneSBicm93c2VycyB3aWxsIHJldHVybiBmZXdlciB0aGFuIHRoZSBjb3JyZWN0IDJcclxuXHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGggPT09IDIgK1xyXG5cdFx0XHQvLyBidWdneSBicm93c2VycyB3aWxsIHJldHVybiBtb3JlIHRoYW4gdGhlIGNvcnJlY3QgMFxyXG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyArIDAgKS5sZW5ndGg7XHJcblx0XHRhc3NlcnRHZXRJZE5vdE5hbWUgPSAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGV4cGFuZG8gKTtcclxuXHJcblx0XHQvLyBDbGVhbnVwXHJcblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBkaXYgKTtcclxuXHJcblx0XHRyZXR1cm4gcGFzcztcclxuXHR9KTtcclxuXHJcbi8vIElmIHNsaWNlIGlzIG5vdCBhdmFpbGFibGUsIHByb3ZpZGUgYSBiYWNrdXBcclxudHJ5IHtcclxuXHRzbGljZS5jYWxsKCBkb2NFbGVtLmNoaWxkTm9kZXMsIDAgKVswXS5ub2RlVHlwZTtcclxufSBjYXRjaCAoIGUgKSB7XHJcblx0c2xpY2UgPSBmdW5jdGlvbiggaSApIHtcclxuXHRcdHZhciBlbGVtLCByZXN1bHRzID0gW107XHJcblx0XHRmb3IgKCA7IChlbGVtID0gdGhpc1tpXSk7IGkrKyApIHtcclxuXHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xyXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xyXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xyXG5cdHZhciBtYXRjaCwgZWxlbSwgeG1sLCBtLFxyXG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xyXG5cclxuXHRpZiAoIG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICkge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH1cclxuXHJcblx0aWYgKCAhc2VsZWN0b3IgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xyXG5cdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0fVxyXG5cclxuXHR4bWwgPSBpc1hNTCggY29udGV4dCApO1xyXG5cclxuXHRpZiAoICF4bWwgJiYgIXNlZWQgKSB7XHJcblx0XHRpZiAoIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XHJcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcclxuXHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcclxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xyXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcclxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXHJcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXHJcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUsIE9wZXJhLCBhbmQgV2Via2l0IHJldHVybiBpdGVtc1xyXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcclxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxyXG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcclxuXHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJiBlbGVtLmlkID09PSBtICkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcclxuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzbGljZS5jYWxsKGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICksIDApICk7XHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXHJcblx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIGFzc2VydFVzYWJsZUNsYXNzTmFtZSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XHJcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbChjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSwgMCkgKTtcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQWxsIG90aGVyc1xyXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkLCB4bWwgKTtcclxufVxyXG5cclxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XHJcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcclxufTtcclxuXHJcblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcclxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XHJcbn07XHJcblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXHJcbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xyXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XHJcblx0fTtcclxufVxyXG5cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcclxuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXHJcbiAqL1xyXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHR2YXIgbm9kZSxcclxuXHRcdHJldCA9IFwiXCIsXHJcblx0XHRpID0gMCxcclxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcblx0aWYgKCBub2RlVHlwZSApIHtcclxuXHRcdGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xyXG5cdFx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXHJcblx0XHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKHNlZSAjMTExNTMpXHJcblx0XHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXHJcblx0XHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XHJcblx0XHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XHJcblx0XHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcclxuXHRcdH1cclxuXHRcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcclxuXHRcdGZvciAoIDsgKG5vZGUgPSBlbGVtW2ldKTsgaSsrICkge1xyXG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xyXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiBpc1hNTCggZWxlbSApIHtcclxuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXHJcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XHJcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcclxufTtcclxuXHJcbi8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxyXG5jb250YWlucyA9IFNpenpsZS5jb250YWlucyA9IGRvY0VsZW0uY29udGFpbnMgP1xyXG5cdGZ1bmN0aW9uKCBhLCBiICkge1xyXG5cdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcclxuXHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XHJcblx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIGFkb3duLmNvbnRhaW5zICYmIGFkb3duLmNvbnRhaW5zKGJ1cCkgKTtcclxuXHR9IDpcclxuXHRkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cclxuXHRmdW5jdGlvbiggYSwgYiApIHtcclxuXHRcdHJldHVybiBiICYmICEhKCBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgJiAxNiApO1xyXG5cdH0gOlxyXG5cdGZ1bmN0aW9uKCBhLCBiICkge1xyXG5cdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XHJcblx0XHRcdGlmICggYiA9PT0gYSApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG5cdHZhciBhdHRyLFxyXG5cdFx0eG1sID0gaXNYTUwoIGVsZW0gKTtcclxuXHJcblx0aWYgKCAheG1sICkge1xyXG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHR9XHJcblx0aWYgKCBFeHByLmF0dHJIYW5kbGVbIG5hbWUgXSApIHtcclxuXHRcdHJldHVybiBFeHByLmF0dHJIYW5kbGVbIG5hbWUgXSggZWxlbSApO1xyXG5cdH1cclxuXHRpZiAoIGFzc2VydEF0dHJpYnV0ZXMgfHwgeG1sICkge1xyXG5cdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XHJcblx0fVxyXG5cdGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcclxuXHRyZXR1cm4gYXR0ciA/XHJcblx0XHR0eXBlb2YgZWxlbVsgbmFtZSBdID09PSBcImJvb2xlYW5cIiA/XHJcblx0XHRcdGVsZW1bIG5hbWUgXSA/IG5hbWUgOiBudWxsIDpcclxuXHRcdFx0YXR0ci5zcGVjaWZpZWQgPyBhdHRyLnZhbHVlIDogbnVsbCA6XHJcblx0XHRudWxsO1xyXG59O1xyXG5cclxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XHJcblxyXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcclxuXHJcblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXHJcblxyXG5cdG1hdGNoOiBtYXRjaEV4cHIsXHJcblxyXG5cdG9yZGVyOiBuZXcgUmVnRXhwKCBcIklEfFRBR1wiICtcclxuXHRcdChhc3NlcnRVc2FibGVOYW1lID8gXCJ8TkFNRVwiIDogXCJcIikgK1xyXG5cdFx0KGFzc2VydFVzYWJsZUNsYXNzTmFtZSA/IFwifENMQVNTXCIgOiBcIlwiKVxyXG5cdCksXHJcblxyXG5cdC8vIElFNi83IHJldHVybiBhIG1vZGlmaWVkIGhyZWZcclxuXHRhdHRySGFuZGxlOiBhc3NlcnRIcmVmTm90Tm9ybWFsaXplZCA/XHJcblx0XHR7fSA6XHJcblx0XHR7XHJcblx0XHRcdFwiaHJlZlwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiLCAyICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFwidHlwZVwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRmaW5kOiB7XHJcblx0XHRcIklEXCI6IGFzc2VydEdldElkTm90TmFtZSA/XHJcblx0XHRcdGZ1bmN0aW9uKCBpZCwgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IHN0cnVuZGVmaW5lZCAmJiAheG1sICkge1xyXG5cdFx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xyXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcclxuXHRcdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFttXSA6IFtdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSA6XHJcblx0XHRcdGZ1bmN0aW9uKCBpZCwgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IHN0cnVuZGVmaW5lZCAmJiAheG1sICkge1xyXG5cdFx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBtID9cclxuXHRcdFx0XHRcdFx0bS5pZCA9PT0gaWQgfHwgdHlwZW9mIG0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gc3RydW5kZWZpbmVkICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLnZhbHVlID09PSBpZCA/XHJcblx0XHRcdFx0XHRcdFx0W21dIDpcclxuXHRcdFx0XHRcdFx0XHR1bmRlZmluZWQgOlxyXG5cdFx0XHRcdFx0XHRbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XCJUQUdcIjogYXNzZXJ0VGFnTmFtZU5vQ29tbWVudHMgP1xyXG5cdFx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xyXG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gOlxyXG5cdFx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xyXG5cdFx0XHRcdHZhciByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XHJcblxyXG5cdFx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcclxuXHRcdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XHJcblx0XHRcdFx0XHR2YXIgZWxlbSxcclxuXHRcdFx0XHRcdFx0dG1wID0gW10sXHJcblx0XHRcdFx0XHRcdGkgPSAwO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIDsgKGVsZW0gPSByZXN1bHRzW2ldKTsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0bXA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFwiTkFNRVwiOiBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xyXG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lICE9PSBzdHJ1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIG5hbWUgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgIXhtbCApIHtcclxuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlbGF0aXZlOiB7XHJcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxyXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxyXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxyXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cclxuXHR9LFxyXG5cclxuXHRwcmVGaWx0ZXI6IHtcclxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcmJhY2tzbGFzaCwgXCJcIiApO1xyXG5cclxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcclxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCByYmFja3NsYXNoLCBcIlwiICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XHJcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcclxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwci5DSElMRFxyXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxyXG5cdFx0XHRcdDIgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXHJcblx0XHRcdFx0MyB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXHJcblx0XHRcdFx0NCBzaWduIG9mIHhuLWNvbXBvbmVudFxyXG5cdFx0XHRcdDUgeCBvZiB4bi1jb21wb25lbnRcclxuXHRcdFx0XHQ2IHNpZ24gb2YgeS1jb21wb25lbnRcclxuXHRcdFx0XHQ3IHkgb2YgeS1jb21wb25lbnRcclxuXHRcdFx0Ki9cclxuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gXCJudGhcIiApIHtcclxuXHRcdFx0XHQvLyBudGgtY2hpbGQgcmVxdWlyZXMgYXJndW1lbnRcclxuXHRcdFx0XHRpZiAoICFtYXRjaFsyXSApIHtcclxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxyXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcclxuXHRcdFx0XHRtYXRjaFszXSA9ICsoIG1hdGNoWzNdID8gbWF0Y2hbNF0gKyAobWF0Y2hbNV0gfHwgMSkgOiAyICogKCBtYXRjaFsyXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbMl0gPT09IFwib2RkXCIgKSApO1xyXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggKCBtYXRjaFs2XSArIG1hdGNoWzddICkgfHwgbWF0Y2hbMl0gPT09IFwib2RkXCIgKTtcclxuXHJcblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcclxuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXRjaDtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCB4bWwgKSB7XHJcblx0XHRcdHZhciB1bnF1b3RlZCwgZXhjZXNzO1xyXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XHJcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFszXTtcclxuXHRcdFx0fSBlbHNlIGlmICggKHVucXVvdGVkID0gbWF0Y2hbNF0pICkge1xyXG5cdFx0XHRcdC8vIE9ubHkgY2hlY2sgYXJndW1lbnRzIHRoYXQgY29udGFpbiBhIHBzZXVkb1xyXG5cdFx0XHRcdGlmICggcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJlxyXG5cdFx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcclxuXHRcdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIGNvbnRleHQsIHhtbCwgdHJ1ZSApKSAmJlxyXG5cdFx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXHJcblx0XHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxyXG5cdFx0XHRcdFx0dW5xdW90ZWQgPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XHJcblx0XHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXHJcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGZpbHRlcjoge1xyXG5cdFx0XCJJRFwiOiBhc3NlcnRHZXRJZE5vdE5hbWUgP1xyXG5cdFx0XHRmdW5jdGlvbiggaWQgKSB7XHJcblx0XHRcdFx0aWQgPSBpZC5yZXBsYWNlKCByYmFja3NsYXNoLCBcIlwiICk7XHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGlkO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gOlxyXG5cdFx0XHRmdW5jdGlvbiggaWQgKSB7XHJcblx0XHRcdFx0aWQgPSBpZC5yZXBsYWNlKCByYmFja3NsYXNoLCBcIlwiICk7XHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZDtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZSApIHtcclxuXHRcdFx0aWYgKCBub2RlTmFtZSA9PT0gXCIqXCIgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlTmFtZSA9IG5vZGVOYW1lLnJlcGxhY2UoIHJiYWNrc2xhc2gsIFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcclxuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBleHBhbmRvIF1bIGNsYXNzTmFtZSBdO1xyXG5cdFx0XHRpZiAoICFwYXR0ZXJuICkge1xyXG5cdFx0XHRcdHBhdHRlcm4gPSBjbGFzc0NhY2hlKCBjbGFzc05hbWUsIG5ldyBSZWdFeHAoXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIpICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIGVsZW0uY2xhc3NOYW1lIHx8ICh0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB8fCBcIlwiICk7XHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xyXG5cdFx0XHRpZiAoICFvcGVyYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKSAhPSBudWxsO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKSxcclxuXHRcdFx0XHRcdHZhbHVlID0gcmVzdWx0ICsgXCJcIjtcclxuXHJcblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3dpdGNoICggb3BlcmF0b3IgKSB7XHJcblx0XHRcdFx0XHRjYXNlIFwiPVwiOlxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IGNoZWNrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIiE9XCI6XHJcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSAhPT0gY2hlY2s7XHJcblx0XHRcdFx0XHRjYXNlIFwiXj1cIjpcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHZhbHVlLmluZGV4T2YoIGNoZWNrICkgPT09IDA7XHJcblx0XHRcdFx0XHRjYXNlIFwiKj1cIjpcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHZhbHVlLmluZGV4T2YoIGNoZWNrICkgPiAtMTtcclxuXHRcdFx0XHRcdGNhc2UgXCIkPVwiOlxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgdmFsdWUuc3Vic3RyKCB2YWx1ZS5sZW5ndGggLSBjaGVjay5sZW5ndGggKSA9PT0gY2hlY2s7XHJcblx0XHRcdFx0XHRjYXNlIFwifj1cIjpcclxuXHRcdFx0XHRcdFx0cmV0dXJuICggXCIgXCIgKyB2YWx1ZSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xyXG5cdFx0XHRcdFx0Y2FzZSBcInw9XCI6XHJcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gY2hlY2sgfHwgdmFsdWUuc3Vic3RyKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnRoXCIgKSB7XHJcblx0XHRcdFx0dmFyIGRvbmVOYW1lID0gZG9uZSsrO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0XHR2YXIgcGFyZW50LCBkaWZmLFxyXG5cdFx0XHRcdFx0XHRjb3VudCA9IDAsXHJcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggcGFyZW50ICYmIChwYXJlbnRbIGV4cGFuZG8gXSAhPT0gZG9uZU5hbWUgfHwgIWVsZW0uc2l6c2V0KSApIHtcclxuXHRcdFx0XHRcdFx0Zm9yICggbm9kZSA9IHBhcmVudC5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZyApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLnNpenNldCA9ICsrY291bnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cGFyZW50WyBleHBhbmRvIF0gPSBkb25lTmFtZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRkaWZmID0gZWxlbS5zaXpzZXQgLSBsYXN0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggZmlyc3QgPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSAwO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHR2YXIgbm9kZSA9IGVsZW07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblx0XHRcdFx0XHRjYXNlIFwib25seVwiOlxyXG5cdFx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XHJcblx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZpcnN0XCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xyXG5cclxuXHRcdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cdFx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQsIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcclxuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcclxuXHRcdFx0dmFyIGFyZ3MsXHJcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIucHNldWRvc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXTtcclxuXHJcblx0XHRcdGlmICggIWZuICkge1xyXG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcclxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cclxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xyXG5cdFx0XHRpZiAoICFmblsgZXhwYW5kbyBdICkge1xyXG5cdFx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCwgY29udGV4dCwgeG1sICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cHNldWRvczoge1xyXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxyXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xyXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcclxuXHRcdFx0dmFyIG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHhtbCApO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0cmV0dXJuICFtYXRjaGVyKCBlbGVtICk7XHJcblx0XHRcdH07XHJcblx0XHR9KSxcclxuXHJcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXHJcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxyXG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XHJcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cclxuXHRcdFx0Ly8gOmVtcHR5IGlzIG9ubHkgYWZmZWN0ZWQgYnkgZWxlbWVudCBub2RlcyBhbmQgY29udGVudCBub2RlcyhpbmNsdWRpbmcgdGV4dCgzKSwgY2RhdGEoNCkpLFxyXG5cdFx0XHQvLyAgIG5vdCBjb21tZW50LCBwcm9jZXNzaW5nIGluc3RydWN0aW9ucywgb3Igb3RoZXJzXHJcblx0XHRcdC8vIFRoYW5rcyB0byBEaWVnbyBQZXJpbmkgZm9yIHRoZSBub2RlTmFtZSBzaG9ydGN1dFxyXG5cdFx0XHQvLyAgIEdyZWF0ZXIgdGhhbiBcIkBcIiBtZWFucyBhbHBoYSBjaGFyYWN0ZXJzIChzcGVjaWZpY2FsbHkgbm90IHN0YXJ0aW5nIHdpdGggXCIjXCIgb3IgXCI/XCIpXHJcblx0XHRcdHZhciBub2RlVHlwZTtcclxuXHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDtcclxuXHRcdFx0d2hpbGUgKCBlbGVtICkge1xyXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlTmFtZSA+IFwiQFwiIHx8IChub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGUpID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbGVtID0gZWxlbS5uZXh0U2libGluZztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSksXHJcblxyXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcclxuXHRcdFx0fTtcclxuXHRcdH0pLFxyXG5cclxuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0dmFyIHR5cGUsIGF0dHI7XHJcblx0XHRcdC8vIElFNiBhbmQgNyB3aWxsIG1hcCBlbGVtLnR5cGUgdG8gJ3RleHQnIGZvciBuZXcgSFRNTDUgdHlwZXMgKHNlYXJjaCwgZXRjKVxyXG5cdFx0XHQvLyB1c2UgZ2V0QXR0cmlidXRlIGluc3RlYWQgdG8gdGVzdCB0aGlzIGNhc2VcclxuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXHJcblx0XHRcdFx0KHR5cGUgPSBlbGVtLnR5cGUpID09PSBcInRleHRcIiAmJlxyXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSB0eXBlICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElucHV0IHR5cGVzXHJcblx0XHRcInJhZGlvXCI6IGNyZWF0ZUlucHV0UHNldWRvKFwicmFkaW9cIiksXHJcblx0XHRcImNoZWNrYm94XCI6IGNyZWF0ZUlucHV0UHNldWRvKFwiY2hlY2tib3hcIiksXHJcblx0XHRcImZpbGVcIjogY3JlYXRlSW5wdXRQc2V1ZG8oXCJmaWxlXCIpLFxyXG5cdFx0XCJwYXNzd29yZFwiOiBjcmVhdGVJbnB1dFBzZXVkbyhcInBhc3N3b3JkXCIpLFxyXG5cdFx0XCJpbWFnZVwiOiBjcmVhdGVJbnB1dFBzZXVkbyhcImltYWdlXCIpLFxyXG5cclxuXHRcdFwic3VibWl0XCI6IGNyZWF0ZUJ1dHRvblBzZXVkbyhcInN1Ym1pdFwiKSxcclxuXHRcdFwicmVzZXRcIjogY3JlYXRlQnV0dG9uUHNldWRvKFwicmVzZXRcIiksXHJcblxyXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XHJcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2MuYWN0aXZlRWxlbWVudCAmJiAoIWRvYy5oYXNGb2N1cyB8fCBkb2MuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZik7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiYWN0aXZlXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZWxlbS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0RmlsdGVyczoge1xyXG5cdFx0XCJmaXJzdFwiOiBmdW5jdGlvbiggZWxlbWVudHMsIGFyZ3VtZW50LCBub3QgKSB7XHJcblx0XHRcdHJldHVybiBub3QgPyBlbGVtZW50cy5zbGljZSggMSApIDogWyBlbGVtZW50c1swXSBdO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcImxhc3RcIjogZnVuY3Rpb24oIGVsZW1lbnRzLCBhcmd1bWVudCwgbm90ICkge1xyXG5cdFx0XHR2YXIgZWxlbSA9IGVsZW1lbnRzLnBvcCgpO1xyXG5cdFx0XHRyZXR1cm4gbm90ID8gZWxlbWVudHMgOiBbIGVsZW0gXTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJldmVuXCI6IGZ1bmN0aW9uKCBlbGVtZW50cywgYXJndW1lbnQsIG5vdCApIHtcclxuXHRcdFx0dmFyIHJlc3VsdHMgPSBbXSxcclxuXHRcdFx0XHRpID0gbm90ID8gMSA6IDAsXHJcblx0XHRcdFx0bGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkgPSBpICsgMiApIHtcclxuXHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW1lbnRzW2ldICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwib2RkXCI6IGZ1bmN0aW9uKCBlbGVtZW50cywgYXJndW1lbnQsIG5vdCApIHtcclxuXHRcdFx0dmFyIHJlc3VsdHMgPSBbXSxcclxuXHRcdFx0XHRpID0gbm90ID8gMCA6IDEsXHJcblx0XHRcdFx0bGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkgPSBpICsgMiApIHtcclxuXHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW1lbnRzW2ldICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwibHRcIjogZnVuY3Rpb24oIGVsZW1lbnRzLCBhcmd1bWVudCwgbm90ICkge1xyXG5cdFx0XHRyZXR1cm4gbm90ID8gZWxlbWVudHMuc2xpY2UoICthcmd1bWVudCApIDogZWxlbWVudHMuc2xpY2UoIDAsICthcmd1bWVudCApO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcImd0XCI6IGZ1bmN0aW9uKCBlbGVtZW50cywgYXJndW1lbnQsIG5vdCApIHtcclxuXHRcdFx0cmV0dXJuIG5vdCA/IGVsZW1lbnRzLnNsaWNlKCAwLCArYXJndW1lbnQgKyAxICkgOiBlbGVtZW50cy5zbGljZSggK2FyZ3VtZW50ICsgMSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcImVxXCI6IGZ1bmN0aW9uKCBlbGVtZW50cywgYXJndW1lbnQsIG5vdCApIHtcclxuXHRcdFx0dmFyIGVsZW0gPSBlbGVtZW50cy5zcGxpY2UoICthcmd1bWVudCwgMSApO1xyXG5cdFx0XHRyZXR1cm4gbm90ID8gZWxlbWVudHMgOiBlbGVtO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiwgcmV0ICkge1xyXG5cdGlmICggYSA9PT0gYiApIHtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHR2YXIgY3VyID0gYS5uZXh0U2libGluZztcclxuXHJcblx0d2hpbGUgKCBjdXIgKSB7XHJcblx0XHRpZiAoIGN1ciA9PT0gYiApIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN1ciA9IGN1ci5uZXh0U2libGluZztcclxuXHR9XHJcblxyXG5cdHJldHVybiAxO1xyXG59XHJcblxyXG5zb3J0T3JkZXIgPSBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID9cclxuXHRmdW5jdGlvbiggYSwgYiApIHtcclxuXHRcdGlmICggYSA9PT0gYiApIHtcclxuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICggIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gfHwgIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb24gP1xyXG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIDpcclxuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDRcclxuXHRcdCkgPyAtMSA6IDE7XHJcblx0fSA6XHJcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XHJcblx0XHQvLyBUaGUgbm9kZXMgYXJlIGlkZW50aWNhbCwgd2UgY2FuIGV4aXQgZWFybHlcclxuXHRcdGlmICggYSA9PT0gYiApIHtcclxuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gdXNpbmcgc291cmNlSW5kZXggKGluIElFKSBpZiBpdCdzIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXHJcblx0XHR9IGVsc2UgaWYgKCBhLnNvdXJjZUluZGV4ICYmIGIuc291cmNlSW5kZXggKSB7XHJcblx0XHRcdHJldHVybiBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYWwsIGJsLFxyXG5cdFx0XHRhcCA9IFtdLFxyXG5cdFx0XHRicCA9IFtdLFxyXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXHJcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcclxuXHRcdFx0Y3VyID0gYXVwO1xyXG5cclxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MgKG9yIGlkZW50aWNhbCkgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcclxuXHRcdGlmICggYXVwID09PSBidXAgKSB7XHJcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcclxuXHJcblx0XHQvLyBJZiBubyBwYXJlbnRzIHdlcmUgZm91bmQgdGhlbiB0aGUgbm9kZXMgYXJlIGRpc2Nvbm5lY3RlZFxyXG5cdFx0fSBlbHNlIGlmICggIWF1cCApIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoICFidXAgKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE90aGVyd2lzZSB0aGV5J3JlIHNvbWV3aGVyZSBlbHNlIGluIHRoZSB0cmVlIHNvIHdlIG5lZWRcclxuXHRcdC8vIHRvIGJ1aWxkIHVwIGEgZnVsbCBsaXN0IG9mIHRoZSBwYXJlbnROb2RlcyBmb3IgY29tcGFyaXNvblxyXG5cdFx0d2hpbGUgKCBjdXIgKSB7XHJcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xyXG5cdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRjdXIgPSBidXA7XHJcblxyXG5cdFx0d2hpbGUgKCBjdXIgKSB7XHJcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xyXG5cdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRhbCA9IGFwLmxlbmd0aDtcclxuXHRcdGJsID0gYnAubGVuZ3RoO1xyXG5cclxuXHRcdC8vIFN0YXJ0IHdhbGtpbmcgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbCAmJiBpIDwgYmw7IGkrKyApIHtcclxuXHRcdFx0aWYgKCBhcFtpXSAhPT0gYnBbaV0gKSB7XHJcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZSBlbmRlZCBzb21lcGxhY2UgdXAgdGhlIHRyZWUgc28gZG8gYSBzaWJsaW5nIGNoZWNrXHJcblx0XHRyZXR1cm4gaSA9PT0gYWwgP1xyXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGEsIGJwW2ldLCAtMSApIDpcclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYiwgMSApO1xyXG5cdH07XHJcblxyXG4vLyBBbHdheXMgYXNzdW1lIHRoZSBwcmVzZW5jZSBvZiBkdXBsaWNhdGVzIGlmIHNvcnQgZG9lc24ndFxyXG4vLyBwYXNzIHRoZW0gdG8gb3VyIGNvbXBhcmlzb24gZnVuY3Rpb24gKGFzIGluIEdvb2dsZSBDaHJvbWUpLlxyXG5bMCwgMF0uc29ydCggc29ydE9yZGVyICk7XHJcbmJhc2VIYXNEdXBsaWNhdGUgPSAhaGFzRHVwbGljYXRlO1xyXG5cclxuLy8gRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xyXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xyXG5cdHZhciBlbGVtLFxyXG5cdFx0aSA9IDE7XHJcblxyXG5cdGhhc0R1cGxpY2F0ZSA9IGJhc2VIYXNEdXBsaWNhdGU7XHJcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcclxuXHJcblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XHJcblx0XHRmb3IgKCA7IChlbGVtID0gcmVzdWx0c1tpXSk7IGkrKyApIHtcclxuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIC0gMSBdICkge1xyXG5cdFx0XHRcdHJlc3VsdHMuc3BsaWNlKCBpLS0sIDEgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcblxyXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xyXG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdG9rZW5pemUoIHNlbGVjdG9yLCBjb250ZXh0LCB4bWwsIHBhcnNlT25seSApIHtcclxuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcclxuXHRcdHNvRmFyLCBncm91cHMsIGdyb3VwLCBpLFxyXG5cdFx0cHJlRmlsdGVycywgZmlsdGVycyxcclxuXHRcdGNoZWNrQ29udGV4dCA9ICF4bWwgJiYgY29udGV4dCAhPT0gZG9jdW1lbnQsXHJcblx0XHQvLyBUb2tlbiBjYWNoZSBzaG91bGQgbWFpbnRhaW4gc3BhY2VzXHJcblx0XHRrZXkgPSAoIGNoZWNrQ29udGV4dCA/IFwiPHM+XCIgOiBcIlwiICkgKyBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMTxzPlwiICksXHJcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBleHBhbmRvIF1bIGtleSBdO1xyXG5cclxuXHRpZiAoIGNhY2hlZCApIHtcclxuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogc2xpY2UuY2FsbCggY2FjaGVkLCAwICk7XHJcblx0fVxyXG5cclxuXHRzb0ZhciA9IHNlbGVjdG9yO1xyXG5cdGdyb3VwcyA9IFtdO1xyXG5cdGkgPSAwO1xyXG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcclxuXHRmaWx0ZXJzID0gRXhwci5maWx0ZXI7XHJcblxyXG5cdHdoaWxlICggc29GYXIgKSB7XHJcblxyXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxyXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XHJcblx0XHRcdGlmICggbWF0Y2ggKSB7XHJcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICk7XHJcblx0XHRcdFx0dG9rZW5zLnNlbGVjdG9yID0gZ3JvdXA7XHJcblx0XHRcdH1cclxuXHRcdFx0Z3JvdXBzLnB1c2goIHRva2VucyA9IFtdICk7XHJcblx0XHRcdGdyb3VwID0gXCJcIjtcclxuXHJcblx0XHRcdC8vIE5lZWQgdG8gbWFrZSBzdXJlIHdlJ3JlIHdpdGhpbiBhIG5hcnJvd2VyIGNvbnRleHQgaWYgbmVjZXNzYXJ5XHJcblx0XHRcdC8vIEFkZGluZyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciB3aWxsIGdlbmVyYXRlIHdoYXQgaXMgbmVlZGVkXHJcblx0XHRcdGlmICggY2hlY2tDb250ZXh0ICkge1xyXG5cdFx0XHRcdHNvRmFyID0gXCIgXCIgKyBzb0ZhcjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBDb21iaW5hdG9yc1xyXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XHJcblx0XHRcdGdyb3VwICs9IG1hdGNoWzBdO1xyXG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKTtcclxuXHJcblx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxyXG5cdFx0XHRtYXRjaGVkID0gdG9rZW5zLnB1c2goe1xyXG5cdFx0XHRcdHBhcnQ6IG1hdGNoLnBvcCgpLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApLFxyXG5cdFx0XHRcdHN0cmluZzogbWF0Y2hbMF0sXHJcblx0XHRcdFx0Y2FwdHVyZXM6IG1hdGNoXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbHRlcnNcclxuXHRcdGZvciAoIHR5cGUgaW4gZmlsdGVycyApIHtcclxuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxyXG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0obWF0Y2gsIGNvbnRleHQsIHhtbCkgKSkgKSB7XHJcblxyXG5cdFx0XHRcdGdyb3VwICs9IG1hdGNoWzBdO1xyXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApO1xyXG5cdFx0XHRcdG1hdGNoZWQgPSB0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0XHRwYXJ0OiB0eXBlLFxyXG5cdFx0XHRcdFx0c3RyaW5nOiBtYXRjaC5zaGlmdCgpLFxyXG5cdFx0XHRcdFx0Y2FwdHVyZXM6IG1hdGNoXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICFtYXRjaGVkICkge1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEF0dGFjaCB0aGUgZnVsbCBncm91cCBhcyBhIHNlbGVjdG9yXHJcblx0aWYgKCBncm91cCApIHtcclxuXHRcdHRva2Vucy5zZWxlY3RvciA9IGdyb3VwO1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXHJcblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXHJcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXHJcblx0cmV0dXJuIHBhcnNlT25seSA/XHJcblx0XHRzb0Zhci5sZW5ndGggOlxyXG5cdFx0c29GYXIgP1xyXG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxyXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXHJcblx0XHRcdHNsaWNlLmNhbGwoIHRva2VuQ2FjaGUoa2V5LCBncm91cHMpLCAwICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGNvbnRleHQsIHhtbCApIHtcclxuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXHJcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcclxuXHJcblx0aWYgKCAhbWF0Y2hlciApIHtcclxuXHRcdC8vIElmIHRoZXJlIGlzIG5vIG1hdGNoZXIgdG8gY2hlY2ssIGNoZWNrIGFnYWluc3QgdGhlIGNvbnRleHRcclxuXHRcdG1hdGNoZXIgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNvbnRleHQ7XHJcblx0XHR9O1xyXG5cdH1cclxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XHJcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcclxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSApICYmIGVsZW07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IDpcclxuXHRcdHhtbCA/XHJcblx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSApICkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IDpcclxuXHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0dmFyIGNhY2hlLFxyXG5cdFx0XHRcdFx0ZGlya2V5ID0gZG9uZU5hbWUgKyBcIi5cIiArIGRpcnJ1bnMsXHJcblx0XHRcdFx0XHRjYWNoZWRrZXkgPSBkaXJrZXkgKyBcIi5cIiArIGNhY2hlZHJ1bnM7XHJcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcclxuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcclxuXHRcdFx0XHRcdFx0aWYgKCAoY2FjaGUgPSBlbGVtWyBleHBhbmRvIF0pID09PSBjYWNoZWRrZXkgKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uc2l6c2V0O1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgY2FjaGUgPT09IFwic3RyaW5nXCIgJiYgY2FjaGUuaW5kZXhPZihkaXJrZXkpID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5zaXpzZXQgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxlbTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0ZWxlbVsgZXhwYW5kbyBdID0gY2FjaGVka2V5O1xyXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5zaXpzZXQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW07XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVsZW0uc2l6c2V0ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE1hdGNoZXIoIGhpZ2hlciwgZGVlcGVyICkge1xyXG5cdHJldHVybiBoaWdoZXIgP1xyXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBkZWVwZXIoIGVsZW0gKTtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdCAmJiBoaWdoZXIoIHJlc3VsdCA9PT0gdHJ1ZSA/IGVsZW0gOiByZXN1bHQgKTtcclxuXHRcdH0gOlxyXG5cdFx0ZGVlcGVyO1xyXG59XHJcblxyXG4vLyBbXCJUQUdcIiwgXCI+XCIsIFwiSURcIiwgXCIgXCIsIFwiQ0xBU1NcIl1cclxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucywgY29udGV4dCwgeG1sICkge1xyXG5cdHZhciB0b2tlbiwgbWF0Y2hlcixcclxuXHRcdGkgPSAwO1xyXG5cclxuXHRmb3IgKCA7ICh0b2tlbiA9IHRva2Vuc1tpXSk7IGkrKyApIHtcclxuXHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW4ucGFydCBdICkge1xyXG5cdFx0XHRtYXRjaGVyID0gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgRXhwci5yZWxhdGl2ZVsgdG9rZW4ucGFydCBdLCBjb250ZXh0LCB4bWwgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1hdGNoZXIgPSBhZGRNYXRjaGVyKCBtYXRjaGVyLCBFeHByLmZpbHRlclsgdG9rZW4ucGFydCBdLmFwcGx5KG51bGwsIHRva2VuLmNhcHR1cmVzLmNvbmNhdCggY29udGV4dCwgeG1sICkpICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWF0Y2hlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBtYXRjaGVycyApIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHR2YXIgbWF0Y2hlcixcclxuXHRcdFx0aiA9IDA7XHJcblx0XHRmb3IgKCA7IChtYXRjaGVyID0gbWF0Y2hlcnNbal0pOyBqKysgKSB7XHJcblx0XHRcdGlmICggbWF0Y2hlcihlbGVtKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcbn1cclxuXHJcbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgeG1sICkge1xyXG5cdHZhciBncm91cCwgaSwgbGVuLFxyXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgZXhwYW5kbyBdWyBzZWxlY3RvciBdO1xyXG5cclxuXHQvLyBSZXR1cm4gYSBjYWNoZWQgZ3JvdXAgZnVuY3Rpb24gaWYgYWxyZWFkeSBnZW5lcmF0ZWQgKGNvbnRleHQgZGVwZW5kZW50KVxyXG5cdGlmICggY2FjaGVkICYmIGNhY2hlZC5jb250ZXh0ID09PSBjb250ZXh0ICkge1xyXG5cdFx0cmV0dXJuIGNhY2hlZDtcclxuXHR9XHJcblxyXG5cdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxyXG5cdGdyb3VwID0gdG9rZW5pemUoIHNlbGVjdG9yLCBjb250ZXh0LCB4bWwgKTtcclxuXHRmb3IgKCBpID0gMCwgbGVuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRncm91cFtpXSA9IG1hdGNoZXJGcm9tVG9rZW5zKGdyb3VwW2ldLCBjb250ZXh0LCB4bWwpO1xyXG5cdH1cclxuXHJcblx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXHJcblx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhncm91cCkgKTtcclxuXHRjYWNoZWQuY29udGV4dCA9IGNvbnRleHQ7XHJcblx0Y2FjaGVkLnJ1bnMgPSBjYWNoZWQuZGlycnVucyA9IDA7XHJcblx0cmV0dXJuIGNhY2hlZDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cywgc2VlZCApIHtcclxuXHR2YXIgaSA9IDAsXHJcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XHJcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cywgc2VlZCApO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlUE9TR3JvdXAoIHNlbGVjdG9yLCBwb3NmaWx0ZXIsIGFyZ3VtZW50LCBjb250ZXh0cywgc2VlZCwgbm90ICkge1xyXG5cdHZhciByZXN1bHRzLFxyXG5cdFx0Zm4gPSBFeHByLnNldEZpbHRlcnNbIHBvc2ZpbHRlci50b0xvd2VyQ2FzZSgpIF07XHJcblxyXG5cdGlmICggIWZuICkge1xyXG5cdFx0U2l6emxlLmVycm9yKCBwb3NmaWx0ZXIgKTtcclxuXHR9XHJcblxyXG5cdGlmICggc2VsZWN0b3IgfHwgIShyZXN1bHRzID0gc2VlZCkgKSB7XHJcblx0XHRtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dHMsIChyZXN1bHRzID0gW10pLCBzZWVkICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0cy5sZW5ndGggPiAwID8gZm4oIHJlc3VsdHMsIGFyZ3VtZW50LCBub3QgKSA6IFtdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVQT1MoIGdyb3VwcywgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcclxuXHR2YXIgZ3JvdXAsIHBhcnQsIGosIGdyb3VwTGVuLCB0b2tlbiwgc2VsZWN0b3IsXHJcblx0XHRhbmNob3IsIGVsZW1lbnRzLCBtYXRjaCwgbWF0Y2hlZCxcclxuXHRcdGxhc3RJbmRleCwgY3VycmVudENvbnRleHRzLCBub3QsXHJcblx0XHRpID0gMCxcclxuXHRcdGxlbiA9IGdyb3Vwcy5sZW5ndGgsXHJcblx0XHRycG9zID0gbWF0Y2hFeHByW1wiUE9TXCJdLFxyXG5cdFx0Ly8gVGhpcyBpcyBnZW5lcmF0ZWQgaGVyZSBpbiBjYXNlIG1hdGNoRXhwcltcIlBPU1wiXSBpcyBleHRlbmRlZFxyXG5cdFx0cnBvc2dyb3VwcyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgcnBvcy5zb3VyY2UgKyBcIig/IVwiICsgd2hpdGVzcGFjZSArIFwiKVwiLCBcImlcIiApLFxyXG5cdFx0Ly8gVGhpcyBpcyBmb3IgbWFraW5nIHN1cmUgbm9uLXBhcnRpY2lwYXRpbmdcclxuXHRcdC8vIG1hdGNoaW5nIGdyb3VwcyBhcmUgcmVwcmVzZW50ZWQgY3Jvc3MtYnJvd3NlciAoSUU2LTgpXHJcblx0XHRzZXRVbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGkgPSAxLFxyXG5cdFx0XHRcdGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0XHRpZiAoIGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0bWF0Y2hbaV0gPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdGdyb3VwID0gZ3JvdXBzW2ldO1xyXG5cdFx0cGFydCA9IFwiXCI7XHJcblx0XHRlbGVtZW50cyA9IHNlZWQ7XHJcblx0XHRmb3IgKCBqID0gMCwgZ3JvdXBMZW4gPSBncm91cC5sZW5ndGg7IGogPCBncm91cExlbjsgaisrICkge1xyXG5cdFx0XHR0b2tlbiA9IGdyb3VwW2pdO1xyXG5cdFx0XHRzZWxlY3RvciA9IHRva2VuLnN0cmluZztcclxuXHRcdFx0aWYgKCB0b2tlbi5wYXJ0ID09PSBcIlBTRVVET1wiICkge1xyXG5cdFx0XHRcdC8vIFJlc2V0IHJlZ2V4IGluZGV4IHRvIDBcclxuXHRcdFx0XHRycG9zLmV4ZWMoXCJcIik7XHJcblx0XHRcdFx0YW5jaG9yID0gMDtcclxuXHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJwb3MuZXhlYyggc2VsZWN0b3IgKSkgKSB7XHJcblx0XHRcdFx0XHRtYXRjaGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGxhc3RJbmRleCA9IHJwb3MubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcblx0XHRcdFx0XHRpZiAoIGxhc3RJbmRleCA+IGFuY2hvciApIHtcclxuXHRcdFx0XHRcdFx0cGFydCArPSBzZWxlY3Rvci5zbGljZSggYW5jaG9yLCBtYXRjaC5pbmRleCApO1xyXG5cdFx0XHRcdFx0XHRhbmNob3IgPSBsYXN0SW5kZXg7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRDb250ZXh0cyA9IFsgY29udGV4dCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCByY29tYmluYXRvcnMudGVzdChwYXJ0KSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW1lbnRzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudENvbnRleHRzID0gZWxlbWVudHM7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzID0gc2VlZDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAobm90ID0gcmVuZHNXaXRoTm90LnRlc3QoIHBhcnQgKSkgKSB7XHJcblx0XHRcdFx0XHRcdFx0cGFydCA9IHBhcnQuc2xpY2UoIDAsIC01ICkucmVwbGFjZSggcmNvbWJpbmF0b3JzLCBcIiQmKlwiICk7XHJcblx0XHRcdFx0XHRcdFx0YW5jaG9yKys7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0Y2gubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRcdFx0XHRtYXRjaFswXS5yZXBsYWNlKCBycG9zZ3JvdXBzLCBzZXRVbmRlZmluZWQgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbGVtZW50cyA9IGhhbmRsZVBPU0dyb3VwKCBwYXJ0LCBtYXRjaFsxXSwgbWF0Y2hbMl0sIGN1cnJlbnRDb250ZXh0cywgZWxlbWVudHMsIG5vdCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cGFydCA9IFwiXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhbWF0Y2hlZCApIHtcclxuXHRcdFx0XHRwYXJ0ICs9IHNlbGVjdG9yO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1hdGNoZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHBhcnQgKSB7XHJcblx0XHRcdGlmICggcmNvbWJpbmF0b3JzLnRlc3QocGFydCkgKSB7XHJcblx0XHRcdFx0bXVsdGlwbGVDb250ZXh0cyggcGFydCwgZWxlbWVudHMgfHwgWyBjb250ZXh0IF0sIHJlc3VsdHMsIHNlZWQgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRTaXp6bGUoIHBhcnQsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgPyBzZWVkLmNvbmNhdChlbGVtZW50cykgOiBlbGVtZW50cyApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBlbGVtZW50cyApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRG8gbm90IHNvcnQgaWYgdGhpcyBpcyBhIHNpbmdsZSBmaWx0ZXJcclxuXHRyZXR1cm4gbGVuID09PSAxID8gcmVzdWx0cyA6IFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQsIHhtbCApIHtcclxuXHQvLyBSZW1vdmUgZXhjZXNzaXZlIHdoaXRlc3BhY2VcclxuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKTtcclxuXHR2YXIgZWxlbWVudHMsIG1hdGNoZXIsIGNhY2hlZCwgZWxlbSxcclxuXHRcdGksIHRva2VucywgdG9rZW4sIGxhc3RUb2tlbiwgZmluZENvbnRleHQsIHR5cGUsXHJcblx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciwgY29udGV4dCwgeG1sICksXHJcblx0XHRjb250ZXh0Tm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xyXG5cclxuXHQvLyBQT1MgaGFuZGxpbmdcclxuXHRpZiAoIG1hdGNoRXhwcltcIlBPU1wiXS50ZXN0KHNlbGVjdG9yKSApIHtcclxuXHRcdHJldHVybiBoYW5kbGVQT1MoIG1hdGNoLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XHJcblx0fVxyXG5cclxuXHRpZiAoIHNlZWQgKSB7XHJcblx0XHRlbGVtZW50cyA9IHNsaWNlLmNhbGwoIHNlZWQsIDAgKTtcclxuXHJcblx0Ly8gVG8gbWFpbnRhaW4gZG9jdW1lbnQgb3JkZXIsIG9ubHkgbmFycm93IHRoZVxyXG5cdC8vIHNldCBpZiB0aGVyZSBpcyBvbmUgZ3JvdXBcclxuXHR9IGVsc2UgaWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XHJcblxyXG5cdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcclxuXHRcdGlmICggKHRva2VucyA9IHNsaWNlLmNhbGwoIG1hdGNoWzBdLCAwICkpLmxlbmd0aCA+IDIgJiZcclxuXHRcdFx0XHQodG9rZW4gPSB0b2tlbnNbMF0pLnBhcnQgPT09IFwiSURcIiAmJlxyXG5cdFx0XHRcdGNvbnRleHROb2RlVHlwZSA9PT0gOSAmJiAheG1sICYmXHJcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnBhcnQgXSApIHtcclxuXHJcblx0XHRcdGNvbnRleHQgPSBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4uY2FwdHVyZXNbMF0ucmVwbGFjZSggcmJhY2tzbGFzaCwgXCJcIiApLCBjb250ZXh0LCB4bWwgKVswXTtcclxuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkuc3RyaW5nLmxlbmd0aCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZpbmRDb250ZXh0ID0gKCAobWF0Y2ggPSByc2libGluZy5leGVjKCB0b2tlbnNbMF0uc3RyaW5nICkpICYmICFtYXRjaC5pbmRleCAmJiBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xyXG5cclxuXHRcdC8vIFJlZHVjZSB0aGUgc2V0IGlmIHBvc3NpYmxlXHJcblx0XHRsYXN0VG9rZW4gPSBcIlwiO1xyXG5cdFx0Zm9yICggaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XHJcblx0XHRcdHR5cGUgPSB0b2tlbi5wYXJ0O1xyXG5cdFx0XHRsYXN0VG9rZW4gPSB0b2tlbi5zdHJpbmcgKyBsYXN0VG9rZW47XHJcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdHlwZSBdICkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggRXhwci5vcmRlci50ZXN0KHR5cGUpICkge1xyXG5cdFx0XHRcdGVsZW1lbnRzID0gRXhwci5maW5kWyB0eXBlIF0oIHRva2VuLmNhcHR1cmVzWzBdLnJlcGxhY2UoIHJiYWNrc2xhc2gsIFwiXCIgKSwgZmluZENvbnRleHQsIHhtbCApO1xyXG5cdFx0XHRcdGlmICggZWxlbWVudHMgPT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCAwLCBzZWxlY3Rvci5sZW5ndGggLSBsYXN0VG9rZW4ubGVuZ3RoICkgK1xyXG5cdFx0XHRcdFx0XHRsYXN0VG9rZW4ucmVwbGFjZSggbWF0Y2hFeHByWyB0eXBlIF0sIFwiXCIgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcclxuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2xpY2UuY2FsbChlbGVtZW50cywgMCkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIE9ubHkgbG9vcCBvdmVyIHRoZSBnaXZlbiBlbGVtZW50cyBvbmNlXHJcblx0aWYgKCBzZWxlY3RvciApIHtcclxuXHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3RvciwgY29udGV4dCwgeG1sICk7XHJcblx0XHRkaXJydW5zID0gbWF0Y2hlci5kaXJydW5zKys7XHJcblx0XHRpZiAoIGVsZW1lbnRzID09IG51bGwgKSB7XHJcblx0XHRcdGVsZW1lbnRzID0gRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgKHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0ICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IChlbGVtID0gZWxlbWVudHNbaV0pOyBpKysgKSB7XHJcblx0XHRcdGNhY2hlZHJ1bnMgPSBtYXRjaGVyLnJ1bnMrKztcclxuXHRcdFx0aWYgKCBtYXRjaGVyKGVsZW0pICkge1xyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuaWYgKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkge1xyXG5cdChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBkaXNjb25uZWN0ZWRNYXRjaCxcclxuXHRcdFx0b2xkU2VsZWN0ID0gc2VsZWN0LFxyXG5cdFx0XHRyZXNjYXBlID0gLyd8XFxcXC9nLFxyXG5cdFx0XHRyYXR0cmlidXRlUXVvdGVzID0gL1xcPVtcXHgyMFxcdFxcclxcblxcZl0qKFteJ1wiXFxdXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXF0vZyxcclxuXHRcdFx0cmJ1Z2d5UVNBID0gW10sXHJcblx0XHRcdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXHJcblx0XHRcdC8vIEEgc3VwcG9ydCB0ZXN0IHdvdWxkIHJlcXVpcmUgdG9vIG11Y2ggY29kZSAod291bGQgaW5jbHVkZSBkb2N1bWVudCByZWFkeSlcclxuXHRcdFx0Ly8ganVzdCBza2lwIG1hdGNoZXNTZWxlY3RvciBmb3IgOmFjdGl2ZVxyXG5cdFx0XHRyYnVnZ3lNYXRjaGVzID0gW1wiOmFjdGl2ZVwiXSxcclxuXHRcdFx0bWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlc1NlbGVjdG9yIHx8XHJcblx0XHRcdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcclxuXHRcdFx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxyXG5cdFx0XHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxyXG5cdFx0XHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XHJcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXHJcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcclxuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxyXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY3RseVxyXG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcclxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcclxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcclxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPHNlbGVjdD48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xyXG5cclxuXHRcdFx0Ly8gSUU4IC0gU29tZSBib29sZWFuIGF0dHJpYnV0ZXMgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxyXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xyXG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Y2hlY2tlZHxkaXNhYmxlZHxpc21hcHxtdWx0aXBsZXxyZWFkb25seXxzZWxlY3RlZHx2YWx1ZSlcIiApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxyXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgKGRvIG5vdCBwdXQgdGVzdHMgYWZ0ZXIgdGhpcyBvbmUpXHJcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xyXG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cclxuXHRcdFx0Ly8gT3BlcmEgMTAtMTIvSUU5IC0gXj0gJD0gKj0gYW5kIGVtcHR5IHZhbHVlc1xyXG5cdFx0XHQvLyBTaG91bGQgbm90IHNlbGVjdCBhbnl0aGluZ1xyXG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCI8cCB0ZXN0PScnPjwvcD5cIjtcclxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlt0ZXN0Xj0nJ11cIikubGVuZ3RoICkge1xyXG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OlxcXCJcXFwifCcnKVwiICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXHJcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSAoZG8gbm90IHB1dCB0ZXN0cyBhZnRlciB0aGlzIG9uZSlcclxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0IHR5cGU9J2hpZGRlbicvPlwiO1xyXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcclxuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xyXG5cclxuXHRcdHNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCwgeG1sICkge1xyXG5cdFx0XHQvLyBPbmx5IHVzZSBxdWVyeVNlbGVjdG9yQWxsIHdoZW4gbm90IGZpbHRlcmluZyxcclxuXHRcdFx0Ly8gd2hlbiB0aGlzIGlzIG5vdCB4bWwsXHJcblx0XHRcdC8vIGFuZCB3aGVuIG5vIFFTQSBidWdzIGFwcGx5XHJcblx0XHRcdGlmICggIXNlZWQgJiYgIXhtbCAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xyXG5cdFx0XHRcdGlmICggY29udGV4dC5ub2RlVHlwZSA9PT0gOSApIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNsaWNlLmNhbGwoY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApLCAwKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHt9XHJcblx0XHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXHJcblx0XHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxyXG5cdFx0XHRcdC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxyXG5cdFx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRcdFx0dmFyIGdyb3VwcywgaSwgbGVuLFxyXG5cdFx0XHRcdFx0XHRvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpLFxyXG5cdFx0XHRcdFx0XHRuaWQgPSBvbGQgfHwgZXhwYW5kbyxcclxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgY29udGV4dC5wYXJlbnROb2RlIHx8IGNvbnRleHQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvbGQgKSB7XHJcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZShzZWxlY3RvciwgY29udGV4dCwgeG1sKTtcclxuXHRcdFx0XHRcdC8vIFRyYWlsaW5nIHNwYWNlIGlzIHVubmVjZXNzYXJ5XHJcblx0XHRcdFx0XHQvLyBUaGVyZSBpcyBhbHdheXMgYSBjb250ZXh0IGNoZWNrXHJcblx0XHRcdFx0XHRuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWQgKyBncm91cHNbaV0uc2VsZWN0b3I7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzbGljZS5jYWxsKCBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoXHJcblx0XHRcdFx0XHRcdFx0Z3JvdXBzLmpvaW4oXCIsXCIpXHJcblx0XHRcdFx0XHRcdCksIDAgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHtcclxuXHRcdFx0XHRcdH0gZmluYWxseSB7XHJcblx0XHRcdFx0XHRcdGlmICggIW9sZCApIHtcclxuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb2xkU2VsZWN0KCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCwgeG1sICk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggbWF0Y2hlcyApIHtcclxuXHRcdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXHJcblx0XHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcclxuXHRcdFx0XHRkaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XHJcblxyXG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cclxuXHRcdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIlt0ZXN0IT0nJ106c2l6emxlXCIgKTtcclxuXHRcdFx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggbWF0Y2hFeHByW1wiUFNFVURPXCJdLnNvdXJjZSwgbWF0Y2hFeHByW1wiUE9TXCJdLnNvdXJjZSwgXCIhPVwiICk7XHJcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIHJidWdneU1hdGNoZXMgYWx3YXlzIGNvbnRhaW5zIDphY3RpdmUsIHNvIG5vIG5lZWQgZm9yIGEgbGVuZ3RoIGNoZWNrXHJcblx0XHRcdHJidWdneU1hdGNoZXMgPSAvKiByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiAqLyBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XHJcblxyXG5cdFx0XHRTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XHJcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXHJcblx0XHRcdFx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xyXG5cclxuXHRcdFx0XHQvLyByYnVnZ3lNYXRjaGVzIGFsd2F5cyBjb250YWlucyA6YWN0aXZlLCBzbyBubyBuZWVkIGZvciBhbiBleGlzdGVuY2UgY2hlY2tcclxuXHRcdFx0XHRpZiAoICFpc1hNTCggZWxlbSApICYmICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSkgKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXHJcblx0XHRcdFx0XHRcdGlmICggcmV0IHx8IGRpc2Nvbm5lY3RlZE1hdGNoIHx8XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxyXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGNhdGNoKGUpIHt9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSkoKTtcclxufVxyXG5cclxuLy8gRGVwcmVjYXRlZFxyXG5FeHByLnNldEZpbHRlcnNbXCJudGhcIl0gPSBFeHByLnNldEZpbHRlcnNbXCJlcVwiXTtcclxuXHJcbi8vIEJhY2stY29tcGF0XHJcbkV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcclxuXHJcbi8vIE92ZXJyaWRlIHNpenpsZSBhdHRyaWJ1dGUgcmV0cmlldmFsXG5TaXp6bGUuYXR0ciA9IGpRdWVyeS5hdHRyO1xualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxyXG5cclxufSkoIHdpbmRvdyApO1xyXG52YXIgcnVudGlsID0gL1VudGlsJC8sXG5cdHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHRpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLyxcblx0cm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxcblx0Ly8gbWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbCwgbGVuZ3RoLCBuLCByLCByZXQsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggXCJcIiwgXCJmaW5kXCIsIHNlbGVjdG9yICk7XG5cblx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0bGVuZ3RoID0gcmV0Lmxlbmd0aDtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3RvciwgdGhpc1tpXSwgcmV0ICk7XG5cblx0XHRcdGlmICggaSA+IDAgKSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByZXN1bHRzIGFyZSB1bmlxdWVcblx0XHRcdFx0Zm9yICggbiA9IGxlbmd0aDsgbiA8IHJldC5sZW5ndGg7IG4rKyApIHtcblx0XHRcdFx0XHRmb3IgKCByID0gMDsgciA8IGxlbmd0aDsgcisrICkge1xuXHRcdFx0XHRcdFx0aWYgKCByZXRbcl0gPT09IHJldFtuXSApIHtcblx0XHRcdFx0XHRcdFx0cmV0LnNwbGljZShuLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bGVuID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IsIGZhbHNlKSwgXCJub3RcIiwgc2VsZWN0b3IpO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCB0cnVlKSwgXCJmaWx0ZXJcIiwgc2VsZWN0b3IgKTtcblx0fSxcblxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXNlbGVjdG9yICYmIChcblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0XHRybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IsIHRoaXMuY29udGV4dCApLmluZGV4KCB0aGlzWzBdICkgPj0gMCA6XG5cdFx0XHRcdFx0alF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKS5sZW5ndGggPiAwIDpcblx0XHRcdFx0dGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMCApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRjdXIgPSB0aGlzW2ldO1xuXG5cdFx0XHR3aGlsZSAoIGN1ciAmJiBjdXIub3duZXJEb2N1bWVudCAmJiBjdXIgIT09IGNvbnRleHQgJiYgY3VyLm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0aWYgKCBwb3MgPyBwb3MuaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0ID0gcmV0Lmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldDtcblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBcImNsb3Nlc3RcIiwgc2VsZWN0b3JzICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxuXHQvLyB0aGUgbWF0Y2hlZCBzZXQgb2YgZWxlbWVudHNcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSA/IHRoaXMucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIGluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuaW5BcnJheSggdGhpc1swXSwgalF1ZXJ5KCBlbGVtICkgKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVswXSA6IGVsZW0sIHRoaXMgKTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgc2V0ID0gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IgJiYgc2VsZWN0b3Iubm9kZVR5cGUgPyBbIHNlbGVjdG9yIF0gOiBzZWxlY3RvciApLFxuXHRcdFx0YWxsID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaXNEaXNjb25uZWN0ZWQoIHNldFswXSApIHx8IGlzRGlzY29ubmVjdGVkKCBhbGxbMF0gKSA/XG5cdFx0XHRhbGwgOlxuXHRcdFx0alF1ZXJ5LnVuaXF1ZSggYWxsICkgKTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG5cdFx0KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cbi8vIEEgcGFpbmZ1bGx5IHNpbXBsZSBjaGVjayB0byBzZWUgaWYgYW4gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWRcbi8vIGZyb20gYSBkb2N1bWVudCAoc2hvdWxkIGJlIGltcHJvdmVkLCB3aGVyZSBmZWFzaWJsZSkuXG5mdW5jdGlvbiBpc0Rpc2Nvbm5lY3RlZCggbm9kZSApIHtcblx0cmV0dXJuICFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdGRvIHtcblx0XHRjdXIgPSBjdXJbIGRpciBdO1xuXHR9IHdoaWxlICggY3VyICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApO1xuXG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApID9cblx0XHRcdGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG5cdFx0XHRqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCAhcnVudGlsLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5sZW5ndGggPiAxICYmICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldDtcblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICYmIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRyZXQgPSByZXQucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBuYW1lLCBjb3JlX3NsaWNlLmNhbGwoIGFyZ3VtZW50cyApLmpvaW4oXCIsXCIpICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGZpbHRlcjogZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdFx0aWYgKCBub3QgKSB7XG5cdFx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgP1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW1zWzBdLCBleHByKSA/IFsgZWxlbXNbMF0gXSA6IFtdIDpcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgZWxlbXMpO1xuXHR9LFxuXG5cdGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHRcdGN1ciA9IGVsZW1bIGRpciBdO1xuXG5cdFx0d2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7XG5cdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdH1cblx0XHRcdGN1ciA9IGN1cltkaXJdO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgciA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRyLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fVxufSk7XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIGtlZXAgKSB7XG5cblx0Ly8gQ2FuJ3QgcGFzcyBudWxsIG9yIHVuZGVmaW5lZCB0byBpbmRleE9mIGluIEZpcmVmb3ggNFxuXHQvLyBTZXQgdG8gMCB0byBza2lwIHN0cmluZyBjaGVja1xuXHRxdWFsaWZpZXIgPSBxdWFsaWZpZXIgfHwgMDtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0dmFyIHJldFZhbCA9ICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHRcdHJldHVybiByZXRWYWwgPT09IGtlZXA7XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSA9PT0ga2VlcDtcblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdHZhciBmaWx0ZXJlZCA9IGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCBpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQsICFrZWVwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBmaWx0ZXJlZCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0cmV0dXJuICggalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHF1YWxpZmllciApID49IDAgKSA9PT0ga2VlcDtcblx0fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICkge1xuXHR2YXIgbGlzdCA9IG5vZGVOYW1lcy5zcGxpdCggXCJ8XCIgKSxcblx0c2FmZUZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0aWYgKCBzYWZlRnJhZy5jcmVhdGVFbGVtZW50ICkge1xuXHRcdHdoaWxlICggbGlzdC5sZW5ndGggKSB7XG5cdFx0XHRzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRsaXN0LnBvcCgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc2FmZUZyYWc7XG59XG5cbnZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuXHRcdFwiaGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixcblx0cmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLFxuXHRybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuXHRydGJvZHkgPSAvPHRib2R5L2ksXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuXHRybm9jYWNoZSA9IC88KD86c2NyaXB0fG9iamVjdHxlbWJlZHxvcHRpb258c3R5bGUpL2ksXG5cdHJub3NoaW1jYWNoZSA9IG5ldyBSZWdFeHAoXCI8KD86XCIgKyBub2RlTmFtZXMgKyBcIilbXFxcXHMvPl1cIiwgXCJpXCIpLFxuXHRyY2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC8sXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL1xcLyhqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8XFwtXFwtKXxbXFxdXFwtXXsyfT5cXHMqJC9nLFxuXHR3cmFwTWFwID0ge1xuXHRcdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXHRcdGxlZ2VuZDogWyAxLCBcIjxmaWVsZHNldD5cIiwgXCI8L2ZpZWxkc2V0PlwiIF0sXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHRhcmVhOiBbIDEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIiBdLFxuXHRcdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxuXHR9LFxuXHRzYWZlRnJhZ21lbnQgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICksXG5cdGZyYWdtZW50RGl2ID0gc2FmZUZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG5cbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gSUU2LTggY2FuJ3Qgc2VyaWFsaXplIGxpbmssIHNjcmlwdCwgc3R5bGUsIG9yIGFueSBodG1sNSAoTm9TY29wZSkgdGFncyxcbi8vIHVubGVzcyB3cmFwcGVkIGluIGEgZGl2IHdpdGggbm9uLWJyZWFraW5nIGNoYXJhY3RlcnMgaW4gZnJvbnQgb2YgaXQuXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5odG1sU2VyaWFsaXplICkge1xuXHR3cmFwTWFwLl9kZWZhdWx0ID0gWyAxLCBcIlg8ZGl2PlwiLCBcIjwvZGl2PlwiIF07XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoICggdGhpc1swXSAmJiB0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKS5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR2YXIgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50ICkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cblx0XHRcdGlmICggdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1swXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykud3JhcElubmVyKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0XHR0aGlzLmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCB0cnVlLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0dGhpcy5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhaXNEaXNjb25uZWN0ZWQoIHRoaXNbMF0gKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZmFsc2UsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0galF1ZXJ5LmNsZWFuKCBhcmd1bWVudHMgKTtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1lcmdlKCBzZXQsIHRoaXMgKSwgXCJiZWZvcmVcIiwgdGhpcy5zZWxlY3RvciApO1xuXHRcdH1cblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhaXNEaXNjb25uZWN0ZWQoIHRoaXNbMF0gKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZmFsc2UsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0galF1ZXJ5LmNsZWFuKCBhcmd1bWVudHMgKTtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1lcmdlKCB0aGlzLCBzZXQgKSwgXCJhZnRlclwiLCB0aGlzLnNlbGVjdG9yICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGtlZXBEYXRhIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS0tZG8gbm90IGRvY3VtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBbIGVsZW0gXSApLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xuXHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksIFwiXCIgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0KCBqUXVlcnkuc3VwcG9ydC5odG1sU2VyaWFsaXplIHx8ICFybm9zaGltY2FjaGUudGVzdCggdmFsdWUgKSAgKSAmJlxuXHRcdFx0XHQoIGpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFybGVhZGluZ1doaXRlc3BhY2UudGVzdCggdmFsdWUgKSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgW1wiXCIsIFwiXCJdIClbMV0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbaV0gfHwge307XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggIWlzRGlzY29ubmVjdGVkKCB0aGlzWzBdICkgKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJlZm9yZSB0aGV5IGFyZSBpbnNlcnRlZFxuXHRcdFx0Ly8gdGhpcyBjYW4gaGVscCBmaXggcmVwbGFjaW5nIGEgcGFyZW50IHdpdGggY2hpbGQgZWxlbWVudHNcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCBvbGQgPSBzZWxmLmh0bWwoKTtcblx0XHRcdFx0XHRzZWxmLnJlcGxhY2VXaXRoKCB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBvbGQgKSApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5KCB2YWx1ZSApLmRldGFjaCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRcdFx0cGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZSgpO1xuXG5cdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRqUXVlcnkobmV4dCkuYmVmb3JlKCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeShwYXJlbnQpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoID9cblx0XHRcdHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlKSwgXCJyZXBsYWNlV2l0aFwiLCB2YWx1ZSApIDpcblx0XHRcdHRoaXM7XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgdGFibGUsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBbXS5jb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgcmVzdWx0cywgZmlyc3QsIGZyYWdtZW50LCBpTm9DbG9uZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0dmFsdWUgPSBhcmdzWzBdLFxuXHRcdFx0c2NyaXB0cyA9IFtdLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSAmJiBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS5kb21NYW5pcCggYXJncywgdGFibGUsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcblx0XHRcdFx0YXJnc1swXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIHRhYmxlID8gc2VsZi5odG1sKCkgOiB1bmRlZmluZWQgKTtcblx0XHRcdFx0c2VsZi5kb21NYW5pcCggYXJncywgdGFibGUsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHRyZXN1bHRzID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXMsIHNjcmlwdHMgKTtcblx0XHRcdGZyYWdtZW50ID0gcmVzdWx0cy5mcmFnbWVudDtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0dGFibGUgPSB0YWJsZSAmJiBqUXVlcnkubm9kZU5hbWUoIGZpcnN0LCBcInRyXCIgKTtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0XHQvLyBGcmFnbWVudHMgZnJvbSB0aGUgZnJhZ21lbnQgY2FjaGUgbXVzdCBhbHdheXMgYmUgY2xvbmVkIGFuZCBuZXZlciB1c2VkIGluIHBsYWNlLlxuXHRcdFx0XHRmb3IgKCBpTm9DbG9uZSA9IHJlc3VsdHMuY2FjaGVhYmxlIHx8IGwgLSAxOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoXG5cdFx0XHRcdFx0XHR0YWJsZSAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXNbaV0sIFwidGFibGVcIiApID9cblx0XHRcdFx0XHRcdFx0ZmluZE9yQXBwZW5kKCB0aGlzW2ldLCBcInRib2R5XCIgKSA6XG5cdFx0XHRcdFx0XHRcdHRoaXNbaV0sXG5cdFx0XHRcdFx0XHRpID09PSBpTm9DbG9uZSA/XG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50IDpcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsb25lKCBmcmFnbWVudCwgdHJ1ZSwgdHJ1ZSApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXggIzExODA5OiBBdm9pZCBsZWFraW5nIG1lbW9yeVxuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdCA9IG51bGw7XG5cblx0XHRcdGlmICggc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBzY3JpcHRzLCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uc3JjICkge1xuXHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuYWpheCApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0XHRcdFx0XHRcdHVybDogZWxlbS5zcmMsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJHRVRcIixcblx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRcdFx0XHRcdFx0XHRhc3luYzogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcInRocm93c1wiOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmVycm9yKFwibm8gYWpheFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoICggZWxlbS50ZXh0IHx8IGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gZmluZE9yQXBwZW5kKCBlbGVtLCB0YWcgKSB7XG5cdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKVswXSB8fCBlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdGFnICkgKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeS5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgdHlwZSwgaSwgbCxcblx0XHRvbGREYXRhID0galF1ZXJ5Ll9kYXRhKCBzcmMgKSxcblx0XHRjdXJEYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0LCBvbGREYXRhICksXG5cdFx0ZXZlbnRzID0gb2xkRGF0YS5ldmVudHM7XG5cblx0aWYgKCBldmVudHMgKSB7XG5cdFx0ZGVsZXRlIGN1ckRhdGEuaGFuZGxlO1xuXHRcdGN1ckRhdGEuZXZlbnRzID0ge307XG5cblx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gbWFrZSB0aGUgY2xvbmVkIHB1YmxpYyBkYXRhIG9iamVjdCBhIGNvcHkgZnJvbSB0aGUgb3JpZ2luYWxcblx0aWYgKCBjdXJEYXRhLmRhdGEgKSB7XG5cdFx0Y3VyRGF0YS5kYXRhID0galF1ZXJ5LmV4dGVuZCgge30sIGN1ckRhdGEuZGF0YSApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lRml4QXR0cmlidXRlcyggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWU7XG5cblx0Ly8gV2UgZG8gbm90IG5lZWQgdG8gZG8gYW55dGhpbmcgZm9yIG5vbi1FbGVtZW50c1xuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gY2xlYXJBdHRyaWJ1dGVzIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZXMsIHdoaWNoIHdlIGRvbid0IHdhbnQsXG5cdC8vIGJ1dCBhbHNvIHJlbW92ZXMgdGhlIGF0dGFjaEV2ZW50IGV2ZW50cywgd2hpY2ggd2UgKmRvKiB3YW50XG5cdGlmICggZGVzdC5jbGVhckF0dHJpYnV0ZXMgKSB7XG5cdFx0ZGVzdC5jbGVhckF0dHJpYnV0ZXMoKTtcblx0fVxuXG5cdC8vIG1lcmdlQXR0cmlidXRlcywgaW4gY29udHJhc3QsIG9ubHkgbWVyZ2VzIGJhY2sgb24gdGhlXG5cdC8vIG9yaWdpbmFsIGF0dHJpYnV0ZXMsIG5vdCB0aGUgZXZlbnRzXG5cdGlmICggZGVzdC5tZXJnZUF0dHJpYnV0ZXMgKSB7XG5cdFx0ZGVzdC5tZXJnZUF0dHJpYnV0ZXMoIHNyYyApO1xuXHR9XG5cblx0bm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBJRTYtMTAgaW1wcm9wZXJseSBjbG9uZXMgY2hpbGRyZW4gb2Ygb2JqZWN0IGVsZW1lbnRzIHVzaW5nIGNsYXNzaWQuXG5cdFx0Ly8gSUUxMCB0aHJvd3MgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgaWYgcGFyZW50IGlzIG51bGwsICMxMjEzMi5cblx0XHRpZiAoIGRlc3QucGFyZW50Tm9kZSApIHtcblx0XHRcdGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcblx0XHR9XG5cblx0XHQvLyBUaGlzIHBhdGggYXBwZWFycyB1bmF2b2lkYWJsZSBmb3IgSUU5LiBXaGVuIGNsb25pbmcgYW4gb2JqZWN0XG5cdFx0Ly8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG5cdFx0Ly8gSWYgdGhlIHNyYyBoYXMgaW5uZXJIVE1MIGFuZCB0aGUgZGVzdGluYXRpb24gZG9lcyBub3QsXG5cdFx0Ly8gY29weSB0aGUgc3JjLmlubmVySFRNTCBpbnRvIHRoZSBkZXN0LmlubmVySFRNTC4gIzEwMzI0XG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lICYmIChzcmMuaW5uZXJIVE1MICYmICFqUXVlcnkudHJpbShkZXN0LmlubmVySFRNTCkpICkge1xuXHRcdFx0ZGVzdC5pbm5lckhUTUwgPSBzcmMuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0Ly8gSUU2LTggZmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveFxuXHRcdC8vIG9yIHJhZGlvIGJ1dHRvbi4gV29yc2UsIElFNi03IGZhaWwgdG8gZ2l2ZSB0aGUgY2xvbmVkIGVsZW1lbnRcblx0XHQvLyBhIGNoZWNrZWQgYXBwZWFyYW5jZSBpZiB0aGUgZGVmYXVsdENoZWNrZWQgdmFsdWUgaXNuJ3QgYWxzbyBzZXRcblxuXHRcdGRlc3QuZGVmYXVsdENoZWNrZWQgPSBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHRcdC8vIElFNi03IGdldCBjb25mdXNlZCBhbmQgZW5kIHVwIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY2xvbmVkXG5cdFx0Ly8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIFwib25cIlxuXHRcdGlmICggZGVzdC52YWx1ZSAhPT0gc3JjLnZhbHVlICkge1xuXHRcdFx0ZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTtcblx0XHR9XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWRcblx0Ly8gc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgKSB7XG5cdFx0ZGVzdC5zZWxlY3RlZCA9IHNyYy5kZWZhdWx0U2VsZWN0ZWQ7XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gc2V0IHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGNvcnJlY3QgdmFsdWUgd2hlblxuXHQvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIElFIGJsYW5rcyBjb250ZW50cyB3aGVuIGNsb25pbmcgc2NyaXB0c1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJzY3JpcHRcIiAmJiBkZXN0LnRleHQgIT09IHNyYy50ZXh0ICkge1xuXHRcdGRlc3QudGV4dCA9IHNyYy50ZXh0O1xuXHR9XG5cblx0Ly8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG9cblx0Ly8gZ2V0cyBjb3BpZWQgdG9vXG5cdGRlc3QucmVtb3ZlQXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xufVxuXG5qUXVlcnkuYnVpbGRGcmFnbWVudCA9IGZ1bmN0aW9uKCBhcmdzLCBjb250ZXh0LCBzY3JpcHRzICkge1xuXHR2YXIgZnJhZ21lbnQsIGNhY2hlYWJsZSwgY2FjaGVoaXQsXG5cdFx0Zmlyc3QgPSBhcmdzWyAwIF07XG5cblx0Ly8gU2V0IGNvbnRleHQgZnJvbSB3aGF0IG1heSBjb21lIGluIGFzIHVuZGVmaW5lZCBvciBhIGpRdWVyeSBjb2xsZWN0aW9uIG9yIGEgbm9kZVxuXHQvLyBVcGRhdGVkIHRvIGZpeCAjMTIyNjYgd2hlcmUgYWNjZXNzaW5nIGNvbnRleHRbMF0gY291bGQgdGhyb3cgYW4gZXhjZXB0aW9uIGluIElFOS8xMCAmXG5cdC8vIGFsc28gZG91YmxlcyBhcyBmaXggZm9yICM4OTUwIHdoZXJlIHBsYWluIG9iamVjdHMgY2F1c2VkIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgZXhjZXB0aW9uXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRjb250ZXh0ID0gIWNvbnRleHQubm9kZVR5cGUgJiYgY29udGV4dFswXSB8fCBjb250ZXh0O1xuXHRjb250ZXh0ID0gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQ7XG5cblx0Ly8gT25seSBjYWNoZSBcInNtYWxsXCIgKDEvMiBLQikgSFRNTCBzdHJpbmdzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFpbiBkb2N1bWVudFxuXHQvLyBDbG9uaW5nIG9wdGlvbnMgbG9zZXMgdGhlIHNlbGVjdGVkIHN0YXRlLCBzbyBkb24ndCBjYWNoZSB0aGVtXG5cdC8vIElFIDYgZG9lc24ndCBsaWtlIGl0IHdoZW4geW91IHB1dCA8b2JqZWN0PiBvciA8ZW1iZWQ+IGVsZW1lbnRzIGluIGEgZnJhZ21lbnRcblx0Ly8gQWxzbywgV2ViS2l0IGRvZXMgbm90IGNsb25lICdjaGVja2VkJyBhdHRyaWJ1dGVzIG9uIGNsb25lTm9kZSwgc28gZG9uJ3QgY2FjaGVcblx0Ly8gTGFzdGx5LCBJRTYsNyw4IHdpbGwgbm90IGNvcnJlY3RseSByZXVzZSBjYWNoZWQgZnJhZ21lbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gdW5rbm93biBlbGVtcyAjMTA1MDFcblx0aWYgKCBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgZmlyc3QubGVuZ3RoIDwgNTEyICYmIGNvbnRleHQgPT09IGRvY3VtZW50ICYmXG5cdFx0Zmlyc3QuY2hhckF0KDApID09PSBcIjxcIiAmJiAhcm5vY2FjaGUudGVzdCggZmlyc3QgKSAmJlxuXHRcdChqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lIHx8ICFyY2hlY2tlZC50ZXN0KCBmaXJzdCApKSAmJlxuXHRcdChqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lIHx8ICFybm9zaGltY2FjaGUudGVzdCggZmlyc3QgKSkgKSB7XG5cblx0XHQvLyBNYXJrIGNhY2hlYWJsZSBhbmQgbG9vayBmb3IgYSBoaXRcblx0XHRjYWNoZWFibGUgPSB0cnVlO1xuXHRcdGZyYWdtZW50ID0galF1ZXJ5LmZyYWdtZW50c1sgZmlyc3QgXTtcblx0XHRjYWNoZWhpdCA9IGZyYWdtZW50ICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICFmcmFnbWVudCApIHtcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdGpRdWVyeS5jbGVhbiggYXJncywgY29udGV4dCwgZnJhZ21lbnQsIHNjcmlwdHMgKTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgY2FjaGUsIGJ1dCBvbmx5IHN0b3JlIGZhbHNlXG5cdFx0Ly8gdW5sZXNzIHRoaXMgaXMgYSBzZWNvbmQgcGFyc2luZyBvZiB0aGUgc2FtZSBjb250ZW50XG5cdFx0aWYgKCBjYWNoZWFibGUgKSB7XG5cdFx0XHRqUXVlcnkuZnJhZ21lbnRzWyBmaXJzdCBdID0gY2FjaGVoaXQgJiYgZnJhZ21lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgZnJhZ21lbnQ6IGZyYWdtZW50LCBjYWNoZWFibGU6IGNhY2hlYWJsZSB9O1xufTtcblxualF1ZXJ5LmZyYWdtZW50cyA9IHt9O1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bCA9IGluc2VydC5sZW5ndGgsXG5cdFx0XHRwYXJlbnQgPSB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLnBhcmVudE5vZGU7XG5cblx0XHRpZiAoIChwYXJlbnQgPT0gbnVsbCB8fCBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxMSAmJiBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpICYmIGwgPT09IDEgKSB7XG5cdFx0XHRpbnNlcnRbIG9yaWdpbmFsIF0oIHRoaXNbMF0gKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGVsZW1zID0gKCBpID4gMCA/IHRoaXMuY2xvbmUodHJ1ZSkgOiB0aGlzICkuZ2V0KCk7XG5cdFx0XHRcdGpRdWVyeSggaW5zZXJ0W2ldIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cdFx0XHRcdHJldCA9IHJldC5jb25jYXQoIGVsZW1zICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBuYW1lLCBpbnNlcnQuc2VsZWN0b3IgKTtcblx0XHR9XG5cdH07XG59KTtcblxuZnVuY3Rpb24gZ2V0QWxsKCBlbGVtICkge1xuXHRpZiAoIHR5cGVvZiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0dXJuIGVsZW0ucXVlcnlTZWxlY3RvckFsbCggXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbXTtcblx0fVxufVxuXG4vLyBVc2VkIGluIGNsZWFuLCBmaXhlcyB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICkge1xuXHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsZW0udHlwZSApICkge1xuXHRcdGVsZW0uZGVmYXVsdENoZWNrZWQgPSBlbGVtLmNoZWNrZWQ7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIHNyY0VsZW1lbnRzLFxuXHRcdFx0ZGVzdEVsZW1lbnRzLFxuXHRcdFx0aSxcblx0XHRcdGNsb25lO1xuXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lIHx8IGpRdWVyeS5pc1hNTERvYyhlbGVtKSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIFwiPFwiICsgZWxlbS5ub2RlTmFtZSArIFwiPlwiICkgKSB7XG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICk7XG5cblx0XHQvLyBJRTw9OCBkb2VzIG5vdCBwcm9wZXJseSBjbG9uZSBkZXRhY2hlZCwgdW5rbm93biBlbGVtZW50IG5vZGVzXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZyYWdtZW50RGl2LmlubmVySFRNTCA9IGVsZW0ub3V0ZXJIVE1MO1xuXHRcdFx0ZnJhZ21lbnREaXYucmVtb3ZlQ2hpbGQoIGNsb25lID0gZnJhZ21lbnREaXYuZmlyc3RDaGlsZCApO1xuXHRcdH1cblxuXHRcdGlmICggKCFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSAmJlxuXHRcdFx0XHQoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSApIHtcblx0XHRcdC8vIElFIGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuXHRcdFx0Ly8gQ2FsbGluZyBkZXRhY2hFdmVudCBvbiB0aGUgY2xvbmUgd2lsbCBhbHNvIHJlbW92ZSB0aGUgZXZlbnRzXG5cdFx0XHQvLyBmcm9tIHRoZSBvcmlnaW5hbC4gSW4gb3JkZXIgdG8gZ2V0IGFyb3VuZCB0aGlzLCB3ZSB1c2Ugc29tZVxuXHRcdFx0Ly8gcHJvcHJpZXRhcnkgbWV0aG9kcyB0byBjbGVhciB0aGUgZXZlbnRzLiBUaGFua3MgdG8gTW9vVG9vbHNcblx0XHRcdC8vIGd1eXMgZm9yIHRoaXMgaG90bmVzcy5cblxuXHRcdFx0Y2xvbmVGaXhBdHRyaWJ1dGVzKCBlbGVtLCBjbG9uZSApO1xuXG5cdFx0XHQvLyBVc2luZyBTaXp6bGUgaGVyZSBpcyBjcmF6eSBzbG93LCBzbyB3ZSB1c2UgZ2V0RWxlbWVudHNCeVRhZ05hbWUgaW5zdGVhZFxuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0Ly8gV2VpcmQgaXRlcmF0aW9uIGJlY2F1c2UgSUUgd2lsbCByZXBsYWNlIHRoZSBsZW5ndGggcHJvcGVydHlcblx0XHRcdC8vIHdpdGggYW4gZWxlbWVudCBpZiB5b3UgYXJlIGNsb25pbmcgdGhlIGJvZHkgYW5kIG9uZSBvZiB0aGVcblx0XHRcdC8vIGVsZW1lbnRzIG9uIHRoZSBwYWdlIGhhcyBhIG5hbWUgb3IgaWQgb2YgXCJsZW5ndGhcIlxuXHRcdFx0Zm9yICggaSA9IDA7IHNyY0VsZW1lbnRzW2ldOyArK2kgKSB7XG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xuXHRcdFx0XHRpZiAoIGRlc3RFbGVtZW50c1tpXSApIHtcblx0XHRcdFx0XHRjbG9uZUZpeEF0dHJpYnV0ZXMoIHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblxuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBzcmNFbGVtZW50c1tpXTsgKytpICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcmNFbGVtZW50cyA9IGRlc3RFbGVtZW50cyA9IG51bGw7XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW46IGZ1bmN0aW9uKCBlbGVtcywgY29udGV4dCwgZnJhZ21lbnQsIHNjcmlwdHMgKSB7XG5cdFx0dmFyIGksIGosIGVsZW0sIHRhZywgd3JhcCwgZGVwdGgsIGRpdiwgaGFzQm9keSwgdGJvZHksIGxlbiwgaGFuZGxlU2NyaXB0LCBqc1RhZ3MsXG5cdFx0XHRzYWZlID0gY29udGV4dCA9PT0gZG9jdW1lbnQgJiYgc2FmZUZyYWdtZW50LFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBjb250ZXh0IGlzIGEgZG9jdW1lbnRcblx0XHRpZiAoICFjb250ZXh0IHx8IHR5cGVvZiBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgc2FmZSBmcmFnbWVudCBpZiBjb250ZXh0IHBlcm1pdHNcblx0XHRmb3IgKCBpID0gMDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0ZWxlbSArPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIHN0cmluZyBpbnRvIERPTSBub2Rlc1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRW5zdXJlIGEgc2FmZSBjb250YWluZXIgaW4gd2hpY2ggdG8gcmVuZGVyIHRoZSBodG1sXG5cdFx0XHRcdFx0c2FmZSA9IHNhZmUgfHwgY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICk7XG5cdFx0XHRcdFx0ZGl2ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRcdHNhZmUuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0XHRcdFx0Ly8gRml4IFwiWEhUTUxcIi1zdHlsZSB0YWdzIGluIGFsbCBicm93c2Vyc1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcblxuXHRcdFx0XHRcdC8vIEdvIHRvIGh0bWwgYW5kIGJhY2ssIHRoZW4gcGVlbCBvZmYgZXh0cmEgd3JhcHBlcnNcblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdGRlcHRoID0gd3JhcFswXTtcblx0XHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gd3JhcFsxXSArIGVsZW0gKyB3cmFwWzJdO1xuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0byB0aGUgcmlnaHQgZGVwdGhcblx0XHRcdFx0XHR3aGlsZSAoIGRlcHRoLS0gKSB7XG5cdFx0XHRcdFx0XHRkaXYgPSBkaXYubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBJRSdzIGF1dG9pbnNlcnRlZCA8dGJvZHk+IGZyb20gdGFibGUgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQudGJvZHkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cblx0XHRcdFx0XHRcdGhhc0JvZHkgPSBydGJvZHkudGVzdChlbGVtKTtcblx0XHRcdFx0XHRcdFx0dGJvZHkgPSB0YWcgPT09IFwidGFibGVcIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0ZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQuY2hpbGROb2RlcyA6XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdFx0XHR3cmFwWzFdID09PSBcIjx0YWJsZT5cIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXYuY2hpbGROb2RlcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IHRib2R5Lmxlbmd0aCAtIDE7IGogPj0gMCA7IC0taiApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRib2R5WyBqIF0sIFwidGJvZHlcIiApICYmICF0Ym9keVsgaiBdLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdHRib2R5WyBqIF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGJvZHlbIGogXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSUUgY29tcGxldGVseSBraWxscyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiBpbm5lckhUTUwgaXMgdXNlZFxuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRkaXYuaW5zZXJ0QmVmb3JlKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyhlbGVtKVswXSApLCBkaXYuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSBkaXYuY2hpbGROb2RlcztcblxuXHRcdFx0XHRcdC8vIFRha2Ugb3V0IG9mIGZyYWdtZW50IGNvbnRhaW5lciAod2UgbmVlZCBhIGZyZXNoIGRpdiBlYWNoIHRpbWUpXG5cdFx0XHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRml4ICMxMTM1NjogQ2xlYXIgZWxlbWVudHMgZnJvbSBzYWZlRnJhZ21lbnRcblx0XHRpZiAoIGRpdiApIHtcblx0XHRcdGVsZW0gPSBkaXYgPSBzYWZlID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBkZWZhdWx0Q2hlY2tlZCBmb3IgYW55IHJhZGlvcyBhbmQgY2hlY2tib3hlc1xuXHRcdC8vIGFib3V0IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBET00gaW4gSUUgNi83ICgjODA2MClcblx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5hcHBlbmRDaGVja2VkICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IChlbGVtID0gcmV0W2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHRmaXhEZWZhdWx0Q2hlY2tlZCggZWxlbSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZ3JlcCggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQXBwZW5kIGVsZW1lbnRzIHRvIGEgcHJvdmlkZWQgZG9jdW1lbnQgZnJhZ21lbnRcblx0XHRpZiAoIGZyYWdtZW50ICkge1xuXHRcdFx0Ly8gU3BlY2lhbCBoYW5kbGluZyBvZiBlYWNoIHNjcmlwdCBlbGVtZW50XG5cdFx0XHRoYW5kbGVTY3JpcHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgY29uc2lkZXIgaXQgZXhlY3V0YWJsZVxuXHRcdFx0XHRpZiAoICFlbGVtLnR5cGUgfHwgcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlICkgKSB7XG5cdFx0XHRcdFx0Ly8gRGV0YWNoIHRoZSBzY3JpcHQgYW5kIHN0b3JlIGl0IGluIHRoZSBzY3JpcHRzIGFycmF5IChpZiBwcm92aWRlZCkgb3IgdGhlIGZyYWdtZW50XG5cdFx0XHRcdFx0Ly8gUmV0dXJuIHRydXRoeSB0byBpbmRpY2F0ZSB0aGF0IGl0IGhhcyBiZWVuIGhhbmRsZWRcblx0XHRcdFx0XHRyZXR1cm4gc2NyaXB0cyA/XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0ucGFyZW50Tm9kZSA/IGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApIDogZWxlbSApIDpcblx0XHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGkgPSAwOyAoZWxlbSA9IHJldFtpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSdyZSBkb25lIGFmdGVyIGhhbmRsaW5nIGFuIGV4ZWN1dGFibGUgc2NyaXB0XG5cdFx0XHRcdGlmICggISggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInNjcmlwdFwiICkgJiYgaGFuZGxlU2NyaXB0KCBlbGVtICkgKSApIHtcblx0XHRcdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnQgYW5kIGhhbmRsZSBlbWJlZGRlZCBzY3JpcHRzXG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdFx0Ly8gaGFuZGxlU2NyaXB0IGFsdGVycyB0aGUgRE9NLCBzbyB1c2UgalF1ZXJ5Lm1lcmdlIHRvIGVuc3VyZSBzbmFwc2hvdCBpdGVyYXRpb25cblx0XHRcdFx0XHRcdGpzVGFncyA9IGpRdWVyeS5ncmVwKCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpICksIGhhbmRsZVNjcmlwdCApO1xuXG5cdFx0XHRcdFx0XHQvLyBTcGxpY2UgdGhlIHNjcmlwdHMgaW50byByZXQgYWZ0ZXIgdGhlaXIgZm9ybWVyIGFuY2VzdG9yIGFuZCBhZHZhbmNlIG91ciBpbmRleCBiZXlvbmQgdGhlbVxuXHRcdFx0XHRcdFx0cmV0LnNwbGljZS5hcHBseSggcmV0LCBbaSArIDEsIDBdLmNvbmNhdCgganNUYWdzICkgKTtcblx0XHRcdFx0XHRcdGkgKz0ganNUYWdzLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zLCAvKiBpbnRlcm5hbCAqLyBhY2NlcHREYXRhICkge1xuXHRcdHZhciBkYXRhLCBpZCwgZWxlbSwgdHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblx0XHRcdGNhY2hlID0galF1ZXJ5LmNhY2hlLFxuXHRcdFx0ZGVsZXRlRXhwYW5kbyA9IGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWw7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblxuXHRcdFx0aWYgKCBhY2NlcHREYXRhIHx8IGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuXHRcdFx0XHRkYXRhID0gaWQgJiYgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBjYWNoZSBvbmx5IGlmIGl0IHdhcyBub3QgYWxyZWFkeSByZW1vdmVkIGJ5IGpRdWVyeS5ldmVudC5yZW1vdmVcblx0XHRcdFx0XHRpZiAoIGNhY2hlWyBpZCBdICkge1xuXG5cdFx0XHRcdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0XHRcdC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2Rlcyxcblx0XHRcdFx0XHRcdC8vIG5vciBkb2VzIGl0IGhhdmUgYSByZW1vdmVBdHRyaWJ1dGUgZnVuY3Rpb24gb24gRG9jdW1lbnQgbm9kZXM7XG5cdFx0XHRcdFx0XHQvLyB3ZSBtdXN0IGhhbmRsZSBhbGwgb2YgdGhlc2UgY2FzZXNcblx0XHRcdFx0XHRcdGlmICggZGVsZXRlRXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGVsZW1bIGludGVybmFsS2V5IF07XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ucmVtb3ZlQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggaW50ZXJuYWxLZXkgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZWxlbVsgaW50ZXJuYWxLZXkgXSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGpRdWVyeS5kZWxldGVkSWRzLnB1c2goIGlkICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcbi8vIExpbWl0IHNjb3BlIHBvbGx1dGlvbiBmcm9tIGFueSBkZXByZWNhdGVkIEFQSVxuKGZ1bmN0aW9uKCkge1xuXG52YXIgbWF0Y2hlZCwgYnJvd3NlcjtcblxuLy8gVXNlIG9mIGpRdWVyeS5icm93c2VyIGlzIGZyb3duZWQgdXBvbi5cbi8vIE1vcmUgZGV0YWlsczogaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5icm93c2VyXG4vLyBqUXVlcnkudWFNYXRjaCBtYWludGFpbmVkIGZvciBiYWNrLWNvbXBhdFxualF1ZXJ5LnVhTWF0Y2ggPSBmdW5jdGlvbiggdWEgKSB7XG5cdHVhID0gdWEudG9Mb3dlckNhc2UoKTtcblxuXHR2YXIgbWF0Y2ggPSAvKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcblx0XHQvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcblx0XHQvKG9wZXJhKSg/Oi4qdmVyc2lvbnwpWyBcXC9dKFtcXHcuXSspLy5leGVjKCB1YSApIHx8XG5cdFx0Lyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcblx0XHR1YS5pbmRleE9mKFwiY29tcGF0aWJsZVwiKSA8IDAgJiYgLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyggdWEgKSB8fFxuXHRcdFtdO1xuXG5cdHJldHVybiB7XG5cdFx0YnJvd3NlcjogbWF0Y2hbIDEgXSB8fCBcIlwiLFxuXHRcdHZlcnNpb246IG1hdGNoWyAyIF0gfHwgXCIwXCJcblx0fTtcbn07XG5cbm1hdGNoZWQgPSBqUXVlcnkudWFNYXRjaCggbmF2aWdhdG9yLnVzZXJBZ2VudCApO1xuYnJvd3NlciA9IHt9O1xuXG5pZiAoIG1hdGNoZWQuYnJvd3NlciApIHtcblx0YnJvd3NlclsgbWF0Y2hlZC5icm93c2VyIF0gPSB0cnVlO1xuXHRicm93c2VyLnZlcnNpb24gPSBtYXRjaGVkLnZlcnNpb247XG59XG5cbi8vIENocm9tZSBpcyBXZWJraXQsIGJ1dCBXZWJraXQgaXMgYWxzbyBTYWZhcmkuXG5pZiAoIGJyb3dzZXIuY2hyb21lICkge1xuXHRicm93c2VyLndlYmtpdCA9IHRydWU7XG59IGVsc2UgaWYgKCBicm93c2VyLndlYmtpdCApIHtcblx0YnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xufVxuXG5qUXVlcnkuYnJvd3NlciA9IGJyb3dzZXI7XG5cbmpRdWVyeS5zdWIgPSBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24galF1ZXJ5U3ViKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeVN1Yi5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9XG5cdGpRdWVyeS5leHRlbmQoIHRydWUsIGpRdWVyeVN1YiwgdGhpcyApO1xuXHRqUXVlcnlTdWIuc3VwZXJjbGFzcyA9IHRoaXM7XG5cdGpRdWVyeVN1Yi5mbiA9IGpRdWVyeVN1Yi5wcm90b3R5cGUgPSB0aGlzKCk7XG5cdGpRdWVyeVN1Yi5mbi5jb25zdHJ1Y3RvciA9IGpRdWVyeVN1Yjtcblx0alF1ZXJ5U3ViLnN1YiA9IHRoaXMuc3ViO1xuXHRqUXVlcnlTdWIuZm4uaW5pdCA9IGZ1bmN0aW9uIGluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdGlmICggY29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICYmICEoY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeVN1YikgKSB7XG5cdFx0XHRjb250ZXh0ID0galF1ZXJ5U3ViKCBjb250ZXh0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5mbi5pbml0LmNhbGwoIHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5U3ViICk7XG5cdH07XG5cdGpRdWVyeVN1Yi5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeVN1Yi5mbjtcblx0dmFyIHJvb3RqUXVlcnlTdWIgPSBqUXVlcnlTdWIoZG9jdW1lbnQpO1xuXHRyZXR1cm4galF1ZXJ5U3ViO1xufTtcblxufSkoKTtcbnZhciBjdXJDU1MsIGlmcmFtZSwgaWZyYW1lRG9jLFxuXHRyYWxwaGEgPSAvYWxwaGFcXChbXildKlxcKS9pLFxuXHRyb3BhY2l0eSA9IC9vcGFjaXR5PShbXildKikvLFxuXHRycG9zaXRpb24gPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC8sXG5cdC8vIHN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGUgZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJtYXJnaW4gPSAvXm1hcmdpbi8sXG5cdHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGNvcmVfcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGNvcmVfcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWy0rXSk9KFwiICsgY29yZV9wbnVtICsgXCIpXCIsIFwiaVwiICksXG5cdGVsZW1kaXNwbGF5ID0ge30sXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiAwLFxuXHRcdGZvbnRXZWlnaHQ6IDQwMFxuXHR9LFxuXG5cdGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdLFxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXG5cdGV2ZW50c1RvZ2dsZSA9IGpRdWVyeS5mbi50b2dnbGU7XG5cbi8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG5cdFx0b3JpZ05hbWUgPSBuYW1lLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvcmlnTmFtZTtcbn1cblxuZnVuY3Rpb24gaXNIaWRkZW4oIGVsZW0sIGVsICkge1xuXHRlbGVtID0gZWwgfHwgZWxlbTtcblx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBlbGVtLCBkaXNwbGF5LFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHR2YWx1ZXNbIGluZGV4IF0gPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBjc3NfZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IGN1ckNTUyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUsIGZuMiApIHtcblx0XHR2YXIgYm9vbCA9IHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCI7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdGF0ZSApICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBmbjIgKSApIHtcblx0XHRcdHJldHVybiBldmVudHNUb2dnbGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGJvb2wgPyBzdGF0ZSA6IGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEV4Y2x1ZGUgdGhlIGZvbGxvd2luZyBjc3MgcHJvcGVydGllcyB0byBhZGQgcHhcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcblx0XHRcImZsb2F0XCI6IGpRdWVyeS5zdXBwb3J0LmNzc0Zsb2F0ID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBzdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggcmV0WzFdICsgMSApICogcmV0WzJdICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgTmFOIGFuZCBudWxsIHZhbHVlcyBhcmVuJ3Qgc2V0LiBTZWU6ICM3MTE2XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTiggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSApIHtcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gV3JhcHBlZCB0byBwcmV2ZW50IElFIGZyb20gdGhyb3dpbmcgZXJyb3JzIHdoZW4gJ2ludmFsaWQnIHZhbHVlcyBhcmUgcHJvdmlkZWRcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM1NTA5XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgbnVtZXJpYywgZXh0cmEgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly9jb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIG51bWVyaWMgfHwgZXh0cmEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIG51bWVyaWMgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fSxcblxuXHQvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zXG5cdHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHR2YXIgcmV0LCBuYW1lLFxuXHRcdFx0b2xkID0ge307XG5cblx0XHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0XHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG59KTtcblxuLy8gTk9URTogVG8gYW55IGZ1dHVyZSBtYWludGFpbmVyLCB3ZSd2ZSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuLy8gYmVjYXVzZSBqc2RvbSBvbiBub2RlLmpzIHdpbGwgYnJlYWsgd2l0aG91dCBpdC5cbmlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHZhciByZXQsIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsXG5cdFx0XHRjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRyZXQgPSBjb21wdXRlZFsgbmFtZSBdO1xuXHRcdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0XHQvLyBDaHJvbWUgPCAxNyBhbmQgU2FmYXJpIDUuMCB1c2VzIFwiY29tcHV0ZWQgdmFsdWVcIiBpbnN0ZWFkIG9mIFwidXNlZCB2YWx1ZVwiIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFNhZmFyaSA1LjEuNyAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gZWxzZSBpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7XG5cdGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHZhciBsZWZ0LCByc0xlZnQsXG5cdFx0XHRyZXQgPSBlbGVtLmN1cnJlbnRTdHlsZSAmJiBlbGVtLmN1cnJlbnRTdHlsZVsgbmFtZSBdLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcblx0XHQvLyBzbyB3ZSBkb24ndCBkZWZhdWx0IHRvIGF1dG9cblx0XHRpZiAoIHJldCA9PSBudWxsICYmIHN0eWxlICYmIHN0eWxlWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXQgPSBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcblx0XHQvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxXG5cblx0XHQvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcblx0XHQvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcblx0XHQvLyBidXQgbm90IHBvc2l0aW9uIGNzcyBhdHRyaWJ1dGVzLCBhcyB0aG9zZSBhcmUgcHJvcG9ydGlvbmFsIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0ZWFkXG5cdFx0Ly8gYW5kIHdlIGNhbid0IG1lYXN1cmUgdGhlIHBhcmVudCBpbnN0ZWFkIGJlY2F1c2UgaXQgbWlnaHQgdHJpZ2dlciBhIFwic3RhY2tpbmcgZG9sbHNcIiBwcm9ibGVtXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgIXJwb3NpdGlvbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGxlZnQgPSBzdHlsZS5sZWZ0O1xuXHRcdFx0cnNMZWZ0ID0gZWxlbS5ydW50aW1lU3R5bGUgJiYgZWxlbS5ydW50aW1lU3R5bGUubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xuXHR9O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94ICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIGJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0Ly8gd2UgdXNlIGpRdWVyeS5jc3MgaW5zdGVhZCBvZiBjdXJDU1MgaGVyZVxuXHRcdFx0Ly8gYmVjYXVzZSBvZiB0aGUgcmVsaWFibGVNYXJnaW5SaWdodCBDU1MgaG9vayFcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gRnJvbSB0aGlzIHBvaW50IG9uIHdlIHVzZSBjdXJDU1MgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UgKHJlbGV2YW50IGluIGFuaW1hdGlvbnMpXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0gKSApIHx8IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0gcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0gcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdICkgKSB8fCAwO1xuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuc3VwcG9ydC5ib3hTaXppbmcgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBzb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmICggalF1ZXJ5LnN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gdXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuXG4vLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuZnVuY3Rpb24gY3NzX2RlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0aWYgKCBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSApIHtcblx0XHRyZXR1cm4gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cdH1cblxuXHR2YXIgZWxlbSA9IGpRdWVyeSggXCI8XCIgKyBub2RlTmFtZSArIFwiPlwiICkuYXBwZW5kVG8oIGRvY3VtZW50LmJvZHkgKSxcblx0XHRkaXNwbGF5ID0gZWxlbS5jc3MoXCJkaXNwbGF5XCIpO1xuXHRlbGVtLnJlbW92ZSgpO1xuXG5cdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLFxuXHQvLyBnZXQgZWxlbWVudCdzIHJlYWwgZGVmYXVsdCBkaXNwbGF5IGJ5IGF0dGFjaGluZyBpdCB0byBhIHRlbXAgaWZyYW1lXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRpZnJhbWUgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuXHRcdFx0aWZyYW1lIHx8IGpRdWVyeS5leHRlbmQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIiksIHtcblx0XHRcdFx0ZnJhbWVCb3JkZXI6IDAsXG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdC8vIENyZWF0ZSBhIGNhY2hlYWJsZSBjb3B5IG9mIHRoZSBpZnJhbWUgZG9jdW1lbnQgb24gZmlyc3QgY2FsbC5cblx0XHQvLyBJRSBhbmQgT3BlcmEgd2lsbCBhbGxvdyB1cyB0byByZXVzZSB0aGUgaWZyYW1lRG9jIHdpdGhvdXQgcmUtd3JpdGluZyB0aGUgZmFrZSBIVE1MXG5cdFx0Ly8gZG9jdW1lbnQgdG8gaXQ7IFdlYktpdCAmIEZpcmVmb3ggd29uJ3QgYWxsb3cgcmV1c2luZyB0aGUgaWZyYW1lIGRvY3VtZW50LlxuXHRcdGlmICggIWlmcmFtZURvYyB8fCAhaWZyYW1lLmNyZWF0ZUVsZW1lbnQgKSB7XG5cdFx0XHRpZnJhbWVEb2MgPSAoIGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQgKS5kb2N1bWVudDtcblx0XHRcdGlmcmFtZURvYy53cml0ZShcIjwhZG9jdHlwZSBodG1sPjxodG1sPjxib2R5PlwiKTtcblx0XHRcdGlmcmFtZURvYy5jbG9zZSgpO1xuXHRcdH1cblxuXHRcdGVsZW0gPSBpZnJhbWVEb2MuYm9keS5hcHBlbmRDaGlsZCggaWZyYW1lRG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpICk7XG5cblx0XHRkaXNwbGF5ID0gY3VyQ1NTKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGlmcmFtZSApO1xuXHR9XG5cblx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxualF1ZXJ5LmVhY2goWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdC8vIGNlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBob3dldmVyLCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0IGZyb20gdGhpc1xuXHRcdFx0XHRpZiAoIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgJiYgcmRpc3BsYXlzd2FwLnRlc3QoIGN1ckNTUyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuc3VwcG9ydC5ib3hTaXppbmcgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiApID09PSBcImJvcmRlci1ib3hcIlxuXHRcdFx0XHQpIDogMFxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59KTtcblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQub3BhY2l0eSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzLm9wYWNpdHkgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHQvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcblx0XHRcdHJldHVybiByb3BhY2l0eS50ZXN0KCAoY29tcHV0ZWQgJiYgZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZS5maWx0ZXIgOiBlbGVtLnN0eWxlLmZpbHRlcikgfHwgXCJcIiApID9cblx0XHRcdFx0KCAwLjAxICogcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgKSArIFwiXCIgOlxuXHRcdFx0XHRjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdFx0XHRjdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0b3BhY2l0eSA9IGpRdWVyeS5pc051bWVyaWMoIHZhbHVlICkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiIDogXCJcIixcblx0XHRcdFx0ZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cblx0XHRcdC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuXHRcdFx0Ly8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbFxuXHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtIGF0dGVtcHQgdG8gcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgIzY2NTJcblx0XHRcdGlmICggdmFsdWUgPj0gMSAmJiBqUXVlcnkudHJpbSggZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgXCJcIiApICkgPT09IFwiXCIgJiZcblx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGUsIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxuLy8gVGhlc2UgaG9va3MgY2Fubm90IGJlIGFkZGVkIHVudGlsIERPTSByZWFkeSBiZWNhdXNlIHRoZSBzdXBwb3J0IHRlc3Rcbi8vIGZvciBpdCBpcyBub3QgcnVuIHVudGlsIGFmdGVyIERPTSByZWFkeVxualF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHRpZiAoICFqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0ICkge1xuXHRcdGpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdFx0Ly8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXG5cdFx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5SaWdodFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG5cdC8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHRcblx0Ly8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIHdlIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcblx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQucGl4ZWxQb3NpdGlvbiAmJiBqUXVlcnkuZm4ucG9zaXRpb24gKSB7XG5cdFx0alF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdFx0XHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblx0XHRcdFx0XHRcdC8vIGlmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCByZXQgKSA/IGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6IHJldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblxufSk7XG5cbmlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcblx0alF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBlbGVtLm9mZnNldFdpZHRoID09PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0ID09PSAwICkgfHwgKCFqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgJiYgKChlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSkgfHwgY3VyQ1NTKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xuXHR9O1xuXG5cdGpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcblx0fTtcbn1cblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSxcblxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF0sXG5cdFx0XHRcdGV4cGFuZGVkID0ge307XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSk7XG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyaW5wdXQgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8aGlkZGVufG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2ksXG5cdHJzZWxlY3RUZXh0YXJlYSA9IC9eKD86c2VsZWN0fHRleHRhcmVhKS9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCB0aGlzLmVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhdGhpcy5kaXNhYmxlZCAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCByc2VsZWN0VGV4dGFyZWEudGVzdCggdGhpcy5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmlucHV0LnRlc3QoIHRoaXMudHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICl7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCwgaSApe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0pLmdldCgpO1xuXHR9XG59KTtcblxuLy9TZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy9rZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElmIGFycmF5IGl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0c1xuXHRcdFx0XHQvLyBudW1lcmljIGluZGV4IHRvIHJlc29sdmUgZGVzZXJpYWxpemF0aW9uIGFtYmlndWl0eSBpc3N1ZXMuXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCByYWNrIChhcyBvZiAxLjAuMCkgY2FuJ3QgY3VycmVudGx5IGRlc2VyaWFsaXplXG5cdFx0XHRcdC8vIG5lc3RlZCBhcnJheXMgcHJvcGVybHksIGFuZCBhdHRlbXB0aW5nIHRvIGRvIHNvIG1heSBjYXVzZVxuXHRcdFx0XHQvLyBhIHNlcnZlciBlcnJvci4gUG9zc2libGUgZml4ZXMgYXJlIHRvIG1vZGlmeSByYWNrJ3Ncblx0XHRcdFx0Ly8gZGVzZXJpYWxpemF0aW9uIGFsZ29yaXRobSBvciB0byBwcm92aWRlIGFuIG9wdGlvbiBvciBmbGFnXG5cdFx0XHRcdC8vIHRvIGZvcmNlIGFycmF5IHNlcmlhbGl6YXRpb24gdG8gYmUgc2hhbGxvdy5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cbnZhciAvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jYXRpb24sXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uIHNlZ21lbnRzXG5cdGFqYXhMb2NQYXJ0cyxcblxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKilcXHI/JC9tZywgLy8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcFxcLXN0b3JhZ2V8LitcXC1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnF1ZXJ5ID0gL1xcPy8sXG5cdHJzY3JpcHQgPSAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRydXJsID0gL14oW1xcd1xcK1xcLlxcLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0Ly8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxuXHRfbG9hZCA9IGpRdWVyeS5mbi5sb2FkLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFtcIiovXCJdICsgW1wiKlwiXTtcblxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcbi8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxudHJ5IHtcblx0YWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbn0gY2F0Y2goIGUgKSB7XG5cdC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XG5cdC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcblx0YWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XG59XG5cbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSwgbGlzdCwgcGxhY2VCZWZvcmUsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5zcGxpdCggY29yZV9yc3BhY2UgKSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZGF0YVR5cGVzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSBdO1xuXHRcdFx0XHQvLyBXZSBjb250cm9sIGlmIHdlJ3JlIGFza2VkIHRvIGFkZCBiZWZvcmVcblx0XHRcdFx0Ly8gYW55IGV4aXN0aW5nIGVsZW1lbnRcblx0XHRcdFx0cGxhY2VCZWZvcmUgPSAvXlxcKy8udGVzdCggZGF0YVR5cGUgKTtcblx0XHRcdFx0aWYgKCBwbGFjZUJlZm9yZSApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnN1YnN0ciggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QgPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW107XG5cdFx0XHRcdC8vIHRoZW4gd2UgYWRkIHRvIHRoZSBzdHJ1Y3R1cmUgYWNjb3JkaW5nbHlcblx0XHRcdFx0bGlzdFsgcGxhY2VCZWZvcmUgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiIF0oIGZ1bmMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUixcblx0XHRkYXRhVHlwZSAvKiBpbnRlcm5hbCAqLywgaW5zcGVjdGVkIC8qIGludGVybmFsICovICkge1xuXG5cdGRhdGFUeXBlID0gZGF0YVR5cGUgfHwgb3B0aW9ucy5kYXRhVHlwZXNbIDAgXTtcblx0aW5zcGVjdGVkID0gaW5zcGVjdGVkIHx8IHt9O1xuXG5cdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cblx0dmFyIHNlbGVjdGlvbixcblx0XHRsaXN0ID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbmd0aCA9IGxpc3QgPyBsaXN0Lmxlbmd0aCA6IDAsXG5cdFx0ZXhlY3V0ZU9ubHkgPSAoIHN0cnVjdHVyZSA9PT0gcHJlZmlsdGVycyApO1xuXG5cdGZvciAoIDsgaSA8IGxlbmd0aCAmJiAoIGV4ZWN1dGVPbmx5IHx8ICFzZWxlY3Rpb24gKTsgaSsrICkge1xuXHRcdHNlbGVjdGlvbiA9IGxpc3RbIGkgXSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdC8vIElmIHdlIGdvdCByZWRpcmVjdGVkIHRvIGFub3RoZXIgZGF0YVR5cGVcblx0XHQvLyB3ZSB0cnkgdGhlcmUgaWYgZXhlY3V0aW5nIG9ubHkgYW5kIG5vdCBkb25lIGFscmVhZHlcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3Rpb24gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoICFleGVjdXRlT25seSB8fCBpbnNwZWN0ZWRbIHNlbGVjdGlvbiBdICkge1xuXHRcdFx0XHRzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0c2VsZWN0aW9uID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoXG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIsIHNlbGVjdGlvbiwgaW5zcGVjdGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIElmIHdlJ3JlIG9ubHkgZXhlY3V0aW5nIG9yIG5vdGhpbmcgd2FzIHNlbGVjdGVkXG5cdC8vIHdlIHRyeSB0aGUgY2F0Y2hhbGwgZGF0YVR5cGUgaWYgbm90IGRvbmUgYWxyZWFkeVxuXHRpZiAoICggZXhlY3V0ZU9ubHkgfHwgIXNlbGVjdGlvbiApICYmICFpbnNwZWN0ZWRbIFwiKlwiIF0gKSB7XG5cdFx0c2VsZWN0aW9uID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoXG5cdFx0XHRcdHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiwgXCIqXCIsIGluc3BlY3RlZCApO1xuXHR9XG5cdC8vIHVubmVjZXNzYXJ5IHdoZW4gb25seSBleGVjdXRpbmcgKHByZWZpbHRlcnMpXG5cdC8vIGJ1dCBpdCdsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYWxsZXIgaW4gdGhhdCBjYXNlXG5cdHJldHVybiBzZWxlY3Rpb247XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cbn1cblxualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdC8vIERvbid0IGRvIGEgcmVxdWVzdCBpZiBubyBlbGVtZW50cyBhcmUgYmVpbmcgcmVxdWVzdGVkXG5cdGlmICggIXRoaXMubGVuZ3RoICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cblx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRzZWxlY3RvciA9IHVybC5zbGljZSggb2ZmLCB1cmwubGVuZ3RoICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gUmVxdWVzdCB0aGUgcmVtb3RlIGRvY3VtZW50XG5cdGpRdWVyeS5hamF4KHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcblx0XHR0eXBlOiB0eXBlLFxuXHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHQvLyBTZWUgaWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkXG5cdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IGRpdiB0byBob2xkIHRoZSByZXN1bHRzXG5cdFx0XHRqUXVlcnkoXCI8ZGl2PlwiKVxuXG5cdFx0XHRcdC8vIGluamVjdCB0aGUgY29udGVudHMgb2YgdGhlIGRvY3VtZW50IGluLCByZW1vdmluZyB0aGUgc2NyaXB0c1xuXHRcdFx0XHQvLyB0byBhdm9pZCBhbnkgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnMgaW4gSUVcblx0XHRcdFx0LmFwcGVuZCggcmVzcG9uc2VUZXh0LnJlcGxhY2UoIHJzY3JpcHQsIFwiXCIgKSApXG5cblx0XHRcdFx0Ly8gTG9jYXRlIHRoZSBzcGVjaWZpZWQgZWxlbWVudHNcblx0XHRcdFx0LmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBJZiBub3QsIGp1c3QgaW5qZWN0IHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0fSk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFwiYWpheFN0YXJ0IGFqYXhTdG9wIGFqYXhDb21wbGV0ZSBhamF4RXJyb3IgYWpheFN1Y2Nlc3MgYWpheFNlbmRcIi5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGksIG8gKXtcblx0alF1ZXJ5LmZuWyBvIF0gPSBmdW5jdGlvbiggZiApe1xuXHRcdHJldHVybiB0aGlzLm9uKCBvLCBmICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFjayxcblx0XHRcdGRhdGFUeXBlOiB0eXBlXG5cdFx0fSk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdHNldHRpbmdzID0gdGFyZ2V0O1xuXHRcdFx0dGFyZ2V0ID0galF1ZXJ5LmFqYXhTZXR0aW5ncztcblx0XHR9XG5cdFx0YWpheEV4dGVuZCggdGFyZ2V0LCBzZXR0aW5ncyApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXG5cdFx0XHRcIipcIjogYWxsVHlwZXNcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIlxuXHRcdH0sXG5cblx0XHQvLyBMaXN0IG9mIGRhdGEgY29udmVydGVyc1xuXHRcdC8vIDEpIGtleSBmb3JtYXQgaXMgXCJzb3VyY2VfdHlwZSBkZXN0aW5hdGlvbl90eXBlXCIgKGEgc2luZ2xlIHNwYWNlIGluLWJldHdlZW4pXG5cdFx0Ly8gMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZCBmb3Igc291cmNlX3R5cGVcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogd2luZG93LlN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0Y29udGV4dDogdHJ1ZSxcblx0XHRcdHVybDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIC8vIGlmTW9kaWZpZWQga2V5XG5cdFx0XHRpZk1vZGlmaWVkS2V5LFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdHJhbnNwb3J0XG5cdFx0XHR0cmFuc3BvcnQsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzXG5cdFx0XHQvLyBJdCdzIHRoZSBjYWxsYmFja0NvbnRleHQgaWYgb25lIHdhcyBwcm92aWRlZCBpbiB0aGUgb3B0aW9uc1xuXHRcdFx0Ly8gYW5kIGlmIGl0J3MgYSBET00gbm9kZSBvciBhIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBjYWxsYmFja0NvbnRleHQgIT09IHMgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICkgP1xuXHRcdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6IGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBzdGF0dXNUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIHN0YXR1c1RleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdC8vIEl0IGlzIGRlZmluZWQgaGVyZSBiZWNhdXNlIGpzbGludCBjb21wbGFpbnMgaWYgaXQgaXMgZGVjbGFyZWRcblx0XHQvLyBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbiAod2hpY2ggd291bGQgYmUgbW9yZSBsb2dpY2FsIGFuZCByZWFkYWJsZSlcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gaXNTdWNjZXNzLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSBpc1N1Y2Nlc3MuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IGlzU3VjY2Vzcy5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XG5cdFx0XHRcdC8vIHRoZW4gbm9ybWFsaXplIHN0YXR1c1RleHQgYW5kIHN0YXR1cyBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggIXN0YXR1c1RleHQgfHwgc3RhdHVzICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSBcIlwiICsgKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKTtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4XCIgKyAoIGlzU3VjY2VzcyA/IFwiU3VjY2Vzc1wiIDogXCJFcnJvclwiICksXG5cdFx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cdFx0anFYSFIuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblxuXHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0anFYSFIuc3RhdHVzQ29kZSA9IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0dmFyIHRtcDtcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0Zm9yICggdG1wIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIHRtcCBdID0gWyBzdGF0dXNDb2RlW3RtcF0sIG1hcFt0bXBdIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9IG1hcFsganFYSFIuc3RhdHVzIF07XG5cdFx0XHRcdFx0anFYSFIuYWx3YXlzKCB0bXAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKCM1ODY2OiBJRTcgaXNzdWUgd2l0aCBwcm90b2NvbC1sZXNzIHVybHMpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKS5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkuc3BsaXQoIGNvcmVfcnNwYWNlICk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgYSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlclxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0cGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MyApICkgIT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHRmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGlmTW9kaWZpZWRLZXkgYmVmb3JlIGFkZGluZyB0aGUgYW50aS1jYWNoZSBwYXJhbWV0ZXJcblx0XHRcdGlmTW9kaWZpZWRLZXkgPSBzLnVybDtcblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHR2YXIgdHMgPSBqUXVlcnkubm93KCksXG5cdFx0XHRcdFx0Ly8gdHJ5IHJlcGxhY2luZyBfPSBpZiBpdCBpcyB0aGVyZVxuXHRcdFx0XHRcdHJldCA9IHMudXJsLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyB0cyApO1xuXG5cdFx0XHRcdC8vIGlmIG5vdGhpbmcgd2FzIHJlcGxhY2VkLCBhZGQgdGltZXN0YW1wIHRvIHRoZSBlbmRcblx0XHRcdFx0cy51cmwgPSByZXQgKyAoICggcmV0ID09PSBzLnVybCApID8gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIHRzIDogXCJcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZk1vZGlmaWVkS2V5ID0gaWZNb2RpZmllZEtleSB8fCBzLnVybDtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cblx0XHR9XG5cblx0XHQvLyBhYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9XG5cbn0pO1xuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIHNldHMgYWxsIHJlc3BvbnNlWFhYIGZpZWxkcyBhY2NvcmRpbmdseVxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMsXG5cdFx0cmVzcG9uc2VGaWVsZHMgPSBzLnJlc3BvbnNlRmllbGRzO1xuXG5cdC8vIEZpbGwgcmVzcG9uc2VYWFggZmllbGRzXG5cdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VGaWVsZHMgKSB7XG5cdFx0aWYgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGpxWEhSWyByZXNwb25zZUZpZWxkc1t0eXBlXSBdID0gcmVzcG9uc2VzWyB0eXBlIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiY29udGVudC10eXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vLyBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKSB7XG5cblx0dmFyIGNvbnYsIGNvbnYyLCBjdXJyZW50LCB0bXAsXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCksXG5cdFx0cHJldiA9IGRhdGFUeXBlc1sgMCBdLFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHRpID0gMDtcblxuXHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRpZiAoIHMuZGF0YUZpbHRlciApIHtcblx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZSwgdG9sZXJhdGluZyBsaXN0IG1vZGlmaWNhdGlvblxuXHRmb3IgKCA7IChjdXJyZW50ID0gZGF0YVR5cGVzWysraV0pOyApIHtcblxuXHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRpZiAoIGN1cnJlbnQgIT09IFwiKlwiICkge1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHRpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnNwbGljZSggaS0tLCAwLCBjdXJyZW50ICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzW1widGhyb3dzXCJdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSBwcmV2IGZvciBuZXh0IGl0ZXJhdGlvblxuXHRcdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRycXVlc3Rpb24gPSAvXFw/Lyxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/Lyxcblx0bm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRkYXRhID0gcy5kYXRhLFxuXHRcdHVybCA9IHMudXJsLFxuXHRcdGhhc0NhbGxiYWNrID0gcy5qc29ucCAhPT0gZmFsc2UsXG5cdFx0cmVwbGFjZUluVXJsID0gaGFzQ2FsbGJhY2sgJiYgcmpzb25wLnRlc3QoIHVybCApLFxuXHRcdHJlcGxhY2VJbkRhdGEgPSBoYXNDYWxsYmFjayAmJiAhcmVwbGFjZUluVXJsICYmIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHQhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmXG5cdFx0XHRyanNvbnAudGVzdCggZGF0YSApO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgfHwgcmVwbGFjZUluVXJsIHx8IHJlcGxhY2VJbkRhdGEgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCByZXBsYWNlSW5VcmwgKSB7XG5cdFx0XHRzLnVybCA9IHVybC5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHJlcGxhY2VJbkRhdGEgKSB7XG5cdFx0XHRzLmRhdGEgPSBkYXRhLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggaGFzQ2FsbGJhY2sgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVzdGlvbi50ZXN0KCB1cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL2phdmFzY3JpcHR8ZWNtYXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBnbG9iYWxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdHMuZ2xvYmFsID0gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiaGVhZFwiIClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0XHRzY3JpcHQuYXN5bmMgPSBcImFzeW5jXCI7XG5cblx0XHRcdFx0aWYgKCBzLnNjcmlwdENoYXJzZXQgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LmNoYXJzZXQgPSBzLnNjcmlwdENoYXJzZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY3JpcHQuc3JjID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcblx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiggXywgaXNBYm9ydCApIHtcblxuXHRcdFx0XHRcdGlmICggaXNBYm9ydCB8fCAhc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdCggc2NyaXB0LnJlYWR5U3RhdGUgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG5cdFx0XHRcdFx0XHRzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRpZiAoIGhlYWQgJiYgc2NyaXB0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRzY3JpcHQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdC8vIENhbGxiYWNrIGlmIG5vdCBhYm9ydFxuXHRcdFx0XHRcdFx0aWYgKCAhaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIDIwMCwgXCJzdWNjZXNzXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIFVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiBhcHBlbmRDaGlsZCAgdG8gY2lyY3VtdmVudCBhbiBJRTYgYnVnLlxuXHRcdFx0XHQvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5IGFuZCAjNDM3OCkuXG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNjcmlwdCApIHtcblx0XHRcdFx0XHRzY3JpcHQub25sb2FkKCAwLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcbnZhciB4aHJDYWxsYmFja3MsXG5cdC8vICM1MjgwOiBJbnRlcm5ldCBFeHBsb3JlciB3aWxsIGtlZXAgY29ubmVjdGlvbnMgYWxpdmUgaWYgd2UgZG9uJ3QgYWJvcnQgb24gdW5sb2FkXG5cdHhock9uVW5sb2FkQWJvcnQgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCA/IGZ1bmN0aW9uKCkge1xuXHRcdC8vIEFib3J0IGFsbCBwZW5kaW5nIHJlcXVlc3RzXG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCAwLCAxICk7XG5cdFx0fVxuXHR9IDogZmFsc2UsXG5cdHhocklkID0gMDtcblxuLy8gRnVuY3Rpb25zIHRvIGNyZWF0ZSB4aHJzXG5mdW5jdGlvbiBjcmVhdGVTdGFuZGFyZFhIUigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aXZlWEhSKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTEhUVFBcIiApO1xuXHR9IGNhdGNoKCBlICkge31cbn1cblxuLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuLy8gKFRoaXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYWpheFNldHRpbmdzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCA/XG5cdC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcblx0ICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxuXHQgKiBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcblx0ICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXG5cdCAqIHdlIG5lZWQgYSBmYWxsYmFjay5cblx0ICovXG5cdGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc0xvY2FsICYmIGNyZWF0ZVN0YW5kYXJkWEhSKCkgfHwgY3JlYXRlQWN0aXZlWEhSKCk7XG5cdH0gOlxuXHQvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHRjcmVhdGVTdGFuZGFyZFhIUjtcblxuLy8gRGV0ZXJtaW5lIHN1cHBvcnQgcHJvcGVydGllc1xuKGZ1bmN0aW9uKCB4aHIgKSB7XG5cdGpRdWVyeS5leHRlbmQoIGpRdWVyeS5zdXBwb3J0LCB7XG5cdFx0YWpheDogISF4aHIsXG5cdFx0Y29yczogISF4aHIgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhociApXG5cdH0pO1xufSkoIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCkgKTtcblxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbmlmICggalF1ZXJ5LnN1cHBvcnQuYWpheCApIHtcblxuXHRqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggcyApIHtcblx0XHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdFx0aWYgKCAhcy5jcm9zc0RvbWFpbiB8fCBqUXVlcnkuc3VwcG9ydC5jb3JzICkge1xuXG5cdFx0XHR2YXIgY2FsbGJhY2s7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblxuXHRcdFx0XHRcdC8vIEdldCBhIG5ldyB4aHJcblx0XHRcdFx0XHR2YXIgaGFuZGxlLCBpLFxuXHRcdFx0XHRcdFx0eGhyID0gcy54aHIoKTtcblxuXHRcdFx0XHRcdC8vIE9wZW4gdGhlIHNvY2tldFxuXHRcdFx0XHRcdC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuXHRcdFx0XHRcdGlmICggcy51c2VybmFtZSApIHtcblx0XHRcdFx0XHRcdHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jLCBzLnVzZXJuYW1lLCBzLnBhc3N3b3JkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRcdGlmICggcy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpIGluIHMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0XHR4aHJbIGkgXSA9IHMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdGlmICggcy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBzLm1pbWVUeXBlICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0XHRpZiAoICFzLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmVlZCBhbiBleHRyYSB0cnkvY2F0Y2ggZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cyBpbiBGaXJlZm94IDNcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCggXyApIHt9XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0XG5cdFx0XHRcdFx0Ly8gVGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uIHdoaWNoIGlzIGFjdHVhbGx5XG5cdFx0XHRcdFx0Ly8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXG5cdFx0XHRcdFx0eGhyLnNlbmQoICggcy5oYXNDb250ZW50ICYmIHMuZGF0YSApIHx8IG51bGwgKTtcblxuXHRcdFx0XHRcdC8vIExpc3RlbmVyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggXywgaXNBYm9ydCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cyxcblx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCxcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZXMsXG5cdFx0XHRcdFx0XHRcdHhtbDtcblxuXHRcdFx0XHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgZXhjZXB0aW9ucyB3aGVuIGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0XHQvLyBvZiBhbiB4aHIgd2hlbiBhIG5ldHdvcmsgZXJyb3Igb2NjdXJyZWRcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9oZWxwZnVsLmtub2JzLWRpYWxzLmNvbS9pbmRleC5waHAvQ29tcG9uZW50X3JldHVybmVkX2ZhaWx1cmVfY29kZTpfMHg4MDA0MDExMV8oTlNfRVJST1JfTk9UX0FWQUlMQUJMRSlcblx0XHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2FzIG5ldmVyIGNhbGxlZCBhbmQgaXMgYWJvcnRlZCBvciBjb21wbGV0ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjYWxsZWQgb25jZVxuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRG8gbm90IGtlZXAgYXMgYWN0aXZlIGFueW1vcmVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBqUXVlcnkubm9vcDtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaGFuZGxlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgaXQncyBhbiBhYm9ydFxuXHRcdFx0XHRcdFx0XHRcdGlmICggaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFib3J0IGl0IG1hbnVhbGx5IGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRcdHhtbCA9IHhoci5yZXNwb25zZVhNTDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ29uc3RydWN0IHJlc3BvbnNlIGxpc3Rcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggeG1sICYmIHhtbC5kb2N1bWVudEVsZW1lbnQgLyogIzQ5NTggKi8gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy54bWwgPSB4bWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gcmVxdWVzdGluZyBiaW5hcnkgZGF0YSwgSUU2LTkgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vIG9uIGFueSBhdHRlbXB0IHRvIGFjY2VzcyByZXNwb25zZVRleHQgKCMxMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2goIF8gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RhdHVzVGV4dCBmb3IgZmF1bHR5IGNyb3NzLWRvbWFpbiByZXF1ZXN0c1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSByZXF1ZXN0IGlzIGxvY2FsIGFuZCB3ZSBoYXZlIGRhdGE6IGFzc3VtZSBhIHN1Y2Nlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdC8vIChzdWNjZXNzIHdpdGggbm8gZGF0YSB3b24ndCBnZXQgbm90aWZpZWQsIHRoYXQncyB0aGUgYmVzdCB3ZVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIGRvIGdpdmVuIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAhc3RhdHVzICYmIHMuaXNMb2NhbCAmJiAhcy5jcm9zc0RvbWFpbiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRSAtICMxNDUwOiBzb21ldGltZXMgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAxMjIzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoKCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICFpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAtMSwgZmlyZWZveEFjY2Vzc0V4Y2VwdGlvbiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENhbGwgY29tcGxldGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzLCByZXNwb25zZUhlYWRlcnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCAhcy5hc3luYyApIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGluIHN5bmMgbW9kZSB3ZSBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdC8vIChJRTYgJiBJRTcpIGlmIGl0J3MgaW4gY2FjaGUgYW5kIGhhcyBiZWVuXG5cdFx0XHRcdFx0XHQvLyByZXRyaWV2ZWQgZGlyZWN0bHkgd2UgbmVlZCB0byBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggY2FsbGJhY2ssIDAgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aGFuZGxlID0gKyt4aHJJZDtcblx0XHRcdFx0XHRcdGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhY3RpdmUgeGhycyBjYWxsYmFja3MgbGlzdCBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdFx0Ly8gYW5kIGF0dGFjaCB0aGUgdW5sb2FkIGhhbmRsZXJcblx0XHRcdFx0XHRcdFx0aWYgKCAheGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0XHRcdFx0XHRcdHhockNhbGxiYWNrcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggd2luZG93ICkudW5sb2FkKCB4aHJPblVubG9hZEFib3J0ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gQWRkIHRvIGxpc3Qgb2YgYWN0aXZlIHhocnMgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdHhockNhbGxiYWNrc1sgaGFuZGxlIF0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjYWxsYmFjaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygwLDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxudmFyIGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFstK10pPXwpKFwiICsgY29yZV9wbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLyxcblx0YW5pbWF0aW9uUHJlZmlsdGVycyA9IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXHR0d2VlbmVycyA9IHtcblx0XHRcIipcIjogW2Z1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbmQsIHVuaXQsIHByZXZTY2FsZSxcblx0XHRcdFx0dHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDAsXG5cdFx0XHRcdHNjYWxlID0gMTtcblxuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0ZW5kID0gK3BhcnRzWzJdO1xuXHRcdFx0XHR1bml0ID0gcGFydHNbM10gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjb21wdXRlIHN0YXJ0aW5nIHZhbHVlXG5cdFx0XHRcdGlmICggdW5pdCAhPT0gXCJweFwiICYmIHN0YXJ0ICkge1xuXHRcdFx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRcdFx0Ly8gUHJlZmVyIHRoZSBjdXJyZW50IHByb3BlcnR5LCBiZWNhdXNlIHRoaXMgcHJvY2VzcyB3aWxsIGJlIHRyaXZpYWwgaWYgaXQgdXNlcyB0aGUgc2FtZSB1bml0c1xuXHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIGVuZCBvciBhIHNpbXBsZSBjb25zdGFudFxuXHRcdFx0XHRcdHN0YXJ0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCwgdHJ1ZSApIHx8IGVuZCB8fCAxO1xuXG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZypcblx0XHRcdFx0XHRcdC8vIFVzZSBhIHN0cmluZyBmb3IgZG91YmxpbmcgZmFjdG9yIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRcdFx0XHRwcmV2U2NhbGUgPSBzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdFx0c3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuXHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCBwcm9wLCBzdGFydCArIHVuaXQgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm9lcyBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0XHRcdFx0XHRzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0O1xuXG5cdFx0XHRcdFx0Ly8gU3RvcCBsb29waW5nIGlmIHdlJ3ZlIGhpdCB0aGUgbWFyayBvciBzY2FsZSBpcyB1bmNoYW5nZWRcblx0XHRcdFx0XHR9IHdoaWxlICggc2NhbGUgIT09IDEgJiYgc2NhbGUgIT09IHByZXZTY2FsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sxXSA/IHN0YXJ0ICsgKCBwYXJ0c1sxXSArIDEgKSAqIGVuZCA6IGVuZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSwgMCApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbnMoIGFuaW1hdGlvbiwgcHJvcHMgKSB7XG5cdGpRdWVyeS5lYWNoKCBwcm9wcywgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdHZhciBjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdGlmICggY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0Ly8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRpbmRleCA9IDAsXG5cdFx0dHdlZW5lckluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtICggcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAgKSxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblxuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGNyZWF0ZVR3ZWVucyggYW5pbWF0aW9uLCBwcm9wcyApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlLFxuXHRcdFx0ZWxlbTogZWxlbVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxuXHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiIFwiKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXSA9IHR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgaW5kZXgsIHByb3AsIHZhbHVlLCBsZW5ndGgsIGRhdGFTaG93LCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRoYW5kbGVkID0gW10sXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApO1xuXG5cdC8vIGhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9pbmcgdGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlIGNvbXBsZXRlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcblx0XHRcdC8vIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcImlubGluZVwiICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0Ly8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7XG5cdFx0XHQvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuXHRcdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBjc3NfZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0eWxlLnpvb20gPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyApIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGhhbmRsZWQucHVzaCggaW5kZXggKTtcblx0XHR9XG5cdH1cblxuXHRsZW5ndGggPSBoYW5kbGVkLmxlbmd0aDtcblx0aWYgKCBsZW5ndGggKSB7XG5cdFx0ZGF0YVNob3cgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIgKSB8fCBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFwiZnhzaG93XCIsIHRydWUgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRmb3IgKCBpbmRleCA9IDAgOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gaGFuZGxlZFsgaW5kZXggXTtcblx0XHRcdHR3ZWVuID0gYW5pbS5jcmVhdGVUd2VlbiggcHJvcCwgaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAgKTtcblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXNzaW5nIGFueSB2YWx1ZSBhcyBhIDR0aCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHNcblx0XHRcdC8vIHNvLCBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBmYWxzZSwgXCJcIiApO1xuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0Ly8gdXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQgLSB1c2UgY3NzSG9vayBpZiBpdHMgdGhlcmUgLSB1c2UgLnN0eWxlIGlmIGl0c1xuXHRcdFx0Ly8gYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGVcblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0uc3R5bGUgJiYgKCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHwgalF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBSZW1vdmUgaW4gMi4wIC0gdGhpcyBzdXBwb3J0cyBJRTgncyBwYW5pYyBiYXNlZCBhcHByb2FjaFxuLy8gdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiB8fFxuXHRcdFx0Ly8gc3BlY2lhbCBjaGVjayBmb3IgLnRvZ2dsZSggaGFuZGxlciwgaGFuZGxlciwgLi4uIClcblx0XHRcdCggIWkgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICkgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gc2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMgcmVzb2x2ZSBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5ICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG5cdFx0XHQvLyB0aW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoIHdpbGwgZGVxdWV1ZVxuXHRcdFx0Ly8gYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmRcblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9LFxuXHRcdGkgPSAwO1xuXG5cdC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGg/IDEgOiAwO1xuXHRmb3IoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwKk1hdGguUEkgKSAvIDI7XG5cdH1cbn07XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0aWYgKCB0aW1lcigpICYmIGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKSAmJiAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuaWYgKCBqUXVlcnkuZXhwciAmJiBqUXVlcnkuZXhwci5maWx0ZXJzICkge1xuXHRqUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHRcdH0pLmxlbmd0aDtcblx0fTtcbn1cbnZhciBycm9vdCA9IC9eKD86Ym9keXxodG1sKSQvaTtcblxualF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0dmFyIGJveCwgZG9jRWxlbSwgYm9keSwgd2luLCBjbGllbnRUb3AsIGNsaWVudExlZnQsIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgdG9wLCBsZWZ0LFxuXHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0aWYgKCAhZG9jICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggKGJvZHkgPSBkb2MuYm9keSkgPT09IGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5vZmZzZXQuYm9keU9mZnNldCggZWxlbSApO1xuXHR9XG5cblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdH1cblxuXHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRjbGllbnRUb3AgID0gZG9jRWxlbS5jbGllbnRUb3AgIHx8IGJvZHkuY2xpZW50VG9wICB8fCAwO1xuXHRjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuXHRzY3JvbGxUb3AgID0gd2luLnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wO1xuXHRzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdDtcblx0dG9wICA9IGJveC50b3AgICsgc2Nyb2xsVG9wICAtIGNsaWVudFRvcDtcblx0bGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cblx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbn07XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cblx0Ym9keU9mZnNldDogZnVuY3Rpb24oIGJvZHkgKSB7XG5cdFx0dmFyIHRvcCA9IGJvZHkub2Zmc2V0VG9wLFxuXHRcdFx0bGVmdCA9IGJvZHkub2Zmc2V0TGVmdDtcblxuXHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQgKSB7XG5cdFx0XHR0b3AgICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoYm9keSwgXCJtYXJnaW5Ub3BcIikgKSB8fCAwO1xuXHRcdFx0bGVmdCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGJvZHksIFwibWFyZ2luTGVmdFwiKSApIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcblx0fSxcblxuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApO1xuXG5cdFx0Ly8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdHZhciBjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpLFxuXHRcdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApLFxuXHRcdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICksXG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiYgalF1ZXJ5LmluQXJyYXkoXCJhdXRvXCIsIFtjdXJDU1NUb3AsIGN1ckNTU0xlZnRdKSA+IC0xLFxuXHRcdFx0cHJvcHMgPSB7fSwgY3VyUG9zaXRpb24gPSB7fSwgY3VyVG9wLCBjdXJMZWZ0O1xuXG5cdFx0Ly8gbmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXIgdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1swXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZWxlbSA9IHRoaXNbMF0sXG5cblx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXG5cblx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0b2Zmc2V0ICAgICAgID0gdGhpcy5vZmZzZXQoKSxcblx0XHRwYXJlbnRPZmZzZXQgPSBycm9vdC50ZXN0KG9mZnNldFBhcmVudFswXS5ub2RlTmFtZSkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gU3VidHJhY3QgZWxlbWVudCBtYXJnaW5zXG5cdFx0Ly8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcblx0XHQvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuXHRcdG9mZnNldC50b3AgIC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5Ub3BcIikgKSB8fCAwO1xuXHRcdG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcblxuXHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIpICkgfHwgMDtcblx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIikgKSB8fCAwO1xuXG5cdFx0Ly8gU3VidHJhY3QgdGhlIHR3byBvZmZzZXRzXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoIXJyb290LnRlc3Qob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAmJiBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHtzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwifSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IC9ZLy50ZXN0KCBwcm9wICk7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IChwcm9wIGluIHdpbikgPyB3aW5bIHByb3AgXSA6XG5cdFx0XHRcdFx0d2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gOlxuXHRcdFx0XHRcdGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHQgdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID9cblx0XHRlbGVtIDpcblx0XHRlbGVtLm5vZGVUeXBlID09PSA5ID9cblx0XHRcdGVsZW0uZGVmYXVsdFZpZXcgfHwgZWxlbS5wYXJlbnRXaW5kb3cgOlxuXHRcdFx0ZmFsc2U7XG59XG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblx0XHQvLyBtYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdC8vIHVuZm9ydHVuYXRlbHksIHRoaXMgY2F1c2VzIGJ1ZyAjMzgzOCBpbiBJRTYvOCBvbmx5LCBidXQgdGhlcmUgaXMgY3VycmVudGx5IG5vIGdvb2QsIHNtYWxsIHdheSB0byBmaXggaXQuXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuLy8gRXhwb3NlIGpRdWVyeSB0byB0aGUgZ2xvYmFsIG9iamVjdFxud2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFzIGFuIEFNRCBtb2R1bGUsIGJ1dCBvbmx5IGZvciBBTUQgbG9hZGVycyB0aGF0XG4vLyB1bmRlcnN0YW5kIHRoZSBpc3N1ZXMgd2l0aCBsb2FkaW5nIG11bHRpcGxlIHZlcnNpb25zIG9mIGpRdWVyeVxuLy8gaW4gYSBwYWdlIHRoYXQgYWxsIG1pZ2h0IGNhbGwgZGVmaW5lKCkuIFRoZSBsb2FkZXIgd2lsbCBpbmRpY2F0ZVxuLy8gdGhleSBoYXZlIHNwZWNpYWwgYWxsb3dhbmNlcyBmb3IgbXVsdGlwbGUgalF1ZXJ5IHZlcnNpb25zIGJ5XG4vLyBzcGVjaWZ5aW5nIGRlZmluZS5hbWQualF1ZXJ5ID0gdHJ1ZS4gUmVnaXN0ZXIgYXMgYSBuYW1lZCBtb2R1bGUsXG4vLyBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsXG4vLyBidXQgbm90IHVzZSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0IHVuZGVyc3RhbmRzIGFub255bW91c1xuLy8gQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Qgd2F5IHRvIHJlZ2lzdGVyLlxuLy8gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmUgZGVyaXZlZCBmcm9tXG4vLyBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZSBmaWxlIG5hbWUuXG4vLyBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzIHRvIGNhbGxcbi8vIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQualF1ZXJ5ICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiBqUXVlcnk7IH0gKTtcbn1cblxucmV0dXJuIGpRdWVyeTtcblxufSkoIHdpbmRvdyApOyB9KSk7XG5cbn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcImFwcFwiOlwiPCUgaWYgKGxvY2FsZS5jdXJyZW50KCkgPT09ICdoZS1JTCcpIHsgJT5cXHJcXG4gIDxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nLi9zdHlsZS1ydGwuY3NzJz5cXHJcXG48JSB9ICU+XFxyXFxuXFxyXFxuPGRpdiBpZD0nbG9hZGVyJyBjbGFzcz0nbG9hZGVyJz48L2Rpdj5cXHJcXG48ZGl2IGlkPSdkcmF3ZXInIGNsYXNzPSdzaWRlYmFyJyA8JSBpZiAobG9jYWxlLmN1cnJlbnQoKSA9PT0gJ2hlLUlMJykgeyAlPmRpcj0ncnRsJzwlIH0gJT4+PC9kaXY+XFxyXFxuPG5hdiBpZD0nbmF2aWdhdGlvbic+PC9uYXY+XFxyXFxuPGRpdiBpZD0nbWFpbicgPCUgaWYgKGxvY2FsZS5jdXJyZW50KCkgPT09ICdoZS1JTCcpIHsgJT5kaXI9J3J0bCc8JSB9ICU+PjwvZGl2PlxcclxcblxcclxcbjxkaXYgY2xhc3M9J3Byb3NlLW1lbnUgZHJvcGRvd24tbWVudScgPCUgaWYgKGxvY2FsZS5jdXJyZW50KCkgPT09ICdoZS1JTCcpIHsgJT5kaXI9J3J0bCc8JSB9ICU+PlxcclxcbiAgPGRpdiBjbGFzcz0naW5uZXIgY2xlYXJmaXgnPlxcclxcbiAgICA8YSBocmVmPScjJyBjbGFzcz0naWNvbiBicmFuZGluZyBkcm9wZG93bi1ob3ZlcicgZGF0YS1saW5rPXRydWU+UHJvc2U8L2E+XFxyXFxuICAgIDx1bCBjbGFzcz0nZHJvcGRvd24gY2xlYXJmaXgnPlxcclxcbiAgICAgIDxsaT48YSBocmVmPScjJz5Qcm9zZTwvYT48L2xpPlxcclxcbiAgICAgIDxsaT48YSBjbGFzcz0nYWJvdXQnIGhyZWY9Jy4vI2Fib3V0Jz48JT0gdCgnbmF2aWdhdGlvbi5hYm91dCcpICU+PC9hPjwvbGk+XFxyXFxuICAgICAgPGxpPjxhIGNsYXNzPSdoZWxwJyBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vcHJvc2UvcHJvc2UnPjwlPSB0KCduYXZpZ2F0aW9uLmRldmVsb3AnKSAlPjwvYT48L2xpPlxcclxcbiAgICAgIDxsaT48YSBocmVmPScuLyNjaG9vc2VsYW5ndWFnZSc+PCU9IHQoJ25hdmlnYXRpb24ubGFuZ3VhZ2UnKSAlPjwvYT48L2xpPlxcclxcbiAgICAgIDxsaSBjbGFzcz0nZGl2aWRlciBhdXRoZW50aWNhdGVkJz48L2xpPlxcclxcbiAgICAgIDxsaSBjbGFzcz0nYXV0aGVudGljYXRlZCc+XFxyXFxuICAgICAgICA8YSBocmVmPScjJyBjbGFzcz0nbG9nb3V0Jz48JT0gdCgnbmF2aWdhdGlvbi5sb2dvdXQnKSAlPjwvYT5cXHJcXG4gICAgICA8L2xpPlxcclxcbiAgICA8L3VsPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJicmVhZGNydW1iXCI6XCI8c3BhbiBjbGFzcz0nc2xhc2gnPi88L3NwYW4+XFxyXFxuPGEgY2xhc3M9J3BhdGgnIGhyZWY9JyM8JT0gdHJhaWwgJT4vPCU9IHVybCAlPic+PCU9IG5hbWUgJT48L2E+XFxyXFxuXCIsXCJjaG9vc2VsYW5ndWFnZVwiOlwiPGgxPjwlPSB0KCdjaG9vc2VsYW5ndWFnZS50aXRsZScpICU+PC9oMT5cXHJcXG48dWwgY2xhc3M9J2ZhdC1saXN0IHJvdW5kJz5cXHJcXG4gIDwlIF8oY2hvb3NlTGFuZ3VhZ2UubGFuZ3VhZ2VzKS5lYWNoKGZ1bmN0aW9uKGwpIHsgJT5cXHJcXG4gICAgPGxpPlxcclxcbiAgICA8YSBocmVmPScjJyBkYXRhLWNvZGU9JzwlPSBsLmNvZGUgJT4nIGNsYXNzPSdsYW5ndWFnZTwlIGlmIChsLmNvZGUgPT09IGNob29zZUxhbmd1YWdlLmFjdGl2ZSkgeyAlPiBhY3RpdmU8JSB9ICU+Jz5cXHJcXG4gICAgICAgIDwlIGlmIChsLmNvZGUgPT09IGNob29zZUxhbmd1YWdlLmFjdGl2ZSkgeyAlPjxzcGFuIGNsYXNzPSdpY28gY2hlY2ttYXJrIGZyJz48L3NwYW4+PCUgfSAlPlxcclxcbiAgICAgICAgPCU9IGwubmFtZSAlPlxcclxcbiAgICAgICAgPHNtYWxsPig8JT0gbC5jb2RlICU+KTwvc21hbGw+XFxyXFxuICAgICAgPC9hPlxcclxcbiAgICA8L2xpPlxcclxcbiAgPCUgfSk7ICU+XFxyXFxuPC91bD5cXHJcXG48cD48JT0gdCgnY2hvb3NlbGFuZ3VhZ2UuZGVzY3JpcHRpb24nKSAlPjwvcD5cXHJcXG5cIixcImRpYWxvZ3NcIjp7XCJoZWxwXCI6XCI8JVxcclxcbiAgZnVuY3Rpb24gZm9ybWF0dGVkQ2xhc3Moc3RyKSB7XFxyXFxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXFxccy9nLCAnLScpLnJlcGxhY2UoJyZhbXA7JywgJycpO1xcclxcbiAgfTtcXHJcXG4lPlxcclxcblxcclxcbjxkaXYgY2xhc3M9J2NvbCBjb2wyNSc+XFxyXFxuICA8dWwgY2xhc3M9J21haW4tbWVudSc+XFxyXFxuICAgIDwlIF8oaGVscCkuZWFjaChmdW5jdGlvbihtYWluTWVudSwgaSkgeyAlPlxcclxcbiAgICAgIDxsaT48YSBocmVmPScjJyBjbGFzcz0nPCUgaWYgKGkgPT09IDApIHsgJT5hY3RpdmUgPCUgfSAlPicgZGF0YS1pZD0nPCU9IGZvcm1hdHRlZENsYXNzKG1haW5NZW51Lm1lbnVOYW1lKSAlPic+PCU9IG1haW5NZW51Lm1lbnVOYW1lICU+PC9hPjwvbGk+XFxyXFxuICAgIDwlIH0pOyAlPlxcclxcbiAgPC91bD5cXHJcXG48L2Rpdj5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPSdjb2wgY29sMjUnPlxcclxcbiAgPCUgXyhoZWxwKS5lYWNoKGZ1bmN0aW9uKG1haW5NZW51LCBpbmRleCkgeyAlPlxcclxcbiAgPHVsIGNsYXNzPSdzdWItbWVudSA8JT0gZm9ybWF0dGVkQ2xhc3MobWFpbk1lbnUubWVudU5hbWUpICU+IDwlIGlmIChpbmRleCA9PT0gMCkgeyAlPmFjdGl2ZTwlIH0gJT4nIGRhdGEtaWQ9JzwlPSBmb3JtYXR0ZWRDbGFzcyhtYWluTWVudS5tZW51TmFtZSkgJT4nPlxcclxcbiAgICAgIDwlIF8obWFpbk1lbnUuY29udGVudCkuZWFjaChmdW5jdGlvbihzdWJNZW51LCBpKSB7ICU+XFxyXFxuICAgICAgICA8bGk+PGEgaHJlZj0nIycgZGF0YS1pZD0nPCU9IGZvcm1hdHRlZENsYXNzKHN1Yk1lbnUubWVudU5hbWUpICU+JyBjbGFzcz0nPCUgaWYgKGluZGV4ID09PSAwICYmIGkgPT09IDApIHsgJT4gYWN0aXZlPCUgfSAlPic+PCU9IHN1Yk1lbnUubWVudU5hbWUgJT48L2E+PC9saT5cXHJcXG4gICAgICA8JSB9KTsgJT5cXHJcXG4gICAgPC91bD5cXHJcXG4gIDwlIH0pOyAlPlxcclxcbjwvZGl2PlxcclxcblxcclxcbjxkaXYgY2xhc3M9J2NvbCBjb2wtbGFzdCBwcm9zZSBzbWFsbCc+XFxyXFxuICA8JSBfKGhlbHApLmVhY2goZnVuY3Rpb24obWFpbk1lbnUsIGluZGV4KSB7ICU+XFxyXFxuICAgIDwlIF8obWFpbk1lbnUuY29udGVudCkuZWFjaChmdW5jdGlvbihkLCBpKSB7ICU+XFxyXFxuICAgIDxkaXYgY2xhc3M9J2hlbHAtY29udGVudCBpbm5lciBoZWxwLTwlPSBmb3JtYXR0ZWRDbGFzcyhkLm1lbnVOYW1lKSAlPjwlIGlmIChpbmRleCA9PT0gMCAmJiBpID09PSAwKSB7ICU+IGFjdGl2ZTwlIH0gJT4nPlxcclxcbiAgICAgIDwlPSBkLmRhdGEgJT5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDwlIH0pOyAlPlxcclxcbiAgPCUgfSk7ICU+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJsaW5rXCI6XCI8ZGl2IGNsYXNzPSdpbm5lcic+XFxyXFxuICA8bGFiZWw+PCU9IHQoJ2RpYWxvZ3MubGluay50aXRsZScpICU+PC9sYWJlbD5cXHJcXG4gIDxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSdocmVmJyBwbGFjZWhvbGRlcj1cXFwiPCU9IHQoJ2RpYWxvZ3MubGluay5ocmVmUGxhY2Vob2xkZXInKSAlPlxcXCIgLz5cXHJcXG4gIDxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSd0ZXh0JyBwbGFjZWhvbGRlcj1cXFwiPCU9IHQoJ2RpYWxvZ3MubGluay50ZXh0UGxhY2Vob2xkZXInKSAlPlxcXCIgLz5cXHJcXG4gIDxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSd0aXRsZScgcGxhY2Vob2xkZXI9XFxcIjwlPSB0KCdkaWFsb2dzLmxpbmsudGl0bGVQbGFjZWhvbGRlcicpICU+XFxcIiAvPlxcclxcblxcclxcbiAgPCUgaWYgKHJlbGF0aXZlTGlua3MpIHsgJT5cXHJcXG4gICAgPGRpdiBjbGFzcz0nY29sbGFwc2libGUnPlxcclxcbiAgICAgIDxzZWxlY3QgZGF0YS1wbGFjZWhvbGRlcj1cXFwiPCU9IHQoJ2RpYWxvZ3MubGluay5pbnNlcnRQbGFjZWhvbGRlcicpICU+XFxcIiBjbGFzcz0nY2h6bi1zZWxlY3QnPlxcclxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT48L29wdGlvbj5cXHJcXG4gICAgICAgIDwlIF8ocmVsYXRpdmVMaW5rcykuZWFjaChmdW5jdGlvbihsaW5rKSB7ICU+XFxyXFxuICAgICAgICA8b3B0aW9uIHZhbHVlPSc8JT0gbGluay5ocmVmICU+LDwlPSBsaW5rLnRleHQgJT4nPjwlPSBsaW5rLnRleHQgJT48L29wdGlvbj5cXHJcXG4gICAgICAgIDwlIH0pOyAlPlxcclxcbiAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwlIH0gJT5cXHJcXG5cXHJcXG4gIDxhIGhyZWY9JyMnIGNsYXNzPSdidXR0b24gcm91bmQgaW5zZXJ0JyBkYXRhLXR5cGU9J2xpbmsnPjwlPSB0KCdkaWFsb2dzLmxpbmsuaW5zZXJ0JykgJT48L2E+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJtZWRpYVwiOlwiPGRpdiBjbGFzcz0naW5uZXIgY2xlYXJmaXgnPlxcclxcblxcclxcbiAgPGRpdiA8JSBpZiAoYXNzZXRzRGlyZWN0b3J5KSB7ICU+Y2xhc3M9J2NvbCBmbCc8JSB9ICU+PlxcclxcbiAgICA8bGFiZWw+PCU9IHQoJ2RpYWxvZ3MubWVkaWEudGl0bGUnKSAlPjwvbGFiZWw+XFxyXFxuXFxyXFxuICAgIDwlIGlmICh3cml0YWJsZSkgeyAlPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9J2NvbnRhaW4gY2xlYXJmaXgnPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9J2ljbyBwaWN0dXJlLWFkZCBmbCc+PC9zcGFuPlxcclxcbiAgICAgICAgPCU9IGRlc2NyaXB0aW9uICU+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG5cXHJcXG4gICAgPGlucHV0IHR5cGU9J3RleHQnIG5hbWU9J3VybCcgcGxhY2Vob2xkZXI9XFxcIjwlPSB0KCdkaWFsb2dzLm1lZGlhLmhyZWZQbGFjZWhvbGRlcicpJT5cXFwiIC8+XFxyXFxuICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSdhbHQnIHBsYWNlaG9sZGVyPVxcXCI8JT0gdCgnZGlhbG9ncy5tZWRpYS5hbHRQbGFjZWhvbGRlcicpJT5cXFwiIC8+XFxyXFxuICAgIDxhIGhyZWY9JyMnIGNsYXNzPSdidXR0b24gcm91bmQgaW5zZXJ0JyBkYXRhLXR5cGU9J21lZGlhJz48JT0gdCgnZGlhbG9ncy5saW5rLmluc2VydCcpICU+PC9hPlxcclxcbiAgICAgIDwlIGlmICghYXNzZXRzRGlyZWN0b3J5KSB7ICU+XFxyXFxuICAgICAgICA8c21hbGwgY2xhc3M9J2NhcHRpb24gZGVlbXBoYXNpemUnPjwlPSB0KCdkaWFsb2dzLm1lZGlhLmhlbHAnKSAlPjwvc21hbGw+XFxyXFxuICAgICAgPCUgfSAlPlxcclxcbiAgPC9kaXY+XFxyXFxuXFxyXFxuICA8JSBpZiAoYXNzZXRzRGlyZWN0b3J5KSB7ICU+XFxyXFxuICAgIDxkaXYgY2xhc3M9J2NvbCBjb2wtbGFzdCBmbCBtZWRpYS1saXN0aW5nJz5cXHJcXG4gICAgICA8bGFiZWw+PCU9IHQoJ2RpYWxvZ3MubWVkaWEuY2hvb3NlJykgJT48L2xhYmVsPlxcclxcbiAgICAgIDx1bCBpZD0nbWVkaWEnPjwvdWw+XFxyXFxuICAgICAgPHNtYWxsIGNsYXNzPSdjYXB0aW9uIGRlZW1waGFzaXplJz48JT0gdCgnZGlhbG9ncy5tZWRpYS5oZWxwTWVkaWEnKSAlPjwvc21hbGw+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPCUgfSAlPlxcclxcbjwvZGl2PlxcclxcblwiLFwibWVkaWFkaXJlY3RvcnlcIjpcIjwlIGlmICh0eXBlID09PSAndHJlZScpIHsgJT5cXHJcXG4gIDxsaSBjbGFzcz0nZGlyZWN0b3J5Jz5cXHJcXG4gICAgPHNwYW4gY2xhc3M9J21hc2snPjwvc3Bhbj5cXHJcXG4gICAgPGEgY2xhc3M9J2NsZWFyZml4IGl0ZW0nIGhyZWY9JzwlPSBwYXRoICU+Jz5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz0naWNvIGZsIHNtYWxsIGlubGluZSBmb2xkZXInPjwvc3Bhbj5cXHJcXG4gICAgICA8JT0gbmFtZSAlPlxcclxcbiAgICA8L2E+XFxyXFxuICA8L2xpPlxcclxcbjwlIH0gZWxzZSB7ICU+XFxyXFxuICA8bGkgY2xhc3M9J2Fzc2V0Jz5cXHJcXG4gICAgPHNwYW4gY2xhc3M9J21hc2snPjwvc3Bhbj5cXHJcXG4gICAgPGEgY2xhc3M9J2NsZWFyZml4IGl0ZW0nIGhyZWY9JzwlPSBwYXRoICU+JyB0aXRsZT0nPCU9IHBhdGggJT4nPlxcclxcbiAgICAgIDwlIGlmIChpc01lZGlhKSB7ICU+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz0naWNvIGZsIHNtYWxsIGlubGluZSBtZWRpYSc+PC9zcGFuPlxcclxcbiAgICAgIDwlIH0gZWxzZSB7ICU+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz0naWNvIGZsIHNtYWxsIGlubGluZSBkb2N1bWVudCc+PC9zcGFuPlxcclxcbiAgICAgIDwlIH0gJT5cXHJcXG4gICAgICA8JT0gbmFtZSAlPlxcclxcbiAgICA8L2E+XFxyXFxuICA8L2xpPlxcclxcbjwlIH0gJT5cXHJcXG5cIn0sXCJkcmF3ZXJcIjpcIjxkaXYgaWQ9J29yZ3MnPjwvZGl2PlxcclxcbjxkaXYgaWQ9J2JyYW5jaGVzJz48L2Rpdj5cXHJcXG48ZGl2IGlkPSdoaXN0b3J5Jz48L2Rpdj5cXHJcXG48ZGl2IGlkPSdkcmFmdHMnPjwvZGl2PlxcclxcbjxkaXYgaWQ9J3NhdmUnPjwvZGl2PlxcclxcbjxkaXYgaWQ9J3NldHRpbmdzJz48L2Rpdj5cXHJcXG5cIixcImZpbGVcIjpcIjxoZWFkZXIgaWQ9J2hlYWRpbmcnIGNsYXNzPSdoZWFkaW5nIGxpbWl0ZXIgY2xlYXJmaXgnPjwvaGVhZGVyPlxcclxcbjxkaXYgaWQ9J21vZGFsJz48L2Rpdj5cXHJcXG5cXHJcXG48ZGl2IGlkPSdwb3N0JyBjbGFzcz0ncG9zdCBsaW1pdGVyJz5cXHJcXG4gIDxkaXYgY2xhc3M9J2VkaXRvciB2aWV3czwlIGlmIChmaWxlLm1hcmtkb3duKSB7ICU+IG1hcmtkb3duPCUgfSBlbHNlIGlmIChmaWxlLmVkYikgeyAlPiBlZGI8JSB9ICU+Jz5cXHJcXG4gICAgPGRpdiBpZD0nZGlmZicgY2xhc3M9J3ZpZXcgcHJvc2UgZGlmZic+XFxyXFxuICAgICAgPGgyPjwlPSB0KCdtYWluLmZpbGUubWV0YVRpdGxlJykgJT48YnIgLz5cXHJcXG4gICAgICAgIDxzcGFuIGNsYXNzPSdkZWVtcGhhc2l6ZSBzbWFsbCc+PCU9IHQoJ21haW4uZmlsZS5tZXRhRGVzY3JpcHRpb24nKSAlPjwvc3Bhbj5cXHJcXG4gICAgICA8L2gyPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9J2RpZmYtY29udGVudCBpbm5lcic+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPSdtZXRhJyBjbGFzcz0ndmlldyByb3VuZCBtZXRhJz48L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD0nZWRpdCcgY2xhc3M9J3ZpZXcgYWN0aXZlIGVkaXQnPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9J3RvcGJhci13cmFwcGVyJz5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9J3RvcGJhcic+XFxyXFxuICAgICAgICAgIDxkaXYgaWQ9J3Rvb2xiYXInIGNsYXNzPSdjb250YWlubWVudCB0b29sYmFyIHJvdW5kJz48L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICAgIDxkaXYgaWQ9J2Ryb3AnIGNsYXNzPSdkcm9wLW1hc2snPjwvZGl2PlxcclxcbiAgICAgIDxkaXYgaWQ9J2NvZGUnIGNsYXNzPSdjb2RlIHJvdW5kIGlubmVyJz48L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgaWQ9J3ByZXZpZXcnIGNsYXNzPSd2aWV3IHByZXZpZXcgcHJvc2UnPjwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJmaWxlc1wiOlwiPCUgaWYgKGRhdGEucGF0aCAmJiBkYXRhLnBhdGggIT09IGRhdGEucm9vdHVybCkgeyAlPlxcclxcbiAgPGRpdiBjbGFzcz0nYnJlYWRjcnVtYic+XFxyXFxuICAgIDxhIGNsYXNzPSdicmFuY2gnIGhyZWY9JyM8JT0gZGF0YS51cmwgJT4nPi4uPC9hPlxcclxcbiAgICA8JSBfLmVhY2goZGF0YS5wYXJ0cywgZnVuY3Rpb24ocGFydCkgeyAlPlxcclxcbiAgICAgIDwlIGlmIChwYXJ0Lm5hbWUgIT09IGRhdGEucm9vdHVybCkgeyAlPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9J3NsYXNoJz4vPC9zcGFuPlxcclxcbiAgICAgICAgPGEgY2xhc3M9J3BhdGgnIGhyZWY9JyM8JT0gW2RhdGEudXJsLCBwYXJ0LnVybF0uam9pbihcXFwiL1xcXCIpICU+Jz48JT0gcGFydC5uYW1lICU+PC9hPlxcclxcbiAgICAgIDwlIH0gJT5cXHJcXG4gICAgPCUgfSk7ICU+XFxyXFxuICA8L2Rpdj5cXHJcXG48JSB9ICU+XFxyXFxuXFxyXFxuPHVsIGNsYXNzPSdsaXN0aW5nJz48L3VsPlxcclxcblwiLFwiaGVhZGVyXCI6XCI8JSBpZiAoZGF0YS5hbHRlcmFibGUpIHsgJT5cXHJcXG4gIDxkaXYgY2xhc3M9J3JvdW5kIGF2YXRhcic+XFxyXFxuICAgIDwlPSBkYXRhLmF2YXRhciAlPlxcclxcbiAgPC9kaXY+XFxyXFxuICA8ZGl2IGNsYXNzPSdmbCBkZXRhaWxzJz5cXHJcXG4gICAgPGg0IGNsYXNzPSdwYXJlbnQtdHJhaWwnPjxhIGhyZWY9JyM8JT0gZGF0YS51c2VyICU+Jz48JT0gZGF0YS51c2VyICU+PC9hPiAvIDxhIGhyZWY9JyM8JT0gZGF0YS51c2VyICU+LzwlPSBkYXRhLnJlcG8ubmFtZSAlPic+PCU9IGRhdGEucmVwby5uYW1lICU+PC9hPjwlIGlmIChkYXRhLmlzUHJpdmF0ZSkgeyAlPjxzcGFuIGNsYXNzPSdpY28gc21hbGwgaW5saW5lIHByaXZhdGUnIHRpdGxlPSdQcml2YXRlIFByb2plY3QnPjwvc3Bhbj48JSB9ICU+PC9oND5cXHJcXG4gICAgPCEtLSBpZiAoaXNOZXcoKSAmJiAhdHJhbnNsYXRlKSBwbGFjZWhvbGRlciwgbm90IHZhbHVlIC0tPlxcclxcbiAgICA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3M9J2hlYWRlcmlucHV0JyBkYXRhLW1vZGU9JzwlPSBkYXRhLm1vZGUgJT4nIDwlIHByaW50KChkYXRhLnBsYWNlaG9sZGVyID8gJ3BsYWNlaG9sZGVyPScgOiAndmFsdWU9JykgKyAnXFxcIicgKyBkYXRhLmlucHV0ICsgJ1xcXCInKSAlPj5cXHJcXG4gICAgPGRpdiBjbGFzcz0nbWFzayc+PC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48JSB9IGVsc2UgeyAlPlxcclxcbiAgPGRpdiBjbGFzcz0nYXZhdGFyIHJvdW5kJz48JT0gZGF0YS5hdmF0YXIgJT48L2Rpdj5cXHJcXG4gIDxkaXYgY2xhc3M9J2ZsIGRldGFpbHMnPlxcclxcbiAgICA8aDQ+PGEgY2xhc3M9J3VzZXInIGhyZWY9JyM8JT0gZGF0YS51c2VyICU+Jz48JT0gZGF0YS51c2VyICU+PC9hPjwvaDQ+XFxyXFxuICAgIDxoMj48YSBjbGFzcz0ncmVwbycgaHJlZj0nIzwlPSBkYXRhLnBhdGggJT4nPjwlPSBkYXRhLnRpdGxlICU+PC9hPjwvaDI+XFxyXFxuICA8L2Rpdj5cXHJcXG48JSB9ICU+XFxyXFxuXCIsXCJsaVwiOntcImZpbGVcIjpcIjwlIGlmIChmaWxlLmJpbmFyeSkgeyAlPlxcclxcbiAgPGRpdiBjbGFzcz0nbGlzdGluZy1pY29uIGljb24gcm91bmQgPCU9IGZpbGUuZXh0ZW5zaW9uICU+IDwlIGlmIChmaWxlLm1lZGlhKSB7ICU+bWVkaWE8JSB9ICU+Jz48L2Rpdj5cXHJcXG48JSB9IGVsc2UgeyAlPlxcclxcbiAgPGEgaHJlZj0nIzwlPSBmaWxlLnJlcG8ub3duZXIubG9naW4gJT4vPCU9IGZpbGUucmVwby5uYW1lICU+L2VkaXQvPCU9IGZpbGUuYnJhbmNoICU+LzwlPSBmaWxlLnBhdGggJT4nIGNsYXNzPSdsaXN0aW5nLWljb24nPlxcclxcbiAgICA8c3BhbiBjbGFzcz0naWNvbiByb3VuZCA8JT0gZmlsZS5leHRlbnNpb24gJT4gPCUgaWYgKGZpbGUubWFya2Rvd24pIHsgJT4gbWQ8JSB9ICU+IDwlIGlmIChmaWxlLm1lZGlhKSB7ICU+IG1lZGlhPCUgfSAlPic+PC9zcGFuPlxcclxcbiAgPC9hPlxcclxcbjwlIH0gJT5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPSdkZXRhaWxzJz5cXHJcXG4gIDxkaXYgY2xhc3M9J2FjdGlvbnMgZnIgY2xlYXJmaXgnPlxcclxcbiAgICA8JSBpZiAoIWZpbGUuYmluYXJ5KSB7ICU+XFxyXFxuICAgICAgPGEgY2xhc3M9J2NsZWFyZml4J1xcclxcbiAgICAgICAgdGl0bGU9XFxcIjwlPSB0KCdtYWluLnJlcG8uZWRpdCcpICU+XFxcIlxcclxcbiAgICAgICAgaHJlZj0nIzwlPSBmaWxlLnJlcG8ub3duZXIubG9naW4gJT4vPCU9IGZpbGUucmVwby5uYW1lICU+L2VkaXQvPCU9IGZpbGUuYnJhbmNoICU+LzwlPSBmaWxlLnBhdGggJT4nPlxcclxcbiAgICAgICAgPCU9IHQoJ21haW4ucmVwby5lZGl0JykgJT5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG4gICAgPCUgaWYgKGZpbGUud3JpdGFibGUpIHsgJT5cXHJcXG4gICAgICA8YVxcclxcbiAgICAgICAgY2xhc3M9J2RlbGV0ZSdcXHJcXG4gICAgICAgIHRpdGxlPVxcXCI8JT0gdCgnbWFpbi5yZXBvLmRlbGV0ZScpICU+XFxcIlxcclxcbiAgICAgICAgaHJlZj0nIyc+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz0naWNvIHJ1YmJpc2ggc21hbGwnPjwvc3Bhbj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPCUgaWYgKGZpbGUuYmluYXJ5KSB7ICU+XFxyXFxuICAgIDxoMyBjbGFzcz0ndGl0bGUnIHRpdGxlPSc8JT0gZmlsZS5uYW1lICU+Jz48JT0gZmlsZS5uYW1lICU+PC9oMz5cXHJcXG4gIDwlIH0gZWxzZSB7ICU+XFxyXFxuICAgIDxoMyBjbGFzcz0ndGl0bGUnIHRpdGxlPSc8JT0gZmlsZS5uYW1lICU+Jz48YSBjbGFzcz0nY2xlYXJmaXgnaHJlZj0nIzwlPSBmaWxlLnJlcG8ub3duZXIubG9naW4gJT4vPCU9IGZpbGUucmVwby5uYW1lICU+L2VkaXQvPCU9IGZpbGUuYnJhbmNoICU+LzwlPSBmaWxlLnBhdGggJT4nPjwlPSBmaWxlLm5hbWUgJT48L2E+PC9oMz5cXHJcXG4gIDwlIH0gJT5cXHJcXG4gIDxzcGFuIGNsYXNzPSdkZWVtcGhhc2l6ZSc+PCU9IGZpbGUuamFpbHBhdGggJT48L3NwYW4+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJmb2xkZXJcIjpcIjxhIGhyZWY9JyM8JT0gZm9sZGVyLnJlcG8ub3duZXIubG9naW4gJT4vPCU9IGZvbGRlci5yZXBvLm5hbWUgJT4vdHJlZS88JT0gZm9sZGVyLmJyYW5jaCAlPi88JT0gZm9sZGVyLnBhdGggJT4nIGNsYXNzPSdsaXN0aW5nLWljb24nPlxcclxcbiAgPHNwYW4gY2xhc3M9J2ljb24gcm91bmQgZm9sZGVyJz48L3NwYW4+XFxyXFxuPC9hPlxcclxcblxcclxcbjxzcGFuIGNsYXNzPSdkZXRhaWxzJz5cXHJcXG4gIDxoMyBjbGFzcz0ndGl0bGUnIHRpdGxlPSc8JT0gZm9sZGVyLm5hbWUgJT4nPlxcclxcbiAgICA8YSBocmVmPScjPCU9IGZvbGRlci5yZXBvLm93bmVyLmxvZ2luICU+LzwlPSBmb2xkZXIucmVwby5uYW1lICU+L3RyZWUvPCU9IGZvbGRlci5icmFuY2ggJT4vPCU9IGZvbGRlci5wYXRoICU+Jz5cXHJcXG4gICAgICA8JT0gZm9sZGVyLm5hbWUgJT5cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9oMz5cXHJcXG4gIDxzcGFuIGNsYXNzPSdkZWVtcGhhc2l6ZSc+PCU9IGZvbGRlci5qYWlscGF0aCAlPjwvc3Bhbj5cXHJcXG48L3NwYW4+XFxyXFxuXCIsXCJyZXBvXCI6XCI8YVxcclxcbiAgY2xhc3M9J2xpc3RpbmctaWNvbidcXHJcXG4gIGRhdGEtdXNlcj0nPCU9IHJlcG8ub3duZXIubG9naW4gJT4nXFxyXFxuICBkYXRhLXJlcG89JzwlPSByZXBvLm5hbWUgJT4nXFxyXFxuICBocmVmPScjPCU9IHJlcG8ub3duZXIubG9naW4gJT4vPCU9IHJlcG8ubmFtZSAlPic+XFxyXFxuICA8JSBpZiAoKHJlcG8ub3duZXIubG9naW4gIT09IHJlcG8ubG9naW4pICYmIHJlcG8ucHJpdmF0ZSkgeyAlPlxcclxcbiAgICA8c3BhbiBjbGFzcz0naWNvbiByb3VuZCByZXBvIG93bmVyIHByaXZhdGUnIHRpdGxlPVxcXCI8JT0gdCgnbWFpbi5yZXBvcy5zaGFyZWRGcm9tJykgJT4gKDwlPSByZXBvLm93bmVyLmxvZ2luICU+KVxcXCI+PC9zcGFuPlxcclxcbiAgPCUgfSBlbHNlIGlmIChyZXBvLm93bmVyLmxvZ2luICE9PSByZXBvLmxvZ2luKSB7ICU+XFxyXFxuICAgIDxzcGFuIGNsYXNzPSdpY29uIHJvdW5kIHJlcG8gb3duZXInIHRpdGxlPVxcXCI8JT0gdCgnbWFpbi5yZXBvcy5zaGFyZWRGcm9tJykgJT4gKDwlPSByZXBvLm93bmVyLmxvZ2luICU+KVxcXCI+PC9zcGFuPlxcclxcbiAgPCUgfSBlbHNlIGlmIChyZXBvLmZvcmsgJiYgcmVwby5wcml2YXRlKSB7ICU+XFxyXFxuICAgIDxzcGFuIGNsYXNzPSdpY29uIHJvdW5kIHJlcG8gcHJpdmF0ZSBmb3JrJyB0aXRsZT1cXFwiPCU9IHQoJ21haW4ucmVwb3MuZm9ya2VkRnJvbScpICU+XFxcIj48L3NwYW4+XFxyXFxuICA8JSB9IGVsc2UgaWYgKHJlcG8uZm9yaykgeyAlPlxcclxcbiAgICA8c3BhbiBjbGFzcz0naWNvbiByb3VuZCByZXBvIGZvcmsnIHRpdGxlPVxcXCI8JT0gdCgnbWFpbi5yZXBvcy5mb3JrZWRGcm9tJykgJT5cXFwiPjwvc3Bhbj5cXHJcXG4gIDwlIH0gZWxzZSBpZiAocmVwby5wcml2YXRlKSB7ICU+XFxyXFxuICAgIDxzcGFuIGNsYXNzPSdpY29uIHJvdW5kIHJlcG8gcHJpdmF0ZSc+PC9zcGFuPlxcclxcbiAgPCUgfSBlbHNlIHsgJT5cXHJcXG4gICAgPHNwYW4gY2xhc3M9J2ljb24gcm91bmQgcmVwbyc+PC9zcGFuPlxcclxcbiAgPCUgfSAlPlxcclxcbjwvYT5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPSdkZXRhaWxzJz5cXHJcXG4gIDxkaXYgY2xhc3M9J2FjdGlvbnMgZnIgY2xlYXJmaXgnPlxcclxcbiAgICA8YVxcclxcbiAgICAgIGRhdGEtdXNlcj0nPCU9IHJlcG8ub3duZXIubG9naW4gJT4nXFxyXFxuICAgICAgZGF0YS1yZXBvPSc8JT0gcmVwby5uYW1lICU+J1xcclxcbiAgICAgIGhyZWY9JyM8JT0gcmVwby5vd25lci5sb2dpbiAlPi88JT0gcmVwby5uYW1lICU+Jz5cXHJcXG4gICAgICA8JT0gdCgnbWFpbi5yZXBvcy5yZXBvJykgJT5cXHJcXG4gICAgPC9hPlxcclxcbiAgICA8JSBpZiAocmVwby5ob21lcGFnZSkgeyAlPlxcclxcbiAgICAgIDxhIGhyZWY9JzwlPSByZXBvLmhvbWVwYWdlICU+Jz48JT0gdCgnbWFpbi5yZXBvcy5zaXRlJykgJT48L2E+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGFcXHJcXG4gICAgZGF0YS11c2VyPSc8JT0gcmVwby5vd25lci5sb2dpbiAlPidcXHJcXG4gICAgZGF0YS1yZXBvPSc8JT0gcmVwby5uYW1lICU+J1xcclxcbiAgICBocmVmPScjPCU9IHJlcG8ub3duZXIubG9naW4gJT4vPCU9IHJlcG8ubmFtZSAlPic+XFxyXFxuICAgIDxoMzwlIGlmICghcmVwby5kZXNjcmlwdGlvbikgeyAlPiBjbGFzcz0ndGl0bGUnPCUgfSAlPj48JT0gcmVwby5uYW1lICU+PC9oMz5cXHJcXG4gICAgPHNwYW4gY2xhc3M9J2RlZW1waGFzaXplJz48JT0gcmVwby5kZXNjcmlwdGlvbiAlPjwvc3Bhbj5cXHJcXG4gIDwvYT5cXHJcXG48L2Rpdj5cXHJcXG5cIn0sXCJsb2FkaW5nXCI6XCI8ZGl2IGNsYXNzPSdsb2FkaW5nIHJvdW5kIGNsZWFyZml4Jz5cXHJcXG4gIDxkaXYgY2xhc3M9J2xvYWRpbmctaWNvbic+PC9kaXY+XFxyXFxuICA8c3BhbiBjbGFzcz1cXFwibWVzc2FnZVxcXCI+PC9zcGFuPlxcclxcbjwvZGl2PlxcclxcblwiLFwibWV0YVwiOntcImJ1dHRvblwiOlwiPGRpdiBjbGFzcz0nZm9ybS1pdGVtJz5cXHJcXG4gIDxsYWJlbCBmb3I9JzwlPSBtZXRhLm5hbWUgJT4nPjwlPSBtZXRhLmxhYmVsICU+PC9sYWJlbD5cXHJcXG4gIDwlIGlmIChtZXRhLmhlbHApIHsgJT48c21hbGwgY2xhc3M9J2RlZW1waGFzaXplJz48JT0gbWV0YS5oZWxwICU+PC9zbWFsbD48JSB9ICU+XFxyXFxuICA8ZmllbGRzZXQ+XFxyXFxuICAgIDxidXR0b24gY2xhc3M9J21ldGFmaWVsZCByb3VuZCA8JT0gbWV0YS5uYW1lICU+JyB0eXBlPSdidXR0b24nIG5hbWU9JzwlPSBtZXRhLm5hbWUgJT4nIHZhbHVlPSc8JT0gbWV0YS52YWx1ZSAlPicgZGF0YS1vbj0nPCU9IG1ldGEub24gJT4nIGRhdGEtb2ZmPSc8JT0gbWV0YS5vZmYgJT4nPlxcclxcbiAgICAgIDwlIHByaW50KHZhbHVlID8gbWV0YS5vbiA6IG1ldGEub2ZmKTsgJT5cXHJcXG4gICAgPC9idXR0b24+XFxyXFxuICA8L2ZpZWxkc2V0PlxcclxcbjwvZGl2PlxcclxcblwiLFwiY2hlY2tib3hcIjpcIjxkaXYgY2xhc3M9J2Zvcm0taXRlbSc+XFxyXFxuICA8ZmllbGRzZXQ+XFxyXFxuICAgIDxpbnB1dCBjbGFzcz0nbWV0YWZpZWxkJyB0eXBlPSdjaGVja2JveCcgbmFtZT0nPCU9IG1ldGEubmFtZSAlPicgdmFsdWU9JzwlPSBtZXRhLnZhbHVlICU+JzwlIHByaW50KG1ldGEuY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnKSAlPiAvPlxcclxcbiAgICA8bGFiZWwgY2xhc3M9J2FzaWRlJyBmb3I9JzwlPSBtZXRhLm5hbWUgJT4nPjwlPSBtZXRhLmxhYmVsICU+PC9sYWJlbD5cXHJcXG4gIDwvZmllbGRzZXQ+XFxyXFxuICA8JSBpZiAobWV0YS5oZWxwKSB7ICU+PHNtYWxsIGNsYXNzPSdkZWVtcGhhc2l6ZSc+PCU9IG1ldGEuaGVscCAlPjwvc21hbGw+PCUgfSAlPlxcclxcbjwvZGl2PlxcclxcblwiLFwibXVsdGlzZWxlY3RcIjpcIjxkaXYgY2xhc3M9J2Zvcm0taXRlbSc+XFxyXFxuICA8bGFiZWwgZm9yPSc8JT0gbWV0YS5uYW1lICU+Jz48JT0gbWV0YS5sYWJlbCAlPjwvbGFiZWw+XFxyXFxuICA8JSBpZiAobWV0YS5oZWxwKSB7ICU+PHNtYWxsIGNsYXNzPSdkZWVtcGhhc2l6ZSc+PCU9IG1ldGEuaGVscCAlPjwvc21hbGw+PCUgfSAlPlxcclxcblxcclxcbiAgPGZpZWxkc2V0PlxcclxcbiAgICA8c2VsZWN0IGlkPSc8JT0gbWV0YS5uYW1lICU+JyBuYW1lPSc8JT0gbWV0YS5uYW1lICU+JyBkYXRhLXBsYWNlaG9sZGVyPSc8JT0gbWV0YS5wbGFjZWhvbGRlciAlPicgbXVsdGlwbGUgY2xhc3M9J21ldGFmaWVsZCBjaHpuLXNlbGVjdCc+XFxyXFxuICAgICAgPCUgXyhtZXRhLm9wdGlvbnMpLmVhY2goZnVuY3Rpb24obykgeyAlPlxcclxcbiAgICAgICAgPCUgaWYgKCFvLmxhbmcgfHwgby5sYW5nID09PSBtZXRhLmxhbmcpIHsgJT5cXHJcXG4gICAgICAgICAgPCUgaWYgKG8ubmFtZSkgeyAlPlxcclxcbiAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nPCU9IG8udmFsdWUgJT4nPjwlPSBvLm5hbWUgJT48L29wdGlvbj5cXHJcXG4gICAgICAgICAgPCUgfSBlbHNlIGlmIChvLnZhbHVlKSB7ICU+XFxyXFxuICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSc8JT0gby52YWx1ZSAlPic+PCU9IG8udmFsdWUgJT48L29wdGlvbj5cXHJcXG4gICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXHJcXG4gICAgICAgICAgIDxvcHRpb24gdmFsdWU9JzwlPSBvICU+Jz48JT0gbyAlPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICA8JSB9ICU+XFxyXFxuICAgICAgICA8JSB9ICU+XFxyXFxuICAgICAgPCUgfSk7ICU+XFxyXFxuICAgIDwvc2VsZWN0PlxcclxcbiAgPC9maWVsZHNldD5cXHJcXG5cXHJcXG4gIDwlIGlmIChtZXRhLmFsdGVyYWJsZSkgeyAlPlxcclxcbiAgICA8ZGl2IGNsYXNzPSdjcmVhdGUnPlxcclxcbiAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzcz0naW5saW5lJyBkYXRhLXNlbGVjdD0nPCU9IG1ldGEubmFtZSAlPicgLz5cXHJcXG4gICAgICA8YSBocmVmPScjJyBjbGFzcz0ncm91bmQgY3JlYXRlLXNlbGVjdCBpbmxpbmUgYnV0dG9uJyBkYXRhLXNlbGVjdD0nPCU9IG1ldGEubmFtZSAlPicgdGl0bGU9XFxcIjwlPSB0KCdtYWluLmZpbGUuY3JlYXRlTWV0YScpICU+XFxcIj48JT0gdCgnbWFpbi5maWxlLmNyZWF0ZU1ldGEnKSAlPjwvYT5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8JSB9ICU+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJyYXdcIjpcIjxkaXYgY2xhc3M9J2Zvcm0taXRlbSc+XFxyXFxuICA8bGFiZWwgZm9yPSdyYXcnPjwlPSB0KCdtYWluLmZpbGUucmF3TWV0YScpICU+PC9sYWJlbD5cXHJcXG4gIDwlIGlmIChtZXRhLmhlbHApIHsgJT48c21hbGw+PCU9IG1ldGEuaGVscCAlPjwvc21hbGw+PCUgfSAlPlxcclxcbiAgPGZpZWxkc2V0PlxcclxcbiAgICA8ZGl2IG5hbWU9J3JhdycgaWQ9J3JhdycgY2xhc3M9J21ldGFmaWVsZCBpbm5lcic+PC9kaXY+XFxyXFxuICA8L2ZpZWxkc2V0PlxcclxcbjwvZGl2PlxcclxcblwiLFwic2VsZWN0XCI6XCI8ZGl2IGNsYXNzPSdmb3JtLWl0ZW0nPlxcclxcbiAgPGxhYmVsIGZvcj0nPCU9IG1ldGEubmFtZSAlPic+PCU9IG1ldGEubGFiZWwgJT48L2xhYmVsPlxcclxcbiAgPCUgaWYgKG1ldGEuaGVscCkgeyAlPjxzbWFsbCBjbGFzcz0nZGVlbXBoYXNpemUnPjwlPSBtZXRhLmhlbHAgJT48L3NtYWxsPjwlIH0gJT5cXHJcXG5cXHJcXG4gIDxmaWVsZHNldD5cXHJcXG4gICAgPHNlbGVjdCBuYW1lPSc8JT0gbWV0YS5uYW1lICU+JyBkYXRhLXBsYWNlaG9sZGVyPSc8JT0gbWV0YS5wbGFjZWhvbGRlciAlPicgY2xhc3M9J21ldGFmaWVsZCBjaHpuLXNlbGVjdCc+XFxyXFxuICAgICAgPCUgXyhtZXRhLm9wdGlvbnMpLmVhY2goZnVuY3Rpb24obykgeyAlPlxcclxcbiAgICAgICAgPCUgaWYgKCFvLmxhbmcgfHwgby5sYW5nID09PSBtZXRhLmxhbmcpIHsgJT5cXHJcXG4gICAgICAgICAgPCUgaWYgKG8ubmFtZSkgeyAlPlxcclxcbiAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nPCU9IG8udmFsdWUgJT4nPjwlPSBvLm5hbWUgJT48L29wdGlvbj5cXHJcXG4gICAgICAgICAgPCUgfSBlbHNlIGlmIChvLnZhbHVlKSB7ICU+XFxyXFxuICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSc8JT0gby52YWx1ZSAlPic+PCU9IG8udmFsdWUgJT48L29wdGlvbj5cXHJcXG4gICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXHJcXG4gICAgICAgICAgIDxvcHRpb24gdmFsdWU9JzwlPSBvICU+Jz48JT0gbyAlPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICA8JSB9ICU+XFxyXFxuICAgICAgICA8JSB9ICU+XFxyXFxuICAgICAgPCUgfSk7ICU+XFxyXFxuICAgIDwvc2VsZWN0PlxcclxcbiAgPC9maWVsZHNldD5cXHJcXG48L2Rpdj5cXHJcXG5cIixcInRleHRcIjpcIjxkaXYgY2xhc3M9J2Zvcm0taXRlbSc+XFxyXFxuICA8bGFiZWwgZm9yPSc8JT0gbWV0YS5uYW1lICU+Jz48JT0gbWV0YS5sYWJlbCAlPjwvbGFiZWw+XFxyXFxuICA8JSBpZiAobWV0YS5oZWxwKSB7ICU+PHNtYWxsIGNsYXNzPSdkZWVtcGhhc2l6ZSc+PCU9IG1ldGEuaGVscCAlPjwvc21hbGw+PCUgfSAlPlxcclxcbiAgPGZpZWxkc2V0PlxcclxcbiAgICA8aW5wdXQgY2xhc3M9J21ldGFmaWVsZCcgdHlwZT0ndGV4dCcgbmFtZT0nPCU9IG1ldGEubmFtZSAlPicgdmFsdWU9JzwlPSBtZXRhLnZhbHVlICU+JyBkYXRhLXR5cGU9JzwlPSBtZXRhLnR5cGUgJT4nIHBsYWNlaG9sZGVyPSc8JT0gbWV0YS5wbGFjZWhvbGRlciAlPicgLz5cXHJcXG4gIDwvZmllbGRzZXQ+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJ0ZXh0YXJlYVwiOlwiPGRpdiBjbGFzcz0nZm9ybS1pdGVtIHlhbWwtYmxvY2snPlxcclxcbiAgPGxhYmVsIGZvcj0nPCU9IG1ldGEubmFtZSAlPic+PCU9IG1ldGEubGFiZWwgJT48L2xhYmVsPlxcclxcbiAgPCUgaWYgKG1ldGEuaGVscCkgeyAlPjxzbWFsbCBjbGFzcz0nZGVlbXBoYXNpemUnPjwlPSBtZXRhLmhlbHAgJT48L3NtYWxsPjwlIH0gJT5cXHJcXG4gIDxmaWVsZHNldD5cXHJcXG4gICAgPHRleHRhcmVhIGNsYXNzPSdtZXRhZmllbGQnIGlkPSc8JT0gbWV0YS5pZCAlPicgdHlwZT0ndGV4dCcgbmFtZT0nPCU9IG1ldGEubmFtZSAlPicgZGF0YS10eXBlPSc8JT0gbWV0YS50eXBlICU+JyBwbGFjZWhvbGRlcj0nPCU9IG1ldGEucGxhY2Vob2xkZXIgJT4nPjwlPSBtZXRhLnZhbHVlICU+PC90ZXh0YXJlYT5cXHJcXG4gIDwvZmllbGRzZXQ+XFxyXFxuPC9kaXY+XFxyXFxuXCJ9LFwibWV0YWRhdGFcIjpcIjxkaXYgY2xhc3M9J2Zvcm0nPjwvZGl2PlxcclxcbjxhIGhyZWY9JyMnIGNsYXNzPSdidXR0b24gcm91bmQgZmluaXNoJz48JT0gdCgnbWFpbi5maWxlLmJhY2snKSAlPjwvYT5cXHJcXG5cIixcIm1vZGFsXCI6XCI8ZGl2IGNsYXNzPSdtb2RhbC1jb250ZW50IHJvdW5kJz5cXHJcXG4gIDxkaXYgY2xhc3M9J21vZGFsLWhlYWRpbmcgaW5uZXInPlxcclxcbiAgICA8JT0gdCgnbW9kYWwuZXJyb3JIZWFkaW5nJykgJT5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz0ncHJvc2UgaW5uZXInPlxcclxcbiAgICA8cD48JT0gbW9kYWwubWVzc2FnZSAlPjwvcD5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyIGlubmVyJz5cXHJcXG4gICAgPGEgaHJlZj0nIycgY2xhc3M9J2J1dHRvbiByb3VuZCBnb3QtaXQnPjwlPSB0KCdtb2RhbC5jb25maXJtJykgJT48L2E+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIixcIm5hdlwiOlwiPHVsIGNsYXNzPSdtb2JpbGUgbmF2IGNsZWFyZml4Jz5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgaHJlZj0nIycgY2xhc3M9J3RvZ2dsZSBpY28gbWVudSByb3VuZCc+PC9hPlxcclxcbiAgPC9saT5cXHJcXG48L3VsPlxcclxcblxcclxcbjx1bCBjbGFzcz0nZmlsZSBuYXYgY2xlYXJmaXgnPlxcclxcbiAgPGxpPlxcclxcbiAgICA8YSBocmVmPScjJyB0aXRsZT1cXFwiPCU9IHQoJ25hdmlnYXRpb24uZWRpdCcpICU+XFxcIiBjbGFzcz0naWNvIHJvdW5kIHBlbmNpbCBlZGl0JyBkYXRhLXN0YXRlPSdlZGl0Jz5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz0ncG9wdXAgcm91bmQgYXJyb3ctcmlnaHQnPjwlPSB0KCduYXZpZ2F0aW9uLmVkaXQnKSAlPjwvc3Bhbj5cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9saT5cXHJcXG5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCduYXZpZ2F0aW9uLnByZXZpZXcnKSAlPlxcXCIgY2xhc3M9J2ljbyByb3VuZCBleWUgYmxvYiBwcmV2aWV3JyBkYXRhLXN0YXRlPSdibG9iJz5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz0ncG9wdXAgcm91bmQgYXJyb3ctcmlnaHQnPjwlPSB0KCduYXZpZ2F0aW9uLnByZXZpZXcnKSAlPjwvc3Bhbj5cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9saT5cXHJcXG5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCduYXZpZ2F0aW9uLm1ldGEnKSAlPlxcXCIgY2xhc3M9J2ljbyByb3VuZCBtZXRhZGF0YSBtZXRhJyBkYXRhLXN0YXRlPSdtZXRhJz5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz0ncG9wdXAgcm91bmQgYXJyb3ctcmlnaHQnPjwlPSB0KCduYXZpZ2F0aW9uLm1ldGEnKSAlPjwvc3Bhbj5cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9saT5cXHJcXG5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCduYXZpZ2F0aW9uLnNldHRpbmdzJykgJT5cXFwiIGNsYXNzPSdpY28gcm91bmQgc3Byb2NrZXQgc2V0dGluZ3MnIGRhdGEtc3RhdGU9J3NldHRpbmdzJyBkYXRhLWRyYXdlcj10cnVlPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPSdwb3B1cCByb3VuZCBhcnJvdy1yaWdodCc+PCU9IHQoJ25hdmlnYXRpb24uc2V0dGluZ3MnKSAlPjwvc3Bhbj5cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9saT5cXHJcXG5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCduYXZpZ2F0aW9uLnNhdmUnKSAlPlxcXCIgY2xhc3M9J2ljbyByb3VuZCBzYXZlJyBkYXRhLXN0YXRlPSdzYXZlJz5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPSdzdGF0dXMnPjwvZGl2PlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPSdwb3B1cCByb3VuZCBhcnJvdy1yaWdodCc+XFxyXFxuICAgICAgICA8JT0gdCgnbmF2aWdhdGlvbi5zYXZlJykgJT5cXHJcXG4gICAgICA8L3NwYW4+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwvbGk+XFxyXFxuPC91bD5cXHJcXG5cXHJcXG48dWwgY2xhc3M9J2F1dGggbmF2IGNsZWFyZml4Jz5cXHJcXG4gIDxsaT5cXHJcXG4gICAgPGEgY2xhc3M9J2ljbyByb3VuZCBzd2l0Y2ggbG9naW4nIGhyZWY9JzwlPSBkYXRhLmxvZ2luICU+JyB0aXRsZT1cXFwiPCU9IHQoJ2xvZ2luJykgJT5cXFwiPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPSdwb3B1cCByb3VuZCBhcnJvdy1yaWdodCc+PCU9IHQoJ2xvZ2luJykgJT48L3NwYW4+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwvbGk+XFxyXFxuPC91bD5cXHJcXG5cIixcIm5vdGlmaWNhdGlvblwiOlwiPGRpdiBjbGFzcz0nbm90aWZ5Jz5cXHJcXG4gIDxoMiBjbGFzcz0naWNvbiBsYW5kaW5nIGVycm9yJz5Qcm9zZTwvaDI+XFxyXFxuICA8ZGl2IGNsYXNzPSdpbm5lcic+XFxyXFxuICAgIDxwPjwlPSBkYXRhLm1lc3NhZ2UgJT48L3A+XFxyXFxuICAgIDxwIGNsYXNzPSdlcnJvcic+PCU9IGRhdGEuZXJyb3IgJT48L3A+XFxyXFxuXFxyXFxuICAgIDwlIF8oZGF0YS5vcHRpb25zKS5lYWNoKGZ1bmN0aW9uKG9wdGlvbnMpIHsgJT5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICA8YSBjbGFzcz0nYnV0dG9uIHJvdW5kIDwlIGlmKG9wdGlvbnMuY2xhc3NOYW1lKSB7ICU+PCU9IG9wdGlvbnMuY2xhc3NOYW1lICU+PCUgfSAlPicgaHJlZj0nPCU9IG9wdGlvbnMubGluayAlPic+PCU9IG9wdGlvbnMudGl0bGUgJT48L2E+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8JSB9KTsgJT5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiLFwicHJvZmlsZVwiOlwiPGhlYWRlciBpZD0naGVhZGluZycgY2xhc3M9J2hlYWRpbmcgbGltaXRlciBjbGVhcmZpeCc+PC9oZWFkZXI+XFxyXFxuXFxyXFxuPGRpdiBpZD0nY29udGVudCcgY2xhc3M9J2FwcGxpY2F0aW9uIGNvbnRlbnQgbGltaXRlcic+XFxyXFxuICA8ZGl2IGNsYXNzPSd0b3BiYXInPlxcclxcbiAgICA8ZGl2IGlkPSdzZWFyY2gnIGNsYXNzPSdjb250ZW50LXNlYXJjaCByb3VuZCc+PC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDx1bCBpZD0ncmVwb3MnIGNsYXNzPSdwcm9qZWN0cyBsaXN0aW5nJz48L3VsPlxcclxcbjwvZGl2PlxcclxcblwiLFwicmVwb1wiOlwiPGhlYWRlciBpZD0naGVhZGluZycgY2xhc3M9J2hlYWRpbmcgbGltaXRlciBjbGVhcmZpeCc+PC9oZWFkZXI+XFxyXFxuXFxyXFxuPGRpdiBpZD0nY29udGVudCcgY2xhc3M9J2FwcGxpY2F0aW9uIGNvbnRlbnQgbGltaXRlcic+XFxyXFxuICA8ZGl2IGNsYXNzPSd0b3BiYXIgY2xlYXJmaXgnPlxcclxcbiAgICA8IS0tIGlmIHJlcG8gYW5kIGF1dGhlbnRpY2F0ZWQgLS0+XFxyXFxuICAgIDwhLS0gI3VzZXIvcmVwby9uZXcvYnJhbmNoL3BhdGggLS0+XFxyXFxuICAgIDxkaXYgaWQ9J3NlYXJjaCcgY2xhc3M9J2ZsIGNvbnRlbnQtc2VhcmNoIHJvdW5kJz48L2Rpdj5cXHJcXG4gICAgPGEgaHJlZj0nIycgY2xhc3M9J2ZsIGJ1dHRvbiByb3VuZCBuZXcgbmV3LWZpbGUnIGRhdGEtc3RhdGU9J25ldyc+XFxyXFxuICAgICAgPCU9IHQoJ25hdmlnYXRpb24ubmV3RmlsZScpICU+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwvZGl2PlxcclxcblxcclxcbiAgPGRpdiBpZD0nZmlsZXMnPjwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiLFwic2VhcmNoXCI6XCI8c3BhbiBjbGFzcz0naWNvIHNlYXJjaCc+PC9zcGFuPlxcclxcbjxpbnB1dCB0eXBlPSd0ZXh0JyBpZD0nZmlsdGVyJyBwbGFjZWhvbGRlcj1cXFwiPCU9IHNlYXJjaC5wbGFjZWhvbGRlciAlPlxcXCIgLz5cXHJcXG5cIixcInNpZGViYXJcIjp7XCJicmFuY2hlc1wiOlwiPGRpdiBjbGFzcz0naW5uZXInPlxcclxcbiAgPGgyIGNsYXNzPSdsYWJlbCc+PCU9IHQoJ3NpZGViYXIucmVwby5icmFuY2gnKSAlPjwvaDI+XFxyXFxuICA8c2VsZWN0IGNsYXNzPSdjaHpuLXNlbGVjdCc+PC9zZWxlY3Q+XFxyXFxuPC9kaXY+XFxyXFxuXCIsXCJkcmFmdHNcIjpcIjxhIGNsYXNzPSdidXR0b24gcm91bmQnIGhyZWY9JyM8JT0gbGluayAlPic+PCU9IHQoJ3NpZGViYXIucmVwby5kcmFmdHMnKSAlPjwvYT5cXHJcXG5cIixcImxhYmVsXCI6XCI8ZGl2IGNsYXNzPSdpbm5lcic+XFxyXFxuICA8aDIgY2xhc3M9J2xhYmVsIGlubmVyJz48JT0gbGFiZWwgJT48L2gyPlxcclxcbjwvZGl2PlxcclxcblwiLFwibGlcIjp7XCJjb21taXRcIjpcIjxhIGNsYXNzPSc8JT0gZGF0YS5zdGF0dXMgJT4nIGhyZWY9JyM8JT0gW2RhdGEucmVwby5vd25lci5sb2dpbiwgZGF0YS5yZXBvLm5hbWUsIGRhdGEubW9kZSwgZGF0YS5icmFuY2gsIGRhdGEucGF0aF0uam9pbihcXFwiL1xcXCIpICU+Jz5cXHJcXG4gIDxzcGFuIGNsYXNzPSdpY28gc21hbGwgaW5saW5lIDwlPSBkYXRhLnN0YXR1cyAlPic+PC9zcGFuPlxcclxcbiAgPHNwYW4gY2xhc3M9J21lc3NhZ2UnPjwlPSBkYXRhLmZpbGUuZmlsZW5hbWUgJT48L3NwYW4+XFxyXFxuPC9hPlxcclxcblwifSxcIm9yZ3NcIjpcIjxkaXYgY2xhc3M9J2lubmVyJz5cXHJcXG4gIDxoMiBjbGFzcz0nbGFiZWwnPjwlPSB0KCdzaWRlYmFyLnJlcG9zLmdyb3VwcycpICU+PC9oMj5cXHJcXG48L2Rpdj5cXHJcXG48dWwgY2xhc3M9J2xpc3RpbmcnPlxcclxcbiAgPGxpPlxcclxcbiAgICA8YSBocmVmPScjPCU9IG9yZ3MubG9naW4udXNlciAlPicgdGl0bGU9JzwlPSBvcmdzLmxvZ2luLnVzZXIgJT4nIGRhdGEtaWQ9JzwlPSBvcmdzLmxvZ2luLmlkICU+Jz5cXHJcXG4gICAgICA8JT0gb3Jncy5sb2dpbi51c2VyICU+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwvbGk+XFxyXFxuICA8JSBvcmdzLm9yZ3MuZWFjaChmdW5jdGlvbihvcmcpIHsgICU+XFxyXFxuICA8bGk+XFxyXFxuICAgIDxhIGhyZWY9JyM8JT0gb3JnLmxvZ2luICU+JyB0aXRsZT0nPCU9IG9yZy5sb2dpbiAlPicgZGF0YS1pZD0nPCU9IG9yZy5pZCAlPic+XFxyXFxuICAgICAgPCU9IG9yZy5sb2dpbiAlPlxcclxcbiAgICA8L2E+XFxyXFxuICA8L2xpPlxcclxcbiAgPCUgfSk7wqAlPlxcclxcbjwvdWw+XFxyXFxuXCIsXCJzYXZlXCI6XCI8ZGl2IGNsYXNzPSdpbm5lcic+XFxyXFxuICA8aDIgY2xhc3M9J2xhYmVsJz48JT0gdCgnc2lkZWJhci5zYXZlLmxhYmVsJykgJT48L2gyPlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9J2lubmVyIGF1dGhvcmluZyc+XFxyXFxuICA8ZGl2IGNsYXNzPSdjb21taXQnPlxcclxcbiAgICA8dGV4dGFyZWEgY2xhc3M9J2NvbW1pdC1tZXNzYWdlJyBwbGFjZWhvbGRlcj48L3RleHRhcmVhPlxcclxcbiAgICA8YSBjbGFzcz0naWNvIHNtYWxsIGNhbmNlbCByb3VuZCcgdGl0bGU9XFxcIjwlPSB0KCdzaWRlYmFyLnNhdmUuY2FuY2VsJykgJT5cXFwiIGhyZWY9JyMnIGRhdGEtYWN0aW9uPSdjYW5jZWwnPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPSdwb3B1cCByb3VuZCBhcnJvdy1ib3R0b20nPjwlPSB0KCdzaWRlYmFyLnNhdmUuY2FuY2VsJykgJT48L3NwYW4+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGEgY2xhc3M9J2NvbmZpcm0gYnV0dG9uIHJvdW5kJyBocmVmPScjJyBkYXRhLWFjdGlvbj0nY29uZmlybSc+PCU9IHdyaXRhYmxlICU+PC9hPlxcclxcbjwvZGl2PlxcclxcblwiLFwic2V0dGluZ3NcIjpcIjxkaXYgY2xhc3M9J2lubmVyJz5cXHJcXG4gIDxoMiBjbGFzcz0nbGFiZWwnPjwlPSB0KCdzaWRlYmFyLnNldHRpbmdzLnRpdGxlJykgJT48L2gyPlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9J2lubmVyIGF1dGhvcmluZyc+XFxyXFxuICA8JSBpZiAoL15fcG9zdHMvLnRlc3Qoc2V0dGluZ3MucGF0aCkpIHsgJT5cXHJcXG4gICAgPGEgY2xhc3M9J2RyYWZ0IGJ1dHRvbiByb3VuZCcgaHJlZj0nIycgZGF0YS1hY3Rpb249J2RyYWZ0Jz48JT0gdCgnc2lkZWJhci5zZXR0aW5ncy5kcmFmdCcpICU+PC9hPlxcclxcbiAgPCUgfSAlPlxcclxcbiAgXFxyXFxuICA8JSBpZiAoc2V0dGluZ3MubGFuZ3VhZ2VzICYmIHNldHRpbmdzLmxhbmcgIT09ICd5YW1sJykgeyAlPlxcclxcbiAgICA8JSBfLmVhY2goc2V0dGluZ3MubGFuZ3VhZ2VzLCBmdW5jdGlvbihsKSB7ICU+XFxyXFxuICAgICAgPCUgaWYgKGwudmFsdWUgJiYgKHNldHRpbmdzLm1ldGFkYXRhICYmIChzZXR0aW5ncy5tZXRhZGF0YS5sYW5nICE9PSBsLnZhbHVlKSkpIHsgJT5cXHJcXG4gICAgICAgIDxhIGNsYXNzPSd0cmFuc2xhdGUgcm91bmQgYnV0dG9uJyBocmVmPScjPCU9IGwudmFsdWUgJT4nIGRhdGEtYWN0aW9uPSd0cmFuc2xhdGUnPjwlPSB0KCdzaWRlYmFyLnNldHRpbmdzLnRyYW5zbGF0ZScpICsgJyAnICsgbC5uYW1lICU+PC9hPlxcclxcbiAgICAgIDwlIH0gJT5cXHJcXG4gICAgPCUgfSk7ICU+XFxyXFxuICA8JSB9ICU+XFxyXFxuXFxyXFxuICA8IS0tIGlmICFpc05ldygpIGFuZCBpcyB3cml0YWJsZSAtLT5cXHJcXG4gIDxhIGNsYXNzPSdkZWxldGUgYnV0dG9uIHJvdW5kJyBocmVmPScjJyBkYXRhLWFjdGlvbj0nZGVzdHJveSc+PCU9IHQoJ3NpZGViYXIuc2V0dGluZ3MuZGVsZXRlJykgJT48L2E+XFxyXFxuPC9kaXY+XFxyXFxuXFxyXFxuPCUgaWYgKHNldHRpbmdzLmZpbGVJbnB1dCkgeyAlPlxcclxcbiAgPGRpdiBjbGFzcz0naW5uZXInPlxcclxcbiAgICA8aDIgY2xhc3M9J2xhYmVsJz48JT0gdCgnc2lkZWJhci5zZXR0aW5ncy5maWxlSW5wdXRMYWJlbCcpICU+PC9oMj5cXHJcXG4gICAgPGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdmaWxlcGF0aCcgcGxhY2Vob2xkZXI9JzwlPSBzZXR0aW5ncy5wYXRoICU+JyB2YWx1ZT0nPCU9IHNldHRpbmdzLnBhdGggJT4nPlxcclxcbiAgPC9kaXY+XFxyXFxuPCUgfSAlPlxcclxcblwifSxcInN0YXJ0XCI6XCI8ZGl2IGNsYXNzPSdyb3VuZCBzcGxhc2gnPlxcclxcbiAgPGgyIGNsYXNzPSdpY29uIGxhbmRpbmcnPlByb3NlPC9oMj5cXHJcXG4gIDxkaXYgY2xhc3M9J2lubmVyJz5cXHJcXG4gICAgPHA+PCU9IHQoJ21haW4uc3RhcnQuY29udGVudCcpICU+PC9wPlxcclxcbiAgICA8cD48YSBocmVmPScjYWJvdXQnPjwlPSB0KCdtYWluLnN0YXJ0LmxlYXJuJykgJT48L2E+PC9wPlxcclxcbiAgICA8YSBjbGFzcz0ncm91bmQgYnV0dG9uJyBocmVmPSc8JT0gYXV0aC5zaXRlICU+L2xvZ2luL29hdXRoL2F1dGhvcml6ZT9jbGllbnRfaWQ9PCU9IGF1dGguaWQgJT4mc2NvcGU9cmVwbyc+PCU9IHQoJ2xvZ2luJykgJT48L2E+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIixcInRvb2xiYXJcIjpcIjwlIGlmICh0b29sYmFyLmRyYWZ0KSB7ICU+XFxyXFxuICA8YSBocmVmPScjJyBjbGFzcz0nZHJhZnQtdG8tcG9zdCByb3VuZCBjb250YWluJz5cXHJcXG4gICAgPCU9IHQoJ2FjdGlvbnMuZHJhZnQudG9Qb3N0JykgJT48c3BhbiBjbGFzcz0naWNvIHNtYWxsIGNoZWNrbWFyayc+PC9zcGFuPlxcclxcbiAgICA8c3BhbiBjbGFzcz0ncG9wdXAgcm91bmQgYXJyb3ctdG9wJz48JT0gdCgnYWN0aW9ucy5kcmFmdC50b1Bvc3RJbmZvJykgJT48L3NwYW4+XFxyXFxuICA8L2E+XFxyXFxuPCUgfSBlbHNlIHsgJT5cXHJcXG4gIDwlIGlmICh0b29sYmFyLm1ldGFkYXRhICYmIHRvb2xiYXIubWV0YWRhdGEucHVibGlzaGVkKSB7ICU+XFxyXFxuICAgIDxhIGhyZWY9JyMnIGNsYXNzPSdwdWJsaXNoLWZsYWcgcHVibGlzaGVkIHJvdW5kIGNvbnRhaW4nIGRhdGEtc3RhdGU9J3RydWUnPlxcclxcbiAgICAgIDwlPSB0KCdhY3Rpb25zLnB1Ymxpc2hpbmcucHVibGlzaGVkJykgJT48c3BhbiBjbGFzcz0naWNvIHNtYWxsIGNoZWNrbWFyayc+PC9zcGFuPlxcclxcbiAgICA8L2E+XFxyXFxuICA8JSB9IGVsc2UgaWYgKHRvb2xiYXIubWV0YWRhdGEgJiYgIXRvb2xiYXIubWV0YWRhdGEucHVibGlzaGVkKSB7ICU+XFxyXFxuICAgIDxhIGhyZWY9JyMnIGNsYXNzPSdwdWJsaXNoLWZsYWcgcm91bmQgY29udGFpbicgZGF0YS1zdGF0ZT0nZmFsc2UnPlxcclxcbiAgICAgIDwlPSB0KCdhY3Rpb25zLnB1Ymxpc2hpbmcudW5wdWJsaXNoZWQnKSAlPjxzcGFuIGNsYXNzPSdpY28gc21hbGwgY2hlY2ttYXJrJz48L3NwYW4+XFxyXFxuICAgIDwvYT5cXHJcXG4gIDwlIH0gJT5cXHJcXG48JSB9ICU+XFxyXFxuXFxyXFxuPCUgaWYgKHRvb2xiYXIubWFya2Rvd24pIHsgJT5cXHJcXG48ZGl2IGNsYXNzPSdvcHRpb25zIGNsZWFyZml4Jz5cXHJcXG4gIDx1bCBjbGFzcz0nZ3JvdXAgcm91bmQgY2xlYXJmaXgnPlxcclxcbiAgICA8bGk+PGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCd0b29sYmFyLmhlYWRpbmcnKSAlPlxcXCIgZGF0YS1rZXk9J2hlYWRpbmcnIGRhdGEtc25pcHBldD0nPCUgcHJpbnQoXFxcIiMjXFxcXG5cXFxcblxcXCIpICU+Jz5oMjwvYT48L2xpPlxcclxcbiAgICA8bGk+PGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCd0b29sYmFyLnN1YkhlYWRpbmcnKSAlPlxcXCIgZGF0YS1rZXk9J3N1Yi1oZWFkaW5nJyBkYXRhLXNuaXBwZXQ9JzwlIHByaW50KFxcXCIjIyNcXFxcblxcXFxuXFxcIikgJT4nPmgzPC9hPjwvbGk+XFxyXFxuICA8L3VsPlxcclxcbiAgPHVsIGNsYXNzPSdncm91cCByb3VuZCBjbGVhcmZpeCc+XFxyXFxuICAgIDxsaT5cXHJcXG4gICAgICA8YSB0aXRsZT1cXFwiPCU9IHQoJ3Rvb2xiYXIubGluaycpICU+XFxcIiBocmVmPScjJyBkYXRhLWtleT0nbGluaycgZGF0YS1zbmlwcGV0PWZhbHNlIGRhdGEtZGlhbG9nPXRydWU+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz0naWNvIHNtYWxsIGxpbmsnPjwvc3Bhbj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgIDwvbGk+XFxyXFxuICAgIDxsaT5cXHJcXG4gICAgICA8YSB0aXRsZT1cXFwiPCU9IHQoJ3Rvb2xiYXIuaW1hZ2UnKSAlPlxcXCIgaHJlZj0nIycgZGF0YS1rZXk9J21lZGlhJyBkYXRhLXNuaXBwZXQ9ZmFsc2UgZGF0YS1kaWFsb2c9dHJ1ZT5cXHJcXG4gICAgICAgIDxzcGFuIGNsYXNzPSdpY28gc21hbGwgcGljdHVyZSc+PC9zcGFuPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgPC9saT5cXHJcXG4gIDwvdWw+XFxyXFxuICA8dWwgY2xhc3M9J2dyb3VwIHJvdW5kIGNsZWFyZml4Jz5cXHJcXG4gICAgPGxpPjxhIGhyZWY9JyMnIHRpdGxlPVxcXCI8JT0gdCgndG9vbGJhci5ib2xkJykgJT5cXFwiIGRhdGEta2V5PSdib2xkJyBkYXRhLXNuaXBwZXQ9JyoqKionPkI8L2E+PC9saT5cXHJcXG4gICAgPGxpPlxcclxcbiAgICAgIDxhIGRhdGEta2V5PSdpdGFsaWMnIGhyZWY9JyMnIHRpdGxlPVxcXCI8JT0gdCgndG9vbGJhci5pdGFsaWMnKSAlPlxcXCIgZGF0YS1zbmlwcGV0PSdfXyc+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz0naWNvIHNtYWxsIGl0YWxpYyc+PC9zcGFuPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgPC9saT5cXHJcXG4gIDwvdWw+XFxyXFxuICA8dWwgY2xhc3M9J2dyb3VwIHJvdW5kIGNsZWFyZml4Jz5cXHJcXG4gICAgPGxpPlxcclxcbiAgICAgIDxhIHRpdGxlPVxcXCI8JT0gdCgndG9vbGJhci5ibG9ja3F1b3RlJykgJT5cXFwiICBocmVmPScjJyBkYXRhLWtleT0ncXVvdGUnIGRhdGEtc25pcHBldD0nPCUgcHJpbnQoXFxcIj4gV2UgbG92ZWQgd2l0aCBhIGxvdmUgdGhhdCB3YXMgbW9yZSB0aGFuIGxvdmVcXFxcblxcXFxuXFxcIik7ICU+Jz5cXHJcXG4gICAgICAgIDxzcGFuIGNsYXNzPSdpY28gc21hbGwgcXVvdGUnPjwvc3Bhbj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgIDwvbGk+XFxyXFxuICAgIDxsaT5cXHJcXG4gICAgICA8YSBocmVmPScjJyB0aXRsZT1cXFwiPCU9IHQoJ3Rvb2xiYXIubGlzdCcpICU+XFxcIiBkYXRhLWtleT0nbGlzdCcgZGF0YS1zbmlwcGV0PSc8JSBwcmludChcXFwiLSBpdGVtXFxcXG4tIGl0ZW1cXFxcbi0gaXRlbVxcXFxuXFxcXG5cXFwiKTsgJT4nPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9J2ljbyBzbWFsbCBsaXN0Jz48L3NwYW4+XFxyXFxuICAgICAgPC9hPlxcclxcbiAgICA8L2xpPlxcclxcbiAgICA8bGk+XFxyXFxuICAgICAgPGEgaHJlZj0nIycgdGl0bGU9XFxcIjwlPSB0KCd0b29sYmFyLm51bWJlcmVkbGlzdCcpICU+XFxcIiBkYXRhLWtleT0nbnVtYmVyZWQtbGlzdCcgZGF0YS1zbmlwcGV0PSc8JSBwcmludChcXFwiMS4gaXRlbVxcXFxuMi4gaXRlbVxcXFxuMy4gaXRlbVxcXFxuXFxcXG5cXFwiKTsgJT4nPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9J2ljbyBzbWFsbCBudW1iZXJlZC1saXN0Jz48L3NwYW4+XFxyXFxuICAgICAgPC9hPlxcclxcbiAgICA8L2xpPlxcclxcbiAgPC91bD5cXHJcXG4gIDx1bCBjbGFzcz0nZ3JvdXAgcm91bmQgY2xlYXJmaXgnPlxcclxcbiAgICA8bGk+XFxyXFxuICAgIDxhIGNsYXNzPSdyb3VuZCcgdGl0bGU9XFxcIjwlPSB0KCd0b29sYmFyLmhlbHAnKSAlPlxcXCIgaHJlZj0nIycgZGF0YS1rZXk9J2hlbHAnIGRhdGEtc25pcHBldD1mYWxzZSBkYXRhLWRpYWxvZz10cnVlPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9J2ljbyBzbWFsbCBxdWVzdGlvbic+PC9zcGFuPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgPC9saT5cXHJcXG4gIDwvdWw+XFxyXFxuPC9kaXY+XFxyXFxuPCUgfSAlPlxcclxcbjxkaXYgaWQ9J2RpYWxvZyc+PC9kaXY+XFxyXFxuXCJ9OyIsIihmdW5jdGlvbigpey8vICAgICBVbmRlcnNjb3JlLmpzIDEuNC40XG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgdmFyIGJyZWFrZXIgPSB7fTtcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlTWFwICAgICAgICAgID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlUmVkdWNlICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgbmF0aXZlUmVkdWNlUmlnaHQgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICBuYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlcixcbiAgICBuYXRpdmVFdmVyeSAgICAgICAgPSBBcnJheVByb3RvLmV2ZXJ5LFxuICAgIG5hdGl2ZVNvbWUgICAgICAgICA9IEFycmF5UHJvdG8uc29tZSxcbiAgICBuYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTGFzdEluZGV4T2YgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZixcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuNC40JztcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIG9iamVjdHMgd2l0aCB0aGUgYnVpbHQtaW4gYGZvckVhY2hgLCBhcnJheXMsIGFuZCByYXcgb2JqZWN0cy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS5cbiAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uaGFzKG9iaiwga2V5KSkge1xuICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlRXZlcnkgJiYgb2JqLmV2ZXJ5ID09PSBuYXRpdmVFdmVyeSkgcmV0dXJuIG9iai5ldmVyeShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICByZXR1cm4gYW55KG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzLCBmaXJzdCkge1xuICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyBudWxsIDogW107XG4gICAgcmV0dXJuIF9bZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10ob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSB2YWx1ZVtrZXldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLndoZXJlKG9iaiwgYXR0cnMsIHRydWUpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODA3OTdcbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5LCB2YWx1ZTogLUluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPj0gcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gSW5maW5pdHk7XG4gICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IEluZmluaXR5LCB2YWx1ZTogSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA8IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByYW5kO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNodWZmbGVkID0gW107XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oaW5kZXgrKyk7XG4gICAgICBzaHVmZmxlZFtpbmRleCAtIDFdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBsb29rdXAgaXRlcmF0b3JzLlxuICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihvYmopeyByZXR1cm4gb2JqW3ZhbHVlXTsgfTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHZhciBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgaW5kZXggOiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWEgOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCA8IHJpZ2h0LmluZGV4ID8gLTEgOiAxO1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQsIGJlaGF2aW9yKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKHZhbHVlIHx8IF8uaWRlbnRpdHkpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdyb3VwKG9iaiwgdmFsdWUsIGNvbnRleHQsIGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgICAgKF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBncm91cChvYmosIHZhbHVlLCBjb250ZXh0LCBmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgICAgaWYgKCFfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldID0gMDtcbiAgICAgIHJlc3VsdFtrZXldKys7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3IgPT0gbnVsbCA/IF8uaWRlbnRpdHkgOiBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gU2FmZWx5IGNvbnZlcnQgYW55dGhpbmcgaXRlcmFibGUgaW50byBhIHJlYWwsIGxpdmUgYXJyYXkuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIChuICE9IG51bGwpICYmICFndWFyZCA/IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pIDogYXJyYXlbMF07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gKChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAoKG4gIT0gbnVsbCkgJiYgIWd1YXJkKSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XG4gICAgZWFjaChpbnB1dCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvbXBsZXRlbHkgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRvcjtcbiAgICAgIGl0ZXJhdG9yID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSA6IGFycmF5O1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBlYWNoKGluaXRpYWwsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKGlzU29ydGVkID8gKCFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IHZhbHVlKSA6ICFfLmNvbnRhaW5zKHNlZW4sIHZhbHVlKSkge1xuICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICByZXN1bHRzLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoXy51bmlxKGFycmF5KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZihvdGhlciwgaXRlbSkgPj0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3MsICdsZW5ndGgnKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmdzLCBcIlwiICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBseSB1cyB3aXRoIGluZGV4T2YgKEknbSBsb29raW5nIGF0IHlvdSwgKipNU0lFKiopLFxuICAvLyB3ZSBuZWVkIHRoaXMgZnVuY3Rpb24uIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW5cbiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGwgKyBpc1NvcnRlZCkgOiBpc1NvcnRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSwgaXNTb3J0ZWQpO1xuICAgIGZvciAoOyBpIDwgbDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaGFzSW5kZXggPSBmcm9tICE9IG51bGw7XG4gICAgaWYgKG5hdGl2ZUxhc3RJbmRleE9mICYmIGFycmF5Lmxhc3RJbmRleE9mID09PSBuYXRpdmVMYXN0SW5kZXhPZikge1xuICAgICAgcmV0dXJuIGhhc0luZGV4ID8gYXJyYXkubGFzdEluZGV4T2YoaXRlbSwgZnJvbSkgOiBhcnJheS5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB9XG4gICAgdmFyIGkgPSAoaGFzSW5kZXggPyBmcm9tIDogYXJyYXkubGVuZ3RoKTtcbiAgICB3aGlsZSAoaS0tKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCAmJiBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhbGwgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0XG4gIC8vIGFsbCBjYWxsYmFja3MgZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkgZnVuY3MgPSBfLmZ1bmN0aW9ucyhvYmopO1xuICAgIGVhY2goZnVuY3MsIGZ1bmN0aW9uKGYpIHsgb2JqW2ZdID0gXy5iaW5kKG9ialtmXSwgb2JqKTsgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtbyA9IHt9O1xuICAgIGhhc2hlciB8fCAoaGFzaGVyID0gXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF8uaGFzKG1lbW8sIGtleSkgPyBtZW1vW2tleV0gOiAobWVtb1trZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgdGltZW91dCwgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9O1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtmdW5jXTtcbiAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIGlmICh0aW1lcyA8PSAwKSByZXR1cm4gZnVuYygpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gbmF0aXZlS2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgdmFsdWVzLnB1c2gob2JqW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBwYWlycy5wdXNoKFtrZXksIG9ialtrZXldXSk7XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmVzdWx0W29ialtrZXldXSA9IGtleTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBlYWNoKGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICghXy5jb250YWlucyhrZXlzLCBrZXkpKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAob2JqW3Byb3BdID09IG51bGwpIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgSGFybW9ueSBgZWdhbGAgcHJvcG9zYWw6IGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbC5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIHZhciBzaXplID0gMCwgcmVzdWx0ID0gdHJ1ZTtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIChhQ3RvciBpbnN0YW5jZW9mIGFDdG9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICBlc2NhcGU6IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAgICcvJzogJyYjeDJGOydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx0JzogICAgICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICAgIHZhciByZW5kZXI7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdOyB9KTtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHJldHVybiByZW5kZXIoZGF0YSwgXyk7XG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAoc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicpICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXyhvYmopLmNoYWluKCk7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIF8uZXh0ZW5kKF8ucHJvdG90eXBlLCB7XG5cbiAgICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gICAgY2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2hhaW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICAgIH1cblxuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkoKSIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcblxyXG52YXIgVXNlciA9IHJlcXVpcmUoJy4vbW9kZWxzL3VzZXInKTtcclxudmFyIFVzZXJzID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy91c2VycycpO1xyXG52YXIgT3JncyA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvb3JncycpO1xyXG5cclxudmFyIFJlcG8gPSByZXF1aXJlKCcuL21vZGVscy9yZXBvJyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi9tb2RlbHMvZmlsZScpO1xyXG5cclxudmFyIEFwcFZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2FwcCcpO1xyXG52YXIgTm90aWZpY2F0aW9uVmlldyA9IHJlcXVpcmUoJy4vdmlld3Mvbm90aWZpY2F0aW9uJyk7XHJcbnZhciBTdGFydFZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL3N0YXJ0Jyk7XHJcbnZhciBQcm9maWxlVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvcHJvZmlsZScpO1xyXG52YXIgU2VhcmNoVmlldyA9IHJlcXVpcmUoJy4vdmlld3Mvc2VhcmNoJyk7XHJcbnZhciBSZXBvc1ZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL3JlcG9zJyk7XHJcbnZhciBSZXBvVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvcmVwbycpO1xyXG52YXIgRmlsZVZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2ZpbGUnKTtcclxudmFyIERvY3VtZW50YXRpb25WaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9kb2N1bWVudGF0aW9uJyk7XHJcbnZhciBDaG9vc2VMYW5ndWFnZVZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2Nob29zZWxhbmd1YWdlJyk7XHJcblxyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuUm91dGVyLmV4dGVuZCh7XHJcblxyXG4gIHJvdXRlczoge1xyXG4gICAgJ2Fib3V0KC8pJzogJ2Fib3V0JyxcclxuICAgICdjaG9vc2VsYW5ndWFnZSgvKSc6ICdjaG9vc2VMYW5ndWFnZScsXHJcbiAgICAnOnVzZXIoLyknOiAncHJvZmlsZScsXHJcbiAgICAnOnVzZXIvOnJlcG8oLyknOiAncmVwbycsXHJcbiAgICAnOnVzZXIvOnJlcG8vKnBhdGgoLyknOiAncGF0aCcsXHJcbiAgICAnKmRlZmF1bHQnOiAnc3RhcnQnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgdGhpcy51c2VycyA9IG5ldyBVc2VycygpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnVzZXIpIHtcclxuICAgICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG4gICAgICB0aGlzLnVzZXJzLmFkZCh0aGlzLnVzZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvYWQgdXAgdGhlIG1haW4gbGF5b3V0XHJcbiAgICB0aGlzLmFwcCA9IG5ldyBBcHBWaWV3KHtcclxuICAgICAgZWw6ICcjcHJvc2UnLFxyXG4gICAgICBtb2RlbDoge30sXHJcbiAgICAgIHVzZXI6IHRoaXMudXNlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5hcHAucmVuZGVyKCk7XHJcbiAgfSxcclxuXHJcbiAgY2hvb3NlTGFuZ3VhZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMudmlldykgdGhpcy52aWV3LnJlbW92ZSgpO1xyXG5cclxuICAgIHRoaXMuYXBwLmxvYWRlci5zdGFydCh0KCdsb2FkaW5nLmZpbGUnKSk7XHJcbiAgICB0aGlzLmFwcC5uYXYubW9kZSgnJyk7XHJcblxyXG4gICAgdGhpcy52aWV3ID0gbmV3IENob29zZUxhbmd1YWdlVmlldygpO1xyXG4gICAgdGhpcy5hcHAuJGVsLmZpbmQoJyNtYWluJykuaHRtbCh0aGlzLnZpZXcucmVuZGVyKCkuZWwpO1xyXG5cclxuICAgIHRoaXMuYXBwLmxvYWRlci5kb25lKCk7XHJcbiAgfSxcclxuXHJcbiAgYWJvdXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMudmlldykgdGhpcy52aWV3LnJlbW92ZSgpO1xyXG5cclxuICAgIHRoaXMuYXBwLmxvYWRlci5zdGFydCh0KCdsb2FkaW5nLmZpbGUnKSk7XHJcbiAgICB0aGlzLmFwcC5uYXYubW9kZSgnJyk7XHJcblxyXG4gICAgdGhpcy52aWV3ID0gbmV3IERvY3VtZW50YXRpb25WaWV3KCk7XHJcbiAgICB0aGlzLmFwcC4kZWwuZmluZCgnI21haW4nKS5odG1sKHRoaXMudmlldy5yZW5kZXIoKS5lbCk7XHJcblxyXG4gICAgdGhpcy5hcHAubG9hZGVyLmRvbmUoKTtcclxuICB9LFxyXG5cclxuICAvLyAjZXhhbXBsZS11c2VyXHJcbiAgLy8gI2V4YW1wbGUtb3JnYW5pemF0aW9uXHJcbiAgcHJvZmlsZTogZnVuY3Rpb24obG9naW4pIHtcclxuICAgIGlmICh0aGlzLnZpZXcpIHRoaXMudmlldy5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQodCgnbG9hZGluZy5yZXBvcycpKTtcclxuICAgIHRoaXMuYXBwLm5hdi5tb2RlKCdyZXBvcycpO1xyXG5cclxuICAgIHV0aWwuZG9jdW1lbnRUaXRsZShsb2dpbik7XHJcblxyXG4gICAgdmFyIHVzZXIgPSB0aGlzLnVzZXJzLmZpbmRXaGVyZSh7IGxvZ2luOiBsb2dpbiB9KTtcclxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXIpKSB7XHJcbiAgICAgIHVzZXIgPSBuZXcgVXNlcih7IGxvZ2luOiBsb2dpbiB9KTtcclxuICAgICAgdGhpcy51c2Vycy5hZGQodXNlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlYXJjaCA9IG5ldyBTZWFyY2hWaWV3KHtcclxuICAgICAgbW9kZWw6IHVzZXIucmVwb3MsXHJcbiAgICAgIG1vZGU6ICdyZXBvcydcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciByZXBvcyA9IG5ldyBSZXBvc1ZpZXcoe1xyXG4gICAgICBtb2RlbDogdXNlci5yZXBvcyxcclxuICAgICAgc2VhcmNoOiBzZWFyY2hcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBjb250ZW50ID0gbmV3IFByb2ZpbGVWaWV3KHtcclxuICAgICAgYXV0aDogdGhpcy51c2VyLFxyXG4gICAgICBzZWFyY2g6IHNlYXJjaCxcclxuICAgICAgc2lkZWJhcjogdGhpcy5hcHAuc2lkZWJhcixcclxuICAgICAgcmVwb3M6IHJlcG9zLFxyXG4gICAgICByb3V0ZXI6IHRoaXMsXHJcbiAgICAgIHVzZXI6IHVzZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZXIuZmV0Y2goe1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5hcHAuJGVsLmZpbmQoJyNtYWluJykuaHRtbCh0aGlzLnZpZXcucmVuZGVyKCkuZWwpO1xyXG5cclxuICAgICAgICBtb2RlbC5yZXBvcy5mZXRjaCh7XHJcbiAgICAgICAgICBzdWNjZXNzOiByZXBvcy5yZW5kZXIsXHJcbiAgICAgICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcih4aHIpO1xyXG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgICAgIGNvbXBsZXRlOiB0aGlzLmFwcC5sb2FkZXIuZG9uZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVycm9yKHhocik7XHJcbiAgICAgIH0pLmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIC8vICNleGFtcGxlLXVzZXIvZXhhbXBsZS1yZXBvXHJcbiAgLy8gI2V4YW1wbGUtdXNlci9leGFtcGxlLXJlcG8vdHJlZS9leGFtcGxlLWJyYW5jaC9leGFtcGxlLXBhdGhcclxuICByZXBvOiBmdW5jdGlvbihsb2dpbiwgcmVwb05hbWUsIGJyYW5jaCwgcGF0aCkge1xyXG4gICAgaWYgKHRoaXMudmlldyBpbnN0YW5jZW9mIFJlcG9WaWV3ICYmXHJcbiAgICAgIHRoaXMudmlldy5tb2RlbC5nZXQoJ293bmVyJykubG9naW4gPT09IGxvZ2luICYmXHJcbiAgICAgIHRoaXMudmlldy5tb2RlbC5nZXQoJ25hbWUnKSA9PT0gcmVwb05hbWUgJiZcclxuICAgICAgKHRoaXMudmlldy5icmFuY2ggPT09IGJyYW5jaCB8fFxyXG4gICAgICAgIChfLmlzVW5kZWZpbmVkKGJyYW5jaCkgJiZcclxuICAgICAgICB0aGlzLnZpZXcuYnJhbmNoID09PSB0aGlzLnZpZXcubW9kZWwuZ2V0KCdkZWZhdWx0X2JyYW5jaCcpKVxyXG4gICAgICApKSB7XHJcbiAgICAgIHRoaXMudmlldy5maWxlcy5wYXRoID0gcGF0aCB8fCAnJztcclxuICAgICAgcmV0dXJuIHRoaXMudmlldy5maWxlcy5yZW5kZXIoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy52aWV3KSB0aGlzLnZpZXcucmVtb3ZlKCk7XHJcblxyXG4gICAgdGhpcy5hcHAubG9hZGVyLnN0YXJ0KHQoJ2xvYWRpbmcucmVwbycpKTtcclxuICAgIHRoaXMuYXBwLm5hdi5tb2RlKCdyZXBvJyk7XHJcblxyXG4gICAgdmFyIHRpdGxlID0gcmVwb05hbWU7XHJcbiAgICBpZiAoYnJhbmNoKSB0aXRsZSA9IHJlcG9OYW1lICsgJzogLycgKyBwYXRoICsgJyBhdCAnICsgYnJhbmNoO1xyXG4gICAgdXRpbC5kb2N1bWVudFRpdGxlKHRpdGxlKTtcclxuXHJcbiAgICB2YXIgdXNlciA9IHRoaXMudXNlcnMuZmluZFdoZXJlKHsgbG9naW46IGxvZ2luIH0pO1xyXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodXNlcikpIHtcclxuICAgICAgdXNlciA9IG5ldyBVc2VyKHsgbG9naW46IGxvZ2luIH0pO1xyXG4gICAgICB0aGlzLnVzZXJzLmFkZCh1c2VyKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVwbyA9IHVzZXIucmVwb3MuZmluZFdoZXJlKHsgbmFtZTogcmVwb05hbWUgfSk7XHJcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZXBvKSkge1xyXG4gICAgICByZXBvID0gbmV3IFJlcG8oe1xyXG4gICAgICAgIG5hbWU6IHJlcG9OYW1lLFxyXG4gICAgICAgIG93bmVyOiB7XHJcbiAgICAgICAgICBsb2dpbjogbG9naW5cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB1c2VyLnJlcG9zLmFkZChyZXBvKTtcclxuICAgIH1cclxuXHJcbiAgICByZXBvLmZldGNoKHtcclxuICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY29udGVudCA9IG5ldyBSZXBvVmlldyh7XHJcbiAgICAgICAgICBhcHA6IHRoaXMuYXBwLFxyXG4gICAgICAgICAgYnJhbmNoOiBicmFuY2gsXHJcbiAgICAgICAgICBtb2RlbDogcmVwbyxcclxuICAgICAgICAgIG5hdjogdGhpcy5hcHAubmF2LFxyXG4gICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgIHJvdXRlcjogdGhpcyxcclxuICAgICAgICAgIHNpZGViYXI6IHRoaXMuYXBwLnNpZGViYXJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29udGVudDtcclxuICAgICAgICB0aGlzLmFwcC4kZWwuZmluZCgnI21haW4nKS5odG1sKHRoaXMudmlldy5yZW5kZXIoKS5lbCk7XHJcbiAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuZXJyb3IoeGhyKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgY29tcGxldGU6IHRoaXMuYXBwLmxvYWRlci5kb25lXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBwYXRoOiBmdW5jdGlvbihsb2dpbiwgcmVwb05hbWUsIHBhdGgpIHtcclxuICAgIHZhciB1cmwgPSB1dGlsLmV4dHJhY3RVUkwocGF0aCk7XHJcblxyXG4gICAgc3dpdGNoKHVybC5tb2RlKSB7XHJcbiAgICAgIGNhc2UgJ3RyZWUnOlxyXG4gICAgICAgIHRoaXMucmVwbyhsb2dpbiwgcmVwb05hbWUsIHVybC5icmFuY2gsIHVybC5wYXRoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbmV3JzpcclxuICAgICAgY2FzZSAnYmxvYic6XHJcbiAgICAgIGNhc2UgJ2VkaXQnOlxyXG4gICAgICBjYXNlICdwcmV2aWV3JzpcclxuICAgICAgICB0aGlzLnBvc3QobG9naW4sIHJlcG9OYW1lLCB1cmwubW9kZSwgdXJsLmJyYW5jaCwgdXJsLnBhdGgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IHVybC5tb2RlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHBvc3Q6IGZ1bmN0aW9uKGxvZ2luLCByZXBvTmFtZSwgbW9kZSwgYnJhbmNoLCBwYXRoKSB7XHJcbiAgICBpZiAodGhpcy52aWV3KSB0aGlzLnZpZXcucmVtb3ZlKCk7XHJcblxyXG4gICAgdGhpcy5hcHAubmF2Lm1vZGUoJ2ZpbGUnKTtcclxuXHJcbiAgICBzd2l0Y2gobW9kZSkge1xyXG4gICAgICBjYXNlICduZXcnOlxyXG4gICAgICAgIHRoaXMuYXBwLmxvYWRlci5zdGFydCh0KCdsb2FkaW5nLmNyZWF0aW5nJykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdlZGl0JzpcclxuICAgICAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQodCgnbG9hZGluZy5maWxlJykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdwcmV2aWV3JzpcclxuICAgICAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQodCgnbG9hZGluZy5wcmV2aWV3JykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB1c2VyID0gdGhpcy51c2Vycy5maW5kV2hlcmUoeyBsb2dpbjogbG9naW4gfSk7XHJcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh1c2VyKSkge1xyXG4gICAgICB1c2VyID0gbmV3IFVzZXIoeyBsb2dpbjogbG9naW4gfSk7XHJcbiAgICAgIHRoaXMudXNlcnMuYWRkKHVzZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXBvID0gdXNlci5yZXBvcy5maW5kV2hlcmUoeyBuYW1lOiByZXBvTmFtZSB9KTtcclxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlcG8pKSB7XHJcbiAgICAgIHJlcG8gPSBuZXcgUmVwbyh7XHJcbiAgICAgICAgbmFtZTogcmVwb05hbWUsXHJcbiAgICAgICAgb3duZXI6IHtcclxuICAgICAgICAgIGxvZ2luOiBsb2dpblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHVzZXIucmVwb3MuYWRkKHJlcG8pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaWxlID0ge1xyXG4gICAgICBhcHA6IHRoaXMuYXBwLFxyXG4gICAgICBicmFuY2g6IGJyYW5jaCxcclxuICAgICAgYnJhbmNoZXM6IHJlcG8uYnJhbmNoZXMsXHJcbiAgICAgIG1vZGU6IG1vZGUsXHJcbiAgICAgIG5hdjogdGhpcy5hcHAubmF2LFxyXG4gICAgICBuYW1lOiB1dGlsLmV4dHJhY3RGaWxlbmFtZShwYXRoKVsxXSxcclxuICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgcmVwbzogcmVwbyxcclxuICAgICAgcm91dGVyOiB0aGlzLFxyXG4gICAgICBzaWRlYmFyOiB0aGlzLmFwcC5zaWRlYmFyXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE86IGRlZmVyIHRoaXMgc3VjY2VzcyBmdW5jdGlvbiB1bnRpbCBib3RoIHVzZXIgYW5kIHJlcG8gaGF2ZSBiZWVuIGZldGNoZWRcclxuICAgIC8vIGluIHBhcmFsZWxsIHJhdGhlciB0aGFuIGluIHNlcmllc1xyXG4gICAgdXNlci5mZXRjaCh7XHJcbiAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihtb2RlbCwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmVwby5mZXRjaCh7XHJcbiAgICAgICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRmlsZVZpZXcoZmlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLiRlbC5maW5kKCcjbWFpbicpLmh0bWwodGhpcy52aWV3LmVsKTtcclxuICAgICAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcih4aHIpO1xyXG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgICAgIGNvbXBsZXRlOiB0aGlzLmFwcC5sb2FkZXIuZG9uZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVycm9yKHhocik7XHJcbiAgICAgIH0pLmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHByZXZpZXc6IGZ1bmN0aW9uKGxvZ2luLCByZXBvTmFtZSwgbW9kZSwgYnJhbmNoLCBwYXRoKSB7XHJcbiAgICBpZiAodGhpcy52aWV3KSB0aGlzLnZpZXcucmVtb3ZlKCk7XHJcblxyXG4gICAgdGhpcy5hcHAubG9hZGVyLnN0YXJ0KHQoJ2xvYWRpbmcucHJldmlldycpKTtcclxuXHJcbiAgICB2YXIgdXNlciA9IHRoaXMudXNlcnMuZmluZFdoZXJlKHsgbG9naW46IGxvZ2luIH0pO1xyXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodXNlcikpIHtcclxuICAgICAgdXNlciA9IG5ldyBVc2VyKHsgbG9naW46IGxvZ2luIH0pO1xyXG4gICAgICB0aGlzLnVzZXJzLmFkZCh1c2VyKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVwbyA9IHVzZXIucmVwb3MuZmluZFdoZXJlKHsgbmFtZTogcmVwb05hbWUgfSk7XHJcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZXBvKSkge1xyXG4gICAgICByZXBvID0gbmV3IFJlcG8oe1xyXG4gICAgICAgIG5hbWU6IHJlcG9OYW1lLFxyXG4gICAgICAgIG93bmVyOiB7XHJcbiAgICAgICAgICBsb2dpbjogbG9naW5cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB1c2VyLnJlcG9zLmFkZChyZXBvKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsZSA9IHtcclxuICAgICAgYnJhbmNoOiBicmFuY2gsXHJcbiAgICAgIGJyYW5jaGVzOiByZXBvLmJyYW5jaGVzLFxyXG4gICAgICBtb2RlOiBtb2RlLFxyXG4gICAgICBuYXY6IHRoaXMuYXBwLm5hdixcclxuICAgICAgbmFtZTogdXRpbC5leHRyYWN0RmlsZW5hbWUocGF0aClbMV0sXHJcbiAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgIHJlcG86IHJlcG8sXHJcbiAgICAgIHJvdXRlcjogdGhpcyxcclxuICAgICAgc2lkZWJhcjogdGhpcy5hcHAuc2lkZWJhclxyXG4gICAgfTtcclxuXHJcbiAgICByZXBvLmZldGNoKHtcclxuICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBzdGlsbCBwYXNzIHRocm91Z2ggRmlsZSB2aWV3P1xyXG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBQcmV2aWV3KGZpbGUpO1xyXG4gICAgICAgIHRoaXMuYXBwLiRlbC5maW5kKCcjbWFpbicpLmh0bWwodGhpcy52aWV3LmVsKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcih4aHIpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBjb21wbGV0ZTogdGhpcy5hcHAubG9hZGVyLmRvbmVcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLnZpZXcpIHRoaXMudmlldy5yZW1vdmUoKTtcclxuXHJcbiAgICAvLyBJZiB1c2VyIGhhcyBhdXRoZW50aWNhdGVkXHJcbiAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0aGlzLnVzZXIuZ2V0KCdsb2dpbicpLCB7XHJcbiAgICAgICAgdHJpZ2dlcjogdHJ1ZSxcclxuICAgICAgICByZXBsYWNlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hcHAubmF2Lm1vZGUoJ3N0YXJ0Jyk7XHJcbiAgICAgIHRoaXMudmlldyA9IG5ldyBTdGFydFZpZXcoKTtcclxuICAgICAgdGhpcy5hcHAuJGVsLmZpbmQoJyNtYWluJykuaHRtbCh0aGlzLnZpZXcucmVuZGVyKCkuZWwpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG5vdGlmeTogZnVuY3Rpb24obWVzc2FnZSwgZXJyb3IsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0aGlzLnZpZXcpIHRoaXMudmlldy5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBuZXcgTm90aWZpY2F0aW9uVmlldyh7XHJcbiAgICAgICdtZXNzYWdlJzogbWVzc2FnZSxcclxuICAgICAgJ2Vycm9yJzogZXJyb3IsXHJcbiAgICAgICdvcHRpb25zJzogb3B0aW9uc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5hcHAuJGVsLmZpbmQoJyNtYWluJykuaHRtbCh0aGlzLnZpZXcucmVuZGVyKCkuZWwpO1xyXG4gICAgdGhpcy5hcHAubG9hZGVyLnN0b3AoKTtcclxuICB9LFxyXG5cclxuICBlcnJvcjogZnVuY3Rpb24oeGhyKSB7XHJcbiAgICB2YXIgbWVzc2FnZSA9IFtcclxuICAgICAgeGhyLnN0YXR1cyxcclxuICAgICAgeGhyLnN0YXR1c1RleHRcclxuICAgIF0uam9pbignICcpO1xyXG5cclxuICAgIHZhciBlcnJvciA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkubWVzc2FnZTtcclxuXHJcbiAgICB2YXIgb3B0aW9ucyA9IFtcclxuICAgICAge1xyXG4gICAgICAgICd0aXRsZSc6IHQoJ25vdGlmaWNhdGlvbi5ob21lJyksXHJcbiAgICAgICAgJ2xpbmsnOiAnLydcclxuICAgICAgfVxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLm5vdGlmeShtZXNzYWdlLCBlcnJvciwgb3B0aW9ucyk7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7IFxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7IFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgZ2l0aHViQXBpOiBmdW5jdGlvbihjYikge1xyXG4gICAgJC5hamF4KHtcclxuICAgICAgdHlwZTogJ0dFVCcsXHJcbiAgICAgIHVybDogY29uZmlnLmFwaVN0YXR1cyArICc/Y2FsbGJhY2s9PycsXHJcbiAgICAgIGRhdGFUeXBlOiAnanNvbnAnLFxyXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcclxuICAgICAgICByZXR1cm4gY2IocmVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsIihmdW5jdGlvbigpey8qIFdlIGNhbiBhZGQgb3RoZXIgSlNPTkZvcm0gZm9ybWF0IGRlZmluaXRpb25zIGJ5IHVzaW5nIHRoaXMgc3ludGF4OlxyXG4gKiBleHBvcnRzLmJsYSA9IHsgLi4uIH07XHJcbiAqIFRoZW4sIGluIGFub3RoZXIgZmlsZSB3ZSBpbXBvcnQgdGhpcyBmaWxlIGFuZCByZWZlcmVuY2Ugb25lIG9mIHRoZSBmb3JtYXRcclxuICogc3BlY2lmaWNhdGlvbnM6XHJcbiAqIHZhciBqc29uZm9ybWZvcm1hdCA9IHJlcXVpcmUoJy4vanNvbmZvcm1mb3JtYXQuanMnKTtcclxuICogdmFyIGJsYWZvcm1hdCA9IGpzb25mb3JtZm9ybWF0LmJsYTtcclxuICpcclxuICogVGhlIG9yZGVyaW5nIG9mIHRoZSBmaWVsZHMgYXJlIGVpdGhlciBkZXRlcm1pbmVkIGJ5IGZpcnN0IHRoZSBmb3JtIGFuZCBzZWNvbmQgYnkgdGhlIHNjaGVtYS5cclxuICpcclxuICpcclxuICovXHJcbiBcclxubW9kdWxlLmV4cG9ydHMucHJvZCA9IHtcclxuICBcInNjaGVtYVwiOiB7XHJcbiAgXHJcblx0ICAvKiBCYXNpYyAqL1xyXG4gICAgICBcIm5hbWVcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJOYW1lICpcIixcclxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiU3BlY2lmaWNhdGlvblwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwic3lub255bXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJTeW5vbnltc1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwibmFtZS1lbmdsaXNoXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiRW5nbGlzaCBOYW1lXCJcclxuICAgICAgfSxcclxuICAgICAgXCJuYW1lLWZyZW5jaFwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkZyZW5jaCBOYW1lXCJcclxuICAgICAgfSwgICAgXHJcbiAgICAgIFwiY28yLXZhbHVlXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiQ08yLVZhbHVlIFtrZyBDTzImQXVtbDtxL2tnXSAoKilcIixcclxuXHRcdFwiZGVzY3JpcHRpb25cIjogXCJZb3UgY2FuIGxlYXZlIHRoZSBDTzItdmFsdWUgZW1wdHkgaWYgdGhpcyBpcyBhIGxpbmtlZCBwcm9kdWN0LlwiXHJcbiAgICAgIH0sICAgICAgXHJcbiAgICAgIFwiaWRcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiSUQgKlwiLFxyXG5cdFx0LypcInJlYWRvbmx5XCI6IFwicmVhZG9ubHlcIiwqL1xyXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxyXG4gICAgICB9LFxyXG5cdCAgXCJudXRyaXRpb24taWRcIjoge1xyXG5cdCAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuXHRcdFwidGl0bGVcIjogXCJOdXRyaXRpb24gRGF0YSAqXCJcclxuXHQgIH0sXHJcblx0ICBcImdyb3VwLWlkXCI6IHtcclxuXHQgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcblx0XHRcInRpdGxlXCI6IFwiUHJvZHVjdCBHcm91cFwiLFxyXG5cdFx0XCJlbnVtXCI6IE9iamVjdC5rZXlzKElEX1BST0QpLnNvcnQoKVxyXG5cdCAgfSxcclxuICAgICAgXCJsaW5rZWQtaWRcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJMaW5rZWQgd2l0aFwiLFxyXG5cdFx0XCJlbnVtXCI6IE9iamVjdC5rZXlzKElEX1BST0QpLnNvcnQoKVxyXG4gICAgICB9LCAgICAgICBcclxuXHQgIFxyXG5cdCAgLyogQWR2YW5jZWQgKi9cclxuICAgICAgXCJ0YWdzXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiVGFncyAqXCIsXHJcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiYWx0ZXJuYXRpdmVzXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiQWx0ZXJuYXRpdmVzXCJcclxuICAgICAgfSxcclxuICAgICAgXCJzdGFuZGFyZC1vcmlnaW5cIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJTdGFuZGFyZCBPcmlnaW5cIlxyXG4gICAgICB9LFxyXG5cdCAgXCJvcmlnaW5zXCI6IHtcclxuXHQgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcblx0XHRcInRpdGxlXCI6IFwiUG9zc2libGUgb3JpZ2luc1wiXHJcblx0ICB9LFxyXG4gICAgICBcInByb2R1Y3Rpb24tbmFtZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJQcm9kdWN0aW9uIG1ldGhvZHNcIlxyXG4gICAgICB9LFxyXG4gICAgICBcInByb2R1Y3Rpb24tdmFsdWVzXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiUHJvZHVjdGlvbiBtZXRob2QgcGFyYW1ldGVyc1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicHJvZHVjdGlvbi1tZXRob2RzXCI6IHtcclxuXHQgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuXHRcdFwidGl0bGVcIjogXCJQcm9kdWN0aW9uIE1ldGhvZHNcIixcclxuXHRcdFwiaXRlbXNcIjoge1xyXG5cdFx0ICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuXHRcdCAgXCJ0aXRsZVwiOiBcIlByb2R1Y3Rpb24gTWV0aG9kXCIsXHJcblx0XHQgIFwiZW51bVwiOiBPYmplY3Qua2V5cyhJRF9QUk9DKS5zb3J0KClcclxuXHRcdH1cclxuXHQgIH0sXHJcbiAgICAgIFwicHJvY2Vzc2luZy1uYW1lc1wiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkRlZ3JlZXMgb2YgcHJvY2Vzc2luZ1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicHJvY2Vzc2luZy12YWx1ZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJEZWdyZWVzIG9mIHByb2Nlc3NpbmcgcGFyYW1ldGVyc1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicHJvY2Vzc2luZy1tZXRob2RzXCI6IHtcclxuXHQgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuXHRcdFwidGl0bGVcIjogXCJQcm9jZXNzaW5nIE1ldGhvZHNcIixcclxuXHRcdFwiaXRlbXNcIjoge1xyXG5cdFx0ICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuXHRcdCAgXCJ0aXRsZVwiOiBcIlByb2Nlc3NpbmcgTWV0aG9kXCIsXHJcblx0XHQgIFwiZW51bVwiOiBPYmplY3Qua2V5cyhJRF9QUk9DKS5zb3J0KClcclxuXHRcdH1cclxuXHQgIH0sXHJcbiAgICAgIFwiY29uc2VydmF0aW9uLW5hbWVzXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiUHJlc2VydmF0aW9uIG1ldGhvZHNcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImNvbnNlcnZhdGlvbi12YWx1ZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJQcmVzZXJ2YXRpb24gbWV0aG9kIHBhcmFtZXRlcnNcIlxyXG4gICAgICB9LFxyXG4gICAgICBcInByZXNlcnZhdGlvbi1tZXRob2RzXCI6IHtcclxuXHQgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuXHRcdFwidGl0bGVcIjogXCJQcmVzZXJ2YXRpb24gTWV0aG9kc1wiLFxyXG5cdFx0XCJpdGVtc1wiOiB7XHJcblx0XHQgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG5cdFx0ICBcInRpdGxlXCI6IFwiUHJlc2VydmF0aW9uIE1ldGhvZFwiLFxyXG5cdFx0ICBcImVudW1cIjogT2JqZWN0LmtleXMoSURfUFJPQykuc29ydCgpXHJcblx0XHR9XHJcblx0ICB9LFx0ICBcclxuICAgICAgXCJwYWNrYWdpbmctbmFtZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJQYWNrYWdpbmdcIlxyXG4gICAgICB9LFxyXG4gICAgICBcInBhY2thZ2luZy12YWx1ZXNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJQYWNrYWdpbmcgcGFyYW1ldGVyc1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicGFja2FnaW5nLW1ldGhvZHNcIjoge1xyXG5cdCAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG5cdFx0XCJ0aXRsZVwiOiBcIlBhY2thZ2luZyBNZXRob2RzXCIsXHJcblx0XHRcIml0ZW1zXCI6IHtcclxuXHRcdCAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcblx0XHQgIFwidGl0bGVcIjogXCJQYWNrYWdpbmcgTWV0aG9kXCIsXHJcblx0XHQgIFwiZW51bVwiOiBPYmplY3Qua2V5cyhJRF9QUk9DKS5zb3J0KClcclxuXHRcdH1cclxuXHQgIH0sXHRcclxuICAgICAgXCJzZWFzb24tYmVnaW5cIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJTdGFydCBvZiBsb2NhbCBzZWFzb25cIlxyXG4gICAgICB9LFxyXG4gICAgICBcInNlYXNvbi1lbmRcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJFbmQgb2YgbG9jYWwgc2Vhc29uXCJcclxuICAgICAgfSxcclxuICAgICAgXCJjb21iaW5lZC1wcm9kdWN0XCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIklzIGEgY29tYmluZWQgcHJvZHVjdFwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZGVuc2l0eVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgICAgIFwidGl0bGVcIjogXCJEZW5zaXR5IFtnL21sXVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwidW5pdC13ZWlnaHRcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgICBcInRpdGxlXCI6IFwiVW5pdCB3ZWlnaHQgW2cvcGllY2VdXCJcclxuICAgICAgfSxcclxuICAgICAgXCJxdWFudGl0eS1jb21tZW50c1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG4gICAgICAgICAgXCJ0aXRsZVwiOiBcIkNvbW1lbnRzIG9mIGRlbnNpdHkgJiB1bml0IHdlaWdodFwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicXVhbnRpdHktcmVmZXJlbmNlc1wiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG4gICAgICAgICAgXCJ0aXRsZVwiOiBcIlJlZmVyZW5jZXMgb2YgZGVuc2l0eSAmIHVuaXQgd2VpZ2h0XCJcclxuICAgICAgfSxcclxuICAgICAgXCJjb25zaXN0ZW5jeVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwidGl0bGVcIjogXCJUZXh0dXJlXCJcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIC8qIERvY3VtZW50YXRpb24gKi9cclxuICAgICAgXCJjbzItY2FsY3VsYXRpb25cIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRhcmVhXCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkNPMiBjYWxjdWxhdGlvbiBwYXRoIGZvciBiYXNpYyBDTzItdmFsdWVcIlxyXG4gICAgICB9LFxyXG4gICAgICBcImNhbGN1bGF0aW9uLXByb2Nlc3MtZG9jdW1lbnRhdGlvblwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dGFyZWFcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiQ2FsY3VsYXRpb24gcHJvY2VzcyBkb2N1bWVudGF0aW9uXCIsXHJcblx0XHRcImRlc2NyaXB0aW9uXCI6IFwiRGVzY3JpcHRpb24gb2YgZGF0YSB1c2VkIGZvciBDTzItY2FsY3VsYXRpb24gYW5kIGltcG9ydGFudCBwcm9kdWN0IHRyYWl0c1wiXHJcbiAgICAgIH0sXHQgIFxyXG4gICAgICBcImluZm8tdGV4dFwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkluZm8gdGV4dCBmb3IgY29va1wiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwicmVmZXJlbmNlc1wiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dGFyZWFcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiUmVmZXJlbmNlcyBmb3IgYmFzaWMgQ08yLXZhbHVlXCJcclxuICAgICAgfSwgXHJcblx0ICBcIm90aGVyLXJlZmVyZW5jZXNcIjoge1xyXG5cdCAgICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG5cdCAgICBcInRpdGxlXCI6IFwiT3RoZXIgcmVmZXJlbmNlcyAobm90IHVzZWQpXCJcclxuXHQgIH0sXHJcbiAgICAgIFwiY29tbWVudHNcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJDb21tZW50XCJcclxuICAgICAgfSxcclxuXHQgIFwiY28yLWNhbGN1bGF0aW9uLXBhcmFtZXRlcnNcIjoge1xyXG5cdCAgICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG5cdFx0XCJ0aXRsZVwiOiBcIkNPMiBjYWxjdWxhdGlvbiBwYXRoIGZvciBkaWZmZXJlbnQgcHJvZHVjdCBwYXJhbWV0ZXJzXCJcclxuXHQgIH0sXHJcblx0ICBcInJlZmVyZW5jZXMtcGFyYW1ldGVyc1wiOiB7XHJcblx0ICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG5cdFx0XCJ0aXRsZVwiOiBcIlJlZmVyZW5jZXMgZm9yIHByb2R1Y3QgcGFyYW1ldGVyIGNhbGN1bGF0aW9uXCJcclxuXHQgIH0sXHJcbiAgICAgXCJkYXRhLXF1YWxpdHlcIjoge1xyXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJEYXRhIHF1YWxpdHkgZXN0aW1hdGlvblwiXHJcbiAgICAgIH0sICAgICAgXHJcbiAgICAgIFwiYXV0aG9yXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiTGFzdCBhbmFseXN0IGluaXRpYWxzXCJcclxuICAgICAgfSxcdCAgXHJcblx0ICBcImRlbGV0ZVwiOiB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJUbyBkZWxldGVcIlxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBcImZvcm1cIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmllbGRzZXRcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiQmFzaWNcIixcclxuICAgICAgICBcImV4cGFuZGFibGVcIjogZmFsc2UsXHJcbiAgICAgICAgXCJpdGVtc1wiOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwia2V5XCI6IFwibmFtZVwiLFxyXG4gICAgICAgICAgICBcImh0bWxDbGFzc1wiOiBcImgxIHRpdGxlIGhlYWRpbmdcIixcclxuICAgICAgICAgICAgXCJmb3JtSHRtbENsYXNzXCI6IFwiaDEgdGl0bGUgaGVhZGluZ1wiXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCIsXHJcbiAgICAgICAgICBcInN5bm9ueW1zXCIsXHJcbiAgICAgICAgICBcIm5hbWUtZW5nbGlzaFwiLFxyXG4gICAgICAgICAgXCJuYW1lLWZyZW5jaFwiLFxyXG4gICAgICAgICAgXCJjbzItdmFsdWVcIixcclxuXHRcdCAge1xyXG5cdFx0ICAgIFwia2V5XCI6IFwiaWRcIixcclxuXHRcdFx0XCJyZWFkb25seVwiOiBcInJlYWRvbmx5XCJcclxuXHRcdCAgfSxcclxuXHRcdCAgXCJudXRyaXRpb24taWRcIixcclxuXHRcdCAge1xyXG5cdFx0ICAgIFwia2V5XCI6IFwiZ3JvdXAtaWRcIixcclxuXHRcdFx0XCJ0aXRsZU1hcFwiOiBJRF9QUk9EXHJcblx0XHQgIH0sXHJcbiAgICAgICAgICB7XHJcblx0XHQgICAgXCJrZXlcIjogXCJsaW5rZWQtaWRcIixcclxuXHRcdFx0XCJ0aXRsZU1hcFwiOiBJRF9QUk9ELyosXHJcblx0XHRcdFwicHJlcGVuZFwiOlwiPGEgb25jbGljaz1cXFwid2luZG93Lm9wZW4oXFwnaHR0cDovL2VkYi5lYXRlcm5pdHkuY2gvcHJvc2UvI2VhdGVybml0eS1hZ2VudC9FYXRlcm5pdHktRGF0ZW5iYW5rL2VkaXQvZ2gtcGFnZXMvX2RhdGEvcHJvZHMvXFwnICsgSURfUFJPRF9GSUxFW2RvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKFxcJ2xpbmtlZC1pZFxcJylbMF0udmFsdWVdICsgXFwnLmpzb25cXCcsIFxcJ19ibGFua1xcJyk7XFxcIj5PcGVuPC9hPlwiKi9cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXVxyXG4gICAgICB9LFxyXG5cdCAgXHJcbiAgICAgIHtcclxuICAgICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJBZHZhbmNlZCBbK11cIixcclxuICAgICAgICBcImV4cGFuZGFibGVcIjogdHJ1ZSxcclxuICAgICAgICBcIml0ZW1zXCI6IFtcclxuICAgICAgICAgIFwidGFnc1wiLFxyXG4gICAgICAgICAgXCJhbHRlcm5hdGl2ZXNcIixcclxuICAgICAgICAgIFwic3RhbmRhcmQtb3JpZ2luXCIsXHJcbiAgICAgICAgICBcIm9yaWdpbnNcIixcclxuICAgICAgICAgIFwicHJvZHVjdGlvbi1uYW1lc1wiLFxyXG4gICAgICAgICAgXCJwcm9kdWN0aW9uLXZhbHVlc1wiLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG5cdFx0XHRcInRpdGxlXCI6IFwiUHJvZHVjdGlvbiBNZXRob2RzIFsrXVwiLFxyXG5cdFx0XHRcImV4cGFuZGFibGVcIjogdHJ1ZSxcclxuXHRcdFx0XCJpdGVtc1wiOiBbXHJcbiAgICAgICAgICAgICAge1xyXG5cdFx0ICAgICAgICBcImtleVwiOiBcInByb2R1Y3Rpb24tbWV0aG9kc1wiLFxyXG5cdFx0XHQgICAgXCJ0eXBlXCI6IFwiY2hlY2tib3hlc1wiLFxyXG5cdFx0XHQgICAgXCJ0aXRsZU1hcFwiOiBJRF9QUk9DXHJcblx0XHQgICAgICB9XHRcdFx0XHJcblx0XHRcdF1cclxuXHRcdCAgfSxcclxuLypcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmllbGRzZXRcIixcclxuXHRcdFx0XCJ0aXRsZVwiOiBcIlByb2R1Y3Rpb24gTWV0aG9kcyBTdGFuZGFyZCBbK11cIixcclxuXHRcdFx0XCJleHBhbmRhYmxlXCI6IHRydWUsXHJcblx0XHRcdFwiaXRlbXNcIjogW1xyXG4gICAgICAgICAgICAgIHtcclxuXHRcdCAgICAgICAgXCJrZXlcIjogXCJwcm9kdWN0aW9uLW1ldGhvZHNcIixcclxuXHRcdFx0ICAgIFwidHlwZVwiOiBcImNoZWNrYm94ZXNcIixcclxuXHRcdFx0ICAgIFwidGl0bGVNYXBcIjogSURfUFJPQ19TVEFOREFSRFxyXG5cdFx0ICAgICAgfVx0XHRcdFxyXG5cdFx0XHRdXHJcblx0XHQgIH0sXHJcblx0XHQgIHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmllbGRzZXRcIixcclxuXHRcdFx0XCJ0aXRsZVwiOiBcIlByb2R1Y3Rpb24gTWV0aG9kcyBOb24tU3RhbmRhcmQgWytdXCIsXHJcblx0XHRcdFwiZXhwYW5kYWJsZVwiOiB0cnVlLFxyXG5cdFx0XHRcIml0ZW1zXCI6IFtcclxuICAgICAgICAgICAgICB7XHJcblx0XHQgICAgICAgIFwia2V5XCI6IFwicHJvZHVjdGlvbi1tZXRob2RzXCIsXHJcblx0XHRcdCAgICBcInR5cGVcIjogXCJjaGVja2JveGVzXCIsXHJcblx0XHRcdCAgICBcInRpdGxlTWFwXCI6IElEX1BST0NfTk9OX1NUQU5EQVJEXHJcblx0XHQgICAgICB9XHRcdFx0XHJcblx0XHRcdF1cclxuXHRcdCAgfSxcclxuKi9cclxuICAgICAgICAgIFwicHJvY2Vzc2luZy1uYW1lc1wiLFxyXG4gICAgICAgICAgXCJwcm9jZXNzaW5nLXZhbHVlc1wiLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG5cdFx0XHRcInRpdGxlXCI6IFwiUHJvY2Vzc2luZyBNZXRob2RzIFsrXVwiLFxyXG5cdFx0XHRcImV4cGFuZGFibGVcIjogdHJ1ZSxcclxuXHRcdFx0XCJpdGVtc1wiOiBbXHJcbiAgICAgICAgICAgICAge1xyXG5cdFx0ICAgICAgICBcImtleVwiOiBcInByb2Nlc3NpbmctbWV0aG9kc1wiLFxyXG5cdFx0XHQgICAgXCJ0eXBlXCI6IFwiY2hlY2tib3hlc1wiLFxyXG5cdFx0XHQgICAgXCJ0aXRsZU1hcFwiOiBJRF9QUk9DXHJcblx0XHQgICAgICB9XHRcdFx0XHJcblx0XHRcdF1cclxuXHRcdCAgfSxcclxuICAgICAgICAgIFwiY29uc2VydmF0aW9uLW5hbWVzXCIsXHJcbiAgICAgICAgICBcImNvbnNlcnZhdGlvbi12YWx1ZXNcIixcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmllbGRzZXRcIixcclxuXHRcdFx0XCJ0aXRsZVwiOiBcIlByZXNlcnZhdGlvbiBNZXRob2RzIFsrXVwiLFxyXG5cdFx0XHRcImV4cGFuZGFibGVcIjogdHJ1ZSxcclxuXHRcdFx0XCJpdGVtc1wiOiBbXHJcbiAgICAgICAgICAgICAge1xyXG5cdFx0ICAgICAgICBcImtleVwiOiBcInByZXNlcnZhdGlvbi1tZXRob2RzXCIsXHJcblx0XHRcdCAgICBcInR5cGVcIjogXCJjaGVja2JveGVzXCIsXHJcblx0XHRcdCAgICBcInRpdGxlTWFwXCI6IElEX1BST0NcclxuXHRcdCAgICAgIH1cdFx0XHRcclxuXHRcdFx0XVxyXG5cdFx0ICB9LFxyXG4gICAgICAgICAgXCJwYWNrYWdpbmctbmFtZXNcIixcclxuICAgICAgICAgIFwicGFja2FnaW5nLXZhbHVlc1wiLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG5cdFx0XHRcInRpdGxlXCI6IFwiUGFja2FnaW5nIE1ldGhvZHMgWytdXCIsXHJcblx0XHRcdFwiZXhwYW5kYWJsZVwiOiB0cnVlLFxyXG5cdFx0XHRcIml0ZW1zXCI6IFtcclxuICAgICAgICAgICAgICB7XHJcblx0XHQgICAgICAgIFwia2V5XCI6IFwicGFja2FnaW5nLW1ldGhvZHNcIixcclxuXHRcdFx0ICAgIFwidHlwZVwiOiBcImNoZWNrYm94ZXNcIixcclxuXHRcdFx0ICAgIFwidGl0bGVNYXBcIjogSURfUFJPQ1xyXG5cdFx0ICAgICAgfVx0XHRcdFxyXG5cdFx0XHRdXHJcblx0XHQgIH0sXHJcbiAgICAgICAgICBcInNlYXNvbi1iZWdpblwiLFxyXG5cdFx0ICBcInNlYXNvbi1lbmRcIixcclxuXHRcdCAgXCJjb21iaW5lZC1wcm9kdWN0XCIsXHJcbiAgICAgICAgICBcImRlbnNpdHlcIixcclxuICAgICAgICAgIFwidW5pdC13ZWlnaHRcIixcclxuICAgICAgICAgIFwicXVhbnRpdHktY29tbWVudHNcIixcclxuICAgICAgICAgIFwicXVhbnRpdHktcmVmZXJlbmNlc1wiLFxyXG5cdFx0ICBcImNvbnNpc3RlbmN5XCJcclxuICAgICAgICBdXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG4gICAgICAgIFwidGl0bGVcIjogXCJEb2N1bWVudGF0aW9uIFsrXVwiLFxyXG4gICAgICAgIFwiZXhwYW5kYWJsZVwiOiB0cnVlLFxyXG4gICAgICAgIFwiaXRlbXNcIjogW1xyXG4gICAgICAgICAgXCJjbzItY2FsY3VsYXRpb25cIixcclxuICAgICAgICAgIFwiY2FsY3VsYXRpb24tcHJvY2Vzcy1kb2N1bWVudGF0aW9uXCIsXHJcbiAgICAgICAgICBcImluZm8tdGV4dFwiLFxyXG4gICAgICAgICAgXCJyZWZlcmVuY2VzXCIsXHJcbiAgICAgICAgICBcIm90aGVyLXJlZmVyZW5jZXNcIixcclxuICAgICAgICAgIFwiY29tbWVudHNcIixcclxuICAgICAgICAgIFwiY28yLWNhbGN1bGF0aW9uLXBhcmFtZXRlcnNcIixcclxuICAgICAgICAgIFwiZGF0YS1xdWFsaXR5XCIsXHJcbiAgICAgICAgICBcImF1dGhvclwiLFxyXG4gICAgICAgICAgXCJkZWxldGVcIlxyXG4gICAgICAgIF1cclxuICAgICAgfSAgXHJcblxyXG5cdCAgLyosXHJcblx0ICAvLyBIaWRkZW4gc3VibWl0IGJ1dHRvblxyXG5cdCAge1xyXG5cdFx0XCJ0eXBlXCI6IFwic3VibWl0XCIsXHJcblx0XHRcInRpdGxlXCI6IFwiSGlkZGVuIEJ1dHRvbiFcIixcclxuXHRcdFwiaHRtbENsYXNzXCI6IFwiaGlkZVwiXHJcblx0ICB9Ki9cclxuICAgIF0sXHJcbiAgICBcclxuICAgIC8vIFRoaXMgd2lsbCBiZSBpbmplY3RlZCB3aGVuIGFuIGVkYiBmaWxlIGlzIGxvYWRlZC4gSXQgd2lsbCBjb250YWluIHRoZSBmaWxlJ3MgdmFsdWVzLlxyXG4gICAgXCJ2YWx1ZVwiOiBudWxsLFxyXG5cdFxyXG5cdC8vIE5vdCByZWFsbHkgbmVjZXNzYXJ5IHRvIHNldCBhcyBkZWZhdWx0IGlzIHRydWUgYW55d2F5XHJcblx0XCJ2YWxpZGF0ZVwiOiB0cnVlLFxyXG4gICAgXHJcbiAgICBcIm9uU3VibWl0VmFsaWRcIjogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG9cclxuICAgIH1cclxuXHRcclxuXHQvKlxyXG4gICAgXCJvblN1Ym1pdFwiOiBmdW5jdGlvbihlcnJvcnMsIHZhbHVlcykge1xyXG4gICAgICAvLyBOb3RoaW5nIHRvIGRvXHJcbiAgICB9Ki9cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5udXRyID0ge1xyXG5cclxuICBcInNjaGVtYVwiOiB7XHJcbiAgICBcImlkXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgIFwidGl0bGVcIjogXCJJRCAqXCIsXHJcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwibmFtZVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcInRpdGxlXCI6IFwiTmFtZSAqXCIsXHJcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxyXG4gICAgfSxcclxuICAgIFwiY291bnRyeVwiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICBcInRpdGxlXCI6IFwiQ291bnRyeVwiXHJcbiAgICB9LFxyXG5cdFwiY29tbWVudFwiOiB7XHJcblx0ICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuXHQgIFwidGl0bGVcIjogXCJDb21tZW50XCJcclxuXHR9LFxyXG4gICAgXCJudXRyLXZhbHNcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcclxuICAgICAgICBcInRpdGxlXCI6IFwiTnV0cml0aW9uYWwgVmFsdWVcIixcclxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgICAgXCJjb21wb25lbnQtaWRcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgXCJ0aXRsZVwiOiBcIkNvbXBvbmVudCBJZCAqXCIvKixcclxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBcInRydWVcIiovXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJ2YWx1ZVwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxyXG4gICAgICAgICAgICBcInRpdGxlXCI6IFwiVmFsdWUgKlwiLyosXHJcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogXCJ0cnVlXCIqL1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwidW5pdFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICBcInRpdGxlXCI6IFwiVW5pdCAqXCIvKixcclxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBcInRydWVcIiovXHJcbiAgICAgICAgICB9XHRcdCAgXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBcImZvcm1cIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG4gICAgICBcInRpdGxlXCI6IFwiQmFzaWNcIixcclxuICAgICAgXCJleHBhbmRhYmxlXCI6IGZhbHNlLFxyXG4gICAgICBcIml0ZW1zXCI6IFtcclxuXHQgICAge1xyXG4gICAgICAgICAgXCJrZXlcIjogXCJuYW1lXCIsXHJcblx0XHQgIFwiaHRtbENsYXNzXCI6IFwiaDEgdGl0bGUgaGVhZGluZ1wiLFxyXG5cdFx0ICBcImZvcm1IdG1sQ2xhc3NcIjogXCJoMSB0aXRsZSBoZWFkaW5nXCJcclxuXHRcdH0sXHRcdCAgXHJcblx0XHQgIFxyXG5cdCAgICBcImlkXCIsXHJcbiAgICAgICAgXCJjb3VudHJ5XCIsXHJcblx0XHR7XHJcblx0XHQgIFwia2V5XCI6IFwiY29tbWVudFwiLFxyXG5cdFx0ICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0ICBcInR5cGVcIjogXCJmaWVsZHNldFwiLFxyXG5cdFx0ICBcInRpdGxlXCI6IFwiTnV0cml0aW9uYWwgVmFsdWVzIFsrXVwiLFxyXG5cdFx0ICBcImV4cGFuZGFibGVcIjogdHJ1ZSxcclxuXHRcdCAgXCJpdGVtc1wiOiBbXHJcblx0XHRcdHtcclxuXHRcdFx0ICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG5cdFx0XHQgIFwiaXRlbXNcIjoge1xyXG5cdFx0XHRcdFwidHlwZVwiOiBcInNlY3Rpb25cIixcclxuXHRcdFx0XHRcIml0ZW1zXCI6IFtcclxuXHRcdFx0XHQgIHtcclxuXHRcdFx0XHRcdFwidHlwZVwiOiBcImZpZWxkc2V0XCIsXHJcblx0XHRcdFx0XHRcImV4cGFuZGFibGVcIjogZmFsc2UsXHJcblx0XHRcdFx0XHRcIml0ZW1zXCI6IFtcclxuXHRcdFx0XHRcdCAge1xyXG5cdFx0XHRcdFx0ICAgIFwia2V5XCI6IFwibnV0ci12YWxzW10uY29tcG9uZW50LWlkXCIsXHJcblx0XHRcdFx0XHRcdFwiaHRtbENsYXNzXCI6IFwiaDMgdGl0bGUgaGVhZGluZ1wiLFxyXG5cdFx0XHRcdFx0XHRcImZvcm1IdG1sQ2xhc3NcIjogXCJoMyB0aXRsZSBoZWFkaW5nXCJcclxuXHRcdFx0XHRcdCAgfSxcclxuXHRcdFx0XHRcdCAgXCJudXRyLXZhbHNbXS52YWx1ZVwiLFxyXG5cdFx0XHRcdFx0ICBcIm51dHItdmFsc1tdLnVuaXRcIlxyXG5cdFx0XHRcdFx0IF1cclxuXHRcdFx0XHQgIH1cclxuXHRcdFx0XHRdXHJcblx0XHRcdCAgfVxyXG5cdFx0XHR9XHRcdCAgXHJcblx0XHQgIF1cclxuXHRcdH1cclxuICAgICAgICAvKntcclxuICAgICAgICAgIFwidHlwZVwiOiBcInRhYmFycmF5XCIsXHJcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VjdGlvblwiLFxyXG5cdFx0XHRcImxlZ2VuZFwiOiBcInt7dmFsdWV9fVwiLFxyXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFtcclxuXHRcdFx0ICB7XHJcblx0XHRcdCAgICBcImtleVwiOiBcIm51dHItdmFsc1tdXCIsXHJcblx0XHRcdCAgICBcInZhbHVlSW5MZWdlbmRcIjogXCJ0cnVlXCJcclxuXHRcdFx0ICB9XHRcdFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSovLyosXHJcblx0XHQvLyBIaWRkZW4gc3VibWl0IGJ1dHRvblxyXG5cdFx0e1xyXG5cdFx0ICBcInR5cGVcIjogXCJzdWJtaXRcIixcclxuXHRcdCAgXCJ0aXRsZVwiOiBcIkhpZGRlbiBCdXR0b24hXCIsXHJcblx0XHQgIFwiaHRtbENsYXNzXCI6IFwiaGlkZVwiXHJcblx0XHR9Ki9cclxuXHQgIF1cclxuICAgIH1cclxuICBdLFxyXG4gIFxyXG4gIFwidmFsdWVcIjogbnVsbCxcclxuICBcclxuICAvLyBOb3QgcmVhbGx5IG5lY2Vzc2FyeSB0byBzZXQgYXMgZGVmYXVsdCBpcyB0cnVlIGFueXdheVxyXG4gIFwidmFsaWRhdGVcIjogdHJ1ZSxcclxuICBcclxuICAvKlxyXG4gIFwib25TdWJtaXRcIjogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAvL2FsZXJ0KFwib25TdWJtaXQgd2FzIGNhbGxlZCFcIik7XHJcblx0Ly8gTm90aGluZyB0byBkb1xyXG4gIH1cclxuICAqL1xyXG5cclxuICBcIm9uU3VibWl0VmFsaWRcIjogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAvL2FsZXJ0KFwib25TdWJtaXRWYWxpZCB3YXMgY2FsbGVkIVwiKTtcclxuXHQvLyBOb3RoaW5nIHRvIGRvXHJcbiAgfVxyXG5cclxuXHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMucHJvYyA9IHtcclxuICBcInNjaGVtYVwiOiB7XHJcbiAgXHJcbiAgICBcIm5hbWVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgXCJ0aXRsZVwiOiBcIk5hbWUgKlwiLFxyXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWVcclxuICAgIH0sXHJcbiAgICBcImlkXCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxyXG4gICAgICBcInRpdGxlXCI6IFwiSUQgKlwiLFxyXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWVcclxuICAgIH0sXHJcblx0XCJkZXNjcmlwdGlvblwiOiB7XHJcblx0ICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG5cdCAgXCJ0aXRsZVwiOiBcIkRlc2NyaXB0aW9uXCJcclxuXHR9LFxyXG4gICAgXCJjbzItdmFsdWVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcclxuICAgICAgXCJ0aXRsZVwiOiBcIkNPMi1WYWx1ZSBba2cgQ08yJkF1bWw7cS9rZ10gKlwiLFxyXG5cdCAgXCJyZXF1aXJlZFwiOiB0cnVlXHJcbiAgICB9LFx0XHJcblx0XCJwYXJhbWV0ZXItbmFtZVwiOiB7XHJcblx0ICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuXHQgIFwidGl0bGVcIjogXCJQYXJhbWV0ZXIgTmFtZVwiXHJcblx0fSxcclxuICAgIFwicmVmZXJlbmNlc1wiOiB7XHJcbiAgICAgIFwidHlwZVwiOiBcInRleHRhcmVhXCIsXHJcbiAgICAgIFwidGl0bGVcIjogXCJSZWZlcmVuY2VzXCJcclxuICAgIH0sXHJcbiAgICBcImRvY3VtZW50YXRpb25cIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJ0ZXh0YXJlYVwiLFxyXG4gICAgICBcInRpdGxlXCI6IFwiRG9jdW1lbnRhdGlvblwiXHJcbiAgICB9LFx0XHJcbiAgICBcImlzLXN0YW5kYXJkLXByb2Nlc3MtdmFsdWVcIjoge1xyXG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXHJcbiAgICAgIFwidGl0bGVcIjogXCJJcyBTdGFuZGFyZCBQcm9jZXNzIFZhbHVlP1wiXHJcbiAgICB9LFxyXG4gICAgXCJjb21tZW50XCI6IHtcclxuICAgICAgXCJ0eXBlXCI6IFwidGV4dGFyZWFcIixcclxuICAgICAgXCJ0aXRsZVwiOiBcIkNvbW1lbnRcIlxyXG4gICAgfVx0XHJcbiAgfSxcclxuICBcclxuICBcImZvcm1cIjoge1xyXG4gIFxyXG4gICAgICAgIFwidHlwZVwiOiBcImZpZWxkc2V0XCIsXHJcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkJhc2ljXCIsXHJcbiAgICAgICAgXCJleHBhbmRhYmxlXCI6IGZhbHNlLFxyXG4gICAgICAgIFwiaXRlbXNcIjogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImtleVwiOiBcIm5hbWVcIixcclxuICAgICAgICAgICAgXCJodG1sQ2xhc3NcIjogXCJoMSB0aXRsZSBoZWFkaW5nXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybUh0bWxDbGFzc1wiOiBcImgxIHRpdGxlIGhlYWRpbmdcIlxyXG4gICAgICAgICAgfSxcclxuXHRcdCAge1xyXG5cdFx0ICAgIFwia2V5XCI6IFwiaWRcIixcclxuXHRcdFx0XCJyZWFkb25seVwiOiBcInJlYWRvbmx5XCJcclxuXHRcdCAgfSxcclxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIixcclxuXHRcdCAgXCJjbzItdmFsdWVcIixcclxuXHRcdCAgXCJwYXJhbWV0ZXItbmFtZVwiLFxyXG5cdFx0ICBcInJlZmVyZW5jZXNcIixcclxuXHRcdCAgXCJkb2N1bWVudGF0aW9uXCIsXHJcblx0XHQgIFwiaXMtc3RhbmRhcmQtcHJvY2Vzcy12YWx1ZVwiLFxyXG5cdFx0ICBcImNvbW1lbnRcIlxyXG5cdFx0XVxyXG4gIH0sXHJcbiAgXHJcbiAgXCJ2YWx1ZVwiOiBudWxsLFxyXG4gIFxyXG4gIFwidmFsaWRhdGVcIjogdHJ1ZSxcclxuICBcclxuICBcIm9uU3VibWl0VmFsaWRcIjogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAvL2FsZXJ0KFwib25TdWJtaXRWYWxpZCB3YXMgY2FsbGVkIVwiKTtcclxuICAgIC8vIE5vdGhpbmcgdG8gZG9cclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgb3RoZXIgSlNPTkZvcm0gZm9ybWF0IGRlZmluaXRpb25zXHJcbi8vIGV4cG9ydHMubnRyID0geyBcInNjaGVtYVwiOiB7IC4uLiB9LCBcImZvcm1cIjogWyAuLi4gXSwgXCJ2YWx1ZVwiOiBudWxsLCBcIm9uU3VibWl0VmFsaWRcIjogLi4uIH07XG59KSgpIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICBMaXF1aWQucmVhZFRlbXBsYXRlRmlsZSA9IChmdW5jdGlvbihwYXRoKSB7XHJcbiAgICB2YXIgZmlsZSA9IHRoaXMuY29sbGVjdGlvbi5maW5kV2hlcmUoeyBwYXRoOiAnX2luY2x1ZGVzLycgKyBwYXRoIH0pO1xyXG4gICAgaWYgKGZpbGUpIHtcclxuICAgICAgcmV0dXJuIGZpbGUuZ2V0Q29udGVudFN5bmMoKS5yZXNwb25zZVRleHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyAoXCJGaWxlIE5vdCBGb3VuZDpcIiArIHBhdGgpO1xyXG4gICAgfVxyXG4gIH0pLmJpbmQodGhpcyk7XHJcblxyXG4gIC8vIFRoaXMgaXMgdGhlIGluY2x1ZGUgdGFnIGZyb20gSmVreWxsIHNlZTogaHR0cDovL2dpdC5pby9Qc1ZHd2dcclxuICBMaXF1aWQuVGVtcGxhdGUucmVnaXN0ZXJUYWcoICdpbmNsdWRlJywgTGlxdWlkLlRhZy5leHRlbmQoe1xyXG5cclxuICAgIHBhcmFtU3ludGF4OiAvKFtcXHctXSspXFxzKj1cXHMqKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwifCcoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknfChbXFx3XFwuLV0rKSkvLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKHRhZywgbWFya3VwLCB0b2tlbnMpIHtcclxuICAgICAgdmFyIGZpbGVQYXJhbU1hdGNoZXMgPSAobWFya3VwIHx8ICcnKS5zdHJpcCgpLnNwbGl0KC9cXHMrKC4rKT8vKTtcclxuICAgICAgaWYgKGZpbGVQYXJhbU1hdGNoZXMpIHtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IGZpbGVQYXJhbU1hdGNoZXNbMF07XHJcbiAgICAgICAgdGhpcy5yYXdQYXJhbXMgPSBmaWxlUGFyYW1NYXRjaGVzWzFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IChcIkVycm9yIGluIHRhZyAnaW5jbHVkZSBcIiArIG1hcmt1cCArIFwiJyAtIFZhbGlkIHN5bnRheDogeyUgaW5jbHVkZSBmaWxlLmV4dCBwYXJhbT0ndmFsdWUnIHBhcmFtMj0ndmFsdWUnICV9XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3N1cGVyKHRhZywgbWFya3VwLCB0b2tlbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgdmFyIHJlc29sdmVkTmFtZSA9IHRoaXMucmV0cmlldmVfdmFyaWFibGUodGhpcy50ZW1wbGF0ZU5hbWUsIGNvbnRleHQpIHx8IHRoaXMudGVtcGxhdGVOYW1lO1xyXG4gICAgICB2YXIgdGFyZ2V0VGVtcGxhdGUgPSBMaXF1aWQucmVhZFRlbXBsYXRlRmlsZShyZXNvbHZlZE5hbWUpO1xyXG4gICAgICB2YXIgcGFydGlhbCA9IExpcXVpZC5wYXJzZSh0YXJnZXRUZW1wbGF0ZSk7XHJcblxyXG4gICAgICAvLyBMb2FkIGNvbnRleHQgd2l0aCBwYXJhbWV0ZXJzXHJcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zKHRoaXMucmF3UGFyYW1zLCBjb250ZXh0KTtcclxuICAgICAgY29udGV4dC5zZXQoJ2luY2x1ZGUnLCBwYXJhbXMpO1xyXG5cclxuICAgICAgdmFyIG91dHB1dCA9IHBhcnRpYWwucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgICBvdXRwdXQgPSBbb3V0cHV0XS5mbGF0dGVuKCkuam9pbignJyk7XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRlc3QgZm9yIHRoZSBwb3NzaWJpbGl0eSBvZiB7e3ZhcmlhYmxlfX0gYW5kIGNoZWNrIHRoZSBjb250ZXh0XHJcbiAgICByZXRyaWV2ZV92YXJpYWJsZTogZnVuY3Rpb24ocG9zc2libGVQYXRoLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IHBvc3NpYmxlUGF0aC5tYXRjaCgvXFx7XFx7KFtcXHdcXC1cXC5dKylcXH1cXH0vKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlID0gY29udGV4dC5nZXQobWF0Y2hbMV0pO1xyXG4gICAgICAgIGlmICh2YXJpYWJsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyAoXCJObyB2YXJpYWJsZSBcIiArIG1hdGNoWzFdICsgXCJ3YXMgZm91bmQgaW4gaW5jbHVkZSB0YWdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlUGFyYW1zOiBmdW5jdGlvbihyYXdQYXJhbXMsIGNvbnRleHQpIHtcclxuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICB2YXIgbWFya3VwID0gcmF3UGFyYW1zIHx8ICcnO1xyXG4gICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBtYXJrdXAubWF0Y2godGhpcy5wYXJhbVN5bnRheCkpKSB7XHJcbiAgICAgICAgLy8gQ3V0IG9mZiBjdXJyZW50IHBhcmFtZXRlclxyXG4gICAgICAgIG1hcmt1cCA9IG1hcmt1cC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFsyXS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LmdldChtYXRjaFs0XSk7IC8vIEl0cyBhIHZhcmlhYmxlIG1vc3QgbGlrZWx5XHJcbiAgICAgICAgIH1cclxuICAgICAgICBwYXJhbXNbbWF0Y2hbMV1dID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH1cclxuICB9KSk7XHJcblxyXG5cclxuICBMaXF1aWQuQmxvY2sucHJvdG90eXBlLnJlbmRlckFsbCA9IGZ1bmN0aW9uKGxpc3QsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiAobGlzdCB8fCBbXSkubWFwKGZ1bmN0aW9uKHRva2VuLCBpKXtcclxuICAgICAgdmFyIG91dHB1dCA9ICcnO1xyXG4gICAgICB0cnkgeyAvLyBobW1tLi4uIGZlZWxzIGEgbGl0dGxlIGhlYXZ5XHJcbiAgICAgICAgb3V0cHV0ID0gKCB0b2tlblsncmVuZGVyJ10gKSA/IHRva2VuLnJlbmRlcihjb250ZXh0KSA6IHRva2VuO1xyXG4gICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhjb250ZXh0LmhhbmRsZUVycm9yKGUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgTGlxdWlkLlRlbXBsYXRlLnJlZ2lzdGVyVGFnKCAnaGlnaGxpZ2h0JywgTGlxdWlkLkJsb2NrLmV4dGVuZCh7XHJcbiAgICB0YWdTeW50YXg6IC8oXFx3KykvLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKHRhZ05hbWUsIG1hcmt1cCwgdG9rZW5zKSB7XHJcbiAgICAgIHZhciBwYXJ0cyA9IG1hcmt1cC5tYXRjaCh0aGlzLnRhZ1N5bnRheCk7XHJcbiAgICAgIGlmKCBwYXJ0cyApIHtcclxuICAgICAgICB0aGlzLnRvID0gcGFydHNbMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgKFwiU3ludGF4IGVycm9yIGluICdoaWdobGlnaHQnIC0gVmFsaWQgc3ludGF4OiBoaWdodGxpZ2h0IFtsYW5ndWFnZV1cIik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc3VwZXIodGFnTmFtZSwgbWFya3VwLCB0b2tlbnMpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fc3VwZXIoY29udGV4dCk7XHJcbiAgICAgIHJldHVybiAnPHByZT4nICsgb3V0cHV0WzBdICsgJzwvcHJlPic7XHJcbiAgICB9XHJcbiAgfSkpO1xyXG5cclxuICAvLyBVbmxlc3MgdGFnIHdhc24ndCBwcm9wZXJseSByZXR1cm5pbmcgb3V0cHV0XHJcbiAgTGlxdWlkLlRlbXBsYXRlLnJlZ2lzdGVyVGFnKCAndW5sZXNzJywgTGlxdWlkLlRlbXBsYXRlLnRhZ3NbJ2lmJ10uZXh0ZW5kKHtcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgb3V0cHV0ID0gJyc7XHJcbiAgICAgIGNvbnRleHQuc3RhY2soZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgYmxvY2sgPSBzZWxmLmJsb2Nrc1swXTtcclxuICAgICAgICBpZiggIWJsb2NrLmV2YWx1YXRlKGNvbnRleHQpICkge1xyXG4gICAgICAgICAgb3V0cHV0ID0gc2VsZi5yZW5kZXJBbGwoYmxvY2suYXR0YWNobWVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGk9MTsgaSA8IHNlbGYuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgYmxvY2sgPSBzZWxmLmJsb2Nrc1tpXTtcclxuICAgICAgICAgIGlmKCBibG9jay5ldmFsdWF0ZShjb250ZXh0KSApIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gc2VsZi5yZW5kZXJBbGwoYmxvY2suYXR0YWNobWVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIFtvdXRwdXRdLmZsYXR0ZW4oKS5qb2luKCcnKTtcclxuICAgIH1cclxuICB9KSk7XHJcblxyXG4gIExpcXVpZC5CbG9jay5wcm90b3R5cGUudW5rbm93blRhZyA9IGZ1bmN0aW9uKHRhZywgcGFyYW1zLCB0b2tlbnMpIHtcclxuICAgIHN3aXRjaCh0YWcpIHtcclxuICAgICAgY2FzZSAnZWxzZSc6IGNvbnNvbGUubG9nKHRoaXMuYmxvY2tOYW1lICtcIiB0YWcgZG9lcyBub3QgZXhwZWN0IGVsc2UgdGFnXCIpOyBicmVhaztcclxuICAgICAgY2FzZSAnZW5kJzogIGNvbnNvbGUubG9nKFwiJ2VuZCcgaXMgbm90IGEgdmFsaWQgZGVsaW1pdGVyIGZvciBcIisgdGhpcy5ibG9ja05hbWUgK1wiIHRhZ3MuIHVzZSBcIisgdGhpcy5ibG9ja0RlbGltaXRlcik7IGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OiAgICAgY29uc29sZS5sb2coXCJVbmtub3duIHRhZzogXCIrIHRhZyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udGFpbnMgc2hvdWxkIHdvcmsgd2l0aCBzdHJpbmdzIG9yIGFycmF5c1xyXG4gIExpcXVpZC5Db25kaXRpb24ub3BlcmF0b3JzLmNvbnRhaW5zID0gZnVuY3Rpb24obCxyKSB7XHJcbiAgICBpZiAodHlwZW9mIGwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiBsLmluY2x1ZGUocik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gKGwuaW5kZXhPZihyKSAhPT0gLTEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRG9uJ3QgdXNlIHJlZ2V4IGZvciByZXBsYWNlIGZ1bmN0aW9ucy4gTWVzc2VzIHVwICcuJ1xyXG4gIExpcXVpZC5UZW1wbGF0ZS5yZWdpc3RlckZpbHRlcih7XHJcbiAgICByZXBsYWNlOiBmdW5jdGlvbihpbnB1dCwgc3RyaW5nLCByZXBsYWNlbWVudCkge1xyXG4gICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50IHx8ICcnO1xyXG4gICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKS5zcGxpdChzdHJpbmcpLmpvaW4ocmVwbGFjZW1lbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXBsYWNlX2ZpcnN0OiBmdW5jdGlvbihpbnB1dCwgc3RyaW5nLCByZXBsYWNlbWVudCkge1xyXG4gICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50IHx8ICcnO1xyXG4gICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKS5yZXBsYWNlKHN0cmluZywgcmVwbGFjZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGRyYWdFbnRlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgJChlLmN1cnJlbnRUYXJnZXQpLmFkZENsYXNzKCdkcmFnLW92ZXInKTtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgZHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JztcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgZHJhZ0xlYXZlOiBmdW5jdGlvbigkZWwsIGUpIHtcclxuICAgICRlbC5yZW1vdmVDbGFzcygnZHJhZy1vdmVyJyk7XHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGRyYWdEcm9wOiBmdW5jdGlvbigkZWwsIGNiKSB7XHJcbiAgICAkZWwub24oJ2RyYWdlbnRlcicsIChmdW5jdGlvbihlKSB7XHJcbiAgICAgIHRoaXMuZHJhZ0VudGVyKGUpO1xyXG4gICAgfSkuYmluZCh0aGlzKSlcclxuICAgIC5vbignZHJhZ292ZXInLCB0aGlzLmRyYWdPdmVyKTtcclxuXHJcbiAgICAkZWwuZmluZCgnI2Ryb3AnKS5vbignZHJhZ2xlYXZlJywgKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgdGhpcy5kcmFnTGVhdmUoJGVsLCBlKTtcclxuICAgIH0pLmJpbmQodGhpcykpXHJcbiAgICAub24oJ2Ryb3AnLCAoZnVuY3Rpb24oZSkge1xyXG4gICAgICB0aGlzLmRyb3AoZSwgY2IpO1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgfSxcclxuXHJcbiAgZmlsZVNlbGVjdDogZnVuY3Rpb24oZSwgY2IpIHtcclxuICAgIHZhciBmaWxlcyA9IGUudGFyZ2V0LmZpbGVzO1xyXG4gICAgdGhpcy5jb21waWxlUmVzdWx0KGZpbGVzLCBjYik7XHJcbiAgfSxcclxuXHJcbiAgZHJvcDogZnVuY3Rpb24oZSwgY2IpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICQoZS5jdXJyZW50VGFyZ2V0KS5yZW1vdmVDbGFzcygnZHJhZy1vdmVyJyk7XHJcblxyXG4gICAgZSA9IGUub3JpZ2luYWxFdmVudFxyXG4gICAgdmFyIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XHJcbiAgICB0aGlzLmNvbXBpbGVSZXN1bHQoZmlsZXMsIGNiKTtcclxuICB9LFxyXG5cclxuICBjb21waWxlUmVzdWx0OiBmdW5jdGlvbihmaWxlcywgY2IpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBmOyBmID0gZmlsZXNbaV07IGkrKykge1xyXG4gICAgICAvLyBUT0RPOiBhZGQgc2l6ZSB2YWxpZGF0aW9uLCB3YXJuID4gNTBNQiwgcmVqZWN0ID4gMTAwTUJcclxuICAgICAgLy8gaHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvd29ya2luZy13aXRoLWxhcmdlLWZpbGVzXHJcblxyXG4gICAgICAvLyBPbmx5IHVwbG9hZCBpbWFnZXNcclxuICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZmlsdGVyLCBhbGxvdyB1cGxvYWRpbmcgYW55IGJpbmFyeSBmaWxlP1xyXG4gICAgICBpZiAoL2ltYWdlLy50ZXN0KGYudHlwZSkpIHtcclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChmdW5jdGlvbihjdXJyZW50RmlsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY2IoZSwgY3VycmVudEZpbGUsIGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKGYpO1xyXG5cclxuICAgICAgICByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKGYpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICBpZDogJ25vdGlmaWNhdGlvbicsXHJcblxyXG4gIGNsYXNzTmFtZTogJ25vdGlmaWNhdGlvbiByb3VuZCcsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubm90aWZpY2F0aW9uLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjbGljayAuY3JlYXRlJzogJ2NyZWF0ZVBvc3QnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xyXG4gICAgdGhpcy5lcnJvciA9IG9wdGlvbnMuZXJyb3I7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnM7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHV0aWwuZG9jdW1lbnRUaXRsZSh0KCdkb2NoZWFkZXIuZXJyb3InKSk7XHJcblxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBkYXRhLCB7XHJcbiAgICAgIHZhcmlhYmxlOiAnZGF0YSdcclxuICAgIH0pKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBjcmVhdGVQb3N0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnLycpO1xyXG4gICAgaGFzaFsyXSA9ICduZXcnO1xyXG5cclxuICAgIHZhciBwYXRoID0gaGFzaFtoYXNoLmxlbmd0aCAtIDFdLnNwbGl0KCc/Jyk7XHJcbiAgICBoYXNoW2hhc2gubGVuZ3RoIC0gMV0gPSBwYXRoWzBdICsgJz9maWxlPScgKyBwYXRoWzBdO1xyXG5cclxuICAgIC8vIGFwcGVuZCBxdWVyeSBzdHJpbmdcclxuICAgIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgaGFzaFtoYXNoLmxlbmd0aCAtIDFdICArPSAnJicgKyBwYXRoWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJvdXRlci5uYXZpZ2F0ZShfKGhhc2gpLmNvbXBhY3QoKS5qb2luKCcvJyksIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIFJlcG9zID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvcmVwb3MnKTtcclxudmFyIE9yZ3MgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9vcmdzJyk7XHJcblxyXG4vLyBUT0RPIFBhc3MgTm90aWZpY2F0aW9uIHZpZXcgaGVyZSBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZz9cclxudmFyIE5vdGlmaWNhdGlvblZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy9ub3RpZmljYXRpb24nKTtcclxuXHJcbnZhciBhdXRoID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuLi9jb29raWUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xyXG4gICAgdGhpcy5yZXBvcyA9IG5ldyBSZXBvcyhbXSwgeyB1c2VyOiB0aGlzIH0pO1xyXG4gICAgdGhpcy5vcmdzID0gbmV3IE9yZ3MoW10sIHsgdXNlcjogdGhpcyB9KTtcclxuICB9LFxyXG5cclxuICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBtYXRjaDtcclxuXHJcbiAgICBpZiAoY29va2llLmdldCgnb2F1dGgtdG9rZW4nKSkge1xyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMuc3VjY2VzcykpIG9wdGlvbnMuc3VjY2VzcygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5tYXRjaCgvXFw/Y29kZT0oW2EtejAtOV0qKS8pO1xyXG5cclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdmFyIGFqYXggPSAkLmFqYXgoYXV0aC51cmwgKyAnL2F1dGhlbnRpY2F0ZS8nICsgbWF0Y2hbMV0sIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgY29va2llLnNldCgnb2F1dGgtdG9rZW4nLCBkYXRhLnRva2VuKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCIoPzpcXFxcLyk/XFxcXD9jb2RlPVwiICsgbWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UocmVnZXgsICcnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy5zdWNjZXNzKSkgb3B0aW9ucy5zdWNjZXNzKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLmVycm9yKSkgb3B0aW9ucy5lcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXJsOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpZCA9IGNvb2tpZS5nZXQoJ2lkJyk7XHJcbiAgICB2YXIgdG9rZW4gPSBjb29raWUuZ2V0KCdvYXV0aC10b2tlbicpO1xyXG5cclxuICAgIC8vIFJldHVybiAnL3VzZXInIGlmIGF1dGhlbnRpY2F0ZWQgYnV0IG5vIHVzZXIgaWQgY29va2llIGhhcyBiZWVuIHNldCB5ZXRcclxuICAgIC8vIG9yIGlmIHRoaXMgbW9kZWwncyBpZCBtYXRjaGVzIGF1dGhlbnRpY2F0ZWQgdXNlciBpZFxyXG4gICAgcmV0dXJuIGF1dGguYXBpICsgKCh0b2tlbiAmJiBfLmlzVW5kZWZpbmVkKGlkKSkgfHwgKGlkICYmIHRoaXMuZ2V0KCdpZCcpID09PSBpZCkgP1xyXG4gICAgICAnL3VzZXInIDogJy91c2Vycy8nICsgdGhpcy5nZXQoJ2xvZ2luJykpO1xyXG4gIH1cclxufSk7XHJcbiIsIihmdW5jdGlvbigpey8vICAgICBCYWNrYm9uZS5qcyAxLjAuMFxuXG4vLyAgICAgKGMpIDIwMTAtMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKCl7XG5cbiAgLy8gSW5pdGlhbCBTZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAoYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIGBleHBvcnRzYFxuICAvLyBvbiB0aGUgc2VydmVyKS5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAvLyBUaGUgdG9wLWxldmVsIG5hbWVzcGFjZS4gQWxsIHB1YmxpYyBCYWNrYm9uZSBjbGFzc2VzIGFuZCBtb2R1bGVzIHdpbGxcbiAgLy8gYmUgYXR0YWNoZWQgdG8gdGhpcy4gRXhwb3J0ZWQgZm9yIGJvdGggdGhlIGJyb3dzZXIgYW5kIHRoZSBzZXJ2ZXIuXG4gIHZhciBCYWNrYm9uZTtcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIEJhY2tib25lID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBCYWNrYm9uZSA9IHJvb3QuQmFja2JvbmUgPSB7fTtcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS4wLjAnO1xuXG4gIC8vIFJlcXVpcmUgVW5kZXJzY29yZSwgaWYgd2UncmUgb24gdGhlIHNlcnZlciwgYW5kIGl0J3Mgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgdmFyIF8gPSByb290Ll87XG4gIGlmICghXyAmJiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSkgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgQmFja2JvbmUuJCA9IHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQ7XG5cbiAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgQmFja2JvbmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgLy8gd2lsbCBmYWtlIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB3aWxsIGVuY29kZSB0aGUgYm9keSBhc1xuICAvLyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCBpbnN0ZWFkIGFuZCB3aWxsIHNlbmQgdGhlIG1vZGVsIGluIGFcbiAgLy8gZm9ybSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICBCYWNrYm9uZS5lbXVsYXRlSlNPTiA9IGZhbHNlO1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGN1c3RvbSBldmVudHMuIFlvdSBtYXkgYmluZCB3aXRoIGBvbmAgb3IgcmVtb3ZlIHdpdGggYG9mZmAgY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgLy8gc3VjY2Vzc2lvbi5cbiAgLy9cbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgLy8gICAgIF8uZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbiAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAvL1xuICB2YXIgRXZlbnRzID0gQmFja2JvbmUuRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBkZWZhdWx0cztcbiAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCdjJyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIG1vZGVsT3B0aW9ucykpO1xuICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IHRoaXMucGFyc2UoYXR0cnMsIG9wdGlvbnMpIHx8IHt9O1xuICAgIGlmIChkZWZhdWx0cyA9IF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKSB7XG4gICAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBkZWZhdWx0cyk7XG4gICAgfVxuICAgIHRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBIGxpc3Qgb2Ygb3B0aW9ucyB0byBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgbW9kZWwsIGlmIHByb3ZpZGVkLlxuICB2YXIgbW9kZWxPcHRpb25zID0gWyd1cmwnLCAndXJsUm9vdCcsICdjb2xsZWN0aW9uJ107XG5cbiAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcblxuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuXG4gICAgLy8gVGhlIGRlZmF1bHQgbmFtZSBmb3IgdGhlIEpTT04gYGlkYCBhdHRyaWJ1dGUgaXMgYFwiaWRcImAuIE1vbmdvREIgYW5kXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHIsIGF0dHJzLCB1bnNldCwgY2hhbmdlcywgc2lsZW50LCBjaGFuZ2luZywgcHJldiwgY3VycmVudDtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICB1bnNldCAgICAgICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgc2lsZW50ICAgICAgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICBjaGFuZ2VzICAgICAgICAgPSBbXTtcbiAgICAgIGNoYW5naW5nICAgICAgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcywgcHJldiA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb2YgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciB2YWwsIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICBpZiAoXy5pc0VxdWFsKG9sZFthdHRyXSwgKHZhbCA9IGRpZmZbYXR0cl0pKSkgY29udGludWU7XG4gICAgICAgIChjaGFuZ2VkIHx8IChjaGFuZ2VkID0ge30pKVthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBJZiB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAgLy8gbW9kZWwgZGlmZmVycyBmcm9tIGl0cyBjdXJyZW50IGF0dHJpYnV0ZXMsIHRoZXkgd2lsbCBiZSBvdmVycmlkZGVuLFxuICAgIC8vIHRyaWdnZXJpbmcgYSBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmICghbW9kZWwuc2V0KG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycywgbWV0aG9kLCB4aHIsIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhcyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgLlxuICAgICAgaWYgKGF0dHJzICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53YWl0KSAmJiAhdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgLy8gRG8gbm90IHBlcnNpc3QgaW52YWxpZCBtb2RlbHMuXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID0gXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fCBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICByZXR1cm4gYmFzZSArIChiYXNlLmNoYXJBdChiYXNlLmxlbmd0aCAtIDEpID09PSAnLycgPyAnJyA6ICcvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBfLmVhY2gobW9kZWxNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnVybCkgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgbWVyZ2U6IGZhbHNlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCBhZGRPcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgbW9kZWxzID0gXy5pc0FycmF5KG1vZGVscykgPyBtb2RlbHMuc2xpY2UoKSA6IFttb2RlbHNdO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgc2V0T3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSkgbW9kZWxzID0gdGhpcy5wYXJzZShtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFfLmlzQXJyYXkobW9kZWxzKSkgbW9kZWxzID0gbW9kZWxzID8gW21vZGVsc10gOiBbXTtcbiAgICAgIHZhciBpLCBsLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG4gICAgICB2YXIgdG9BZGQgPSBbXSwgdG9SZW1vdmUgPSBbXSwgbW9kZWxNYXAgPSB7fTtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBtb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsc1tpXSwgb3B0aW9ucykpKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZCwgcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIGFuZFxuICAgICAgICAvLyBvcHRpb25hbGx5IG1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1vZGVsLlxuICAgICAgICBpZiAoZXhpc3RpbmcgPSB0aGlzLmdldChtb2RlbCkpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5yZW1vdmUpIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChvcHRpb25zLm1lcmdlKSB7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQobW9kZWwuYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hZGQpIHtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgIC8vIExpc3RlbiB0byBhZGRlZCBtb2RlbHMnIGV2ZW50cywgYW5kIGluZGV4IG1vZGVscyBmb3IgbG9va3VwIGJ5XG4gICAgICAgICAgLy8gYGlkYCBhbmQgYnkgYGNpZGAuXG4gICAgICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG5vbmV4aXN0ZW50IG1vZGVscyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwWyhtb2RlbCA9IHRoaXMubW9kZWxzW2ldKS5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgIHNwbGljZS5hcHBseSh0aGlzLm1vZGVscywgW2F0LCAwXS5jb25jYXQodG9BZGQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHRoaXMubW9kZWxzLCB0b0FkZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBUcmlnZ2VyIGBhZGRgIGV2ZW50cy5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBgc29ydGAgaWYgdGhlIGNvbGxlY3Rpb24gd2FzIHNvcnRlZC5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0pO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29iai5pZCAhPSBudWxsID8gb2JqLmlkIDogb2JqLmNpZCB8fCBvYmpdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIG1vZGVsIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICBhdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgIC8vIGBmaWx0ZXJgLlxuICAgIHdoZXJlOiBmdW5jdGlvbihhdHRycywgZmlyc3QpIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyB2b2lkIDAgOiBbXTtcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGlmIChhdHRyc1trZXldICE9PSBtb2RlbC5nZXQoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlc1xuICAgIC8vIG9mIGBmaW5kYC5cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIEZvcmNlIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgdW5kZXJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgLy8gaXMgYWRkZWQuXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgaWYgKF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSB8fCB0aGlzLmNvbXBhcmF0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkodGhpcy5jb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvcnQoXy5iaW5kKHRoaXMuY29tcGFyYXRvciwgdGhpcykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBGaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIG1vZGVsIHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhc1xuICAgIC8vIHRvIG1haW50YWluIG9yZGVyLlxuICAgIHNvcnRlZEluZGV4OiBmdW5jdGlvbihtb2RlbCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhbHVlIHx8ICh2YWx1ZSA9IHRoaXMuY29tcGFyYXRvcik7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gXy5zb3J0ZWRJbmRleCh0aGlzLm1vZGVscywgbW9kZWwsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKSBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXNldCA/ICdyZXNldCcgOiAnc2V0JztcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdKHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKCEobW9kZWwgPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFvcHRpb25zLndhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAob3B0aW9ucy53YWl0KSBjb2xsZWN0aW9uLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBtb2RlbC5zYXZlKG51bGwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIGEgbGlzdCBvZiBtb2RlbHMgdG8gYmUgYWRkZWQgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIGl0IHRocm91Z2guXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB3aXRoIGFuIGlkZW50aWNhbCBsaXN0IG9mIG1vZGVscyBhcyB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMpO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZCB0byByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGUuIENhbGxlZCB3aGVuIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gaXMgZmlyc3QgaW5pdGlhbGl6ZWQgb3IgcmVzZXQuXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgICB0aGlzLl9ieUlkICA9IHt9O1xuICAgIH0sXG5cbiAgICAvLyBQcmVwYXJlIGEgaGFzaCBvZiBhdHRyaWJ1dGVzIChvciBvdGhlciBtb2RlbCkgdG8gYmUgYWRkZWQgdG8gdGhpc1xuICAgIC8vIGNvbGxlY3Rpb24uXG4gICAgX3ByZXBhcmVNb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChtb2RlbCAmJiBldmVudCA9PT0gJ2NoYW5nZTonICsgbW9kZWwuaWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMobW9kZWwuaWRBdHRyaWJ1dGUpXTtcbiAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gIC8vIHJpZ2h0IGhlcmU6XG4gIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2NvbGxlY3QnLCAncmVkdWNlJywgJ2ZvbGRsJyxcbiAgICAnaW5qZWN0JywgJ3JlZHVjZVJpZ2h0JywgJ2ZvbGRyJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsICdzZWxlY3QnLFxuICAgICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLCAnY29udGFpbnMnLCAnaW52b2tlJyxcbiAgICAnbWF4JywgJ21pbicsICd0b0FycmF5JywgJ3NpemUnLCAnZmlyc3QnLCAnaGVhZCcsICd0YWtlJywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgJ3RhaWwnLCAnZHJvcCcsICdsYXN0JywgJ3dpdGhvdXQnLCAnaW5kZXhPZicsICdzaHVmZmxlJywgJ2xhc3RJbmRleE9mJyxcbiAgICAnaXNFbXB0eScsICdjaGFpbiddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMubW9kZWxzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgdGFrZSBhIHByb3BlcnR5IG5hbWUgYXMgYW4gYXJndW1lbnQuXG4gIHZhciBhdHRyaWJ1dGVNZXRob2RzID0gWydncm91cEJ5JywgJ2NvdW50QnknLCAnc29ydEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXMubW9kZWxzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZShvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVyZWQgdG8gZ2xvYmFsIGxvb2t1cHMgd2hlcmUgcG9zc2libGUuXG4gICAgJDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gKipyZW5kZXIqKiBpcyB0aGUgY29yZSBmdW5jdGlvbiB0aGF0IHlvdXIgdmlldyBzaG91bGQgb3ZlcnJpZGUsIGluIG9yZGVyXG4gICAgLy8gdG8gcG9wdWxhdGUgaXRzIGVsZW1lbnQgKGB0aGlzLmVsYCksIHdpdGggdGhlIGFwcHJvcHJpYXRlIEhUTUwuIFRoZVxuICAgIC8vIGNvbnZlbnRpb24gaXMgZm9yICoqcmVuZGVyKiogdG8gYWx3YXlzIHJldHVybiBgdGhpc2AuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3IGJ5IHRha2luZyB0aGUgZWxlbWVudCBvdXQgb2YgdGhlIERPTSwgYW5kIHJlbW92aW5nIGFueVxuICAgIC8vIGFwcGxpY2FibGUgQmFja2JvbmUuRXZlbnRzIGxpc3RlbmVycy5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDaGFuZ2UgdGhlIHZpZXcncyBlbGVtZW50IChgdGhpcy5lbGAgcHJvcGVydHkpLCBpbmNsdWRpbmcgZXZlbnRcbiAgICAvLyByZS1kZWxlZ2F0aW9uLlxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICBpZiAodGhpcy4kZWwpIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgdGhpcy4kZWwgPSBlbGVtZW50IGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IGVsZW1lbnQgOiBCYWNrYm9uZS4kKGVsZW1lbnQpO1xuICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgICAgaWYgKGRlbGVnYXRlICE9PSBmYWxzZSkgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCBjYWxsYmFja3MsIHdoZXJlIGB0aGlzLmV2ZW50c2AgaXMgYSBoYXNoIG9mXG4gICAgLy9cbiAgICAvLyAqe1wiZXZlbnQgc2VsZWN0b3JcIjogXCJjYWxsYmFja1wifSpcbiAgICAvL1xuICAgIC8vICAgICB7XG4gICAgLy8gICAgICAgJ21vdXNlZG93biAudGl0bGUnOiAgJ2VkaXQnLFxuICAgIC8vICAgICAgICdjbGljayAuYnV0dG9uJzogICAgICdzYXZlJ1xuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxuICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgd2l0aCBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBlcmZvcm1zIHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gb2YgYSBWaWV3IHdpdGggYSBzZXQgb2Ygb3B0aW9ucy5cbiAgICAvLyBLZXlzIHdpdGggc3BlY2lhbCBtZWFuaW5nICooZS5nLiBtb2RlbCwgY29sbGVjdGlvbiwgaWQsIGNsYXNzTmFtZSkqIGFyZVxuICAgIC8vIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSB2aWV3LiAgU2VlIGB2aWV3T3B0aW9uc2AgZm9yIGFuIGV4aGF1c3RpdmVcbiAgICAvLyBsaXN0LlxuICAgIF9jb25maWd1cmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMpIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ29wdGlvbnMnKSwgb3B0aW9ucyk7XG4gICAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgdmlld09wdGlvbnMpKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5zeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSB0aGUgbWFubmVyIGluIHdoaWNoIEJhY2tib25lIHBlcnNpc3RzXG4gIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAvLyB0byB0aGUgbW9kZWwncyBgdXJsKClgLiBTb21lIHBvc3NpYmxlIGN1c3RvbWl6YXRpb25zIGNvdWxkIGJlOlxuICAvL1xuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgLy8gKiBTZW5kIHVwIHRoZSBtb2RlbHMgYXMgWE1MIGluc3RlYWQgb2YgSlNPTi5cbiAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gIC8vXG4gIC8vIFR1cm4gb24gYEJhY2tib25lLmVtdWxhdGVIVFRQYCBpbiBvcmRlciB0byBzZW5kIGBQVVRgIGFuZCBgREVMRVRFYCByZXF1ZXN0c1xuICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgLy8gaW5zdGVhZCBvZiBgYXBwbGljYXRpb24vanNvbmAgd2l0aCB0aGUgbW9kZWwgaW4gYSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMsIHVubGVzcyBzcGVjaWZpZWQuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgSlNPTi1yZXF1ZXN0IG9wdGlvbnMuXG4gICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsICYmIG1vZGVsICYmIChtZXRob2QgPT09ICdjcmVhdGUnIHx8IG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHwgbWV0aG9kID09PSAncGF0Y2gnKSkge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAvLyBBbmQgYW4gYFgtSFRUUC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHBhcmFtcy5kYXRhLl9tZXRob2QgPSB0eXBlO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBvcHRpb25zLmJlZm9yZVNlbmQ7XG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCB0eXBlKTtcbiAgICAgICAgaWYgKGJlZm9yZVNlbmQpIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgIC8vIGZvciBYSFIgaW5zdGVhZC4gUmVtb3ZlIHRoaXMgbGluZSB3aGVuIGpRdWVyeSBzdXBwb3J0cyBgUEFUQ0hgIG9uIElFOC5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgd2luZG93LkFjdGl2ZVhPYmplY3QgJiZcbiAgICAgICAgICAhKHdpbmRvdy5leHRlcm5hbCAmJiB3aW5kb3cuZXh0ZXJuYWwubXNBY3RpdmVYRmlsdGVyaW5nRW5hYmxlZCkpIHtcbiAgICAgIHBhcmFtcy54aHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QsIGFsbG93aW5nIHRoZSB1c2VyIHRvIG92ZXJyaWRlIGFueSBBamF4IG9wdGlvbnMuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyID0gQmFja2JvbmUuYWpheChfLmV4dGVuZChwYXJhbXMsIG9wdGlvbnMpKTtcbiAgICBtb2RlbC50cmlnZ2VyKCdyZXF1ZXN0JywgbW9kZWwsIHhociwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHhocjtcbiAgfTtcblxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAnY3JlYXRlJzogJ1BPU1QnLFxuICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAncGF0Y2gnOiAgJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAgICdHRVQnXG4gIH07XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICBCYWNrYm9uZS5hamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlJvdXRlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAvLyBtYXRjaGVkLiBDcmVhdGluZyBhIG5ldyBvbmUgc2V0cyBpdHMgYHJvdXRlc2AgaGFzaCwgaWYgbm90IHNldCBzdGF0aWNhbGx5LlxuICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMucm91dGVzKSB0aGlzLnJvdXRlcyA9IG9wdGlvbnMucm91dGVzO1xuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICB0aGlzLnJvdXRlKCdzZWFyY2gvOnF1ZXJ5L3A6bnVtJywgJ3NlYXJjaCcsIGZ1bmN0aW9uKHF1ZXJ5LCBudW0pIHtcbiAgICAvLyAgICAgICAuLi5cbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmFwcGx5KHJvdXRlciwgYXJncyk7XG4gICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIoJ3JvdXRlJywgbmFtZSwgYXJncyk7XG4gICAgICAgIEJhY2tib25lLmhpc3RvcnkudHJpZ2dlcigncm91dGUnLCByb3V0ZXIsIG5hbWUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpe1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteXFwvXSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoLio/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnJCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYEhpc3RvcnlgIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cbiAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gIHZhciByb290U3RyaXBwZXIgPSAvXlxcLyt8XFwvKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIGRldGVjdGluZyBNU0lFLlxuICB2YXIgaXNFeHBsb3JlciA9IC9tc2llIFtcXHcuXSsvO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgcmVtb3ZpbmcgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50LCBlaXRoZXIgZnJvbSB0aGUgVVJMLFxuICAgIC8vIHRoZSBoYXNoLCBvciB0aGUgb3ZlcnJpZGUuXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50LCBmb3JjZVB1c2hTdGF0ZSkge1xuICAgICAgaWYgKGZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSB8fCAhdGhpcy5fd2FudHNIYXNoQ2hhbmdlIHx8IGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xuICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSkgZnJhZ21lbnQgPSBmcmFnbWVudC5zdWJzdHIocm9vdC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlKHJvdXRlU3RyaXBwZXIsICcnKTtcbiAgICB9LFxuXG4gICAgLy8gU3RhcnQgdGhlIGhhc2ggY2hhbmdlIGhhbmRsaW5nLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgLy8gYW4gZXhpc3Rpbmcgcm91dGUsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKEhpc3Rvcnkuc3RhcnRlZCkgdGhyb3cgbmV3IEVycm9yKFwiQmFja2JvbmUuaGlzdG9yeSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWRcIik7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHt9LCB7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucm9vdCAgICAgICAgICAgICA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlICAgID0gISEodGhpcy5vcHRpb25zLnB1c2hTdGF0ZSAmJiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB2YXIgZnJhZ21lbnQgICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG4gICAgICB2YXIgZG9jTW9kZSAgICAgICAgICAgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgICB2YXIgb2xkSUUgICAgICAgICAgICAgPSAoaXNFeHBsb3Jlci5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgJiYgKCFkb2NNb2RlIHx8IGRvY01vZGUgPD0gNykpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgIGlmIChvbGRJRSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBCYWNrYm9uZS4kKCc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIHRhYmluZGV4PVwiLTFcIiAvPicpLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgdmFyIGF0Um9vdCA9IGxvYy5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZCBicm93c2VyLFxuICAgICAgLy8gYnV0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuLi5cbiAgICAgIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5fd2FudHNQdXNoU3RhdGUgJiYgIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhYXRSb290KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2UodGhpcy5yb290ICsgdGhpcy5sb2NhdGlvbi5zZWFyY2ggKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNQdXNoU3RhdGUgJiYgdGhpcy5faGFzUHVzaFN0YXRlICYmIGF0Um9vdCAmJiBsb2MuaGFzaCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCkucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50ICsgbG9jLnNlYXJjaCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCkgfHwgdGhpcy5sb2FkVXJsKHRoaXMuZ2V0SGFzaCgpKTtcbiAgICB9LFxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxuICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICBsb2FkVXJsOiBmdW5jdGlvbihmcmFnbWVudE92ZXJyaWRlKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudE92ZXJyaWRlKTtcbiAgICAgIHZhciBtYXRjaGVkID0gXy5hbnkodGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFuZGxlci5yb3V0ZS50ZXN0KGZyYWdtZW50KSkge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiBvcHRpb25zfTtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJyk7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciB1cmwgPSB0aGlzLnJvb3QgKyBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpKSkge1xuICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgb24gaGFzaC10YWcgY2hhbmdlLiAgV2hlbiByZXBsYWNlIGlzIHRydWUsIHdlIGRvbid0XG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgIGlmKCFvcHRpb25zLnJlcGxhY2UpIHRoaXMuaWZyYW1lLmRvY3VtZW50Lm9wZW4oKS5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5pZnJhbWUubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgIGlmIChwcm90b1Byb3BzKSBfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIG1vZGVsLnRyaWdnZXIoJ2Vycm9yJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pKCkiLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxudmFyIGNocm9ubyA9IHJlcXVpcmUoJ2Nocm9ubycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gIC8vIENsZWFucyB1cCBhIHN0cmluZyBmb3IgdXNlIGluIHVybHNcclxuICBzdHJpbmdUb1VybDogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAvLyBDaGFuZ2Ugbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIHRvIGRhc2hlcywgdHJpbSBleGNlc3MgZGFzaGVzXHJcbiAgICByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldKy9nLCAnLScpLnJlcGxhY2UoLy0qJC8sICcnKTtcclxuICB9LFxyXG5cclxuICAvLyBFeHRyYWN0IGEgSmVreWxsIGRhdGUgZm9ybWF0IGZyb20gYSBmaWxlbmFtZVxyXG4gIGV4dHJhY3REYXRlOiBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Lyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xyXG4gIH0sXHJcblxyXG4gIC8vIEV4dHJhY3QgZmlsZW5hbWUgZnJvbSBhIGdpdmVuIHBhdGhcclxuICAvLyAtLS0tLS0tXHJcbiAgLy9cclxuICAvLyB0aGlzLmV4dHJhY3RGaWxlbmFtZSgncGF0aC90by9mb28ubWQnKVxyXG4gIC8vID0+IFsncGF0aC90bycsICdmb28ubWQnXVxyXG5cclxuICBleHRyYWN0RmlsZW5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHZhciByZWdleCA9IC9cXC8vO1xyXG4gICAgaWYgKCFyZWdleC50ZXN0KHBhdGgpKSByZXR1cm4gWycnLCBwYXRoXTtcclxuICAgIHZhciBtYXRjaGVzID0gcGF0aC5tYXRjaCgvKC4qKVxcLyguKikkLyk7XHJcbiAgICByZXR1cm4gW21hdGNoZXNbMV0sIG1hdGNoZXNbMl1dO1xyXG4gIH0sXHJcblxyXG4gIHZhbGlkUGF0aG5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHZhciByZWdleCA9IC9eKFthLXpBLVowLTlfXFwtXXxcXC4pKyQvO1xyXG4gICAgcmV0dXJuIF8uYWxsKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24oZmlsZW5hbWUpIHtcclxuICAgICAgcmV0dXJuICEhcmVnZXgudGVzdChmaWxlbmFtZSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBwYXJlbnRQYXRoOiBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8/W2EtekEtWjAtOV9cXC1dKiQvLCAnJyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gRXh0cmFjdCBwYXJ0cyBvZiB0aGUgcGF0aFxyXG4gIC8vIGludG8gYSBzdGF0ZSBmcm9tIHRoZSByb3V0ZXJcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIGV4dHJhY3RVUkw6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdXJsID0gdXJsLnNwbGl0KCcvJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbW9kZTogdXJsWzBdLFxyXG4gICAgICBicmFuY2g6IHVybFsxXSxcclxuICAgICAgcGF0aDogKHVybC5zbGljZSgyKSB8fCBbXSkuam9pbignLycpXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8vIERldGVybWluZSBtb2RlIGZvciBDb2RlTWlycm9yXHJcbiAgLy8gLS0tLS0tLVxyXG5cclxuICBtb2RlOiBmdW5jdGlvbihleHRlbnNpb24pIHtcclxuICAgIGlmICh0aGlzLmlzTWFya2Rvd24oZXh0ZW5zaW9uKSkgcmV0dXJuICdnZm0nO1xyXG4gICAgaWYgKF8uaW5jbHVkZShbJ2pzJywgJ2pzb24nXSwgZXh0ZW5zaW9uKSkgcmV0dXJuICdqYXZhc2NyaXB0JztcclxuICAgIGlmIChleHRlbnNpb24gPT09ICdodG1sJykgcmV0dXJuICdodG1sbWl4ZWQnO1xyXG4gICAgaWYgKGV4dGVuc2lvbiA9PT0gJ3JiJykgcmV0dXJuICdydWJ5JztcclxuICAgIGlmICgvKHltbHx5YW1sKS8udGVzdChleHRlbnNpb24pKSByZXR1cm4gJ3lhbWwnO1xyXG4gICAgaWYgKF8uaW5jbHVkZShbJ2phdmEnLCAnYycsICdjcHAnLCAnY3MnLCAncGhwJ10sIGV4dGVuc2lvbikpIHJldHVybiAnY2xpa2UnO1xyXG5cclxuICAgIHJldHVybiBleHRlbnNpb247XHJcbiAgfSxcclxuXHJcbiAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBmaWxlIGhhcyBZQU1MIGZyb250bWF0ZXJcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIGhhc01ldGFkYXRhOiBmdW5jdGlvbihjb250ZW50KSB7XHJcbiAgICB2YXIgcmVnZXggPSAvXigtLS1cXG4pKCgufFxcbikqPylcXG4tLS1cXG5lPy87XHJcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpOyAvLyBub3JtYWxpemUgYSBsaXR0bGUgYml0XHJcbiAgICByZXR1cm4gcmVnZXgudGVzdChjb250ZW50KTtcclxuICB9LFxyXG5cclxuICAvLyBFeHRyYWN0IGZpbGUgZXh0ZW5zaW9uXHJcbiAgLy8gLS0tLS0tLVxyXG5cclxuICBleHRlbnNpb246IGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goL1xcLihcXHcrKSQvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICB9LFxyXG5cclxuICAvLyBEb2VzIHRoZSByb290IG9mIHRoZSBwYXRoID09PSBfZHJhZnRzP1xyXG4gIC8vIC0tLS0tLS1cclxuXHJcbiAgZHJhZnQ6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHJldHVybiAocGF0aC5zcGxpdCgnLycpWzBdID09PSAnX2RyYWZ0cycpID8gdHJ1ZSA6IGZhbHNlXHJcbiAgfSxcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHR5cGVzXHJcbiAgLy8gLS0tLS0tLVxyXG5cclxuICBtYXJrZG93bjogZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgvLihtZHxta2RuP3xtZG93bnxtYXJrZG93bikkLyk7XHJcbiAgICByZXR1cm4gISEocmVnZXgudGVzdChmaWxlKSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gY2h1bmtlZCBwYXRoXHJcbiAgLy8gLS0tLS0tLVxyXG4gIC8vXHJcbiAgLy8gdGhpcy5jaHVua2VkUGF0aCgncGF0aC90by9mb28nKVxyXG4gIC8vID0+XHJcbiAgLy8gW1xyXG4gIC8vICAgeyB1cmw6ICdwYXRoJywgICAgICAgIG5hbWU6ICdwYXRoJyB9LFxyXG4gIC8vICAgeyB1cmw6ICdwYXRoL3RvJywgICAgIG5hbWU6ICd0bycgfSxcclxuICAvLyAgIHsgdXJsOiAncGF0aC90by9mb28nLCBuYW1lOiAnZm9vJyB9XHJcbiAgLy8gXVxyXG5cclxuICBjaHVua2VkUGF0aDogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgdmFyIGNodW5rcyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgIHJldHVybiBfLm1hcChjaHVua3MsIGZ1bmN0aW9uKGNodW5rLCBpbmRleCkge1xyXG4gICAgICB2YXIgdXJsID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyBpKyspIHtcclxuICAgICAgICB1cmwucHVzaChjaHVua3NbaV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiB1cmwuam9pbignLycpLFxyXG4gICAgICAgIG5hbWU6IGNodW5rXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBpc0JpbmFyeTogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIi4oanBlZ3xqcGd8Z2lmfHBuZ3xpY298ZW90fHR0Znx3b2ZmfG90Znx6aXB8c3dmfG1vdnxkYmZ8aW5kZXh8cHJqfHNocHxzaHh8RFNfU3RvcmV8Y3J4fGdseXBocykkXCIsICdpJyk7XHJcbiAgICByZXR1cm4gISEocmVnZXgudGVzdChwYXRoKSk7XHJcbiAgfSxcclxuXHJcbiAgLy9pc1Byb2Q6IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xyXG4gIC8vIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJeKHByb2QpJFwiLCAnaScpO1xyXG4gIC8vXHRyZXR1cm4gISEocmVnZXgudGVzdChleHRlbnNpb24pKTtcclxuICAvL30sXHJcbiAgXHJcbiAgaXNQcm9kOiBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiLXByb2QuanNvbiRcIiwgJ2knKTtcclxuXHRyZXR1cm4gISEocmVnZXgudGVzdChwYXRoKSk7XHJcbiAgfSxcclxuICBcclxuICBpc051dHI6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCItbnV0ci5qc29uJFwiLCAnaScpO1xyXG5cdHJldHVybiAhIShyZWdleC50ZXN0KHBhdGgpKTtcclxuICB9LCBcclxuXHJcbiAgaXNQcm9jOiBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiLXByb2MuanNvbiRcIiwgJ2knKTtcclxuXHRyZXR1cm4gISEocmVnZXgudGVzdChwYXRoKSk7XHJcbiAgfSwgXHJcbiAgXHJcbiAgaXNNYXJrZG93bjogZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiXihtZHxta2RuP3xtZG93bnxtYXJrZG93bikkXCIsICdpJyk7XHJcbiAgICByZXR1cm4gISEocmVnZXgudGVzdChleHRlbnNpb24pKTtcclxuICB9LFxyXG5cclxuICBpc01lZGlhOiBmdW5jdGlvbihleHRlbnNpb24pIHtcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJeKGpwZWd8anBnfGdpZnxwbmd8c3dmfG1vdikkXCIsICdpJyk7XHJcbiAgICByZXR1cm4gISEocmVnZXgudGVzdChleHRlbnNpb24pKTtcclxuICB9LFxyXG5cclxuICBpc0ltYWdlOiBmdW5jdGlvbihleHRlbnNpb24pIHtcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJeKGpwZWd8anBnfGdpZnxwbmd8c3ZnKikkXCIsICdpJyk7XHJcbiAgICByZXR1cm4gISEocmVnZXgudGVzdChleHRlbnNpb24pKTtcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gYSB0cnVlIG9yIGZhbHNlIGJvb2xlYW4gaWYgYSBwYXRoXHJcbiAgLy8gYSBhYnNvbHV0ZSBvciBub3QuXHJcbiAgLy8gLS0tLS0tLVxyXG5cclxuICBhYnNvbHV0ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHJldHVybiAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KHBhdGgpO1xyXG4gIH0sXHJcblxyXG4gIC8vIENvbmNhdGVuYXRlIHBhdGggKyBmaWxlIHRvIGZ1bGwgZmlsZXBhdGhcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIGZpbGVwYXRoOiBmdW5jdGlvbihwYXRoLCBmaWxlKSB7XHJcbiAgICByZXR1cm4gKHBhdGggPyBwYXRoICsgJy8nIDogJycpICsgZmlsZTtcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIGEgZmlsZW5hbWUgd2l0aG91dCB0aGUgZmlsZSBleHRlbnNpb25cclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIGZpbGVuYW1lOiBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICByZXR1cm4gZmlsZS5yZXBsYWNlKC9cXC5bXlxcLy5dKyQvLCAnJyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gU3RyaW5nIE1hbmlwdWxhdGlvbnNcclxuICAvLyAtLS0tLS0tXHJcbiAgdHJpbTogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xyXG4gIH0sXHJcblxyXG4gIGxUcmltOiBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVUkgU3R1ZmZcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIGRvY3VtZW50VGl0bGU6IGZ1bmN0aW9uKHRpdGxlKSB7XHJcbiAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlICsgJyDCtyBQcm9zZSc7XHJcbiAgfSxcclxuXHJcbiAgZml4ZWRTY3JvbGw6IGZ1bmN0aW9uKCRlbCwgb2Zmc2V0KSB7XHJcbiAgICAkKHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgdmFyIHkgPSAkKHRoaXMpLnNjcm9sbFRvcCgpO1xyXG4gICAgICBpZiAoeSA+PSBvZmZzZXQpIHtcclxuICAgICAgICAkZWwuYWRkQ2xhc3MoJ2ZpeGVkJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKCdmaXhlZCcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBwYWdlTGlzdGluZzogZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgaWYgKCQoJy5pdGVtJykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KCQoJy5pdGVtLmFjdGl2ZScpLmRhdGEoJ2luZGV4JyksIDEwKTtcclxuICAgICAgdmFyIG9mZnNldDtcclxuXHJcbiAgICAgICQoJy5pdGVtLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGluVmlldyhlbCkge1xyXG4gICAgICAgICAgdmFyIGN1clRvcCA9IGVsLm9mZnNldCgpLnRvcDtcclxuICAgICAgICAgIHZhciBzY3JlZW5IZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcbiAgICAgICAgICByZXR1cm4gKGN1clRvcCA+IHNjcmVlbkhlaWdodCkgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVQXHJcbiAgICAgIGlmIChoYW5kbGVyID09PSAnaycpIHtcclxuICAgICAgICBpZiAoaW5kZXggIT09IDApIC0taW5kZXg7XHJcbiAgICAgICAgdmFyICRwcmV2ID0gJCgnLml0ZW1bZGF0YS1pbmRleD0nICsgaW5kZXggKyAnXScpO1xyXG4gICAgICAgIHZhciBwcmV2VG9wID0gJHByZXYub2Zmc2V0KCkudG9wICsgJHByZXYuaGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIGlmICghaW5WaWV3KCRwcmV2KSkge1xyXG4gICAgICAgICAgLy8gT2Zmc2V0IGlzIHRoZSBsaXN0IGhlaWdodCBtaW51cyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZVxyXG4gICAgICAgICAgLy8gaGVpZ2h0IGFuZCAuY29udGVudC1zZWFyY2ggKDYwKSB0aGF0IGlzIGZpeGVkIGRvd24gdGhlIHBhZ2VcclxuICAgICAgICAgIG9mZnNldCA9ICRwcmV2LmhlaWdodCgpO1xyXG5cclxuICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcclxuICAgICAgICAgICAgc2Nyb2xsVG9wOiAkcHJldi5vZmZzZXQoKS50b3AgKyAoJHByZXYuaGVpZ2h0KCkgLSBvZmZzZXQpXHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICBzY3JvbGxUb3A6IDBcclxuICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJHByZXYuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgLy8gRE9XTlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpbmRleCA8ICQoJyNjb250ZW50IGxpJykubGVuZ3RoIC0gMSkgKytpbmRleDtcclxuICAgICAgICB2YXIgJG5leHQgPSAkKCcuaXRlbVtkYXRhLWluZGV4PScgKyBpbmRleCArICddJyk7XHJcbiAgICAgICAgdmFyIG5leHRUb3AgPSAkbmV4dC5vZmZzZXQoKS50b3AgKyAkbmV4dC5oZWlnaHQoKTtcclxuICAgICAgICBvZmZzZXQgPSAkbmV4dC5oZWlnaHQoKTtcclxuXHJcbiAgICAgICAgaWYgKCFpblZpZXcoJG5leHQpKSB7XHJcbiAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgICBzY3JvbGxUb3A6ICRuZXh0Lm9mZnNldCgpLnRvcCArICgkbmV4dC5oZWlnaHQoKSAtIG9mZnNldClcclxuICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJG5leHQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkKCcuaXRlbVtkYXRhLWluZGV4PTBdJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdvVG9GaWxlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwYXRoID0gJCgnLml0ZW0uYWN0aXZlJykuZGF0YSgnbmF2aWdhdGUnKTtcclxuICAgIGlmIChwYXRoKSByb3V0ZXIubmF2aWdhdGUocGF0aCwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgYXV0b1NlbGVjdDogZnVuY3Rpb24oJGVsKSB7XHJcbiAgICAkZWwub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICRlbC5zZWxlY3QoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaGVscDogW1xyXG4gICAge1xyXG4gICAgICBtZW51TmFtZTogdCgnZGlhbG9ncy5oZWxwLmJsb2NrRWxlbWVudHMudGl0bGUnKSxcclxuICAgICAgY29udGVudDogW3tcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAuYmxvY2tFbGVtZW50cy5jb250ZW50LnBhcmFncmFwaHMudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQucGFyYWdyYXBocy5jb250ZW50JylcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBtZW51TmFtZTogdCgnZGlhbG9ncy5oZWxwLmJsb2NrRWxlbWVudHMuY29udGVudC5oZWFkZXJzLnRpdGxlJyksXHJcbiAgICAgICAgICBkYXRhOiB0KCdkaWFsb2dzLmhlbHAuYmxvY2tFbGVtZW50cy5jb250ZW50LmhlYWRlcnMuY29udGVudCcpXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbWVudU5hbWU6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQuYmxvY2txdW90ZXMudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQuYmxvY2txdW90ZXMuY29udGVudCcpXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbWVudU5hbWU6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQubGlzdHMudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQubGlzdHMuY29udGVudCcpXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbWVudU5hbWU6IHQoJ2RpYWxvZ3MuaGVscC5ibG9ja0VsZW1lbnRzLmNvbnRlbnQuY29kZUJsb2Nrcy50aXRsZScpLFxyXG4gICAgICAgICAgZGF0YTogdCgnZGlhbG9ncy5oZWxwLmJsb2NrRWxlbWVudHMuY29udGVudC5jb2RlQmxvY2tzLmNvbnRlbnQnKVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAuYmxvY2tFbGVtZW50cy5jb250ZW50Lmhvcml6b250YWxSdWxlcy50aXRsZScpLFxyXG4gICAgICAgICAgZGF0YTogdCgnZGlhbG9ncy5oZWxwLmJsb2NrRWxlbWVudHMuY29udGVudC5ob3Jpem9udGFsUnVsZXMuY29udGVudCcpXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9LFxyXG5cclxuICAgIHtcclxuICAgICAgbWVudU5hbWU6IHQoJ2RpYWxvZ3MuaGVscC5zcGFuRWxlbWVudHMudGl0bGUnKSxcclxuICAgICAgY29udGVudDogW3tcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAuc3BhbkVsZW1lbnRzLmNvbnRlbnQubGlua3MudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5zcGFuRWxlbWVudHMuY29udGVudC5saW5rcy5jb250ZW50JylcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAuc3BhbkVsZW1lbnRzLmNvbnRlbnQuZW1waGFzaXMudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5zcGFuRWxlbWVudHMuY29udGVudC5lbXBoYXNpcy5jb250ZW50JylcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAuc3BhbkVsZW1lbnRzLmNvbnRlbnQuY29kZS50aXRsZScpLFxyXG4gICAgICAgICAgZGF0YTogdCgnZGlhbG9ncy5oZWxwLnNwYW5FbGVtZW50cy5jb250ZW50LmNvZGUuY29udGVudCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBtZW51TmFtZTogdCgnZGlhbG9ncy5oZWxwLnNwYW5FbGVtZW50cy5jb250ZW50LmltYWdlcy50aXRsZScpLFxyXG4gICAgICAgICAgZGF0YTogdCgnZGlhbG9ncy5oZWxwLnNwYW5FbGVtZW50cy5jb250ZW50LmltYWdlcy5jb250ZW50JylcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH0sXHJcblxyXG4gICAge1xyXG4gICAgICBtZW51TmFtZTogdCgnZGlhbG9ncy5oZWxwLm1pc2NlbGxhbmVvdXMudGl0bGUnKSxcclxuICAgICAgY29udGVudDogW3tcclxuICAgICAgICAgIG1lbnVOYW1lOiB0KCdkaWFsb2dzLmhlbHAubWlzY2VsbGFuZW91cy5jb250ZW50LmF1dG9tYXRpY0xpbmtzLnRpdGxlJyksXHJcbiAgICAgICAgICBkYXRhOiB0KCdkaWFsb2dzLmhlbHAubWlzY2VsbGFuZW91cy5jb250ZW50LmF1dG9tYXRpY0xpbmtzLmNvbnRlbnQnKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbWVudU5hbWU6IHQoJ2RpYWxvZ3MuaGVscC5taXNjZWxsYW5lb3VzLmNvbnRlbnQuZXNjYXBpbmcudGl0bGUnKSxcclxuICAgICAgICAgIGRhdGE6IHQoJ2RpYWxvZ3MuaGVscC5taXNjZWxsYW5lb3VzLmNvbnRlbnQuZXNjYXBpbmcuY29udGVudCcpXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgT3JnID0gcmVxdWlyZSgnLi4vbW9kZWxzL29yZycpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuICBtb2RlbDogT3JnLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpIHx8IHt9O1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMudXNlciA9IG9wdGlvbnMudXNlcjtcclxuICB9LFxyXG5cclxuICB1cmw6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXNlciA/IGNvbmZpZy5hcGkgKyAnL3VzZXJzLycgKyB0aGlzLnVzZXIuZ2V0KCdsb2dpbicpICsgJy9vcmdzJyA6XHJcbiAgICAgICcvdXNlci9vcmdzJztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIEJyYW5jaGVzID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvYnJhbmNoZXMnKTtcclxudmFyIENvbW1pdHMgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9jb21taXRzJyk7XHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xyXG4gICAgQmFja2JvbmUuTW9kZWwuY2FsbCh0aGlzLCB7XHJcbiAgICAgIGlkOiBhdHRyaWJ1dGVzLmlkLFxyXG4gICAgICBkZXNjcmlwdGlvbjogYXR0cmlidXRlcy5kZXNjcmlwdGlvbixcclxuICAgICAgZm9yazogYXR0cmlidXRlcy5mb3JrLFxyXG4gICAgICBob21lcGFnZTogYXR0cmlidXRlcy5ob21lcGFnZSxcclxuICAgICAgZGVmYXVsdF9icmFuY2g6IGF0dHJpYnV0ZXMuZGVmYXVsdF9icmFuY2gsXHJcbiAgICAgIG5hbWU6IGF0dHJpYnV0ZXMubmFtZSxcclxuICAgICAgb3duZXI6IHtcclxuICAgICAgICBpZDogYXR0cmlidXRlcy5vd25lci5pZCxcclxuICAgICAgICBsb2dpbjogYXR0cmlidXRlcy5vd25lci5sb2dpblxyXG4gICAgICB9LFxyXG4gICAgICBwZXJtaXNzaW9uczogYXR0cmlidXRlcy5wZXJtaXNzaW9ucyxcclxuICAgICAgcHJpdmF0ZTogYXR0cmlidXRlcy5wcml2YXRlLFxyXG4gICAgICB1cGRhdGVkX2F0OiBhdHRyaWJ1dGVzLnVwZGF0ZWRfYXRcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuYnJhbmNoZXMgPSBuZXcgQnJhbmNoZXMoW10sIHsgcmVwbzogdGhpcyB9KTtcclxuICAgIHRoaXMuY29tbWl0cyA9IG5ldyBDb21taXRzKFtdLCB7IHJlcG86IHRoaXMsIGJyYW5jaDogdGhpcy5icmFuY2ggfSlcclxuICB9LFxyXG5cclxuICByZWY6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpIHx8IHt9O1xyXG5cclxuICAgICQuYWpheCh7XHJcbiAgICAgIHR5cGU6ICdQT1NUJyxcclxuICAgICAgdXJsOiB0aGlzLnVybCgpICsgJy9naXQvcmVmcycsXHJcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICByZWY6IG9wdGlvbnMucmVmLFxyXG4gICAgICAgIHNoYTogb3B0aW9ucy5zaGFcclxuICAgICAgfSksXHJcbiAgICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcclxuICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGZvcms6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpIHx8IHt9O1xyXG5cclxuICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xyXG5cclxuICAgICQuYWpheCh7XHJcbiAgICAgIHR5cGU6ICdQT1NUJyxcclxuICAgICAgdXJsOiB0aGlzLnVybCgpICsgJy9mb3JrcycsXHJcbiAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihyZXMpIHtcclxuICAgICAgICAvLyBJbml0aWFsaXplIG5ldyBSZXBvIG1vZGVsXHJcbiAgICAgICAgLy8gVE9ETzogaXMgcmVmZXJlbmNpbmcgbW9kdWxlLmV4cG9ydHMgaW4gdGhpcyBtYW5uZXIgYWNjZXB0YWJsZT9cclxuICAgICAgICB2YXIgcmVwbyA9IG5ldyBtb2R1bGUuZXhwb3J0cyhyZXMpO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBGb3JraW5nIGlzIGFzeW5jLCByZXRyeSBpZiByZXF1ZXN0IGZhaWxzXHJcbiAgICAgICAgcmVwby5icmFuY2hlcy5mZXRjaCh7XHJcbiAgICAgICAgICBzdWNjZXNzOiAoZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSAncHJvc2UtcGF0Y2gtJztcclxuXHJcbiAgICAgICAgICAgIHZhciBicmFuY2hlcyA9IGNvbGxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldCgnbmFtZScpLmluZGV4T2YocHJlZml4KSA9PT0gMDtcclxuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1vZGVsLmdldCgnbmFtZScpLnNwbGl0KHByZWZpeClbMV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBwcmVmaXggKyAoYnJhbmNoZXMubGVuZ3RoID8gXy5tYXgoYnJhbmNoZXMpICsgMSA6IDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihzdWNjZXNzKSkgc3VjY2VzcyhyZXBvLCBicmFuY2gpO1xyXG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgICAgIGVycm9yOiBvcHRpb25zLmVycm9yXHJcbiAgICAgICAgfSlcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gY29uZmlnLmFwaSArICcvcmVwb3MvJyArIHRoaXMuZ2V0KCdvd25lcicpLmxvZ2luICsgJy8nICsgdGhpcy5nZXQoJ25hbWUnKTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgTG9hZGVyVmlldyA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XHJcbnZhciBTaWRlYmFyVmlldyA9IHJlcXVpcmUoJy4vc2lkZWJhcicpO1xyXG52YXIgTmF2VmlldyA9IHJlcXVpcmUoJy4vbmF2Jyk7XHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuLi9jb29raWUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgY2xhc3NOYW1lOiAnYXBwbGljYXRpb24nLFxyXG5cclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLmFwcCxcclxuXHJcbiAgc3Vidmlld3M6IHt9LFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjbGljayBhLmxvZ291dCc6ICdsb2dvdXQnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIGtleSgnaiwgaywgZW50ZXIsIG8nLCAoZnVuY3Rpb24oZSwgaGFuZGxlcikge1xyXG4gICAgICBpZiAodGhpcy4kZWwuZmluZCgnLmxpc3RpbmcnKVswXSkge1xyXG4gICAgICAgIGlmIChoYW5kbGVyLmtleSA9PT0gJ2onIHx8IGhhbmRsZXIua2V5ID09PSAnaycpIHtcclxuICAgICAgICAgIHV0aWwucGFnZUxpc3RpbmcoaGFuZGxlci5rZXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB1dGlsLmdvVG9GaWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXI7XHJcblxyXG4gICAgLy8gTG9hZGVyXHJcbiAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXJWaWV3KCk7XHJcbiAgICB0aGlzLnN1YnZpZXdzWydsb2FkZXInXSA9IHRoaXMubG9hZGVyO1xyXG5cclxuICAgIC8vIFNpZGViYXJcclxuICAgIHRoaXMuc2lkZWJhciA9IG5ldyBTaWRlYmFyVmlldyh7XHJcbiAgICAgIGFwcDogdGhpcyxcclxuICAgICAgdXNlcjogdGhpcy51c2VyXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3Vidmlld3NbJ3NpZGViYXInXSA9IHRoaXMuc2lkZWJhcjtcclxuXHJcbiAgICAvLyBOYXZcclxuICAgIHRoaXMubmF2ID0gbmV3IE5hdlZpZXcoe1xyXG4gICAgICBhcHA6IHRoaXMsXHJcbiAgICAgIHNpZGViYXI6IHRoaXMuc2lkZWJhcixcclxuICAgICAgdXNlcjogdGhpcy51c2VyXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3Vidmlld3NbJ25hdiddID0gdGhpcy5uYXY7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB7fSwgeyB2YXJpYWJsZTogJ2RhdGEnIH0pKTtcclxuXHJcbiAgICB0aGlzLmxvYWRlci5zZXRFbGVtZW50KHRoaXMuJGVsLmZpbmQoJyNsb2FkZXInKSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLnNpZGViYXIuc2V0RWxlbWVudCh0aGlzLiRlbC5maW5kKCcjZHJhd2VyJykpLnJlbmRlcigpO1xyXG4gICAgdGhpcy5uYXYuc2V0RWxlbWVudCh0aGlzLiRlbC5maW5kKCduYXYnKSkucmVuZGVyKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgbG9nb3V0OiBmdW5jdGlvbigpIHtcclxuICAgIGNvb2tpZS51bnNldCgnb2F1dGgtdG9rZW4nKTtcclxuICAgIGNvb2tpZS51bnNldCgnaWQnKTtcclxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5pbnZva2UodGhpcy5zdWJ2aWV3cywgJ3JlbW92ZScpO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IHt9O1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG52YXIgYXV0aCA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgaWQ6ICdzdGFydCcsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMuc3RhcnQsXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC5odG1sKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgYXV0aCwgeyB2YXJpYWJsZTogJ2F1dGgnIH0pKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBIZWFkZXJWaWV3ID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcclxudmFyIE9yZ3NWaWV3ID0gcmVxdWlyZSgnLi9zaWRlYmFyL29yZ3MnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi91dGlsJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5wcm9maWxlLFxyXG5cclxuICBzdWJ2aWV3czoge30sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuYXV0aCA9IG9wdGlvbnMuYXV0aDtcclxuICAgIHRoaXMucmVwb3MgPSBvcHRpb25zLnJlcG9zO1xyXG4gICAgdGhpcy5yb3V0ZXIgPSBvcHRpb25zLnJvdXRlcjtcclxuICAgIHRoaXMuc2VhcmNoID0gb3B0aW9ucy5zZWFyY2g7XHJcbiAgICB0aGlzLnNpZGViYXIgPSBvcHRpb25zLnNpZGViYXI7XHJcbiAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXI7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSkpO1xyXG5cclxuICAgIHRoaXMuc2VhcmNoLnNldEVsZW1lbnQodGhpcy4kZWwuZmluZCgnI3NlYXJjaCcpKS5yZW5kZXIoKTtcclxuICAgIHRoaXMucmVwb3Muc2V0RWxlbWVudCh0aGlzLiRlbC5maW5kKCcjcmVwb3MnKSk7XHJcblxyXG4gICAgdmFyIGhlYWRlciA9IG5ldyBIZWFkZXJWaWV3KHsgdXNlcjogdGhpcy51c2VyLCBhbHRlcmFibGU6IGZhbHNlIH0pO1xyXG4gICAgaGVhZGVyLnNldEVsZW1lbnQodGhpcy4kZWwuZmluZCgnI2hlYWRpbmcnKSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLnN1YnZpZXdzWydoZWFkZXInXSA9IGhlYWRlcjtcclxuXHJcbiAgICBpZiAodGhpcy5hdXRoKSB7XHJcbiAgICAgIHZhciBvcmdzID0gdGhpcy5zaWRlYmFyLmluaXRTdWJ2aWV3KCdvcmdzJywge1xyXG4gICAgICAgIG1vZGVsOiB0aGlzLmF1dGgub3JncyxcclxuICAgICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxyXG4gICAgICAgIHNpZGViYXI6IHRoaXMuc2lkZWJhcixcclxuICAgICAgICB1c2VyOiB0aGlzLnVzZXJcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnN1YnZpZXdzWydvcmdzJ10gPSBvcmdzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNpZGViYXIuY2xvc2UoKTtcclxuXHJcbiAgICBfLmludm9rZSh0aGlzLnN1YnZpZXdzLCAncmVtb3ZlJyk7XHJcbiAgICB0aGlzLnN1YnZpZXdzID0ge307XHJcblxyXG4gICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIGpzeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uL3V0aWwnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuICBpZEF0dHJpYnV0ZTogJ3BhdGgnLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmlzQ2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICEhb3B0aW9ucy5jbG9uZTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IG5ldyBEYXRlKCkuZm9ybWF0KCdZLW0tZCcpICsgJy15b3VyLWZpbGVuYW1lLm1kJztcclxuICAgIHZhciBwYXRoID0gYXR0cmlidXRlcy5wYXRoLnNwbGl0KCc/JylbMF07XHJcblxyXG4gICAgLy8gQXBwZW5kIHBsYWNlaG9sZGVyIG5hbWUgaWYgZmlsZSBpcyBuZXcgYW5kXHJcbiAgICAvLyBwYXRoIGlzIGFuIGVtcHR5IHN0cmluZywgbWF0Y2hlcyBfZHJhZnRzXHJcbiAgICAvLyBvciBtYXRjaGVzIGEgZGlyZWN0b3J5IGluIGNvbGxlY3Rpb25cclxuICAgIHZhciBkaXIgPSBhdHRyaWJ1dGVzLmNvbGxlY3Rpb24uZ2V0KHBhdGgpO1xyXG4gICAgaWYgKHRoaXMuaXNOZXcoKSAmJiAoIXBhdGggfHwgcGF0aCA9PT0gJ19kcmFmdHMnIHx8XHJcbiAgICAgIChkaXIgJiYgZGlyLmdldCgndHlwZScpID09PSAndHJlZScpKSkge1xyXG4gICAgICBwYXRoID0gcGF0aCA/IHBhdGggKyAnLycgKyB0aGlzLnBsYWNlaG9sZGVyIDogdGhpcy5wbGFjZWhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXh0ZW5zaW9uID0gdXRpbC5leHRlbnNpb24ocGF0aCk7XHJcbiAgICB2YXIgcGVybWlzc2lvbnMgPSBhdHRyaWJ1dGVzLnJlcG8gP1xyXG4gICAgICBhdHRyaWJ1dGVzLnJlcG8uZ2V0KCdwZXJtaXNzaW9ucycpIDogdW5kZWZpbmVkO1xyXG4gICAgdmFyIHR5cGU7XHJcblxyXG4gICAgdGhpcy5jb2xsZWN0aW9uID0gYXR0cmlidXRlcy5jb2xsZWN0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmV3KCkgfHwgYXR0cmlidXRlcy50eXBlID09PSAnYmxvYicpIHtcclxuICAgICAgdHlwZSA9ICdmaWxlJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHR5cGUgPSBhdHRyaWJ1dGVzLnR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXQoe1xyXG4gICAgICAnYmluYXJ5JzogdXRpbC5pc0JpbmFyeShwYXRoKSxcclxuICAgICAgJ2NvbnRlbnQnOiB0aGlzLmlzTmV3KCkgJiYgXy5pc1VuZGVmaW5lZChhdHRyaWJ1dGVzLmNvbnRlbnQpID8gdCgnbWFpbi5uZXcuYm9keScpIDogYXR0cmlidXRlcy5jb250ZW50LFxyXG4gICAgICAnY29udGVudF91cmwnOiBhdHRyaWJ1dGVzLnVybCxcclxuICAgICAgJ2RyYWZ0JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldCgncGF0aCcpO1xyXG4gICAgICAgIHJldHVybiB1dGlsLmRyYWZ0KHBhdGgpO1xyXG4gICAgICB9LFxyXG4gICAgICAnZXh0ZW5zaW9uJzogZXh0ZW5zaW9uLFxyXG4gICAgICAnbGFuZyc6IHV0aWwubW9kZShleHRlbnNpb24pLFxyXG5cdCAgLy8ncHJvZCc6IHV0aWwuaXNQcm9kKGV4dGVuc2lvbiksXHJcbiAgICAgICdwcm9kJzogdXRpbC5pc1Byb2QocGF0aCksXHJcbiAgICAgICdudXRyJzogdXRpbC5pc051dHIocGF0aCksXHJcbiAgICAgICdwcm9jJzogdXRpbC5pc1Byb2MocGF0aCksXHJcbiAgICAgICdtZWRpYSc6IHV0aWwuaXNNZWRpYShleHRlbnNpb24pLFxyXG4gICAgICAnbWFya2Rvd24nOiB1dGlsLmlzTWFya2Rvd24oZXh0ZW5zaW9uKSxcclxuICAgICAgJ25hbWUnOiB1dGlsLmV4dHJhY3RGaWxlbmFtZShwYXRoKVsxXSxcclxuICAgICAgJ29sZHBhdGgnOiBwYXRoLFxyXG4gICAgICAncGF0aCc6IHBhdGgsXHJcbiAgICAgICd0eXBlJzogdHlwZSxcclxuICAgICAgJ3dyaXRhYmxlJzogcGVybWlzc2lvbnMgPyBwZXJtaXNzaW9ucy5wdXNoIDogZmFsc2VcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGdldDogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgLy8gUmV0dXJuIHJlc3VsdCBvZiBmdW5jdGlvbnMgc2V0IG9uIG1vZGVsXHJcbiAgICB2YXIgdmFsdWUgPSBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgYXR0cik7XHJcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodGhpcykgOiB2YWx1ZTtcclxuICB9LFxyXG5cclxuICBpc05ldzogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3NoYScpID09IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2YgcmVzcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb250ZW50KHJlc3ApO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgLy8gVE9ETzogd2hpdGVsaXN0IHJlc3AgSlNPTlxyXG4gICAgICByZXR1cm4gXy5vbWl0KHJlc3AsICdjb250ZW50Jyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcGFyc2VDb250ZW50OiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XHJcbiAgICAvLyBFeHRyYWN0IFlBTUwgZnJvbSBhIHBvc3QsIHRyaW1zIHdoaXRlc3BhY2VcclxuICAgIHJlc3AgPSByZXNwLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7IC8vIG5vcm1hbGl6ZSBhIGxpdHRsZSBiaXRcclxuXHJcbiAgICB2YXIgaGFzTWV0YWRhdGEgPSAhIXV0aWwuaGFzTWV0YWRhdGEocmVzcCk7XHJcblxyXG4gICAgaWYgKCFoYXNNZXRhZGF0YSkgcmV0dXJuIHtcclxuICAgICAgY29udGVudDogcmVzcCxcclxuICAgICAgbWV0YWRhdGE6IGZhbHNlLFxyXG4gICAgICBwcmV2aW91czogcmVzcFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcmVzID0ge1xyXG4gICAgICBwcmV2aW91czogcmVzcFxyXG4gICAgfTtcclxuXHJcbiAgICByZXMuY29udGVudCA9IHJlc3AucmVwbGFjZSgvXigtLS1cXG4pKCgufFxcbikqPyktLS1cXG4/LywgZnVuY3Rpb24obWF0Y2gsIGRhc2hlcywgZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgdmFyIHJlZ2V4ID0gL3B1Ymxpc2hlZDogZmFsc2UvO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBUT0RPOiBfLmRlZmF1bHRzIGZvciBlYWNoIGtleVxyXG4gICAgICAgIHJlcy5tZXRhZGF0YSA9IGpzeWFtbC5zYWZlTG9hZChmcm9udG1hdHRlcik7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gcHVibGlzaGVkIHVubGVzcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZVxyXG4gICAgICAgIHJlcy5tZXRhZGF0YS5wdWJsaXNoZWQgPSAhcmVnZXgudGVzdChmcm9udG1hdHRlcik7XHJcbiAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0VSUk9SIGVuY29kaW5nIFlBTUwnKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9KS50cmltKCk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9LFxyXG5cclxuICBnZXRDb250ZW50OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcclxuXHJcbiAgICBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBfLmV4dGVuZChvcHRpb25zLCB7XHJcbiAgICAgIGRhdGFUeXBlOiAndGV4dCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMucmF3J1xyXG4gICAgICB9LFxyXG4gICAgICB1cmw6IHRoaXMuZ2V0KCdjb250ZW50X3VybCcpXHJcbiAgICB9KSk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0Q29udGVudFN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xyXG5cclxuICAgIHJldHVybiBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBfLmV4dGVuZChvcHRpb25zLCB7XHJcbiAgICAgIGFzeW5jOiBmYWxzZSxcclxuICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52My5yYXcnXHJcbiAgICAgIH0sXHJcbiAgICAgIHVybDogdGhpcy5nZXQoJ2NvbnRlbnRfdXJsJylcclxuICAgIH0pKTtcclxuICB9LFxyXG5cclxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXQoJ21ldGFkYXRhJyk7XHJcblxyXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpIHx8ICcnO1xyXG4gICAgdmFyIGZyb250bWF0dGVyO1xyXG5cclxuICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZyb250bWF0dGVyID0ganN5YW1sLnNhZmVEdW1wKG1ldGFkYXRhKS50cmltKCk7XHJcbiAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gWyctLS0nLCBmcm9udG1hdHRlciwgJy0tLSddLmpvaW4oJ1xcbicpICsgJ1xcblxcbicgKyBjb250ZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZW5jb2RlOiBmdW5jdGlvbihjb250ZW50KSB7XHJcbiAgICAvLyBFbmNvZGUgVVRGLTggdG8gQmFzZTY0XHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmJ0b2EjVW5pY29kZV9TdHJpbmdzXHJcbiAgICByZXR1cm4gd2luZG93LmJ0b2Eod2luZG93LnVuZXNjYXBlKHdpbmRvdy5lbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpKTtcclxuICB9LFxyXG5cclxuICBkZWNvZGU6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcclxuICAgIC8vIERlY29kZSBCYXNlNjQgdG8gVVRGLThcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuYnRvYSNVbmljb2RlX1N0cmluZ3NcclxuICAgIHJldHVybiB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5lc2NhcGUod2luZG93LmF0b2IoY29udGVudCkpKTtcclxuICB9LFxyXG5cclxuICBnZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBkYXRhID0ge307XHJcblxyXG4gICAgXy5lYWNoKHRoaXMuYXR0cmlidXRlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICBkYXRhW2tleV0gPSB0aGlzLmdldChrZXkpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgdG9KU09OIG1ldGhvZCB0byBvbmx5IHNlbmQgbmVjZXNzYXJ5IGRhdGEgdG8gR2l0SHViXHJcbiAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0KCdvbGRwYXRoJykgfHwgdGhpcy5nZXQoJ3BhdGgnKTtcclxuICAgIHZhciBjb250ZW50ID0gdGhpcy5zZXJpYWxpemUoKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgbWVzc2FnZTogdGhpcy5nZXQoJ21lc3NhZ2UnKSB8fCB0aGlzLmdldCgncGxhY2Vob2xkZXInKSxcclxuICAgICAgY29udGVudDogdGhpcy5nZXQoJ2JpbmFyeScpID8gd2luZG93LmJ0b2EoY29udGVudCkgOiB0aGlzLmVuY29kZShjb250ZW50KSxcclxuICAgICAgYnJhbmNoOiB0aGlzLmNvbGxlY3Rpb24uYnJhbmNoLmdldCgnbmFtZScpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNldCBzaGEgaWYgbW9kaWZ5aW5nIGV4aXN0aW5nIGZpbGVcclxuICAgIGlmICghdGhpcy5pc05ldygpKSBkYXRhLnNoYSA9IHRoaXMuZ2V0KCdzaGEnKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG5cclxuICBjbG9uZTogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKF8uZXh0ZW5kKF8ucGljayh0aGlzLmF0dHJpYnV0ZXMsIFtcclxuICAgICAgJ2JyYW5jaCcsXHJcbiAgICAgICdjb2xsZWN0aW9uJyxcclxuICAgICAgJ2NvbnRlbnQnLFxyXG4gICAgICAnbWV0YWRhdGEnLFxyXG4gICAgICAncmVwbydcclxuICAgIF0pLCBhdHRyaWJ1dGVzKSwgXy5leHRlbmQob3B0aW9ucywge1xyXG4gICAgICBjbG9uZTogdHJ1ZVxyXG4gICAgfSkpO1xyXG4gIH0sXHJcblxyXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcclxuXHJcbiAgICAvLyBTZXJpZXMgbmVjZXNzYXJ5IGZvciBhY2N1cmF0ZSBpc05ldygpIGNoZWNrIGluIGdldENvbnRlbnRcclxuICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLnN1Y2Nlc3MpKSBvcHRpb25zLnN1Y2Nlc3MoKTtcclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLmNvbXBsZXRlKSkgb3B0aW9ucy5jb21wbGV0ZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVE9ETzogdXNlIGRlZmZlcmVkIHRvIGZpcmUgY2FsbGJhY2tzIHdoZW4gYm90aCBmdW5jdGlvbnMgY29tcGxldGVcclxuICAgICAgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgXy5vbWl0KG9wdGlvbnMsICdzdWNjZXNzJywgJ2Vycm9yJywgJ2NvbXBsZXRlJykpO1xyXG4gICAgICB0aGlzLmdldENvbnRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBzYXZlOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcclxuXHJcbiAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuXHJcbiAgICAvLyBzZXQgbWV0aG9kIHRvIFBVVCBldmVuIHdoZW4gdGhpcy5pc05ldygpXHJcbiAgICBpZiAodGhpcy5pc05ldygpKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZChvcHRpb25zLCB7XHJcbiAgICAgICAgdHlwZTogJ1BVVCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucy5zdWNjZXNzID0gKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5zZXQoXy5leHRlbmQocmVzLmNvbnRlbnQsIHtcclxuICAgICAgICBwcmV2aW91czogdGhpcy5zZXJpYWxpemUoKVxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHN1Y2Nlc3MpKSBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9KS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIENhbGwgc2F2ZSBtZXRob2Qgd2l0aCB1bmRlZmluZWQgYXR0cmlidXRlc1xyXG4gICAgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xyXG4gIH0sXHJcblxyXG4gIHBhdGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcclxuXHJcbiAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XHJcblxyXG4gICAgdGhpcy5jb2xsZWN0aW9uLnJlcG8uZm9yayh7XHJcbiAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihyZXBvLCBicmFuY2gpIHtcclxuICAgICAgICByZXBvLnJlZih7XHJcbiAgICAgICAgICAncmVmJzogJ3JlZnMvaGVhZHMvJyArIGJyYW5jaCxcclxuICAgICAgICAgICdzaGEnOiB0aGlzLmNvbGxlY3Rpb24uYnJhbmNoLmdldCgnc2hhJyksXHJcbiAgICAgICAgICAnc3VjY2Vzcyc6IChmdW5jdGlvbihyZXMpIHtcclxuICAgICAgICAgICAgcmVwby5icmFuY2hlcy5mZXRjaCh7XHJcbiAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihjb2xsZWN0aW9uLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGJyYW5jaCA9IGNvbGxlY3Rpb24uZmluZFdoZXJlKHsgbmFtZTogYnJhbmNoIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgRmlsZSBtb2RlbCBpbiBmb3JrZWQgcmVwb1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2VyaWFsaXplIG1ldGFkYXRhLCBzZXQgcmF3IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbmV3IG1vZHVsZS5leHBvcnRzKHtcclxuICAgICAgICAgICAgICAgICAgYnJhbmNoOiBicmFuY2gsXHJcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZ2V0KCdjb250ZW50JyksXHJcbiAgICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuZ2V0KCdwYXRoJyksXHJcbiAgICAgICAgICAgICAgICAgIHJlcG86IHJlcG8sXHJcbiAgICAgICAgICAgICAgICAgIHNoYTogdGhpcy5nZXQoJ3NoYScpLFxyXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmdldCgnbWVzc2FnZScpIHx8IHRoaXMuZ2V0KCdwbGFjZWhvbGRlcicpLFxyXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5nZXQoJ21ldGFkYXRhJyksXHJcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiB0aGlzLmdldCgnZGVmYXVsdHMnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQmFja2JvbmUgZXhwZWN0cyB0aGVzZSB0byBiZSB0b3AgbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAvLyBub3QgaW4gX2F0dHJpYnV0ZXMgZm9yIHNvbWUgcmVhc29uXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBEb24ndCBhY3R1YWxseSBkbyB0aGlzLCBidXQgaGV5LCBZT0xPLlxyXG4gICAgICAgICAgICAgICAgZmlsZS5icmFuY2ggPSBicmFuY2g7XHJcbiAgICAgICAgICAgICAgICBmaWxlLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZmlsZS5jb2xsZWN0aW9uLmJyYW5jaCA9IGJyYW5jaDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gY29sbGVjdGlvbiBvbiBzYXZlXHJcbiAgICAgICAgICAgICAgICBmaWxlLnNhdmUoe1xyXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtb2RlbCBhdHRyaWJ1dGVzIGFuZCBhZGQgdG8gY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChyZXMuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoLmZpbGVzLmFkZChtb2RlbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY29sbGVjdGlvbi5yZXBvLnVybCgpICsgJy9wdWxscycsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiByZXMuY29tbWl0Lm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdUaGlzIHB1bGwgcmVxdWVzdCBoYXMgYmVlbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBwcm9zZS5pby4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLmNvbGxlY3Rpb24uYnJhbmNoLmdldCgnbmFtZScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkOiByZXBvLmdldCgnb3duZXInKS5sb2dpbiArICc6JyArIGJyYW5jaC5nZXQoJ25hbWUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgJ2Vycm9yJzogb3B0aW9ucy5lcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgdmFyIHBhdGggPSB0aGlzLmdldCgncGF0aCcpO1xyXG5cclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICBtZXNzYWdlOiB0KCdhY3Rpb25zLmNvbW1pdHMuZGVsZXRlZCcsIHsgZmlsZW5hbWU6IHBhdGggfSksXHJcbiAgICAgIHNoYTogdGhpcy5nZXQoJ3NoYScpLFxyXG4gICAgICBicmFuY2g6IHRoaXMuY29sbGVjdGlvbi5icmFuY2guZ2V0KCduYW1lJylcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHVybCA9IHRoaXMudXJsKCkuc3BsaXQoJz8nKVswXTtcclxuICAgIHZhciBwYXJhbXMgPSBfLm1hcChfLnBhaXJzKGRhdGEpLCBmdW5jdGlvbihwYXJhbSkgeyByZXR1cm4gcGFyYW0uam9pbignPScpOyB9KS5qb2luKCcmJyk7XHJcblxyXG4gICAgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBfLmV4dGVuZChvcHRpb25zLCB7XHJcbiAgICAgIHVybDogdXJsICsgJz8nICsgcGFyYW1zLFxyXG4gICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSA0MjIgVW5wcm9jZXNzYWJsZSBFbnRpdHkgZXJyb3JcclxuICAgICAgICBjb25zb2xlLmxvZyhtb2RlbCwgeGhyLCBvcHRpb25zKTtcclxuICAgICAgfSxcclxuICAgICAgd2FpdDogdHJ1ZVxyXG4gICAgfSkpO1xyXG4gIH0sXHJcblxyXG4gIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICBicmFuY2ggPSB0aGlzLmNvbGxlY3Rpb24uYnJhbmNoIHx8IHRoaXMuYnJhbmNoIHx8IHRoaXMuZ2V0KFwiYnJhbmNoXCIpO1xyXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5yZXBvLnVybCgpICsgJy9jb250ZW50cy8nICsgdGhpcy5nZXQoJ3BhdGgnKSArICc/cmVmPScgKyBicmFuY2guZ2V0KCduYW1lJyk7XHJcbiAgfSxcclxuXHJcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyBGb3IgdGVzdGluZzpcclxuICAgIC8vIGlmIChhdHRyaWJ1dGVzKSByZXR1cm4gJ3VoIG9oIHNwYWdoZXR0aSBvJ1xyXG4gICAgLy8gRmFpbCB2YWxpZGF0aW9uIGlmIHBhdGggY29uZmxpY3RzIHdpdGggYW5vdGhlciBmaWxlIGluIHJlcG9cclxuICAgIGlmICh0aGlzLmNvbGxlY3Rpb24ud2hlcmUoeyBwYXRoOiBhdHRyaWJ1dGVzLnBhdGggfSkubGVuZ3RoID4gMSkgcmV0dXJuIHQoJ2FjdGlvbnMuc2F2ZS5maWxlTmFtZUV4aXN0cycpO1xyXG5cclxuICAgIC8vIEZhaWwgdmFsaWRhdGlvbiBpZiBuYW1lIG1hdGNoZXMgZGVmYXVsdFxyXG4gICAgdmFyIG5hbWUgPSB1dGlsLmV4dHJhY3RGaWxlbmFtZSh0aGlzLmdldCgncGF0aCcpKTtcclxuICAgIGlmIChuYW1lID09PSB0aGlzLnBsYWNlaG9sZGVyKSByZXR1cm4gJ0ZpbGUgbmFtZSBpcyBkZWZhdWx0JztcclxuXHJcbiAgICAvLyBGYWlsIHZhbGlkYXRpb24gaWYgbWFya2VkIHJldHVybnMgYW4gZXJyb3JcclxuICAgIC8vIFRPRE86IGRvZXMgdGhpcyB3b3JrIGFzIGNhbGxiYWNrP1xyXG4gICAgbWFya2VkKGF0dHJpYnV0ZXMuY29udGVudCwge30sIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1xyXG4gICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5zZWFyY2gsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2tleXVwIGlucHV0JzogJ2tleXVwJ1xyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZTtcclxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB0KCdtYWluLnJlcG9zLmZpbHRlcicpO1xyXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ3JlcG8nKSBwbGFjZWhvbGRlciA9IHQoJ21haW4ucmVwby5maWx0ZXInKTtcclxuXHJcbiAgICB2YXIgc2VhcmNoID0ge1xyXG4gICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXJcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy4kZWwuZW1wdHkoKS5hcHBlbmQoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBzZWFyY2gsIHtcclxuICAgICAgdmFyaWFibGU6ICdzZWFyY2gnXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuJGVsLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLmlucHV0LmZvY3VzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBrZXl1cDogZnVuY3Rpb24oZSkge1xyXG4gICAgaWYgKGUgJiYgZS53aGljaCA9PT0gMjcpIHtcclxuICAgICAgLy8gRVNDIGtleVxyXG4gICAgICB0aGlzLmlucHV0LnZhbCgnJyk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignc2VhcmNoJyk7XHJcbiAgICB9IGVsc2UgaWYgKGUgJiYgZS53aGljaCA9PT0gNDApIHtcclxuICAgICAgLy8gRG93biBBcnJvd1xyXG4gICAgICB1dGlsLnBhZ2VMaXN0aW5nKCdkb3duJyk7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgdGhpcy5pbnB1dC5ibHVyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3NlYXJjaCcpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlYXJjaDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VhcmNoc3RyID0gdGhpcy5pbnB1dCA/IHRoaXMuaW5wdXQudmFsKCkgOiAnJztcclxuICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbHRlcihmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICByZXR1cm4gbW9kZWwuZ2V0KCduYW1lJykuaW5kZXhPZihzZWFyY2hzdHIpID4gLTE7XHJcbiAgICB9KTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgUmVwb1ZpZXcgPSByZXF1aXJlKCcuL2xpL3JlcG8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHN1YnZpZXdzOiB7fSxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnbW91c2VvdmVyIC5pdGVtJzogJ2FjdGl2ZUxpc3RpbmcnLFxyXG4gICAgJ21vdXNlb3ZlciAuaXRlbSBhJzogJ2FjdGl2ZUxpc3RpbmcnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgdGhpcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuc2VhcmNoLCAnc2VhcmNoJywgdGhpcy5yZW5kZXIpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuc2VhcmNoID8gdGhpcy5zZWFyY2guc2VhcmNoKCkgOiB0aGlzLm1vZGVsO1xyXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgY29sbGVjdGlvbi5lYWNoKChmdW5jdGlvbihyZXBvLCBpKSB7XHJcbiAgICAgIHZhciB2aWV3ID0gbmV3IFJlcG9WaWV3KHtcclxuICAgICAgICBpbmRleDogaSxcclxuICAgICAgICBtb2RlbDogcmVwb1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodmlldy5yZW5kZXIoKS5lbCk7XHJcbiAgICAgIHRoaXMuc3Vidmlld3NbcmVwby5pZF0gPSB2aWV3O1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdGhpcy4kZWwuaHRtbChmcmFnKTtcclxuXHJcbiAgICB0aGlzLiRsaXN0aW5ncyA9IHRoaXMuJGVsLmZpbmQoJy5pdGVtJyk7XHJcbiAgICB0aGlzLiRzZWFyY2ggPSB0aGlzLiRlbC5maW5kKCcjZmlsdGVyJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgYWN0aXZlTGlzdGluZzogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyICRsaXN0aW5nID0gJChlLnRhcmdldCk7XHJcblxyXG4gICAgaWYgKCEkbGlzdGluZy5oYXNDbGFzcygnaXRlbScpKSB7XHJcbiAgICAgICRsaXN0aW5nID0gJChlLnRhcmdldCkuY2xvc2VzdCgnbGknKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiRsaXN0aW5ncy5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAkbGlzdGluZy5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblxyXG4gICAgLy8gQmx1ciBvdXQgc2VhcmNoIGlmIGl0cyBzZWxlY3RlZFxyXG4gICAgdGhpcy4kc2VhcmNoLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5pbnZva2UodGhpcy5zdWJ2aWV3cywgJ3JlbW92ZScpO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IHt9O1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBVc2VyID0gcmVxdWlyZSgnLi4vbW9kZWxzL3VzZXInKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XHJcbiAgbW9kZWw6IFVzZXJcclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgY2xhc3NOYW1lOiAnaW5uZXIgZGVlcCBwcm9zZSBsaW1pdGVyJyxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KClcclxuICAgICAgLmFwcGVuZChtYXJrZWQodCgnYWJvdXQuY29udGVudCcpKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgcXVldWUgPSByZXF1aXJlKCdxdWV1ZS1hc3luYycpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgRmlsZXNWaWV3ID0gcmVxdWlyZSgnLi9maWxlcycpO1xyXG52YXIgSGVhZGVyVmlldyA9IHJlcXVpcmUoJy4vaGVhZGVyJyk7XHJcbnZhciBTZWFyY2hWaWV3ID0gcmVxdWlyZSgnLi9zZWFyY2gnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uL3V0aWwnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLnJlcG8sXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIGEubmV3JzogJ2NyZWF0ZSdcclxuICB9LFxyXG5cclxuICBzdWJ2aWV3czoge30sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuXHJcbiAgICB2YXIgYXBwID0gb3B0aW9ucy5hcHA7XHJcbiAgICBhcHAubG9hZGVyLnN0YXJ0KCk7XHJcblxyXG4gICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICB0aGlzLmJyYW5jaCA9IG9wdGlvbnMuYnJhbmNoIHx8IHRoaXMubW9kZWwuZ2V0KCdkZWZhdWx0X2JyYW5jaCcpO1xyXG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICB0aGlzLm5hdiA9IG9wdGlvbnMubmF2O1xyXG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8ICcnO1xyXG4gICAgdGhpcy5yb3V0ZXIgPSBvcHRpb25zLnJvdXRlcjtcclxuICAgIHRoaXMuc2lkZWJhciA9IG9wdGlvbnMuc2lkZWJhcjtcclxuXHJcbiAgICAvLyBJbml0IHN1YnZpZXdzXHJcbiAgICB0aGlzLmluaXRCcmFuY2hlcygpO1xyXG4gICAgdGhpcy5pbml0SGVhZGVyKCk7XHJcblxyXG4gICAgdmFyIHEgPSBxdWV1ZSgpO1xyXG4gICAgcS5kZWZlcih0aGlzLmluaXRTZWFyY2gpO1xyXG4gICAgcS5kZWZlcih0aGlzLmluaXRIaXN0b3J5KTtcclxuICAgIHEuYXdhaXRBbGwodGhpcy5pbml0RmlsZXMpO1xyXG5cclxuICAgIC8vIEV2ZW50cyBmcm9tIHNpZGViYXJcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5zaWRlYmFyLCAnZGVzdHJveScsIHRoaXMuZGVzdHJveSk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuc2lkZWJhciwgJ2NhbmNlbCcsIHRoaXMuY2FuY2VsKTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5zaWRlYmFyLCAnY29uZmlybScsIHRoaXMudXBkYXRlRmlsZSk7XHJcblxyXG4gICAgYXBwLmxvYWRlci5kb25lKCk7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB7fSwgeyB2YXJpYWJsZTogJ2RhdGEnIH0pKTtcclxuXHJcbiAgICB0aGlzLmhlYWRlci5zZXRFbGVtZW50KHRoaXMuJGVsLmZpbmQoJyNoZWFkaW5nJykpLnJlbmRlcigpO1xyXG4gICAgdGhpcy5zZWFyY2guc2V0RWxlbWVudCh0aGlzLiRlbC5maW5kKCcjc2VhcmNoJykpLnJlbmRlcigpO1xyXG4gICAgdGhpcy5maWxlcy5zZXRFbGVtZW50KHRoaXMuJGVsLmZpbmQoJyNmaWxlcycpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBpbml0SGVhZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlclZpZXcoe1xyXG4gICAgICByZXBvOiB0aGlzLm1vZGVsLFxyXG4gICAgICBhbHRlcmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnN1YnZpZXdzWydoZWFkZXInXSA9IHRoaXMuaGVhZGVyO1xyXG4gIH0sXHJcblxyXG4gIGluaXRTZWFyY2g6IGZ1bmN0aW9uKGNiKSB7XHJcbiAgICB0aGlzLnNlYXJjaCA9IG5ldyBTZWFyY2hWaWV3KHtcclxuICAgICAgbW9kZTogJ3JlcG8nXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnN1YnZpZXdzWydzZWFyY2gnXSA9IHRoaXMuc2VhcmNoO1xyXG5cclxuICAgIGlmIChfLmlzRnVuY3Rpb24oY2IpKSBjYi5hcHBseSh0aGlzKTtcclxuICB9LFxyXG5cclxuICBpbml0RmlsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlc1ZpZXcoe1xyXG4gICAgICBhcHA6IHRoaXMuYXBwLFxyXG4gICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICBicmFuY2hlczogdGhpcy5tb2RlbC5icmFuY2hlcyxcclxuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxyXG4gICAgICBuYXY6IHRoaXMubmF2LFxyXG4gICAgICBwYXRoOiB0aGlzLnBhdGgsXHJcbiAgICAgIHJlcG86IHRoaXMubW9kZWwsXHJcbiAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXIsXHJcbiAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2gsXHJcbiAgICAgIHNpZGViYXI6IHRoaXMuc2lkZWJhclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdWJ2aWV3c1snZmlsZXMnXSA9IHRoaXMuZmlsZXM7XHJcbiAgfSxcclxuXHJcbiAgaW5pdEJyYW5jaGVzOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYnJhbmNoZXMgPSB0aGlzLnNpZGViYXIuaW5pdFN1YnZpZXcoJ2JyYW5jaGVzJywge1xyXG4gICAgICBhcHA6IHRoaXMuYXBwLFxyXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbC5icmFuY2hlcyxcclxuICAgICAgcmVwbzogdGhpcy5tb2RlbCxcclxuICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaCxcclxuICAgICAgcm91dGVyOiB0aGlzLnJvdXRlcixcclxuICAgICAgc2lkZWJhcjogdGhpcy5zaWRlYmFyXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnN1YnZpZXdzWydicmFuY2hlcyddID0gdGhpcy5icmFuY2hlcztcclxuICB9LFxyXG5cclxuICBpbml0SGlzdG9yeTogZnVuY3Rpb24oY2IpIHtcclxuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuc2lkZWJhci5pbml0U3VidmlldygnaGlzdG9yeScsIHtcclxuICAgICAgYXBwOiB0aGlzLmFwcCxcclxuICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaCxcclxuICAgICAgY29tbWl0czogdGhpcy5tb2RlbC5jb21taXRzLFxyXG4gICAgICByZXBvOiB0aGlzLm1vZGVsLFxyXG4gICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxyXG4gICAgICBzaWRlYmFyOiB0aGlzLnNpZGViYXIsXHJcbiAgICAgIHZpZXc6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3Vidmlld3NbJ2hpc3RvcnknXSA9IHRoaXMuaGlzdG9yeTtcclxuXHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGNiKSkgY2IuYXBwbHkodGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZmlsZXMubmV3RmlsZSgpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNpZGViYXIuY2xvc2UoKTtcclxuXHJcbiAgICBfLmludm9rZSh0aGlzLnN1YnZpZXdzLCAncmVtb3ZlJyk7XHJcbiAgICB0aGlzLnN1YnZpZXdzID0ge307XHJcblxyXG4gICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIGNvb2tpZSA9IHJlcXVpcmUoJy4uL2Nvb2tpZScpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxudmFyIExPQ0FMRVMgPSByZXF1aXJlKCcuLi8uLi90cmFuc2xhdGlvbnMvbG9jYWxlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgY2xhc3NOYW1lOiAnaW5uZXIgZGVlcCBwcm9zZSBsaW1pdGVyJyxcclxuXHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5jaG9vc2VsYW5ndWFnZSxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnY2xpY2sgLmxhbmd1YWdlJzogJ3NldExhbmd1YWdlJyBcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNob29zZUxhbmd1YWdlcyA9IHtcclxuICAgICAgbGFuZ3VhZ2VzOiBMT0NBTEVTLFxyXG4gICAgICBhY3RpdmU6IGFwcC5sb2NhbGUgPyBhcHAubG9jYWxlIDogd2luZG93LmxvY2FsZS5fY3VycmVudFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpLmFwcGVuZChfLnRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIGNob29zZUxhbmd1YWdlcywge1xyXG4gICAgICB2YXJpYWJsZTogJ2Nob29zZUxhbmd1YWdlJ1xyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgc2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmICghJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcbiAgICAgIHZhciBjb2RlID0gJChlLnRhcmdldCkuZGF0YSgnY29kZScpO1xyXG4gICAgICBjb29raWUuc2V0KCdsYW5nJywgY29kZSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlcnMgbGFuZ3VhZ2UgaXMgc3VwcG9ydGVkXHJcbiAgICAgIGFwcC5sb2NhbGUgPSBjb2RlO1xyXG5cclxuICAgICAgaWYgKGFwcC5sb2NhbGUgJiYgYXBwLmxvY2FsZSAhPT0gJ2VuJykge1xyXG4gICAgICAgICAgJC5nZXRKU09OKCcuL3RyYW5zbGF0aW9ucy9sb2NhbGVzLycgKyBhcHAubG9jYWxlICsgJy5qc29uJywgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsZVthcHAubG9jYWxlXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxlLmN1cnJlbnQoYXBwLmxvY2FsZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVmbGVjdCBjaGFuZ2VzLiBDb3VsZCBiZSBtb3JlIGVsZWdhbnQuXHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KTtcclxuIiwiKGZ1bmN0aW9uKCl7dmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIHF1ZXVlID0gcmVxdWlyZSgncXVldWUtYXN5bmMnKTtcclxudmFyIGpzeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcclxudmFyIHBhdGNoID0gcmVxdWlyZSgnLi4vLi4vdmVuZG9yL2xpcXVpZC5wYXRjaCcpO1xyXG5cclxudmFyIE1vZGFsVmlldyA9IHJlcXVpcmUoJy4vbW9kYWwnKTtcclxudmFyIGtleSA9IHJlcXVpcmUoJ2tleW1hc3RlcicpO1xyXG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XHJcbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9maWxlJyk7XHJcbnZhciBIZWFkZXJWaWV3ID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcclxudmFyIFRvb2xiYXJWaWV3ID0gcmVxdWlyZSgnLi90b29sYmFyJyk7XHJcbnZhciBNZXRhZGF0YVZpZXcgPSByZXF1aXJlKCcuL21ldGFkYXRhJyk7XHJcbnZhciBhdXRoID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgdXBsb2FkID0gcmVxdWlyZSgnLi4vdXBsb2FkJyk7XHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuLi9jb29raWUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcblxyXG52YXIganNvbmZvcm0gPSByZXF1aXJlKCdqc29uLWZvcm0nKTtcclxudmFyIGpzb25mb3JtZm9ybWF0ID0gcmVxdWlyZSgnLi9qc29uZm9ybWZvcm1hdC5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcblxyXG4gIGpzb25Gb3JtRm9ybWF0T2JqOiBudWxsLFxyXG5cclxuICBpZDogJ3Bvc3QnLFxyXG5cclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLmZpbGUsXHJcblxyXG4gIHN1YnZpZXdzOiB7fSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHZhciBhcHAgPSBvcHRpb25zLmFwcDtcclxuICAgIGFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICAvLyBQYXRjaCBMaXF1aWRcclxuICAgIHBhdGNoLmFwcGx5KHRoaXMpO1xyXG5cclxuICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgdGhpcy5icmFuY2ggPSBvcHRpb25zLmJyYW5jaCB8fCBvcHRpb25zLnJlcG8uZ2V0KCdkZWZhdWx0X2JyYW5jaCcpO1xyXG4gICAgdGhpcy5icmFuY2hlcyA9IG9wdGlvbnMuYnJhbmNoZXM7XHJcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGU7XHJcbiAgICB0aGlzLm5hdiA9IG9wdGlvbnMubmF2O1xyXG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8ICcnO1xyXG4gICAgdGhpcy5yZXBvID0gb3B0aW9ucy5yZXBvO1xyXG4gICAgdGhpcy5yb3V0ZXIgPSBvcHRpb25zLnJvdXRlcjtcclxuICAgIHRoaXMuc2lkZWJhciA9IG9wdGlvbnMuc2lkZWJhcjtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGFjdGl2ZSBuYXYgZWxlbWVudCBlc3RhYmxpc2hlZCBieSB0aGlzLm1vZGVcclxuICAgIHRoaXMubmF2LnNldEZpbGVTdGF0ZSh0aGlzLm1vZGUpO1xyXG5cclxuICAgIC8vIEV2ZW50cyBmcm9tIHZlcnRpY2FsIG5hdlxyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm5hdiwgJ2VkaXQnLCB0aGlzLmVkaXQpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm5hdiwgJ2Jsb2InLCB0aGlzLmJsb2IpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm5hdiwgJ21ldGEnLCB0aGlzLm1ldGEpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm5hdiwgJ3NldHRpbmdzJywgdGhpcy5zZXR0aW5ncyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubmF2LCAnc2F2ZScsIHRoaXMuc2hvd0RpZmYpO1xyXG5cclxuICAgIC8vIEV2ZW50cyBmcm9tIHNpZGViYXJcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5zaWRlYmFyLCAnZGVzdHJveScsIHRoaXMuZGVzdHJveSk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuc2lkZWJhciwgJ2RyYWZ0JywgdGhpcy5kcmFmdCk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuc2lkZWJhciwgJ2NhbmNlbCcsIHRoaXMuY2FuY2VsKTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5zaWRlYmFyLCAnY29uZmlybScsIHRoaXMudXBkYXRlRmlsZSk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuc2lkZWJhciwgJ3RyYW5zbGF0ZScsIHRoaXMudHJhbnNsYXRlKTtcclxuXHJcbiAgICAvLyBTdGFzaCBlZGl0b3IgYW5kIG1ldGFkYXRhRWRpdG9yIGNvbnRlbnQgdG8gc2Vzc2lvblN0b3JhZ2Ugb24gcGFnZWhpZGUgZXZlbnRcclxuICAgIHRoaXMubGlzdGVuVG8oJCh3aW5kb3cpLCAncGFnZWhpZGUnLCB0aGlzLnN0YXNoRmlsZSk7XHJcblxyXG4gICAgLy8gUHJldmVudCBleGl0IHdoZW4gdGhlcmUgYXJlIHVuc2F2ZWQgY2hhbmdlc1xyXG4gICAgLy8galF1ZXJ5IHdvbid0IGJpbmQgdG8gJ2JlZm9yZXVubG9hZCcgZXZlbnRcclxuICAgIC8vIGUucmV0dXJuVmFsdWUgZm9yIEZpcmVmb3ggY29tcGF0aWJpbGl0eVxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvUmVmZXJlbmNlL0V2ZW50cy9iZWZvcmV1bmxvYWRcclxuICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IChmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0KCdhY3Rpb25zLnVuc2F2ZWQnKTtcclxuICAgICAgICAoZSB8fCB3aW5kb3cuZXZlbnQpLnJldHVyblZhbHVlID0gbWVzc2FnZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgIH1cclxuICAgIH0pLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5icmFuY2hlcy5mZXRjaCh7XHJcbiAgICAgIHN1Y2Nlc3M6IHRoaXMuc2V0Q29sbGVjdGlvbixcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgY29tcGxldGU6IGFwcC5sb2FkZXIuZG9uZVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgc2V0Q29sbGVjdGlvbjogZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbmRXaGVyZSh7IG5hbWU6IHRoaXMuYnJhbmNoIH0pLmZpbGVzO1xyXG4gICAgdGhpcy5jb2xsZWN0aW9uLmZldGNoKHtcclxuICAgICAgc3VjY2VzczogdGhpcy5zZXRNb2RlbCxcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgY29tcGxldGU6IHRoaXMuYXBwLmxvYWRlci5kb25lLFxyXG4gICAgICBhcmdzOiBhcmd1bWVudHNcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHNldE1vZGVsOiBmdW5jdGlvbihtb2RlbCwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICAvLyBTZXQgbW9kZWwgZWl0aGVyIGJ5IGNhbGxpbmcgZGlyZWN0bHkgZm9yIG5ldyBGaWxlIG1vZGVsc1xyXG4gICAgLy8gb3IgYnkgZmlsdGVyaW5nIGNvbGxlY3Rpb24gZm9yIGV4aXN0aW5nIEZpbGUgbW9kZWxzXHJcbiAgICBzd2l0Y2godGhpcy5tb2RlKSB7XHJcbiAgICAgIGNhc2UgJ2VkaXQnOlxyXG4gICAgICBjYXNlICdibG9iJzpcclxuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5jb2xsZWN0aW9uLmZpbmRXaGVyZSh7IHBhdGg6IHRoaXMucGF0aCB9KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncHJldmlldyc6XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuY29sbGVjdGlvbi5maW5kV2hlcmUoeyBwYXRoOiB0aGlzLnBhdGggfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1vZGVsKSB7XHJcbiAgICAgICAgICAvLyBXZSBtYXkgYmUgdHJ5aW5nIHRvIHByZXZpZXcgYSBuZXcgZmlsZSB0aGF0IG9ubHkgaGFzXHJcbiAgICAgICAgICAvLyBzdGFzaGVkIGluZm9ybWF0aW9uIGxldHMgY2hlY2sgYW5kIGNyZWF0ZSBhIGR1bW15IG1vZGVsXHJcbiAgICAgICAgICB2YXIgcHJldmlld1BhdGggPSB0aGlzLmFic29sdXRlUGF0aEZyb21Db21wb25lbnRzIChcclxuICAgICAgICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgICAgICAgdGhpcy5yZXBvLmdldCgnbmFtZScpLFxyXG4gICAgICAgICAgICB0aGlzLmJyYW5jaCxcclxuICAgICAgICAgICAgdGhpcy5wYXRoXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0U3Rhc2hGb3JQYXRoKHByZXZpZXdQYXRoKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5uZXdFbXB0eUZpbGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ25ldyc6XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMubmV3RW1wdHlGaWxlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNldCBkZWZhdWx0IG1ldGFkYXRhIGZyb20gY29sbGVjdGlvblxyXG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5jb2xsZWN0aW9uLmRlZmF1bHRzO1xyXG4gICAgdmFyIHBhdGg7XHJcbiAgICBpZiAodGhpcy5tb2RlbCkge1xyXG4gICAgICBpZiAoZGVmYXVsdHMpIHtcclxuICAgICAgICBwYXRoID0gdGhpcy5uZWFyZXN0UGF0aCh0aGlzLm1vZGVsLmdldCgncGF0aCcpLCBkZWZhdWx0cyk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ2RlZmF1bHRzJywgZGVmYXVsdHNbcGF0aF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW5kZXIgb24gY29tcGxldGUgdG8gcmVuZGVyIGV2ZW4gaWYgbW9kZWwgZG9lcyBub3QgZXhpc3Qgb24gcmVtb3RlIHlldFxyXG4gICAgICB0aGlzLm1vZGVsLmZldGNoKHtcclxuICAgICAgICBjb21wbGV0ZTogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGhpcy5hcHAubG9hZGVyLmRvbmUoKTtcclxuICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucm91dGVyLm5vdGlmeShcclxuICAgICAgICB0KCdub3RpZmljYXRpb24uZXJyb3IuZXhpc3RzJyksXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgJ3RpdGxlJzogdCgnbm90aWZpY2F0aW9uLmNyZWF0ZScpLFxyXG4gICAgICAgICAgICAnY2xhc3NOYW1lJzogJ2NyZWF0ZScsXHJcbiAgICAgICAgICAgICdsaW5rJzogJyMnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAndGl0bGUnOiB0KCdub3RpZmljYXRpb24uYmFjaycpLFxyXG4gICAgICAgICAgICAnbGluayc6ICcjJyArIF8uY29tcGFjdChbXHJcbiAgICAgICAgICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgICAgICAgICB0aGlzLnJlcG8uZ2V0KCduYW1lJyksXHJcbiAgICAgICAgICAgICAgJ3RyZWUnLFxyXG4gICAgICAgICAgICAgIHRoaXMuYnJhbmNoLFxyXG4gICAgICAgICAgICAgIHV0aWwuZXh0cmFjdEZpbGVuYW1lKHRoaXMucGF0aClbMF1cclxuICAgICAgICAgICAgXSkuam9pbignLycpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5hcHAubG9hZGVyLmRvbmUoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBuZXdFbXB0eUZpbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBGaWxlKHtcclxuICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaGVzLmZpbmRXaGVyZSh7IG5hbWU6IHRoaXMuYnJhbmNoIH0pLFxyXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb24sXHJcbiAgICAgIHBhdGg6IHRoaXMucGF0aCxcclxuICAgICAgcmVwbzogdGhpcy5yZXBvXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBuZWFyZXN0UGF0aDogZnVuY3Rpb24ocGF0aCwgZGVmYXVsdHMpIHtcclxuICAgIC8vIE1hdGNoIG5lYXJlc3QgcGFyZW50IGRpcmVjdG9yeSBkZWZhdWx0IG1ldGFkYXRhXHJcbiAgICAvLyBNYXRjaCBwYXRocyBpbiBfZHJhZnRzIHRvIGNvcnJlc3BvbmRpbmcgZGVmYXVsdHMgc2V0IGF0IF9wb3N0c1xyXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXihfZHJhZnRzKS8sICdfcG9zdHMnKTtcclxuICAgIHZhciBuZWFyZXN0RGlyID0gL1xcLz8oPyEuKlxcLykuKiQvO1xyXG5cclxuICAgIHdoaWxlICghXy5oYXMoZGVmYXVsdHMsIHBhdGgpICYmIG5lYXJlc3REaXIudGVzdChwYXRoKSAmJiBwYXRoKSB7XHJcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoIG5lYXJlc3REaXIsICcnICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfSxcclxuXHJcbiAgY3Vyc29yOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2aWV3ID0gdGhpcztcclxuICAgIHZhciBzZWxlY3Rpb24gPSB1dGlsLnRyaW0odGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xyXG5cclxuICAgIHZhciBtYXRjaCA9IHtcclxuICAgICAgbGluZUJyZWFrOiAvXFxuLyxcclxuICAgICAgaDE6IC9eI3sxfS8sXHJcbiAgICAgIGgyOiAvXiN7Mn0vLFxyXG4gICAgICBoMzogL14jezN9LyxcclxuICAgICAgaDQ6IC9eI3s0fS8sXHJcbiAgICAgIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxyXG4gICAgICBpdGFsaWM6IC9eXFxiXygoPzpfX3xbXFxzXFxTXSkrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxyXG4gICAgICBpc051bWJlcjogcGFyc2VJbnQoc2VsZWN0aW9uLmNoYXJBdCgwKSwgMTApXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghbWF0Y2guaXNOdW1iZXIpIHtcclxuICAgICAgc3dpdGNoIChzZWxlY3Rpb24uY2hhckF0KDApKSB7XHJcbiAgICAgICAgY2FzZSAnIyc6XHJcbiAgICAgICAgICBpZiAoIW1hdGNoLmxpbmVCcmVhay50ZXN0KHNlbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoLmgzLnRlc3Qoc2VsZWN0aW9uKSAmJiAhbWF0Y2guaDQudGVzdChzZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmhpZ2hsaWdodCgnc3ViLWhlYWRpbmcnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaC5oMi50ZXN0KHNlbGVjdGlvbikgJiYgIW1hdGNoLmgzLnRlc3Qoc2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMudG9vbGJhci5oaWdobGlnaHQoJ2hlYWRpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgICB0aGlzLnRvb2xiYXIuaGlnaGxpZ2h0KCdxdW90ZScpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnKic6XHJcbiAgICAgICAgY2FzZSAnXyc6XHJcbiAgICAgICAgICBpZiAoIW1hdGNoLmxpbmVCcmVhay50ZXN0KHNlbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoLnN0cm9uZy50ZXN0KHNlbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgY2hhbmdlXHJcbiAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmhpZ2hsaWdodCgnYm9sZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLml0YWxpYy50ZXN0KHNlbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIuaGlnaGxpZ2h0KCdpdGFsaWMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnISc6XHJcbiAgICAgICAgICBpZiAoIW1hdGNoLmxpbmVCcmVhay50ZXN0KHNlbGVjdGlvbikgJiZcclxuICAgICAgICAgICAgICBzZWxlY3Rpb24uY2hhckF0KDEpID09PSAnWycgJiZcclxuICAgICAgICAgICAgICBzZWxlY3Rpb24uY2hhckF0KHNlbGVjdGlvbi5sZW5ndGggLSAxKSA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmhpZ2hsaWdodCgnbWVkaWEnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgaWYgKCFtYXRjaC5saW5lQnJlYWsudGVzdChzZWxlY3Rpb24pICYmXHJcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLmNoYXJBdChzZWxlY3Rpb24ubGVuZ3RoIC0gMSkgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgIHRoaXMudG9vbGJhci5oaWdobGlnaHQoJ2xpbmsnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi5jaGFyQXQoMSkgPT09ICcgJykge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXIuaGlnaGxpZ2h0KCdsaXN0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXIpIHRoaXMudG9vbGJhci5oaWdobGlnaHQoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHNlbGVjdGlvbi5jaGFyQXQoMSkgPT09ICcuJyAmJiBzZWxlY3Rpb24uY2hhckF0KDIpID09PSAnICcpIHtcclxuICAgICAgICB0aGlzLnRvb2xiYXIuaGlnaGxpZ2h0KCdudW1iZXJlZC1saXN0Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBjb21waWxlUHJldmlldzogZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgLy8gU2NhbiB0aGUgY29udGVudCBzZWFyY2ggZm9yICFbXSgpXHJcbiAgICAvLyBncmFiIHRoZSBwYXRoIGFuZCBmaWxlIGFuZCBmb3JtIGEgUkFXIGdpdGh1YiBhYm9zbHV0ZSByZXF1ZXN0IGZvciBpdFxyXG4gICAgdmFyIHNjYW4gPSAvXFwhXFxbKFteXFxbXSopXFxdXFwoKFteXFwpXSspXFwpL2c7XHJcbiAgICB2YXIgaW1hZ2UgPSAvXFwhXFxbKFteXFxbXSopXFxdXFwoKFteXFwpXSspXFwpLztcclxuICAgIHZhciB0aXRsZUF0dHJpYnV0ZSA9IC9cIi4qP1wiLztcclxuXHJcbiAgICAvLyBCdWlsZCBhbiBhcnJheSBvZiBmb3VuZCBpbWFnZXNcclxuICAgIHZhciByZXN1bHRzID0gY29udGVudC5tYXRjaChzY2FuKTtcclxuXHJcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHJlc3VsdHMgYW5kIHJlcGxhY2VcclxuICAgIF8uZWFjaChyZXN1bHRzLCAoZnVuY3Rpb24ocikge1xyXG4gICAgICB2YXIgcGFydHMgPSAoaW1hZ2UpLmV4ZWMocik7XHJcbiAgICAgIHZhciBwYXRoO1xyXG5cclxuICAgICAgaWYgKHBhcnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhcnRzWzJdO1xyXG5cclxuICAgICAgICBpZiAoIXV0aWwuYWJzb2x1dGVQYXRoKHBhdGgpKSB7XHJcbiAgICAgICAgICAvLyBSZW1vdmUgYW55IHRpdGxlIGF0dHJpYnV0ZSBpbiB0aGUgaW1hZ2UgdGFnIGlzIHRoZXJlIGlzIG9uZS5cclxuICAgICAgICAgIGlmICh0aXRsZUF0dHJpYnV0ZS50ZXN0KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KHRpdGxlQXR0cmlidXRlKVswXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQcmVwZW5kIGRpcmVjdG9yeSBwYXRoIGlmIG5vdCBzaXRlIHJvb3QgcmVsYXRpdmVcclxuICAgICAgICAgIHBhdGggPSAvXlxcLy8udGVzdChwYXRoKSA/IHBhdGguc2xpY2UoMSkgOlxyXG4gICAgICAgICAgICB1dGlsLmV4dHJhY3RGaWxlbmFtZSh0aGlzLm1vZGVsLmdldCgncGF0aCcpKVswXSArICcvJyArIHBhdGg7XHJcblxyXG4gICAgICAgICAgdmFyIHVybCA9IGF1dGguc2l0ZSArICcvJyArIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4gKyAnLycgKyB0aGlzLnJlcG8uZ2V0KCduYW1lJykgKyAnL2Jsb2IvJyArICB0aGlzLmJyYW5jaCArICcvJyArIHdpbmRvdy5lc2NhcGUocGF0aCkgKyAnP3Jhdz10cnVlJztcclxuXHJcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHIsICchWycgKyBwYXJ0c1sxXSArICddKCcgKyB1cmwgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfSxcclxuXHJcbiAgaW5pdEpzb25Gb3JtRWRpdG9yOiBmdW5jdGlvbigpIHtcclxuIFx0XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0dmFyIGNvbnRlbnRTdHIgPSB0aGlzLm1vZGVsLmdldCgnY29udGVudCcpIHx8ICcnO1xyXG5cdFxyXG5cdC8vIFJlcGxhY2UgYWxsIGxpbmUgYnJlYWtzIGFuZCBjYXJyaWFnZSByZXR1cm5zIGluIGpzb24gaW5wdXQgdG8gYmxhbmtzXHJcblx0dmFyIGNvbnRlbnQgPSBjb250ZW50U3RyLnJlcGxhY2UoLyhcXG58XFxyKS9nLCBcIiBcIik7XHJcblx0dmFyIGNvbnRlbnRPYmogPSAkLnBhcnNlSlNPTihjb250ZW50KTtcclxuXHRcclxuXHQvLyBPbmx5IGFwcGVuZCBpZiB0YWcgZG9lcyBub3QgZXhpc3QgeWV0XHJcblx0aWYgKCQoJyNqc29uZm9ybScpLmxlbmd0aCA8PSAwKSB7XHJcblx0XHJcbiAgICAgIC8vIEltcG9ydGFudDogVGhlIGpzb25mb3JtIG91dHB1dCBtdXN0IGJlIGluc2lkZSBhIDxmb3JtPiB0YWcsIG90aGVyd2lzZVxyXG5cdCAgLy8gdGhlIG9uU3VibWl0L29uU3VibWl0VmFsaWQgSmF2YXNjcmlwdCBjb2RlIHdpbGwgbm90IHdvcmsuXHJcblx0ICAkKCcjZWRpdCcpLmFwcGVuZCgnPGZvcm0gaWQ9XCJqc29uZm9ybVwiPjwvZm9ybT4nKTtcclxuXHQgXHJcbiAgICAgIC8vIEluamVjdCB0aGUgdmFsdWUgYXR0cmlidXRlIG9idGFpbmVkIGZyb20gdGhlIHByb2QvbnV0ci9wcm9jIGZpbGVcclxuXHQgIHRoaXMuanNvbkZvcm1Gb3JtYXRPYmoudmFsdWUgPSBjb250ZW50T2JqO1xyXG5cdCAgdGhpcy5qc29uRm9ybUZvcm1hdE9iai5vblN1Ym1pdFZhbGlkID0gdGhpcy5qc29uRm9ybUZvcm1hdE9iai5vblN1Ym1pdFZhbGlkLmJpbmQoc2VsZik7XHJcblx0ICAvL3RoaXMuanNvbkZvcm1Gb3JtYXRPYmoub25TdWJtaXQgPSB0aGlzLmpzb25Gb3JtRm9ybWF0T2JqLm9uU3VibWl0LmJpbmQoc2VsZik7XHJcblx0ICBcclxuICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHJlZmVyZW5jZSBzZWxmLmpzb25Gb3JtRm9ybWF0T2JqIGluc3RlYWQgb2YgdGhpcy5qc29uRm9ybUZvcm1hdE9ialxyXG5cdCAgJCgnI2pzb25mb3JtJykuanNvbkZvcm0oc2VsZi5qc29uRm9ybUZvcm1hdE9iaik7IFxyXG5cdCAgXHJcblx0ICAvLyBXaGVuIGNsaWNraW5nIHRoZSBKU09ORm9ybSBzdWJtaXQgYnV0dG9uLCBhIGNsaWNrIGV2ZW50IGlzIGZpcnN0IHRocm93bi4gVGhyb3VnaCB0aGVcclxuXHQgIC8vIGNsaWNrIGV2ZW50LCB0aGUgbmF0aXZlIEhUTUw1IGZvcm0gdmFsaWRhdGlvbiBpcyB0cmlnZ2VyZWQuIE9ubHkgaWYgdGhlIGZvcm0gaXMgdmFsaWRcclxuXHQgIC8vIGEgc3VibWl0IGV2ZW50IGlzIHRocm93bi4gV2Ugd2FudCB0aGUgbmF0aXZlIEhUTUw1IHN0eWxlIHZhbGlkYXRpb24sIGJ1dCBub3QgSlNPTkZvcm0nc1xyXG5cdCAgLy8gc3VibWlzc2lvbi4gSW5zdGVhZCwgd2UnbGwgdXNlIFByb3NlJ3Mgc3VibWlzc2lvbi4gSGVuY2UsIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZvciB0aGVcclxuXHQgIC8vIHN1Ym1pdCBldmVudCBvbiB0aGUgZm9ybS5cclxuXHQgICQoJyNqc29uZm9ybScpLnVuYmluZCgnc3VibWl0Jyk7XHJcblx0ICAkKCcjanNvbmZvcm0nKS51bmJpbmQoJ3N1Ym1pdC5qc29uZm9ybScpO1xyXG5cdH1cclxuICB9LFxyXG4gIFxyXG4gIGluaXRCYXNlRWRpdG9yOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBsYW5nID0gdGhpcy5tb2RlbC5nZXQoJ2xhbmcnKTtcclxuXHJcbiAgICAvLyBUT0RPOiBzZXQgZGVmYXVsdCBjb250ZW50IGZvciBDb2RlTWlycm9yXHJcbiAgICB0aGlzLmVkaXRvciA9IENvZGVNaXJyb3IodGhpcy4kZWwuZmluZCgnI2NvZGUnKVswXSwge1xyXG4gICAgICBtb2RlOiBsYW5nLFxyXG4gICAgICB2YWx1ZTogdGhpcy5tb2RlbC5nZXQoJ2NvbnRlbnQnKSB8fCAnJyxcclxuICAgICAgbGluZVdyYXBwaW5nOiB0cnVlLFxyXG4gICAgICBsaW5lTnVtYmVyczogKGxhbmcgPT09ICdnZm0nIHx8IGxhbmcgPT09IG51bGwpID8gZmFsc2UgOiB0cnVlLFxyXG4gICAgICBleHRyYUtleXM6IHRoaXMua2V5TWFwKCksXHJcbiAgICAgIG1hdGNoQnJhY2tldHM6IHRydWUsXHJcbiAgICAgIGRyYWdEcm9wOiBmYWxzZSxcclxuICAgICAgdGhlbWU6ICdwcm9zZS1icmlnaHQnXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCaW5kIERyYWcgYW5kIERyb3Agd29yayBvbiB0aGUgZWRpdG9yXHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ21hcmtkb3duJykgJiYgdGhpcy5tb2RlbC5nZXQoJ3dyaXRhYmxlJykpIHtcclxuICAgICAgdXBsb2FkLmRyYWdEcm9wKHRoaXMuJGVsLCAoZnVuY3Rpb24oZSwgZmlsZSwgY29udGVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLiRlbC5maW5kKCcjZGlhbG9nJykuaGFzQ2xhc3MoJ2RpYWxvZycpKSB7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlSW5zZXJ0KGUsIGZpbGUsIGNvbnRlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDbGVhciBzZWxlY3Rpb25cclxuICAgICAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XHJcbiAgICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKCcnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgaW1hZ2VzIGxpbmtzIGluIHRoaXMudXBsb2FkKClcclxuICAgICAgICAgIHRoaXMudXBsb2FkKGUsIGZpbGUsIGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTW9uaXRvciB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIGFwcGx5XHJcbiAgICAvLyBhbiBhY3RpdmUgY2xhc3MgdG8gYW55IHNuaXBwZXQgbGlua3NcclxuICAgIGlmIChsYW5nID09PSAnZ2ZtJykge1xyXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuZWRpdG9yLCAnY3Vyc29yQWN0aXZpdHknLCB0aGlzLmN1cnNvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmVkaXRvciwgJ2NoYW5nZScsIHRoaXMubWFrZURpcnR5LCB0aGlzKTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5lZGl0b3IsICdmb2N1cycsIHRoaXMuZm9jdXMsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVmcmVzaENvZGVNaXJyb3IoKTtcclxuXHJcbiAgICAvLyBDaGVjayBzZXNzaW9uU3RvcmFnZSBmb3IgZXhpc3Rpbmcgc3Rhc2hcclxuICAgIC8vIEFwcGx5IGlmIHN0YXNoIGV4aXN0cyBhbmQgaXMgY3VycmVudCwgcmVtb3ZlIGlmIGV4cGlyZWRcclxuICAgIHRoaXMuc3Rhc2hBcHBseSgpO1xyXG4gIH0sXHJcblxyXG4gIGluaXRFZGl0b3I6IGZ1bmN0aW9uKCkge1xyXG4gXHRpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2QnKSkge1xyXG5cdCAgLy8gRWRpdG9yIGZvciBQUk9EIGZpbGVzXHJcblx0ICB0aGlzLmpzb25Gb3JtRm9ybWF0T2JqID0ganNvbmZvcm1mb3JtYXQucHJvZDtcclxuXHQgIHRoaXMuaW5pdEpzb25Gb3JtRWRpdG9yKCk7XHJcblx0fVxyXG5cdGVsc2UgaWYgKHRoaXMubW9kZWwuZ2V0KCdudXRyJykpIHtcclxuICAgICAgLy8gRWRpdG9yIGZvciBOVVRSIGZpbGVzXHJcblx0ICB0aGlzLmpzb25Gb3JtRm9ybWF0T2JqID0ganNvbmZvcm1mb3JtYXQubnV0cjtcclxuICAgICAgdGhpcy5pbml0SnNvbkZvcm1FZGl0b3IoKTtcclxuXHR9XHJcblx0ZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2MnKSkge1xyXG4gICAgICAvLyBFZGl0b3IgZm9yIFBST0MgZmlsZXNcclxuXHQgIHRoaXMuanNvbkZvcm1Gb3JtYXRPYmogPSBqc29uZm9ybWZvcm1hdC5wcm9jO1xyXG4gICAgICB0aGlzLmluaXRKc29uRm9ybUVkaXRvcigpO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHQgIC8vIEVkaXRvciBmb3IgZXZlcnl0aGluZyBlbHNlIHRoYW4gUFJPRCwgTlVUUiwgUFJPQyBmaWxlcyAoZS5nLiBtYXJrZG93biwgaHRtbCwgcGxhaW4gdGV4dC4uLilcclxuXHQgIHRoaXMuaW5pdEJhc2VFZGl0b3IoKTtcclxuXHR9XHJcbiB9LFxyXG5cclxuICBrZXlNYXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbWFya2Rvd24nKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICdDdHJsLVMnOiBmdW5jdGlvbihjb2RlbWlycm9yKSB7XHJcbiAgICAgICAgICBzZWxmLnVwZGF0ZUZpbGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdDbWQtQic6IGZ1bmN0aW9uKGNvZGVtaXJyb3IpIHtcclxuICAgICAgICAgIGlmIChzZWxmLmVkaXRvci5nZXRTZWxlY3Rpb24oKSAhPT0gJycpIHNlbGYudG9vbGJhci5ib2xkKHNlbGYuZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdDdHJsLUInOiBmdW5jdGlvbihjb2RlbWlycm9yKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkgIT09ICcnKSBzZWxmLnRvb2xiYXIuYm9sZChzZWxmLmVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnQ21kLUknOiBmdW5jdGlvbihjb2RlbWlycm9yKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkgIT09ICcnKSBzZWxmLnRvb2xiYXIuaXRhbGljKHNlbGYuZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdDdHJsLUknOiBmdW5jdGlvbihjb2RlbWlycm9yKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkgIT09ICcnKSBzZWxmLnRvb2xiYXIuaXRhbGljKHNlbGYuZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICdDdHJsLVMnOiBmdW5jdGlvbihjb2RlbWlycm9yKSB7XHJcbiAgICAgICAgICBzZWxmLnVwZGF0ZUZpbGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gSWYgYW4gdXBsb2FkIHF1ZXVlIGlzIHNldCwgd2Ugd2FudCB0byBjbGVhciBpdC5cclxuICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gSWYgYSBkaWFsb2cgd2luZG93IGlzIG9wZW4gYW5kIHRoZSBlZGl0b3IgaXMgaW4gZm9jdXMsIGNsb3NlIGl0LlxyXG4gICAgdGhpcy4kZWwuZmluZCgnLnRvb2xiYXIgLmdyb3VwIGEnKS5yZW1vdmVDbGFzcygnb24nKTtcclxuICAgIHRoaXMuJGVsLmZpbmQoJyNkaWFsb2cnKS5lbXB0eSgpLnJlbW92ZUNsYXNzKCk7XHJcbiAgfSxcclxuICBcclxuICBpbml0VG9vbGJhcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnRvb2xiYXIgPSBuZXcgVG9vbGJhclZpZXcoe1xyXG4gICAgICB2aWV3OiB0aGlzLFxyXG4gICAgICBmaWxlOiB0aGlzLm1vZGVsLFxyXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb24sXHJcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3Vidmlld3NbJ3Rvb2xiYXInXSA9IHRoaXMudG9vbGJhcjtcclxuICAgIHRoaXMudG9vbGJhci5zZXRFbGVtZW50KHRoaXMuJGVsLmZpbmQoJyN0b29sYmFyJykpLnJlbmRlcigpO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy50b29sYmFyLCAndXBkYXRlSW1hZ2VJbnNlcnQnLCB0aGlzLnVwZGF0ZUltYWdlSW5zZXJ0KTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy50b29sYmFyLCAncG9zdCcsIHRoaXMucG9zdCk7XHJcbiAgfSxcclxuXHJcbiAgdGl0bGVBc0hlYWRpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gSWYgdGhlIGZpbGUgaXMgTWFya2Rvd24sIGhhcyBtZXRhZGF0YSBmb3IgYSB0aXRsZSxcclxuICAgIC8vIHRoZSBlZGl0YWJsZSBmaWVsZCBpbiB0aGUgaGVhZGVyIHNob3VsZCBiZVxyXG4gICAgLy8gdGhlIHRpdGxlIG9mIHRoZSBNYXJrZG93biBkb2N1bWVudC5cclxuICAgIHZhciBtZXRhZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdtZXRhZGF0YScpO1xyXG5cclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbWFya2Rvd24nKSkge1xyXG5cclxuICAgICAgLy8gMS4gQSB0aXRsZSBleGlzdHMgaW4gYSBmaWxlcyBjdXJyZW50IG1ldGFkYXRhXHJcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS50aXRsZSkge1xyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YS50aXRsZTtcclxuXHJcbiAgICAgIC8vIDIuIEEgdGl0bGUgZG9lcyBub3QgZXhpc3QgYW5kIHNob3VsZCBiZSBjaGVja2VkIGluIHRoZSBkZWZhdWx0c1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwuZ2V0KCdkZWZhdWx0cycpKSB7XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0VGl0bGUgPSBfKHRoaXMubW9kZWwuZ2V0KCdkZWZhdWx0cycpKS5maW5kKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgIHJldHVybiB0Lm5hbWUgPT0gJ3RpdGxlJztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGRlZmF1bHRUaXRsZSkge1xyXG4gICAgICAgICAgaWYgKGRlZmF1bHRUaXRsZS5maWVsZCAmJiBkZWZhdWx0VGl0bGUuZmllbGQudmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUaXRsZS5maWVsZC52YWx1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyAzLiBJZiBhIHRpdGxlIGVudHJ5IGlzIGluIHRoZSBkZWZhdWx0cyBidXQgd2l0aCBub1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlLCB1c2UgYW4gdW50aXRsZWQgcGxhY2Vob2xkZXIgbWVzc2FnZS5cclxuICAgICAgICAgICAgLy8gcmV0dXJuIHQoJ21haW4uZmlsZS5ub1RpdGxlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0KCdtYWluLmZpbGUubm9UaXRsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIE1hcmtkb3duIHBvc3QsIGJvdW5jZVxyXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGhhbmRsZSBfcG9zdHMvbmFtZS5odG1sP1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGluaXRTaWRlYmFyOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIFNldHRpbmdzIHNpZGViYXIgcGFuZWxcclxuICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnNpZGViYXIuaW5pdFN1YnZpZXcoJ3NldHRpbmdzJywge1xyXG4gICAgICBzaWRlYmFyOiB0aGlzLnNpZGViYXIsXHJcbiAgICAgIGNvbmZpZzogdGhpcy5jb2xsZWN0aW9uLmNvbmZpZyxcclxuICAgICAgZmlsZTogdGhpcy5tb2RlbCxcclxuICAgICAgZmlsZUlucHV0OiB0aGlzLnRpdGxlQXNIZWFkaW5nKClcclxuICAgIH0pLnJlbmRlcigpO1xyXG4gICAgdGhpcy5zdWJ2aWV3c1snc2V0dGluZ3MnXSA9IHRoaXMuc2V0dGluZ3M7XHJcblxyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnNpZGViYXIsICdtYWtlRGlydHknLCB0aGlzLm1ha2VEaXJ0eSk7XHJcblxyXG4gICAgLy8gQ29tbWl0IG1lc3NhZ2Ugc2lkZWJhciBwYW5lbFxyXG4gICAgdGhpcy5zYXZlID0gdGhpcy5zaWRlYmFyLmluaXRTdWJ2aWV3KCdzYXZlJywge1xyXG4gICAgICBzaWRlYmFyOiB0aGlzLnNpZGViYXIsXHJcbiAgICAgIGZpbGU6IHRoaXMubW9kZWxcclxuICAgIH0pLnJlbmRlcigpO1xyXG4gICAgdGhpcy5zdWJ2aWV3c1snc2F2ZSddID0gdGhpcy5zYXZlO1xyXG4gIH0sXHJcblxyXG4gIGluaXRIZWFkZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRpdGxlID0gdGhpcy50aXRsZUFzSGVhZGluZygpO1xyXG4gICAgdmFyIGlucHV0ID0gdGl0bGUgP1xyXG4gICAgICB0aXRsZSA6XHJcbiAgICAgIHRoaXMubW9kZWwuZ2V0KCdwYXRoJyk7XHJcblxyXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyVmlldyh7XHJcbiAgICAgIGlucHV0OiBpbnB1dCxcclxuICAgICAgdGl0bGU6IHRpdGxlID8gdHJ1ZSA6IGZhbHNlLFxyXG4gICAgICBmaWxlOiB0aGlzLm1vZGVsLFxyXG4gICAgICByZXBvOiB0aGlzLnJlcG8sXHJcbiAgICAgIGFsdGVyYWJsZTogdHJ1ZSxcclxuICAgICAgcGxhY2Vob2xkZXI6IHRoaXMubW9kZWwuaXNOZXcoKSAmJiAhdGhpcy5tb2RlbC50cmFuc2xhdGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3Vidmlld3NbJ2hlYWRlciddID0gdGhpcy5oZWFkZXI7XHJcbiAgICB0aGlzLmhlYWRlci5zZXRFbGVtZW50KHRoaXMuJGVsLmZpbmQoJyNoZWFkaW5nJykpLnJlbmRlcigpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmhlYWRlciwgJ21ha2VEaXJ0eScsIHRoaXMubWFrZURpcnR5KTtcclxuICB9LFxyXG5cclxuICByZW5kZXJNZXRhZGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLm1ldGFkYXRhRWRpdG9yID0gbmV3IE1ldGFkYXRhVmlldyh7XHJcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxyXG4gICAgICB0aXRsZUFzSGVhZGluZzogdGhpcy50aXRsZUFzSGVhZGluZygpLFxyXG4gICAgICB2aWV3OiB0aGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1ldGFkYXRhRWRpdG9yLnNldEVsZW1lbnQodGhpcy4kZWwuZmluZCgnI21ldGEnKSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLnN1YnZpZXdzWydtZXRhZGF0YSddID0gdGhpcy5tZXRhZGF0YUVkaXRvcjtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5hcHAubG9hZGVyLnN0YXJ0KCk7XHJcblxyXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ3ByZXZpZXcnKSB7XHJcbiAgICAgIHRoaXMucHJldmlldygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLm1vZGVsLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgdmFyIGZpbGUgPSB7XHJcbiAgICAgICAgbWFya2Rvd246IHRoaXMubW9kZWwuZ2V0KCdtYXJrZG93bicpLFxyXG5cdFx0cHJvZDogdGhpcy5tb2RlbC5nZXQoJ3Byb2QnKSxcclxuXHRcdG51dHI6IHRoaXMubW9kZWwuZ2V0KCdudXRyJyksXHJcblx0XHRwcm9jOiB0aGlzLm1vZGVsLmdldCgncHJvYycpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLiRlbC5lbXB0eSgpLmFwcGVuZChfLnRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIGZpbGUsIHtcclxuICAgICAgICB2YXJpYWJsZTogJ2ZpbGUnXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIC8vIFN0b3JlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5tb2RlbC5nZXQoJ2NvbGxlY3Rpb24nKS5jb25maWc7XHJcblxyXG4gICAgICAvLyBpbml0aWFsaXplIHRoZSBzdWJ2aWV3c1xyXG4gICAgICB0aGlzLmluaXRFZGl0b3IoKTtcclxuICAgICAgdGhpcy5pbml0SGVhZGVyKCk7XHJcbiAgICAgIHRoaXMuaW5pdFRvb2xiYXIoKTtcclxuICAgICAgdGhpcy5pbml0U2lkZWJhcigpO1xyXG5cclxuICAgICAgdmFyIG1vZGUgPSBbJ2ZpbGUnXTtcclxuICAgICAgdmFyIG1hcmtkb3duID0gdGhpcy5tb2RlbC5nZXQoJ21hcmtkb3duJyk7XHJcbiAgICAgIHZhciBwcm9kID0gdGhpcy5tb2RlbC5nZXQoJ3Byb2QnKTtcclxuICAgICAgdmFyIG51dHIgPSB0aGlzLm1vZGVsLmdldCgnbnV0cicpO1xyXG4gICAgICB2YXIgcHJvYyA9IHRoaXMubW9kZWwuZ2V0KCdwcm9jJyk7XHJcbiAgICAgIHZhciBqZWt5bGwgPSAvXihfcG9zdHN8X2RyYWZ0cykvLnRlc3QodGhpcy5tb2RlbC5nZXQoJ3BhdGgnKSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIG5hdmlnYXRpb24gdmlldyB3aXRoIG1lbnUgb3B0aW9uc1xyXG4gICAgICAvLyBpZiBhIGZpbGUgY29udGFpbnMgbWV0YWRhdGEsIGhhcyBkZWZhdWx0IG1ldGFkYXRhIG9yIGlzIE1hcmtkb3duXHJcblx0ICAvLyBcclxuXHQgIC8vIEluc2lkZSB0aGUgSUYtY29uZGl0aW9uLCB3ZSBjb3VsZCBleHBsaWNpdGx5IGFkZCBcInx8IChwcm9kICYmIGpla3lsbClcIlxyXG5cdCAgLy8gdG8gdGVzdCBmb3IgcHJvZCBmaWxlcyB3aXRoIG1ldGFkYXRhLCBidXQgdGhpcyBpcyBub3QgcmVhbGx5IG5lY2Vzc2FyeVxyXG5cdCAgLy8gYXMgbWV0YWRhdGEgaXMgYXV0b21hdGljYWxseSByZWNvZ25pemVkIGFscmVhZHkuXHJcbiAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKSB8fCB0aGlzLm1vZGVsLmdldCgnZGVmYXVsdHMnKSB8fFxyXG4gICAgICAgIChtYXJrZG93biAmJiBqZWt5bGwpKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJNZXRhZGF0YSgpO1xyXG5cclxuICAgICAgICBtb2RlLnB1c2goJ21ldGEnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1hcmtkb3duIHx8IChqZWt5bGwgJiYgdGhpcy5tb2RlbC5nZXQoJ2V4dGVuc2lvbicpID09PSAnaHRtbCcpKSBtb2RlLnB1c2goJ3ByZXZpZXcnKTtcclxuXHQgIC8vaWYgKHByb2QpIG1vZGUucHVzaCgncHJvZC1lZGl0b3InKTtcclxuXHQgIC8vaWYgKG51dHIpIG1vZGUucHVzaCgnbnV0ci1lZGl0b3InKTtcclxuICAgICAgaWYgKCF0aGlzLm1vZGVsLmlzTmV3KCkpIG1vZGUucHVzaCgnc2V0dGluZ3MnKTtcclxuXHJcbiAgICAgIHRoaXMubmF2Lm1vZGUobW9kZS5qb2luKCcgJykpO1xyXG5cclxuICAgICAgdGhpcy51cGRhdGVEb2N1bWVudFRpdGxlKCk7XHJcblxyXG4gICAgICAvLyBQcmV2aWV3IG5lZWRzIGFjY2VzcyB0byBtYXJrZWQsIHNvIGl0J3MgcmVnaXN0ZXJlZCBoZXJlXHJcbiAgICAgIExpcXVpZC5UZW1wbGF0ZS5yZWdpc3RlckZpbHRlcih7XHJcbiAgICAgICAgJ21hcmtkb3duaWZ5JzogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICAgIHJldHVybiBtYXJrZWQoaW5wdXQgfHwgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gLy8gICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbWFya2Rvd24nKSAmJiB0aGlzLm1vZGUgPT09ICdibG9iJykge1xyXG4gICAgICBpZiAoKHRoaXMubW9kZWwuZ2V0KCdtYXJrZG93bicpICYmIHRoaXMubW9kZSA9PT0gJ2Jsb2InKVxyXG5cdCAgICAgIHx8ICh0aGlzLm1vZGVsLmdldCgncHJvZCcpICYmIHRoaXMubW9kZSA9PT0gJ2Jsb2InKVxyXG5cdFx0ICB8fCAodGhpcy5tb2RlbC5nZXQoJ251dHInKSAmJiB0aGlzLm1vZGUgPT09ICdibG9iJylcclxuXHRcdCAgfHwgKHRoaXMubW9kZWwuZ2V0KCdwcm9jJykgJiYgdGhpcy5tb2RlID09PSAnYmxvYicpKSB7XHJcbiAgICAgICAgdGhpcy5ibG9iKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRWRpdG9yIGlzIGZpcnN0IHVwIHNvIHRyaWdnZXIgYW4gYWN0aXZlIGNsYXNzIGZvciBpdFxyXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJyNlZGl0JykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJy5maWxlIC5lZGl0JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ21hcmtkb3duJykpIHtcclxuICAgICAgICAgIHV0aWwuZml4ZWRTY3JvbGwodGhpcy4kZWwuZmluZCgnLnRvcGJhcicpLCA5MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbi8qXHQgIFxyXG5cdCAgLy8gTm90IHN1cmUgaWYgdGhpcyBpcyByZXF1aXJlZC4uLlxyXG5cdCAgaWYgKHRoaXMubW9kZWwuZ2V0KCdwcm9kJykgJiYgdGhpcy5tb2RlID09PSAnYmxvYicpIHtcclxuXHQgICAgdGhpcy5ibG9iKCk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdFx0dGhpcy4kZWwuZmluZCgnI2VkaXQnKS50b2dnbGVDbGFzcygnYWN0aXZlJywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnLmZpbGUgLmVkaXQnKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblx0XHRcclxuXHRcdGlmICh0aGlzLm1vZGVsLmdldCgncHJvZCcpKSB7XHJcbiAgICAgICAgICB1dGlsLmZpeGVkU2Nyb2xsKHRoaXMuJGVsLmZpbmQoJy50b3BiYXInKSwgOTApO1xyXG4gICAgICAgIH1cclxuXHQgIH1cclxuXHQgIFxyXG5cdCAgLy8gTm90IHN1cmUgaWYgdGhpcyBpcyByZXF1aXJlZC4uLlxyXG5cdCAgaWYgKHRoaXMubW9kZWwuZ2V0KCdudXRyJykgJiYgdGhpcy5tb2RlID09PSAnYmxvYicpIHtcclxuXHQgICAgdGhpcy5ibG9iKCk7XHJcblx0ICB9IGVsc2Uge1xyXG5cdFx0dGhpcy4kZWwuZmluZCgnI2VkaXQnKS50b2dnbGVDbGFzcygnYWN0aXZlJywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnLmZpbGUgLmVkaXQnKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblx0XHRcclxuXHRcdGlmICh0aGlzLm1vZGVsLmdldCgnbnV0cicpKSB7XHJcbiAgICAgICAgICB1dGlsLmZpeGVkU2Nyb2xsKHRoaXMuJGVsLmZpbmQoJy50b3BiYXInKSwgOTApO1xyXG4gICAgICAgIH1cclxuXHQgIH1cclxuKi9cclxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgdGhpcy5ibG9iKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuZG9uZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZURvY3VtZW50VGl0bGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSAodGhpcy5tb2RlID09PSAnYmxvYicgPyB0KCdkb2NoZWFkZXIucHJldmlldycpIDogdCgnZG9jaGVhZGVyLmVkaXRpbmcnKSk7XHJcblxyXG4gICAgdmFyIHBhdGggPSB0aGlzLm1vZGVsLmdldCgncGF0aCcpO1xyXG4gICAgdmFyIHBhdGhUaXRsZSA9IHBhdGggPyBwYXRoIDogJyc7XHJcblxyXG4gICAgdXRpbC5kb2N1bWVudFRpdGxlKGNvbnRleHQgKyAnICcgKyBwYXRoVGl0bGUgKyAnLycgKyB0aGlzLm1vZGVsLmdldCgnbmFtZScpICsgJyBhdCAnICsgdGhpcy5icmFuY2gpO1xyXG4gIH0sXHJcblxyXG4gIGVkaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXcgPSB0aGlzO1xyXG4gICAgdGhpcy5zaWRlYmFyLmNsb3NlKCk7XHJcblxyXG4gICAgLy8gSWYgcHJldmlldyB3YXMgaGl0IG9uIGxvYWQgdGhpcy5lZGl0b3JcclxuICAgIC8vIHdhcyBub3QgaW5pdGlhbGl6ZWQuXHJcbiAgICBpZiAoIXRoaXMuZWRpdG9yKSB7XHJcbiAgICAgIHRoaXMuaW5pdEVkaXRvcigpO1xyXG5cclxuICAgICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdtYXJrZG93bicpKSB7XHJcbiAgICAgICAgXy5kZWxheShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHV0aWwuZml4ZWRTY3JvbGwoJCgnLnRvcGJhcicsIHZpZXcuZWwpLCA5MCk7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICAgIH1cclxuXHQgIFxyXG5cdCAgLy8gVE9ETyAtIHRoZSBzYW1lIGZvciBQUk9EP1xyXG5cdCAgaWYgKHRoaXMubW9kZWwuZ2V0KCdwcm9kJykpIHtcclxuICAgICAgICBfLmRlbGF5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdXRpbC5maXhlZFNjcm9sbCgkKCcudG9wYmFyJywgdmlldy5lbCksIDkwKTtcclxuICAgICAgICB9LCAxKTtcclxuICAgICAgfVxyXG5cdCAgXHJcblx0ICAvLyBUT0RPIC0gdGhlIHNhbWUgZm9yIE5VVFI/XHJcblx0ICBpZiAodGhpcy5tb2RlbC5nZXQoJ251dHInKSkge1xyXG4gICAgICAgIF8uZGVsYXkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB1dGlsLmZpeGVkU2Nyb2xsKCQoJy50b3BiYXInLCB2aWV3LmVsKSwgOTApO1xyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgICB9XHJcblx0ICBcclxuXHQgIFx0ICAvLyBUT0RPIC0gdGhlIHNhbWUgZm9yIFBST0M/XHJcblx0ICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2MnKSkge1xyXG4gICAgICAgIF8uZGVsYXkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB1dGlsLmZpeGVkU2Nyb2xsKCQoJy50b3BiYXInLCB2aWV3LmVsKSwgOTApO1xyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgJCgnI3Byb3NlJykudG9nZ2xlQ2xhc3MoJ29wZW4nLCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50TW9kZSgnZWRpdCcpO1xyXG4gICAgdGhpcy5tb2RlID0gdGhpcy5tb2RlbC5pc05ldygpID8gJ25ldycgOiAnZWRpdCc7XHJcbiAgICB0aGlzLm5hdi5zZXRGaWxlU3RhdGUodGhpcy5tb2RlKTtcclxuICAgIHRoaXMudXBkYXRlVVJMKCk7XHJcbiAgfSxcclxuXHJcbiAgYmxvYjogZnVuY3Rpb24oZSkge1xyXG4gICAgdGhpcy5zaWRlYmFyLmNsb3NlKCk7XHJcblxyXG4gICAgdmFyIG1ldGFkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ21ldGFkYXRhJyk7XHJcbiAgICB2YXIgamVreWxsID0gdGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcuc2l0ZXVybCAmJiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5sYXlvdXQ7XHJcblxyXG4gICAgaWYgKGpla3lsbCAmJiBlKSB7XHJcbiAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYWxsIGJlIHJlbW92ZWQgaWYgcHJldmlldyBidXR0b24gbGlzdGVuZWQgdG9cclxuICAgICAgLy8gY2hhbmdlOnBhdGggZXZlbnQgb24gbW9kZWxcclxuICAgICAgdGhpcy5uYXYuc2V0RmlsZVN0YXRlKCdlZGl0Jyk7IC8vIFJldHVybiB0byBlZGl0IGJlY2F1c2Ugd2UgYXJlIGNyZWF0aW5nIGEgbmV3IHdpbmRvd1xyXG4gICAgICB0aGlzLnN0YXNoRmlsZSgpO1xyXG5cclxuICAgICAgdmFyIGhhc2ggPSB0aGlzLmFic29sdXRlRmlsZXBhdGgoKS5zcGxpdCgnLycpO1xyXG4gICAgICBoYXNoLnNwbGljZSgyLCAwLCAncHJldmlldycpO1xyXG4gICAgICAkKGUuY3VycmVudFRhcmdldCkuYXR0cih7XHJcbiAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcclxuICAgICAgICBocmVmOiAnIycgKyBoYXNoLmpvaW4oJy8nKVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICB0aGlzLiRlbC5maW5kKCcjcHJldmlldycpLmh0bWwobWFya2VkKHRoaXMuY29tcGlsZVByZXZpZXcodGhpcy5tb2RlbC5nZXQoJ2NvbnRlbnQnKSkpKTtcclxuXHJcbiAgICAgIHRoaXMubW9kZSA9ICdibG9iJztcclxuICAgICAgdGhpcy5jb250ZW50TW9kZSgncHJldmlldycpO1xyXG4gICAgICB0aGlzLm5hdi5zZXRGaWxlU3RhdGUoJ2Jsb2InKTtcclxuICAgICAgdGhpcy51cGRhdGVVUkwoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwcmV2aWV3OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBxID0gcXVldWUoMSk7XHJcbiAgICAvLyBSZXRyaWV2ZSB0aGUgc3Rhc2ggZnJvbSB0aGUgbW9kZWwgcGF0aCBiZWNhdXNlIHRoYXRzIHdoYXQgd291bGRcclxuICAgIC8vIGhhdmUgYmVlbiBzdG9yZWQgd2hlbiB0aGUgcHJldmlldyBidXR0b24gaXMgY2xpY2tlZFxyXG4gICAgdmFyIHN0YXNoID0gdGhpcy5nZXRTdGFzaEZvclBhdGgodGhpcy5hYnNvbHV0ZVBhdGhGcm9tRmlsZSh0aGlzLm1vZGVsKSk7XHJcbiAgICB2YXIgbWV0YWRhdGEgPSB7fTtcclxuICAgIHZhciBjb250ZW50ID0gJyc7XHJcbiAgICBpZiAoc3Rhc2ggJiYgc3Rhc2guY29udGVudCkge1xyXG4gICAgICBtZXRhZGF0YSA9IHN0YXNoLm1ldGFkYXRhO1xyXG4gICAgICBjb250ZW50ID0gc3Rhc2guY29udGVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1ldGFkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ21ldGFkYXRhJykgfHwge307XHJcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1vZGVsLmdldCgnY29udGVudCcpIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwID0ge1xyXG4gICAgICBzaXRlOiB0aGlzLmNvbGxlY3Rpb24uY29uZmlnLFxyXG4gICAgICBwb3N0OiBtZXRhZGF0YSxcclxuICAgICAgcGFnZTogbWV0YWRhdGEsXHJcbiAgICAgIGNvbnRlbnQ6IG1hcmtlZChMaXF1aWQucGFyc2UodGhpcy5jb21waWxlUHJldmlldyhjb250ZW50KSkucmVuZGVyKHtcclxuICAgICAgICBzaXRlOiB0aGlzLmNvbGxlY3Rpb24uY29uZmlnLFxyXG4gICAgICAgIHBvc3Q6IG1ldGFkYXRhLFxyXG4gICAgICAgIHBhZ2U6IG1ldGFkYXRhXHJcbiAgICAgIH0pKSB8fCAnJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHcmFiIGEgZGF0ZSBmcm9tIHRoZSBmaWxlbmFtZVxyXG4gICAgLy8gYW5kIGFkZCB0aGlzIHBvc3QgdG8gYmUgZXZhbHVhdGVkIGFzIHt7cG9zdC5kYXRlfX1cclxuICAgIHZhciBwYXJ0cyA9IHV0aWwuZXh0cmFjdEZpbGVuYW1lKHRoaXMucGF0aClbMV0uc3BsaXQoJy0nKTtcclxuICAgIHZhciB5ZWFyID0gcGFydHNbMF07XHJcbiAgICB2YXIgbW9udGggPSBwYXJ0c1sxXTtcclxuICAgIHZhciBkYXkgPSBwYXJ0c1syXTtcclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgRVNUIHNwZWNpZmljIHRpbWUgYWRqdXN0bWVudFxyXG4gICAgdmFyIGRhdGUgPSBbeWVhciwgbW9udGgsIGRheV0uam9pbignLScpICsgJyAwNTowMDowMCc7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcC5wb3N0LmRhdGUgPSBqc3lhbWwuc2FmZUxvYWQoZGF0ZSkudG9EYXRlU3RyaW5nKCk7XHJcbiAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHBhcnNpbmcgZGF0ZVwiKTtcclxuICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBKU09OUCBsaW5rc1xyXG4gICAgaWYgKHAuc2l0ZSAmJiBwLnNpdGUuc2l0ZSkge1xyXG4gICAgICBfKHAuc2l0ZS5zaXRlKS5lYWNoKGZ1bmN0aW9uKGZpbGUsIGtleSkge1xyXG4gICAgICAgIHEuZGVmZXIoZnVuY3Rpb24oY2Ipe1xyXG4gICAgICAgICAgdmFyIG5leHQgPSBmYWxzZTtcclxuICAgICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJyxcclxuICAgICAgICAgICAganNvbnA6IGZhbHNlLFxyXG4gICAgICAgICAgICBqc29ucENhbGxiYWNrOiAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgICB1cmw6IGZpbGUsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAgICAgICAgICBwLnNpdGVba2V5XSA9IGQ7XHJcbiAgICAgICAgICAgICAgbmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1zZywgYiwgYykge1xyXG4gICAgICAgICAgICAgIGlmICghbmV4dCkgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldExheW91dChjYikge1xyXG4gICAgICB2YXIgZmlsZSA9IHAucGFnZS5sYXlvdXQ7XHJcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbGxlY3Rpb24uZmluZFdoZXJlKHsgcGF0aDogJ19sYXlvdXRzLycgKyBmaWxlICsgJy5odG1sJyB9KTtcclxuXHJcbiAgICAgIGxheW91dC5mZXRjaCh7XHJcbiAgICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgIG1vZGVsLmdldENvbnRlbnQoe1xyXG4gICAgICAgICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgIHZhciBtZXRhID0gbW9kZWwuZ2V0KCdtZXRhZGF0YScpO1xyXG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbW9kZWwuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gTGlxdWlkLnBhcnNlKGNvbnRlbnQpO1xyXG5cclxuICAgICAgICAgICAgICBwLnBhZ2UgPSBfLmV4dGVuZChtZXRhZGF0YSwgbWV0YSk7XHJcblxyXG4gICAgICAgICAgICAgIHAuY29udGVudCA9IHRlbXBsYXRlLnJlbmRlcih7XHJcbiAgICAgICAgICAgICAgICBzaXRlOiBwLnNpdGUsXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBwLnBvc3QsXHJcbiAgICAgICAgICAgICAgICBwYWdlOiBwLnBhZ2UsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBwLmNvbnRlbnRcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBsYXlvdXRzXHJcbiAgICAgICAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5sYXlvdXQpIHEuZGVmZXIoZ2V0TGF5b3V0LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICB0aGlzLnJvdXRlci5lcnJvcih4aHIpO1xyXG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIGVycm9yOiAoZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwLnBhZ2UubGF5b3V0KSB7XHJcbiAgICAgIHEuZGVmZXIoZ2V0TGF5b3V0LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHEuYXdhaXQoKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb2xsZWN0aW9uLmNvbmZpZztcclxuICAgICAgdmFyIGNvbnRlbnQgPSBwLmNvbnRlbnQ7XHJcblxyXG4gICAgICAvLyBTZXQgYmFzZSBVUkwgdG8gcHVibGljIHNpdGVcclxuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuc2l0ZXVybCkge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyg8aGVhZCg/Oi4qKT4pLywgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1sxXSArICc8YmFzZSBocmVmPVwiJyArIGNvbmZpZy5zaXRldXJsICsgJ1wiPic7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvY3VtZW50LndyaXRlKGNvbnRlbnQpO1xyXG4gICAgICBkb2N1bWVudC5jbG9zZSgpO1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgfSxcclxuXHJcbiAgY29udGVudE1vZGU6IGZ1bmN0aW9uKG1vZGUpIHtcclxuICAgIHRoaXMuJGVsLmZpbmQoJy52aWV3cyAudmlldycpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgIGlmIChtb2RlKSB7XHJcbiAgICAgIHRoaXMuJGVsLmZpbmQoJyMnICsgbW9kZSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnI3ByZXZpZXcnKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnI2VkaXQnKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4vLyAgZ2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4vLyAgICAvLyBGaWxlIGlzIGVpdGhlciAtcHJvZC5qcyBvciAtbnV0ci5qc1xyXG4vLyAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2QnKSB8fCB0aGlzLm1vZGVsLmdldCgnbnV0cicpKSB7XHJcbi8vXHRcclxuLy8gICAgICB2YXIganNvbkZvcm1WYWx1ZU9iaiA9ICQoJyNqc29uZm9ybScpLmpzb25Gb3JtVmFsdWUoKTsgXHJcbi8vXHQgIFxyXG4vLyAgICAgIC8vIFByZXR0eSBwcmludCB0aGUganNvbiBvYmplY3QgdXNpbmcgaW5kZW50YXRpb24gb2YgMiBhbmQgbmV3IGxpbmVzXHJcbi8vICAgICAgdmFyIGpzb25Gb3JtVmFsdWVTdHIgPSBKU09OLnN0cmluZ2lmeShqc29uRm9ybVZhbHVlT2JqLCBudWxsLCAyKTtcclxuLy9cdFxyXG4vLyAgICAgIHJldHVybiAoanNvbkZvcm1WYWx1ZVN0cikgPyBqc29uRm9ybVZhbHVlU3RyIDogbnVsbDtcclxuLy8gICAgfVxyXG4vL1x0XHJcbi8vXHQvLyBCYXNlIGNhc2VcclxuLy8gICAgZWxzZSB7XHJcbi8vICAgICAgcmV0dXJuICgodGhpcy5lZGl0b3IgJiYgdGhpcy5lZGl0b3IuZ2V0VmFsdWUpID8gZWRpdG9yLmdldFZhbHVlKCkgOiBudWxsKTtcclxuLy8gICAgfVxyXG4vLyAgfSxcclxuXHJcbiAgbWV0YTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNpZGViYXIuY2xvc2UoKTtcclxuICAgIHRoaXMuY29udGVudE1vZGUoJ21ldGEnKTtcclxuXHJcbiAgICAvLyBSZWZyZXNoIGFueSB0ZXh0YXJlYSdzIGluIHRoZSBmcm9udG1hdHRlciBmb3JtIHRoYXQgdXNlIGNvZGVtaXJyb3JcclxuICAgIHRoaXMubWV0YWRhdGFFZGl0b3IucmVmcmVzaCgpO1xyXG4gIH0sXHJcblxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKGNvbmZpcm0odCgnYWN0aW9ucy5kZWxldGUud2FybicpKSkge1xyXG4gICAgICB0aGlzLm1vZGVsLmRlc3Ryb3koe1xyXG4gICAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtcclxuICAgICAgICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgICAgICAgdGhpcy5yZXBvLmdldCgnbmFtZScpLFxyXG4gICAgICAgICAgICAndHJlZScsXHJcbiAgICAgICAgICAgIHRoaXMuYnJhbmNoXHJcbiAgICAgICAgICBdLmpvaW4oJy8nKSwgdHJ1ZSk7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAgIHRoaXMucm91dGVyLmVycm9yKHhocik7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVVUkw6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVybCA9IF8uY29tcGFjdChbXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4sXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ25hbWUnKSxcclxuICAgICAgdGhpcy5tb2RlLFxyXG4gICAgICB0aGlzLmJyYW5jaCxcclxuICAgICAgdGhpcy5wYXRoXHJcbiAgICBdKTtcclxuXHJcbiAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZSh1cmwuam9pbignLycpLCB7XHJcbiAgICAgIHRyaWdnZXI6IGZhbHNlLFxyXG4gICAgICByZXBsYWNlOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURvY3VtZW50VGl0bGUoKTtcclxuXHJcbiAgICAvLyBUT0RPOiB3aGF0IGlzIHRoaXMgdXBkYXRpbmc/XHJcbiAgICB0aGlzLiRlbC5maW5kKCcuY2h6bi1zZWxlY3QnKS50cmlnZ2VyKCdsaXN6dDp1cGRhdGVkJyk7XHJcbiAgfSxcclxuXHJcbiAgbWFrZURpcnR5OiBmdW5jdGlvbihlKSB7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbi8vICAgIC8vIFVwZGF0ZSBDb250ZW50LlxyXG4vL1x0aWYgKHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLmdldFZhbHVlKSB7XHJcbi8vXHRcdHZhciBjb250ZW50ID0gdGhpcy5nZXRFZGl0b3JWYWx1ZSgpO1xyXG4vL1x0XHRpZiAoY29udGVudCAhPT0gbnVsbCkge1xyXG4vL1x0XHQgIHRoaXMubW9kZWwuc2V0KCdjb250ZW50JywgY29udGVudCk7XHJcbi8vXHRcdH1cclxuLy9cdH1cclxuICAgIGlmICh0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5nZXRWYWx1ZSkge1xyXG4gICAgICB0aGlzLm1vZGVsLnNldCgnY29udGVudCcsIHRoaXMuZWRpdG9yLmdldFZhbHVlKCkpO1x0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIE1ldGFEYXRhXHJcbiAgICBpZiAodGhpcy5tZXRhZGF0YUVkaXRvcikge1xyXG4gICAgICB0aGlzLm1vZGVsLnNldCgnbWV0YWRhdGEnLCB0aGlzLm1ldGFkYXRhRWRpdG9yLmdldFZhbHVlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsYWJlbCA9IHRoaXMubW9kZWwuZ2V0KCd3cml0YWJsZScpID9cclxuICAgICAgdCgnYWN0aW9ucy5jaGFuZ2Uuc2F2ZScpIDpcclxuICAgICAgdCgnYWN0aW9ucy5jaGFuZ2Uuc3VibWl0Jyk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVTYXZlU3RhdGUobGFiZWwsICdzYXZlJyk7XHJcbiAgfSxcclxuXHJcbiAgc2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb250ZW50TW9kZSgpO1xyXG4gICAgdGhpcy5zaWRlYmFyLm1vZGUoJ3NldHRpbmdzJyk7XHJcbiAgICB0aGlzLnNpZGViYXIub3BlbigpO1xyXG4gIH0sXHJcblxyXG4gIHNob3dEaWZmOiBmdW5jdGlvbigpIHtcclxuXHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBDdXN0b20gVmFsaWRhdGlvbiBCZWdpbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gXHJcblx0aWYgKHRoaXMubW9kZWwuZ2V0KCdwcm9kJylcclxuXHRcdHx8IHRoaXMubW9kZWwuZ2V0KCdudXRyJylcclxuXHRcdHx8IHRoaXMubW9kZWwuZ2V0KCdwcm9jJykpIHtcclxuXHQgIC8vIEJlIGF3YXJlIHRoYXQgdGhpcyByZXF1aXJlcyB0aGF0IEpTT05Gb3JtJ3Mgb3duIHZlcnNpb24gb2YganN2LmpzIGhhcyBiZWVuXHJcbiAgICAgIC8vIGFkZGVkIHRvIHRoZSBnbG9iYWwgc2NvcGUuIEFsc28gc2VlIGluZGV4Lmh0bWwgZmlsZS5cclxuICAgICAgdmFyIGVudiA9IEpTT05Gb3JtVmFsaWRhdG9yLmNyZWF0ZUVudmlyb25tZW50KFwianNvbi1zY2hlbWEtZHJhZnQtMDNcIik7XHJcblx0ICBcclxuXHQgIHZhciBzY2hlbWE7XHJcblx0ICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2QnKSkge1xyXG5cdCAgICBzY2hlbWEgPSB7IFwicHJvcGVydGllc1wiOiBqc29uZm9ybWZvcm1hdC5wcm9kLnNjaGVtYSB9O1xyXG5cdCAgfVxyXG5cdCAgZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ251dHInKSkge1xyXG5cdCAgICBzY2hlbWEgPSB7IFwicHJvcGVydGllc1wiOiBqc29uZm9ybWZvcm1hdC5udXRyLnNjaGVtYSB9O1xyXG5cdCAgfVxyXG5cdCAgZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2MnKSkge1xyXG5cdCAgICBzY2hlbWEgPSB7IFwicHJvcGVydGllc1wiOiBqc29uZm9ybWZvcm1hdC5wcm9jLnNjaGVtYSB9O1xyXG5cdCAgfVxyXG5cdCAgZWxzZSB7XHJcblx0ICAgIC8vIEludmFsaWQgYWx0ZXJuYXRpdmUsIHRocm93IGVycm9yIG9yIHNvbWV0aGluZ1xyXG5cdFx0Q29uc29sZS5sb2coXCJwcm9zZS9hcHAvdmlld3MvZmlsZS5qcy9zaG93RGlmZjogSW52YWxpZCBmaWxlIHR5cGUgZm9yIHZhbGlkYXRpb24uXCIpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cclxuICAgICAgdmFyIHJlcG9ydCA9IGVudi52YWxpZGF0ZSgkKCdmb3JtJykuanNvbkZvcm1WYWx1ZSgpLCBzY2hlbWEpO1xyXG5cdCAgaWYgKHJlcG9ydC5lcnJvcnMubGVuZ3RoICE9IDApIHsgXHJcblx0ICAgICQoJyNqc29uZm9ybScpLmpzb25Gb3JtRXJyb3JzKHJlcG9ydC5lcnJvcnMsIHt9KTtcclxuXHRcdHRoaXMuZWRpdCgpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cdH1cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gQ3VzdG9tIFZhbGlkYXRpb24gRW5kIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0XHJcbiAgXHJcbi8qXHQvLyAtLS0tLS0tLS0tLS0tLS0tIEN1c3RvbSBWYWxpZGF0aW9uIEJlZ2luIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgXHJcblx0Ly8gVGhpcyBjb2RlIG9ubHkgdHJpZ2dlcnMgdGhlIEJyb3dzZXIncyB2YWxpZGF0aW9uLCBidXQgbm90IEpTT05Gb3JtJ3MgdmFsaWRhdGlvbi5cclxuXHJcblx0Ly8gTm90IHN1cmUsIGJ1dCBJIGJlbGlldmUgY2hlY2tWYWxpZGl0eSB3b3JrcyBvbmx5IGlmIHdlIGdldCB0aGUgZm9ybSBlbGVtZW50XHJcblx0Ly8gdGhyb3VnaCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCAtIGJ1dCBub3QgdGhyb3VnaCBqUXVlcnkhIFdoYXRldmVyIHRoZSBjYXNlLFxyXG5cdC8vIHRoaXMgd29ya3MgKGV4Y2x1ZGluZyBvbGQgYnJvd3NlcnMpLlxyXG5cdGlmICh0aGlzLm1vZGVsLmdldCgncHJvZCcpIHx8IHRoaXMubW9kZWwuZ2V0KCdudXRyJykpIHtcclxuXHRcdHZhciBqc29uRm9ybUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pzb25mb3JtJyk7XHJcblx0XHRpZiAoKGpzb25Gb3JtRWwgIT09IG51bGwpICYmICEodHlwZW9mIGpzb25Gb3JtRWwgPT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFxyXG5cdFx0XHR2YXIgaXNGb3JtVmFsaWQgPSBqc29uRm9ybUVsLmNoZWNrVmFsaWRpdHkoKTtcclxuXHRcdFx0aWYgKCFpc0Zvcm1WYWxpZCkge1xyXG5cdFx0XHQgIC8vIENoYW5nZSB0aGUgXCJzYXZlXCIgYnV0dG9uIGJhY2sgdG8gaXRzIHN0YXRlXHJcblx0XHRcdFx0dGhpcy5lZGl0KCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2ltdWxhdGUgYSBjbGljayBvbiBKU09ORm9ybSBzdWJtaXQgYnV0dG9uXHJcblx0XHRcdFx0JCgnI2pzb25mb3JtIGlucHV0LmJ0bi1wcmltYXJ5JykuY2xpY2soKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0gQ3VzdG9tIFZhbGlkYXRpb24gRW5kIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0XHJcbiovXHJcbiAgICB0aGlzLmNvbnRlbnRNb2RlKCdkaWZmJyk7XHJcbiAgICB0aGlzLnNpZGViYXIubW9kZSgnc2F2ZScpO1xyXG4gICAgdGhpcy5zaWRlYmFyLm9wZW4oKTtcclxuXHJcbiAgICB2YXIgJGRpZmYgPSB0aGlzLiRlbC5maW5kKCcjZGlmZicpO1xyXG5cclxuICAgIC8vIFVzZSBfLmVzY2FwZSgpIHRvIHByZXZlbnQgcmVuZGVyaW5nIEhUTUwgdGFnc1xyXG4gICAgdmFyIHRleHQxID0gdGhpcy5tb2RlbC5pc05ldygpID8gJycgOiBfLmVzY2FwZSh0aGlzLm1vZGVsLmdldCgncHJldmlvdXMnKSk7XHJcbiAgICB2YXIgdGV4dDIgPSBfLmVzY2FwZSh0aGlzLm1vZGVsLnNlcmlhbGl6ZSgpKTtcclxuXHJcbiAgICB2YXIgZCA9IGRpZmYuZGlmZldvcmRzKHRleHQxLCB0ZXh0Mik7XHJcbiAgICB2YXIgbGVuZ3RoID0gZC5sZW5ndGg7XHJcbiAgICB2YXIgY29tcGFyZSA9ICcnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGRbaV0ucmVtb3ZlZCkge1xyXG4gICAgICAgIGNvbXBhcmUgKz0gJzxkZWw+JyArIGRbaV0udmFsdWUgKyAnPC9kZWw+JztcclxuICAgICAgfSBlbHNlIGlmIChkW2ldLmFkZGVkKSB7XHJcbiAgICAgICAgY29tcGFyZSArPSAnPGlucz4nICsgZFtpXS52YWx1ZSArICc8L2lucz4nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBhcmUgKz0gZFtpXS52YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICRkaWZmLmZpbmQoJy5kaWZmLWNvbnRlbnQnKS5odG1sKCc8cHJlPicgKyBjb21wYXJlICsgJzwvcHJlPicpO1xyXG4gIH0sXHJcblxyXG4gIGNhbmNlbDogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBDbG9zZSB0aGUgc2lkZWJhciBhbmQgcmV0dXJuIHRoZVxyXG4gICAgLy8gYWN0aXZlIG5hdiBpdGVtIHRvIHRoZSBjdXJyZW50IGZpbGUgbW9kZS5cclxuICAgIHRoaXMuc2lkZWJhci5jbG9zZSgpO1xyXG4gICAgdGhpcy5uYXYuYWN0aXZlKHRoaXMubW9kZSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGJhY2sgdG8gb2xkIG1vZGUuXHJcbiAgICB0aGlzLmNvbnRlbnRNb2RlKCk7XHJcbiAgfSxcclxuXHJcbiAgcmVmcmVzaENvZGVNaXJyb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVkaXRvci5yZWZyZXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlTWV0YURhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLm1vZGVsLmpla3lsbCkgcmV0dXJuIHRydWU7IC8vIG1ldGFkYXRhIC0+IHNraXBcclxuICAgIHRoaXMubW9kZWwubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhRWRpdG9yLmdldFZhbHVlKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG5cclxuICBwYXRjaDogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBTdWJtaXQgYSBwYXRjaCAoZm9yayArIHB1bGwgcmVxdWVzdCB3b3JrZmxvdylcclxuICAgIHRoaXMudXBkYXRlU2F2ZVN0YXRlKHQoJ2FjdGlvbnMuc2F2ZS5wYXRjaCcpLCAnc2F2aW5nJyk7XHJcblxyXG4gICAgLy8gdmlldy51cGRhdGVNZXRhRGF0YSgpO1xyXG5cclxuICAgIHRoaXMubW9kZWwucGF0Y2goe1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24ocmVzKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAvLyBUT0RPOiByZXZlcnQgdG8gcHJldmlvdXMgc3RhdGU/XHJcbiAgICAgICAgdmFyIHByZXZpb3VzID0gdmlldy5tb2RlbC5nZXQoJ3ByZXZpb3VzJyk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5jb250ZW50ID0gcHJldmlvdXM7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUocHJldmlvdXMpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1vZGVsLnBlcnNpc3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maWxlID0gZmlsZW5hbWU7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3ByZXZpb3VzJywgZmlsZWNvbnRlbnQpO1xyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGJyZWFraW5nP1xyXG4gICAgICAgIC8vIHRoaXMudG9vbGJhci51cGRhdGVQdWJsaXNoU3RhdGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVVUkwoKTtcclxuICAgICAgICB0aGlzLnNpZGViYXIuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNhdmVTdGF0ZSh0KCdhY3Rpb25zLnNhdmUuc3VibWlzc2lvbicpLCAnc2F2ZWQnKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTYXZlU3RhdGUocmVzLm1lc3NhZ2UsICdlcnJvcicpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBmaWxlcGF0aDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy50aXRsZUFzSGVhZGluZygpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpZGViYXIuZmlsZXBhdGhHZXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhlYWRlci5pbnB1dEdldCgpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFic29sdXRlRmlsZXBhdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYXRoRnJvbUNvbXBvbmVudHMoXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4sXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ25hbWUnKSxcclxuICAgICAgdGhpcy5icmFuY2gsXHJcbiAgICAgIHRoaXMuZmlsZXBhdGgoKVxyXG4gICAgKTtcclxuICB9LFxyXG5cclxuICBhYnNvbHV0ZVBhdGhGcm9tRmlsZTogZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYXRoRnJvbUNvbXBvbmVudHMoXHJcbiAgICAgIGZpbGUuY29sbGVjdGlvbi5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgZmlsZS5jb2xsZWN0aW9uLnJlcG8uZ2V0KCduYW1lJyksXHJcbiAgICAgIGZpbGUuY29sbGVjdGlvbi5icmFuY2guZ2V0KCduYW1lJyksXHJcbiAgICAgIGZpbGUuZ2V0KCdwYXRoJylcclxuICAgICk7XHJcbiAgfSxcclxuXHJcbiAgYWJzb2x1dGVQYXRoRnJvbUNvbXBvbmVudHM6IGZ1bmN0aW9uKHVzZXIsIHJlcG8sIGJyYW5jaCwgcGF0aCkge1xyXG4gICAgdmFyIHVybCA9IF8uY29tcGFjdChbIHVzZXIsIHJlcG8sIGJyYW5jaCwgcGF0aCBdKTtcclxuICAgIHJldHVybiB1cmwuam9pbignLycpO1xyXG4gIH0sXHJcblxyXG4gIGRyYWZ0OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuY29sbGVjdGlvbi5kZWZhdWx0cyB8fCB7fTtcclxuICAgIHZhciBwYXRoID0gdGhpcy5tb2RlbC5nZXQoJ3BhdGgnKS5yZXBsYWNlKC9eKF9wb3N0cykvLCAnX2RyYWZ0cycpO1xyXG4gICAgdmFyIHVybDtcclxuXHJcbiAgICAvLyBDcmVhdGUgRmlsZSBtb2RlbCBjbG9uZSB3aXRoIG1ldGFkYXRhIGFuZCBjb250ZW50XHJcbiAgICAvLyBSZWFzc2lnbiB0aGlzLm1vZGVsIHRvIGNsb25lIGFuZCByZS1yZW5kZXJcclxuICAgIHRoaXMubW9kZWwgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0KHBhdGgpIHx8IHRoaXMubW9kZWwuY2xvbmUoe1xyXG4gICAgICBwYXRoOiBwYXRoXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZXQgZGVmYXVsdCBtZXRhZGF0YSBmb3IgbmV3IHBhdGhcclxuICAgIGlmICh0aGlzLm1vZGVsICYmIGRlZmF1bHRzKSB7XHJcbiAgICAgIHRoaXMubW9kZWwuc2V0KCdkZWZhdWx0cycsIGRlZmF1bHRzW3RoaXMubmVhcmVzdFBhdGgocGF0aCwgZGVmYXVsdHMpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHZpZXcgcHJvcGVydGllc1xyXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcclxuXHJcbiAgICB1cmwgPSBfLmNvbXBhY3QoW1xyXG4gICAgICB0aGlzLnJlcG8uZ2V0KCdvd25lcicpLmxvZ2luLFxyXG4gICAgICB0aGlzLnJlcG8uZ2V0KCduYW1lJyksXHJcbiAgICAgIHRoaXMubW9kZSxcclxuICAgICAgdGhpcy5icmFuY2gsXHJcbiAgICAgIHRoaXMucGF0aFxyXG4gICAgXSk7XHJcblxyXG4gICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUodXJsLmpvaW4oJy8nKSwge1xyXG4gICAgICB0cmlnZ2VyOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zaWRlYmFyLmNsb3NlKCk7XHJcbiAgICB0aGlzLm5hdi5hY3RpdmUoJ2VkaXQnKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmZldGNoKHsgY29tcGxldGU6IHRoaXMucmVuZGVyIH0pO1xyXG4gIH0sXHJcblxyXG4gIHBvc3Q6IGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuY29sbGVjdGlvbi5kZWZhdWx0cyB8fCB7fTtcclxuICAgIHZhciBtZXRhZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdtZXRhZGF0YScpIHx8IHt9O1xyXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLm1vZGVsLmdldCgnY29udGVudCcpIHx8ICcnO1xyXG4gICAgdmFyIHBhdGggPSB0aGlzLm1vZGVsLmdldCgncGF0aCcpLnJlcGxhY2UoL14oX2RyYWZ0cykvLCAnX3Bvc3RzJyk7XHJcbiAgICB2YXIgdXJsO1xyXG5cclxuICAgIC8vIENyZWF0ZSBGaWxlIG1vZGVsIGNsb25lIHdpdGggbWV0YWRhdGEgYW5kIGNvbnRlbnRcclxuICAgIC8vIFJlYXNzaWduIHRoaXMubW9kZWwgdG8gY2xvbmUgYW5kIHJlLXJlbmRlclxyXG4gICAgdGhpcy5tb2RlbCA9IHRoaXMuY29sbGVjdGlvbi5nZXQocGF0aCkgfHwgdGhpcy5tb2RlbC5jbG9uZSh7XHJcbiAgICAgIHBhdGg6IHBhdGhcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNldCBkZWZhdWx0IG1ldGFkYXRhIGZvciBuZXcgcGF0aFxyXG4gICAgaWYgKHRoaXMubW9kZWwgJiYgZGVmYXVsdHMpIHtcclxuICAgICAgdGhpcy5tb2RlbC5zZXQoJ2RlZmF1bHRzJywgZGVmYXVsdHNbdGhpcy5uZWFyZXN0UGF0aChwYXRoLCBkZWZhdWx0cyldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgdmlldyBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG5cclxuICAgIHVybCA9IF8uY29tcGFjdChbXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4sXHJcbiAgICAgIHRoaXMucmVwby5nZXQoJ25hbWUnKSxcclxuICAgICAgdGhpcy5tb2RlLFxyXG4gICAgICB0aGlzLmJyYW5jaCxcclxuICAgICAgdGhpcy5wYXRoXHJcbiAgICBdKTtcclxuXHJcbiAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZSh1cmwuam9pbignLycpLCB7XHJcbiAgICAgIHRyaWdnZXI6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmZldGNoKHtcclxuICAgICAgY29tcGxldGU6IChmdW5jdGlvbihtb2RlbCwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gU2V0IG1ldGFkYXRhIGFuZCBjb250ZW50IGZyb20gZHJhZnQgb24gcG9zdCBtb2RlbFxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldCgnY29udGVudCcsIGNvbnRlbnQpO1xyXG5cclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLm5hdi5hY3RpdmUoJ3NhdmUnKTtcclxuICAgICAgICB0aGlzLnNob3dEaWZmKCk7XHJcbiAgICAgIH0pLmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5jb2xsZWN0aW9uLmRlZmF1bHRzIHx8IHt9O1xyXG4gICAgdmFyIG1ldGFkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ21ldGFkYXRhJykgfHwge307XHJcbiAgICB2YXIgbGFuZyA9ICQoZS5jdXJyZW50VGFyZ2V0KS5hdHRyKCdocmVmJykuc3Vic3RyKDEpO1xyXG4gICAgdmFyIHBhdGggPSB0aGlzLm1vZGVsLmdldCgncGF0aCcpLnNwbGl0KCcvJyk7XHJcbiAgICB2YXIgbW9kZWw7XHJcbiAgICB2YXIgdXJsO1xyXG5cclxuICAgIC8vIFRPRE86IERyb3AgdGhlICdlbicgcmVxdWlyZW1lbnQuXHJcbiAgICBpZiAobGFuZyA9PT0gJ2VuJykge1xyXG4gICAgICAvLyBJZiBjdXJyZW50IHBhZ2UgaXMgbm90IGVuZ2xpc2ggYW5kIHRhcmdldCBwYWdlIGlzIGVuZ2xpc2hcclxuICAgICAgcGF0aC5zcGxpY2UoLTIsIDIsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XHJcbiAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLmxhbmcgPT09ICdlbicpIHtcclxuICAgICAgLy8gSWYgY3VycmVudCBwYWdlIGlzIGVuZ2xpc2ggYW5kIHRhcmdldCBwYWdlIGlzIG5vdCBlbmdsaXNoXHJcbiAgICAgIHBhdGguc3BsaWNlKC0xLCAxLCBsYW5nLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgY3VycmVudCBwYWdlIGlzIG5vdCBlbmdsaXNoIGFuZCB0YXJnZXQgcGFnZSBpcyBub3QgZW5nbGlzaFxyXG4gICAgICBwYXRoLnNwbGljZSgtMiwgMiwgbGFuZywgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXRoID0gXy5jb21wYWN0KHBhdGgpLmpvaW4oJy8nKTtcclxuXHJcbiAgICB2YXIgY2F0ZWdvcmllcyA9IChtZXRhZGF0YS5jYXRlZ29yaWVzIHx8IFtdKTtcclxuICAgIGNhdGVnb3JpZXMudW5zaGlmdChsYW5nKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsID0gdGhpcy5jb2xsZWN0aW9uLmdldChwYXRoKSB8fCB0aGlzLm1vZGVsLmNsb25lKHtcclxuICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzLFxyXG4gICAgICAgIGxhbmc6IGxhbmdcclxuICAgICAgfSxcclxuICAgICAgcGF0aDogcGF0aFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2V0IGRlZmF1bHQgbWV0YWRhdGEgZm9yIG5ldyBwYXRoXHJcbiAgICBpZiAodGhpcy5tb2RlbCAmJiBkZWZhdWx0cykge1xyXG4gICAgICB0aGlzLm1vZGVsLnNldCgnZGVmYXVsdHMnLCBkZWZhdWx0c1t0aGlzLm5lYXJlc3RQYXRoKHBhdGgsIGRlZmF1bHRzKV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB2aWV3IHByb3BlcnRpZXNcclxuICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcblxyXG4gICAgdXJsID0gXy5jb21wYWN0KFtcclxuICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgdGhpcy5yZXBvLmdldCgnbmFtZScpLFxyXG4gICAgICB0aGlzLm1vZGUsXHJcbiAgICAgIHRoaXMuYnJhbmNoLFxyXG4gICAgICB0aGlzLnBhdGhcclxuICAgIF0pO1xyXG5cclxuICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKHVybC5qb2luKCcvJyksIHtcclxuICAgICAgdHJpZ2dlcjogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2lkZWJhci5jbG9zZSgpO1xyXG4gICAgdGhpcy5tb2RlbC5mZXRjaCh7IGNvbXBsZXRlOiB0aGlzLnJlbmRlciB9KTtcclxuICB9LFxyXG5cclxuICBzdGFzaEZpbGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBpZiAoIXdpbmRvdy5zZXNzaW9uU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBzdG9yZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcclxuICAgIHZhciBmaWxlcGF0aCA9IHRoaXMuYWJzb2x1dGVGaWxlcGF0aCgpO1xyXG4gICAgLy8gRG9uJ3Qgc3Rhc2ggaWYgZmlsZXBhdGggaXMgdW5kZWZpbmVkXHJcbiAgICBpZiAoZmlsZXBhdGgpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzdG9yZS5zZXRJdGVtKGZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBzaGE6IHRoaXMubW9kZWwuZ2V0KCdzaGEnKSxcclxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWRpdG9yID8gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSA6IG51bGwsXHJcbi8vICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKSxcclxuICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhRWRpdG9yID8gdGhpcy5tZXRhZGF0YUVkaXRvci5nZXRWYWx1ZSgpIDogbnVsbFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHN0YXNoQXBwbHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGZpbGVwYXRoID0gdGhpcy5hYnNvbHV0ZVBhdGhGcm9tRmlsZSh0aGlzLm1vZGVsKTtcclxuICAgIHZhciBzdGFzaCA9IHRoaXMuZ2V0U3Rhc2hGb3JQYXRoKGZpbGVwYXRoKTtcclxuICAgIGlmICghc3Rhc2gpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChzdGFzaC5zaGEgPT09IHRoaXMubW9kZWwuZ2V0KCdzaGEnKSkge1xyXG4gICAgICAvLyBSZXN0b3JlIGZyb20gc3Rhc2ggaWYgZmlsZSBzaGEgaGFzbid0IGNoYW5nZWRcclxuICAgICAgaWYgKHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLnNldFZhbHVlKSB0aGlzLmVkaXRvci5zZXRWYWx1ZShzdGFzaC5jb250ZW50KTtcclxuICAgICAgaWYgKHRoaXMubWV0YWRhdGFFZGl0b3IpIHtcclxuICAgICAgICAvLyB0aGlzLnJhd0VkaXRvci5zZXRWYWx1ZSgnJyk7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YUVkaXRvci5zZXRWYWx1ZShzdGFzaC5tZXRhZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGNvbnRlbnRcclxuICAgICAgdGhpcy5jbGVhclN0YXNoRm9yUGF0aChmaWxlcGF0aCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0U3Rhc2hGb3JQYXRoOiBmdW5jdGlvbihmaWxlcGF0aCkge1xyXG4gICAgaWYgKCF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBzdG9yZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcclxuICAgIHZhciBpdGVtID0gc3RvcmUuZ2V0SXRlbShmaWxlcGF0aCk7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcclxuICB9LFxyXG5cclxuICBjbGVhclN0YXNoRm9yUGF0aDogZnVuY3Rpb24oZmlsZXBhdGgpIHtcclxuICAgIGlmICghd2luZG93LnNlc3Npb25TdG9yYWdlKSByZXR1cm47XHJcbiAgICB2YXIgc3RvcmUgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2U7XHJcbiAgICBzdG9yZS5yZW1vdmVJdGVtKGZpbGVwYXRoKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVGaWxlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2aWV3ID0gdGhpcztcclxuXHRcdFxyXG4gICAgLy8gVHJpZ2dlciB0aGUgc2F2ZSBldmVudFxyXG4gICAgdGhpcy51cGRhdGVTYXZlU3RhdGUodCgnYWN0aW9ucy5zYXZlLnNhdmluZycpLCAnc2F2aW5nJyk7XHJcblxyXG4gICAgdmFyIG1ldGhvZCA9IHRoaXMubW9kZWwuZ2V0KCd3cml0YWJsZScpID8gdGhpcy5tb2RlbC5zYXZlIDogdGhpcy5wYXRjaDtcclxuXHJcbiAgICAvL3RoaXMudXBkYXRlU2F2ZVN0YXRlKHQoJ2FjdGlvbnMuc2F2ZS5tZXRhRXJyb3InKSwgJ2Vycm9yJyk7XHJcbiAgICAvL3RoaXMudXBkYXRlU2F2ZVN0YXRlKHQoJ2FjdGlvbnMuZXJyb3InKSwgJ2Vycm9yJyk7XHJcbiAgICAvL3RoaXMudXBkYXRlU2F2ZVN0YXRlKHQoJ2FjdGlvbnMuc2F2ZS5zYXZlZCcpLCAnc2F2ZWQnLCB0cnVlKTtcclxuICAgIC8vdGhpcy51cGRhdGVTYXZlU3RhdGUodCgnYWN0aW9ucy5zYXZlLmZpbGVOYW1lRXJyb3InKSwgJ2Vycm9yJyk7XHJcblx0XHJcbiAgICAvLyBWYWxpZGF0aW9uIGNoZWNraW5nXHJcbiAgICB0aGlzLm1vZGVsLm9uKCdpbnZhbGlkJywgKGZ1bmN0aW9uKG1vZGVsLCBlcnJvcikge1xyXG4gICAgICB0aGlzLnVwZGF0ZVNhdmVTdGF0ZShlcnJvciwgJ2Vycm9yJyk7XHJcblxyXG4gICAgICB2aWV3Lm1vZGFsID0gbmV3IE1vZGFsVmlldyh7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3JcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2aWV3LiRlbC5maW5kKCcjbW9kYWwnKS5odG1sKHZpZXcubW9kYWwuZWwpO1xyXG4gICAgICB2aWV3Lm1vZGFsLnJlbmRlcigpO1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4vL1x0dmFyIGNvbnRlbnQgPSB0aGlzLmdldEVkaXRvclZhbHVlKCk7XHJcbi8vXHR0aGlzLm1vZGVsLnNldCgnY29udGVudCcsIChjb250ZW50ID09PSBudWxsKSA/ICcnIDogY29udGVudCk7XHJcbi8vLS0tLS0tLS0tLS0tLS0tLT5cdFxyXG4gICAgLy8gVXBkYXRlIGNvbnRlbnRcclxuXHRpZiAodGhpcy5tb2RlbC5nZXQoJ3Byb2QnKVxyXG5cdFx0fHwgdGhpcy5tb2RlbC5nZXQoJ251dHInKVxyXG5cdFx0fHwgdGhpcy5tb2RlbC5nZXQoJ3Byb2MnKSkge1xyXG5cdFxyXG5cdCAgLy8kKCcjanNvbmZvcm0nKS50cmlnZ2VyKCdzdWJtaXQnKTtcclxuXHQgIC8vJCgnI2pzb25mb3JtIGlucHV0LmJ0bi1wcmltYXJ5JykuY2xpY2soKTtcclxuXHRcclxuXHQgIHZhciBqc29uRm9ybVZhbHVlT2JqID0gJCgnI2pzb25mb3JtJykuanNvbkZvcm1WYWx1ZSgpOyBcclxuXHQgIFxyXG5cdCAgLy8gUHJldHR5IHByaW50IHRoZSBqc29uIG9iamVjdCB1c2luZyBpbmRlbnRhdGlvbiBvZiAyIGFuZCBuZXcgbGluZXNcclxuXHQgIHZhciBqc29uRm9ybVZhbHVlU3RyID0gSlNPTi5zdHJpbmdpZnkoanNvbkZvcm1WYWx1ZU9iaiwgbnVsbCwgMik7XHJcblx0XHJcbiAgICAvLyBUT0RPOiBTaG91bGQgd2UgY2hlY2sgaGVyZSB3aGV0aGVyIHRoZSBQUk9EL05VVFIvUFJPQyBlZGl0b3IgaGFzIGJlZW4gaW5pdGlhdGVkP1xyXG5cdCAgdGhpcy5tb2RlbC5zZXQoJ2NvbnRlbnQnLCBqc29uRm9ybVZhbHVlU3RyKTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcbi8vLS0tLS0tLS0tLS0tLS0tLTxcclxuICAgICAgdGhpcy5tb2RlbC5jb250ZW50ID0gKHRoaXMuZWRpdG9yKSA/IHRoaXMuZWRpdG9yLmdldFZhbHVlKCkgOiAnJztcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLT5cclxuXHR9XHJcbi8vLS0tLS0tLS0tLS0tLS0tLTxcclxuXHJcbiAgICAvLyBEZWxlZ2F0ZVxyXG4gICAgbWV0aG9kLmNhbGwodGhpcywge1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgdmFyIHBhcmFtcztcclxuXHJcbiAgICAgICAgdGhpcy5zaWRlYmFyLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTYXZlU3RhdGUodCgnYWN0aW9ucy5zYXZlLnNhdmVkJyksICdzYXZlZCcpO1xyXG5cclxuICAgICAgICAvLyBFbmFibGUgc2V0dGluZ3Mgc2lkZWJhciBpdGVtXHJcbiAgICAgICAgdGhpcy5uYXYuJGVsLmFkZENsYXNzKCdzZXR0aW5ncycpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBwYXRoXHJcbiAgICAgICAgdmFyIHBhdGggPSBtb2RlbC5nZXQoJ3BhdGgnKTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG5cclxuICAgICAgICAvLyBVbnNldCBkaXJ0eSwgcmV0dXJuIHRvIGVkaXQgdmlld1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVkaXQoKTtcclxuXHJcbiAgICAgICAgdmFyIG9sZCA9IG1vZGVsLmdldCgnb2xkcGF0aCcpO1xyXG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5leHRyYWN0RmlsZW5hbWUob2xkKVsxXTtcclxuICAgICAgICB2YXIgcGF0aENoYW5nZSA9IHBhdGggIT09IG9sZDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBmaWxlIGlmIHJlbmFtZWRcclxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIFJlcG8gQ29udGVudHMgQVBJIHN1cHBvcnRzIHJlbmFtaW5nXHJcbiAgICAgICAgaWYgKG1vZGVsLnByZXZpb3VzKCdzaGEnKSAmJiBwYXRoQ2hhbmdlKSB7XHJcbiAgICAgICAgICB1cmwgPSBtb2RlbC51cmwoKS5yZXBsYWNlKHBhdGgsIG9sZCkuc3BsaXQoJz8nKVswXTtcclxuXHJcbiAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBvbGQsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ2FjdGlvbnMuY29tbWl0cy5kZWxldGVkJywgeyBmaWxlbmFtZTogbmFtZSB9KSxcclxuICAgICAgICAgICAgc2hhOiBtb2RlbC5wcmV2aW91cygnc2hhJyksXHJcbiAgICAgICAgICAgIGJyYW5jaDogdGhpcy5jb2xsZWN0aW9uLmJyYW5jaC5nZXQoJ25hbWUnKVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBwYXJhbXMgPSBfLm1hcChfLnBhaXJzKGRhdGEpLCBmdW5jdGlvbihwYXJhbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW0uam9pbignPScpO1xyXG4gICAgICAgICAgfSkuam9pbignJicpO1xyXG5cclxuICAgICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICB1cmw6IHVybCArICc/JyArIHBhcmFtcyxcclxuICAgICAgICAgICAgZXJyb3I6IChmdW5jdGlvbih4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVTYXZlU3RhdGUocmVzLm1lc3NhZ2UsICdlcnJvcicpO1xyXG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2F2ZVN0YXRlKHJlcy5tZXNzYWdlLCAnZXJyb3InKTtcclxuICAgICAgfSkuYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVNhdmVTdGF0ZTogZnVuY3Rpb24obGFiZWwsIGNsYXNzZXMsIGtpbGwpIHtcclxuXHJcbiAgICAvLyBDYW5jZWwgaWYgdGhpcyBjb25kaXRpb24gaXMgbWV0XHJcbiAgICBpZiAoY2xhc3NlcyA9PT0gJ3NhdmUnICYmICQodGhpcy5lbCkuaGFzQ2xhc3MoJ3NhdmluZycpKSByZXR1cm47XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBTaWRlYmFyIHNhdmUgYnV0dG9uXHJcbiAgICBpZiAodGhpcy5zaWRlYmFyKSB0aGlzLnNpZGViYXIudXBkYXRlU3RhdGUobGFiZWwpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgYXZhdGFyIGluIHRoZSB0b29sYmFyXHJcbiAgICBpZiAodGhpcy5uYXYpIHRoaXMubmF2LnVwZGF0ZVN0YXRlKGxhYmVsLCBjbGFzc2VzLCBraWxsKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVJbWFnZUluc2VydDogZnVuY3Rpb24oZSwgZmlsZSwgY29udGVudCkge1xyXG4gICAgdGhpcy5xdWV1ZSA9IHtcclxuICAgICAgZTogZSxcclxuICAgICAgZmlsZTogZmlsZSxcclxuICAgICAgY29udGVudDogY29udGVudFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICB1cGxvYWQ6IGZ1bmN0aW9uKGUsIGZpbGUsIGNvbnRlbnQsIHBhdGgpIHtcclxuICAgIC8vIExvYWRpbmcgU3RhdGVcclxuICAgIHRoaXMudXBkYXRlU2F2ZVN0YXRlKHQoJ2FjdGlvbnMudXBsb2FkLnVwbG9hZGluZycsIHsgZmlsZTogZmlsZS5uYW1lIH0pLCAnc2F2aW5nJyk7XHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byBtZWRpYSBkaXJlY3RvcnkgaWYgZGVmaW5lZCBpbiBjb25maWcsXHJcbiAgICAvLyBjdXJyZW50IGRpcmVjdG9yeSBpZiBubyBwYXRoIHNwZWNpZmllZFxyXG4gICAgdmFyIGRpciA9IHRoaXMuY29uZmlnLm1lZGlhID8gdGhpcy5jb25maWcubWVkaWEgOlxyXG4gICAgICB1dGlsLmV4dHJhY3RGaWxlbmFtZSh0aGlzLm1vZGVsLmdldCgncGF0aCcpKVswXTtcclxuICAgIHBhdGggPSBwYXRoIHx8IF8uY29tcGFjdChbZGlyLCBmaWxlLm5hbWVdKS5qb2luKCcvJyk7XHJcblxyXG4gICAgdGhpcy5jb2xsZWN0aW9uLnVwbG9hZChmaWxlLCBjb250ZW50LCBwYXRoLCB7XHJcbiAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihtb2RlbCwgcmVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSByZXMuY29udGVudC5uYW1lO1xyXG4gICAgICAgIHZhciBwYXRoID0gcmVzLmNvbnRlbnQucGF0aDtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogd2hlcmUgZG9lcyAkYWx0IGV4aXN0IGluIHRoZSBVST9cclxuICAgICAgICB2YXIgJGFsdCA9ICQoJ2lucHV0W25hbWU9XCJhbHRcIl0nKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSAkYWx0LnZhbCgpO1xyXG4gICAgICAgIHZhciBpbWFnZSA9ICh2YWx1ZSkgP1xyXG4gICAgICAgICAgJyFbJyArIHZhbHVlICsgJ10oLycgKyBwYXRoICsgJyknIDpcclxuICAgICAgICAgICchWycgKyBuYW1lICsgJ10oLycgKyBwYXRoICsgJyknO1xyXG5cclxuICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oaW1hZ2UgKyAnXFxuJywgJ2VuZCcpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2F2ZVN0YXRlKCdTYXZlZCcsICdzYXZlZCcsIHRydWUpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBEaXNwbGF5IGVycm9yIG1lc3NhZ2UgcmV0dXJuZWQgYnkgWEhSXHJcbiAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTYXZlU3RhdGUocmVzLm1lc3NhZ2UsICdlcnJvcicpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gVW5iaW5kIGJlZm9yZXVubG9hZCBwcm9tcHRcclxuICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IG51bGw7XHJcblxyXG4gICAgLy8gUmVzZXQgZGlydHkgbW9kZWxzIG9uIG5hdmlnYXRpb25cclxuICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgIHRoaXMuc3Rhc2hGaWxlKCk7XHJcbiAgICAgIHRoaXMubW9kZWwuZmV0Y2goKTtcclxuICAgIH1cclxuXHJcbiAgICBfLmludm9rZSh0aGlzLnN1YnZpZXdzLCAncmVtb3ZlJyk7XHJcbiAgICB0aGlzLnN1YnZpZXdzID0ge307XHJcblxyXG4gICAgLy8gQ2xlYXIgYW55IGZpbGUgc3RhdGUgY2xhc3NlcyBpbiAjcHJvc2VcclxuICAgIHRoaXMudXBkYXRlU2F2ZVN0YXRlKCcnLCAnJyk7XHJcblxyXG4gICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59KTtcclxuXG59KSgpIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgUmVwbyA9IHJlcXVpcmUoJy4uL21vZGVscy9yZXBvJyk7XHJcblxyXG52YXIgYXV0aCA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG52YXIgY29va2llID0gcmVxdWlyZSgnLi4vY29va2llJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuICBtb2RlbDogUmVwbyxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG5cclxuICAgIHRoaXMuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHJlcG8pIHtcclxuICAgICAgcmV0dXJuIC0obmV3IERhdGUocmVwby5nZXQoJ3VwZGF0ZWRfYXQnKSkuZ2V0VGltZSgpKTtcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgcGFyc2VMaW5rSGVhZGVyOiBmdW5jdGlvbih4aHIsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMpIHx8IHt9O1xyXG5cclxuICAgIHZhciBoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2xpbmsnKTtcclxuXHJcbiAgICBpZiAoaGVhZGVyKSB7XHJcbiAgICAgIHZhciBwYXJ0cyA9IGhlYWRlci5zcGxpdCgnLCcpO1xyXG4gICAgICB2YXIgbGlua3MgPSB7fTtcclxuXHJcbiAgICAgIF8uZWFjaChwYXJ0cywgZnVuY3Rpb24obGluaykge1xyXG4gICAgICAgIHZhciBzZWN0aW9uID0gbGluay5zcGxpdCgnOycpO1xyXG5cclxuICAgICAgICB2YXIgdXJsID0gc2VjdGlvblswXS5yZXBsYWNlKC88KC4qKT4vLCAnJDEnKS50cmltKCk7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uWzFdLnJlcGxhY2UoL3JlbD1cIiguKilcIi8sICckMScpLnRyaW0oKTtcclxuXHJcbiAgICAgICAgbGlua3NbbmFtZV0gPSB1cmw7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGxpbmtzLm5leHQpIHtcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgdHlwZTogJ0dFVCcsXHJcbiAgICAgICAgICB1cmw6IGxpbmtzLm5leHQsXHJcbiAgICAgICAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXHJcbiAgICAgICAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy5jb21wbGV0ZSkpIG9wdGlvbnMuY29tcGxldGUoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLmVycm9yKSkgb3B0aW9ucy5lcnJvcigpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcclxuXHJcbiAgICB2YXIgY2IgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcblxyXG4gICAgdmFyIHN1Y2Nlc3MgPSAoZnVuY3Rpb24ocmVzLCBzdGF0dXNUZXh0LCB4aHIpIHtcclxuICAgICAgdGhpcy5hZGQocmVzKTtcclxuICAgICAgdGhpcy5wYXJzZUxpbmtIZWFkZXIoeGhyLCB7XHJcbiAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICBjb21wbGV0ZTogY2JcclxuICAgICAgfSk7XHJcbiAgICB9KS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIEJhY2tib25lLkNvbGxlY3Rpb24ucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgXy5leHRlbmQob3B0aW9ucywge1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucGFyc2VMaW5rSGVhZGVyKG9wdGlvbnMueGhyLCB7XHJcbiAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgZXJyb3I6IGNiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pLmJpbmQodGhpcylcclxuICAgIH0pKTtcclxuICB9LFxyXG5cclxuICB1cmw6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGlkID0gY29va2llLmdldCgnaWQnKTtcclxuICAgIHZhciB0eXBlID0gdGhpcy51c2VyLmdldCgndHlwZScpO1xyXG4gICAgdmFyIHBhdGg7XHJcblxyXG4gICAgc3dpdGNoKHR5cGUpIHtcclxuICAgICAgY2FzZSAnVXNlcic6XHJcbiAgICAgICAgcGF0aCA9IChpZCAmJiB0aGlzLnVzZXIuZ2V0KCdpZCcpID09PSBpZCkgPyAnL3VzZXInIDpcclxuICAgICAgICAgICgnL3VzZXJzLycgKyB0aGlzLnVzZXIuZ2V0KCdsb2dpbicpKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdPcmdhbml6YXRpb24nOlxyXG4gICAgICAgIHBhdGggPSAnL29yZ3MvJyArIHRoaXMudXNlci5nZXQoJ2xvZ2luJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF1dGguYXBpICsgcGF0aCArICcvcmVwb3M/cGVyX3BhZ2U9MTAwJztcclxuICB9XHJcbn0pO1xyXG4iLCIoZnVuY3Rpb24oZ2xvYmFsKXsvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMywgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcblteXFxuXSspKlxcbiopKy8sXG4gIGxpc3Q6IC9eKCAqKShidWxsKSBbXFxzXFxTXSs/KD86aHJ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudHxjbG9zZWR8Y2xvc2luZykgKig/OlxcbnsyLH18XFxzKiQpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAvXFxuKyg/PSg/OiAqWy0qX10pezMsfSAqKD86XFxuK3wkKSkvKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSkgKihcXFMrKT8gKlxcbihbXFxzXFxTXSs/KVxccypcXDEgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3RfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGh0bWxcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5odG1sLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHByZTogY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/Ol9ffFtcXHNcXFNdKSs/KV9cXGJ8XlxcKigoPzpcXCpcXCp8W1xcc1xcU10pKz8pXFwqKD8hXFwqKS8sXG4gIGNvZGU6IC9eKGArKVxccyooW1xcc1xcU10qP1teYF0pXFxzKlxcMSg/IWApLyxcbiAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eW1xcc1xcU10rPyg/PVtcXFxcPCFcXFtfKmBdfCB7Mix9XFxufCQpL1xufTtcblxuaW5saW5lLl9pbnNpZGUgPSAvKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV18XFxdKD89W15cXFtdKlxcXSkpKi87XG5pbmxpbmUuX2hyZWYgPSAvXFxzKjw/KFtcXHNcXFNdKj8pPj8oPzpcXHMrWydcIl0oW1xcc1xcU10qPylbJ1wiXSk/XFxzKi87XG5cbmlubGluZS5saW5rID0gcmVwbGFjZShpbmxpbmUubGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCdocmVmJywgaW5saW5lLl9ocmVmKVxuICAoKTtcblxuaW5saW5lLnJlZmxpbmsgPSByZXBsYWNlKGlubGluZS5yZWZsaW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0gbWVyZ2Uoe30sIGlubGluZSk7XG5cbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUucGVkYW50aWMgPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBzdHJvbmc6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKXxeXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKikvXG59KTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgZXNjYXBlOiByZXBsYWNlKGlubGluZS5lc2NhcGUpKCddKScsICd+fF0pJykoKSxcbiAgdXJsOiAvXihodHRwcz86XFwvXFwvW15cXHM8XStbXjwuLDo7XCInKVxcXVxcc10pLyxcbiAgZGVsOiAvXn5+KD89XFxTKShbXFxzXFxTXSo/XFxTKX5+LyxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUudGV4dClcbiAgICAoJ118JywgJ35dfCcpXG4gICAgKCd8JywgJ3xodHRwcz86Ly98JylcbiAgICAoKVxufSk7XG5cbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gbWVyZ2Uoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IHJlcGxhY2UoaW5saW5lLmJyKSgnezIsfScsICcqJykoKSxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUuZ2ZtLnRleHQpKCd7Mix9JywgJyonKSgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ld1xuICAgICAgRXJyb3IoJ1Rva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgSW5saW5lIFJ1bGVzXG4gKi9cblxuSW5saW5lTGV4ZXIucnVsZXMgPSBpbmxpbmU7XG5cbi8qKlxuICogU3RhdGljIExleGluZy9Db21waWxpbmcgTWV0aG9kXG4gKi9cblxuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICB2YXIgaW5saW5lID0gbmV3IElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIGlubGluZS5vdXRwdXQoc3JjKTtcbn07XG5cbi8qKlxuICogTGV4aW5nL0NvbXBpbGluZ1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihzcmMpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsaW5rXG4gICAgLCB0ZXh0XG4gICAgLCBocmVmXG4gICAgLCBjYXA7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gY2FwWzFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXV0b2xpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgID8gdGhpcy5tYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IHRoaXMubWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0aGlzLm1hbmdsZSgnbWFpbHRvOicpICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJzxhIGhyZWY9XCInXG4gICAgICAgICsgaHJlZlxuICAgICAgICArICdcIj4nXG4gICAgICAgICsgdGV4dFxuICAgICAgICArICc8L2E+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSAnPGEgaHJlZj1cIidcbiAgICAgICAgKyBocmVmXG4gICAgICAgICsgJ1wiPidcbiAgICAgICAgKyB0ZXh0XG4gICAgICAgICsgJzwvYT4nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgPyBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3Ryb25nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuc3Ryb25nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSAnPHN0cm9uZz4nXG4gICAgICAgICsgdGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSlcbiAgICAgICAgKyAnPC9zdHJvbmc+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9ICc8ZW0+J1xuICAgICAgICArIHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pXG4gICAgICAgICsgJzwvZW0+JztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSAnPGNvZGU+J1xuICAgICAgICArIGVzY2FwZShjYXBbMl0sIHRydWUpXG4gICAgICAgICsgJzwvY29kZT4nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gJzxicj4nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSAnPGRlbD4nXG4gICAgICAgICsgdGhpcy5vdXRwdXQoY2FwWzFdKVxuICAgICAgICArICc8L2RlbD4nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgIHJldHVybiAnPGEgaHJlZj1cIidcbiAgICAgICsgZXNjYXBlKGxpbmsuaHJlZilcbiAgICAgICsgJ1wiJ1xuICAgICAgKyAobGluay50aXRsZVxuICAgICAgPyAnIHRpdGxlPVwiJ1xuICAgICAgKyBlc2NhcGUobGluay50aXRsZSlcbiAgICAgICsgJ1wiJ1xuICAgICAgOiAnJylcbiAgICAgICsgJz4nXG4gICAgICArIHRoaXMub3V0cHV0KGNhcFsxXSlcbiAgICAgICsgJzwvYT4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnPGltZyBzcmM9XCInXG4gICAgICArIGVzY2FwZShsaW5rLmhyZWYpXG4gICAgICArICdcIiBhbHQ9XCInXG4gICAgICArIGVzY2FwZShjYXBbMV0pXG4gICAgICArICdcIidcbiAgICAgICsgKGxpbmsudGl0bGVcbiAgICAgID8gJyB0aXRsZT1cIidcbiAgICAgICsgZXNjYXBlKGxpbmsudGl0bGUpXG4gICAgICArICdcIidcbiAgICAgIDogJycpXG4gICAgICArICc+JztcbiAgfVxufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsID0gdGV4dC5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2VuID0gbnVsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucyk7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiAnPGgnXG4gICAgICAgICsgdGhpcy50b2tlbi5kZXB0aFxuICAgICAgICArICcgaWQ9XCInXG4gICAgICAgICsgdGhpcy50b2tlbi50ZXh0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgICAgICsgJ1wiPidcbiAgICAgICAgKyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICArICc8L2gnXG4gICAgICAgICsgdGhpcy50b2tlbi5kZXB0aFxuICAgICAgICArICc+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnY29kZSc6IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodCh0aGlzLnRva2VuLnRleHQsIHRoaXMudG9rZW4ubGFuZyk7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdGhpcy50b2tlbi50ZXh0KSB7XG4gICAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy50b2tlbi5lc2NhcGVkKSB7XG4gICAgICAgIHRoaXMudG9rZW4udGV4dCA9IGVzY2FwZSh0aGlzLnRva2VuLnRleHQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwcmU+PGNvZGUnXG4gICAgICAgICsgKHRoaXMudG9rZW4ubGFuZ1xuICAgICAgICA/ICcgY2xhc3M9XCInXG4gICAgICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICAgICAgKyB0aGlzLnRva2VuLmxhbmdcbiAgICAgICAgKyAnXCInXG4gICAgICAgIDogJycpXG4gICAgICAgICsgJz4nXG4gICAgICAgICsgdGhpcy50b2tlbi50ZXh0XG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBoZWFkaW5nXG4gICAgICAgICwgaVxuICAgICAgICAsIHJvd1xuICAgICAgICAsIGNlbGxcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGJvZHkgKz0gJzx0aGVhZD5cXG48dHI+XFxuJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZWFkaW5nID0gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2ldKTtcbiAgICAgICAgYm9keSArPSAnPHRoJztcbiAgICAgICAgaWYgKHRoaXMudG9rZW4uYWxpZ25baV0pIHtcbiAgICAgICAgICBib2R5ICs9ICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyB0aGlzLnRva2VuLmFsaWduW2ldICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBib2R5ICs9ICc+JyArIGhlYWRpbmcgKyAnPC90aD5cXG4nO1xuICAgICAgfVxuICAgICAgYm9keSArPSAnPC90cj5cXG48L3RoZWFkPlxcbic7XG5cbiAgICAgIC8vIGJvZHlcbiAgICAgIGJvZHkgKz0gJzx0Ym9keT5cXG4nXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuICAgICAgICBib2R5ICs9ICc8dHI+XFxuJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgPSB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKTtcbiAgICAgICAgICBib2R5ICs9ICc8dGQnO1xuICAgICAgICAgIGlmICh0aGlzLnRva2VuLmFsaWduW2pdKSB7XG4gICAgICAgICAgICBib2R5ICs9ICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyB0aGlzLnRva2VuLmFsaWduW2pdICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keSArPSAnPicgKyBjZWxsICsgJzwvdGQ+XFxuJztcbiAgICAgICAgfVxuICAgICAgICBib2R5ICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgICBib2R5ICs9ICc8L3Rib2R5Plxcbic7XG5cbiAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nXG4gICAgICAgICsgYm9keVxuICAgICAgICArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50b2tlbi5vcmRlcmVkID8gJ29sJyA6ICd1bCdcbiAgICAgICAgLCBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8J1xuICAgICAgICArIHR5cGVcbiAgICAgICAgKyAnPlxcbidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvJ1xuICAgICAgICArIHR5cGVcbiAgICAgICAgKyAnPlxcbic7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8bGk+J1xuICAgICAgICArIGJvZHlcbiAgICAgICAgKyAnPC9saT5cXG4nO1xuICAgIH1cbiAgICBjYXNlICdsb29zZV9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPGxpPidcbiAgICAgICAgKyBib2R5XG4gICAgICAgICsgJzwvbGk+XFxuJztcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHJldHVybiAhdGhpcy50b2tlbi5wcmUgJiYgIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICA/IHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpXG4gICAgICAgIDogdGhpcy50b2tlbi50ZXh0O1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gJzxwPidcbiAgICAgICAgKyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICArICc8L3A+XFxuJztcbiAgICB9XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIHJldHVybiAnPHA+J1xuICAgICAgICArIHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgKyAnPC9wPlxcbic7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrIHx8IHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcblxuICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0XG4gICAgICAsIHRva2Vuc1xuICAgICAgLCBwZW5kaW5nXG4gICAgICAsIGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuXG4gICAgcGVuZGluZyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG91dCwgZXJyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoY29kZSA9PSBudWxsIHx8IGNvZGUgPT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKHRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdCkgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWQuJztcbiAgICBpZiAoKG9wdCB8fCBtYXJrZWQuZGVmYXVsdHMpLnNpbGVudCkge1xuICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmRlZmF1bHRzID0ge1xuICBnZm06IHRydWUsXG4gIHRhYmxlczogdHJ1ZSxcbiAgYnJlYWtzOiBmYWxzZSxcbiAgcGVkYW50aWM6IGZhbHNlLFxuICBzYW5pdGl6ZTogZmFsc2UsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG59KSh3aW5kb3cpIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBxdWV1ZShwYXJhbGxlbGlzbSkge1xuICAgIHZhciBxLFxuICAgICAgICB0YXNrcyA9IFtdLFxuICAgICAgICBzdGFydGVkID0gMCwgLy8gbnVtYmVyIG9mIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHN0YXJ0ZWQgKGFuZCBwZXJoYXBzIGZpbmlzaGVkKVxuICAgICAgICBhY3RpdmUgPSAwLCAvLyBudW1iZXIgb2YgdGFza3MgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIChzdGFydGVkIGJ1dCBub3QgZmluaXNoZWQpXG4gICAgICAgIHJlbWFpbmluZyA9IDAsIC8vIG51bWJlciBvZiB0YXNrcyBub3QgeWV0IGZpbmlzaGVkXG4gICAgICAgIHBvcHBpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yID0gbnVsbCxcbiAgICAgICAgYXdhaXQgPSBub29wLFxuICAgICAgICBhbGw7XG5cbiAgICBpZiAoIXBhcmFsbGVsaXNtKSBwYXJhbGxlbGlzbSA9IEluZmluaXR5O1xuXG4gICAgZnVuY3Rpb24gcG9wKCkge1xuICAgICAgd2hpbGUgKHBvcHBpbmcgPSBzdGFydGVkIDwgdGFza3MubGVuZ3RoICYmIGFjdGl2ZSA8IHBhcmFsbGVsaXNtKSB7XG4gICAgICAgIHZhciBpID0gc3RhcnRlZCsrLFxuICAgICAgICAgICAgdCA9IHRhc2tzW2ldLFxuICAgICAgICAgICAgYSA9IHNsaWNlLmNhbGwodCwgMSk7XG4gICAgICAgIGEucHVzaChjYWxsYmFjayhpKSk7XG4gICAgICAgICsrYWN0aXZlO1xuICAgICAgICB0WzBdLmFwcGx5KG51bGwsIGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlLCByKSB7XG4gICAgICAgIC0tYWN0aXZlO1xuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IgPSBlOyAvLyBpZ25vcmUgbmV3IHRhc2tzIGFuZCBzcXVlbGNoIGFjdGl2ZSBjYWxsYmFja3NcbiAgICAgICAgICBzdGFydGVkID0gcmVtYWluaW5nID0gTmFOOyAvLyBzdG9wIHF1ZXVlZCB0YXNrcyBmcm9tIHN0YXJ0aW5nXG4gICAgICAgICAgbm90aWZ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFza3NbaV0gPSByO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZykgcG9wcGluZyB8fCBwb3AoKTtcbiAgICAgICAgICBlbHNlIG5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSBhd2FpdChlcnJvcik7XG4gICAgICBlbHNlIGlmIChhbGwpIGF3YWl0KGVycm9yLCB0YXNrcyk7XG4gICAgICBlbHNlIGF3YWl0LmFwcGx5KG51bGwsIFtlcnJvcl0uY29uY2F0KHRhc2tzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHEgPSB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICB0YXNrcy5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgICAgKytyZW1haW5pbmc7XG4gICAgICAgICAgcG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgYXdhaXQgPSBmO1xuICAgICAgICBhbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBhd2FpdCA9IGY7XG4gICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgIGlmICghcmVtYWluaW5nKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIHF1ZXVlLnZlcnNpb24gPSBcIjEuMC43XCI7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gcXVldWU7IH0pO1xuICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IHF1ZXVlO1xuICBlbHNlIHRoaXMucXVldWUgPSBxdWV1ZTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXsvLyAgICAga2V5bWFzdGVyLmpzXHJcbi8vICAgICAoYykgMjAxMS0yMDEyIFRob21hcyBGdWNoc1xyXG4vLyAgICAga2V5bWFzdGVyLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG5cclxuOyhmdW5jdGlvbihnbG9iYWwpe1xyXG4gIHZhciBrLFxyXG4gICAgX2hhbmRsZXJzID0ge30sXHJcbiAgICBfbW9kcyA9IHsgMTY6IGZhbHNlLCAxODogZmFsc2UsIDE3OiBmYWxzZSwgOTE6IGZhbHNlIH0sXHJcbiAgICBfc2NvcGUgPSAnYWxsJyxcclxuICAgIC8vIG1vZGlmaWVyIGtleXNcclxuICAgIF9NT0RJRklFUlMgPSB7XHJcbiAgICAgICfih6cnOiAxNiwgc2hpZnQ6IDE2LFxyXG4gICAgICAn4oylJzogMTgsIGFsdDogMTgsIG9wdGlvbjogMTgsXHJcbiAgICAgICfijIMnOiAxNywgY3RybDogMTcsIGNvbnRyb2w6IDE3LFxyXG4gICAgICAn4oyYJzogOTEsIGNvbW1hbmQ6IDkxXHJcbiAgICB9LFxyXG4gICAgLy8gc3BlY2lhbCBrZXlzXHJcbiAgICBfTUFQID0ge1xyXG4gICAgICBiYWNrc3BhY2U6IDgsIHRhYjogOSwgY2xlYXI6IDEyLFxyXG4gICAgICBlbnRlcjogMTMsICdyZXR1cm4nOiAxMyxcclxuICAgICAgZXNjOiAyNywgZXNjYXBlOiAyNywgc3BhY2U6IDMyLFxyXG4gICAgICBsZWZ0OiAzNywgdXA6IDM4LFxyXG4gICAgICByaWdodDogMzksIGRvd246IDQwLFxyXG4gICAgICBkZWw6IDQ2LCAnZGVsZXRlJzogNDYsXHJcbiAgICAgIGhvbWU6IDM2LCBlbmQ6IDM1LFxyXG4gICAgICBwYWdldXA6IDMzLCBwYWdlZG93bjogMzQsXHJcbiAgICAgICcsJzogMTg4LCAnLic6IDE5MCwgJy8nOiAxOTEsXHJcbiAgICAgICdgJzogMTkyLCAnLSc6IDE4OSwgJz0nOiAxODcsXHJcbiAgICAgICc7JzogMTg2LCAnXFwnJzogMjIyLFxyXG4gICAgICAnWyc6IDIxOSwgJ10nOiAyMjEsICdcXFxcJzogMjIwXHJcbiAgICB9LFxyXG4gICAgY29kZSA9IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gX01BUFt4XSB8fCB4LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcclxuICAgIH0sXHJcbiAgICBfZG93bktleXMgPSBbXTtcclxuXHJcbiAgZm9yKGs9MTtrPDIwO2srKykgX01BUFsnZicra10gPSAxMTEraztcclxuXHJcbiAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IEFycmF5I2luZGV4T2YsIHNvIGhhdmUgYSBzaW1wbGUgcmVwbGFjZW1lbnRcclxuICBmdW5jdGlvbiBpbmRleChhcnJheSwgaXRlbSl7XHJcbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSkgaWYoYXJyYXlbaV09PT1pdGVtKSByZXR1cm4gaTtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8vIGZvciBjb21wYXJpbmcgbW9kcyBiZWZvcmUgdW5hc3NpZ25tZW50XHJcbiAgZnVuY3Rpb24gY29tcGFyZUFycmF5KGExLCBhMikge1xyXG4gICAgaWYgKGExLmxlbmd0aCAhPSBhMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYTFbaV0gIT09IGEyW2ldKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBtb2RpZmllck1hcCA9IHtcclxuICAgICAgMTY6J3NoaWZ0S2V5JyxcclxuICAgICAgMTg6J2FsdEtleScsXHJcbiAgICAgIDE3OidjdHJsS2V5JyxcclxuICAgICAgOTE6J21ldGFLZXknXHJcbiAgfTtcclxuICBmdW5jdGlvbiB1cGRhdGVNb2RpZmllcktleShldmVudCkge1xyXG4gICAgICBmb3IoayBpbiBfbW9kcykgX21vZHNba10gPSBldmVudFttb2RpZmllck1hcFtrXV07XHJcbiAgfTtcclxuXHJcbiAgLy8gaGFuZGxlIGtleWRvd24gZXZlbnRcclxuICBmdW5jdGlvbiBkaXNwYXRjaChldmVudCwgc2NvcGUpe1xyXG4gICAgdmFyIGtleSwgaGFuZGxlciwgaywgaSwgbW9kaWZpZXJzTWF0Y2g7XHJcbiAgICBrZXkgPSBldmVudC5rZXlDb2RlO1xyXG5cclxuICAgIGlmIChpbmRleChfZG93bktleXMsIGtleSkgPT0gLTEpIHtcclxuICAgICAgICBfZG93bktleXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGEgbW9kaWZpZXIga2V5LCBzZXQgdGhlIGtleS48bW9kaWZpZXJrZXluYW1lPiBwcm9wZXJ0eSB0byB0cnVlIGFuZCByZXR1cm5cclxuICAgIGlmKGtleSA9PSA5MyB8fCBrZXkgPT0gMjI0KSBrZXkgPSA5MTsgLy8gcmlnaHQgY29tbWFuZCBvbiB3ZWJraXQsIGNvbW1hbmQgb24gR2Vja29cclxuICAgIGlmKGtleSBpbiBfbW9kcykge1xyXG4gICAgICBfbW9kc1trZXldID0gdHJ1ZTtcclxuICAgICAgLy8gJ2Fzc2lnbktleScgZnJvbSBpbnNpZGUgdGhpcyBjbG9zdXJlIGlzIGV4cG9ydGVkIHRvIHdpbmRvdy5rZXlcclxuICAgICAgZm9yKGsgaW4gX01PRElGSUVSUykgaWYoX01PRElGSUVSU1trXSA9PSBrZXkpIGFzc2lnbktleVtrXSA9IHRydWU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1vZGlmaWVyS2V5KGV2ZW50KTtcclxuXHJcbiAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBpZ25vcmUgdGhlIGtleXByZXNzIChmaWx0ZXIoKSBjYW4gY2FuIGJlIG92ZXJyaWRkZW4pXHJcbiAgICAvLyBieSBkZWZhdWx0IGlnbm9yZSBrZXkgcHJlc3NlcyBpZiBhIHNlbGVjdCwgdGV4dGFyZWEsIG9yIGlucHV0IGlzIGZvY3VzZWRcclxuICAgIGlmKCFhc3NpZ25LZXkuZmlsdGVyLmNhbGwodGhpcywgZXZlbnQpKSByZXR1cm47XHJcblxyXG4gICAgLy8gYWJvcnQgaWYgbm8gcG90ZW50aWFsbHkgbWF0Y2hpbmcgc2hvcnRjdXRzIGZvdW5kXHJcbiAgICBpZiAoIShrZXkgaW4gX2hhbmRsZXJzKSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIGZvciBlYWNoIHBvdGVudGlhbCBzaG9ydGN1dFxyXG4gICAgZm9yIChpID0gMDsgaSA8IF9oYW5kbGVyc1trZXldLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGhhbmRsZXIgPSBfaGFuZGxlcnNba2V5XVtpXTtcclxuXHJcbiAgICAgIC8vIHNlZSBpZiBpdCdzIGluIHRoZSBjdXJyZW50IHNjb3BlXHJcbiAgICAgIGlmKGhhbmRsZXIuc2NvcGUgPT0gc2NvcGUgfHwgaGFuZGxlci5zY29wZSA9PSAnYWxsJyl7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgbW9kaWZpZXJzIG1hdGNoIGlmIGFueVxyXG4gICAgICAgIG1vZGlmaWVyc01hdGNoID0gaGFuZGxlci5tb2RzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgZm9yKGsgaW4gX21vZHMpXHJcbiAgICAgICAgICBpZigoIV9tb2RzW2tdICYmIGluZGV4KGhhbmRsZXIubW9kcywgK2spID4gLTEpIHx8XHJcbiAgICAgICAgICAgIChfbW9kc1trXSAmJiBpbmRleChoYW5kbGVyLm1vZHMsICtrKSA9PSAtMSkpIG1vZGlmaWVyc01hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgaGFuZGxlciBhbmQgc3RvcCB0aGUgZXZlbnQgaWYgbmVjY2Vzc2FyeVxyXG4gICAgICAgIGlmKChoYW5kbGVyLm1vZHMubGVuZ3RoID09IDAgJiYgIV9tb2RzWzE2XSAmJiAhX21vZHNbMThdICYmICFfbW9kc1sxN10gJiYgIV9tb2RzWzkxXSkgfHwgbW9kaWZpZXJzTWF0Y2gpe1xyXG4gICAgICAgICAgaWYoaGFuZGxlci5tZXRob2QoZXZlbnQsIGhhbmRsZXIpPT09ZmFsc2Upe1xyXG4gICAgICAgICAgICBpZihldmVudC5wcmV2ZW50RGVmYXVsdCkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICBlbHNlIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LmNhbmNlbEJ1YmJsZSkgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyB1bnNldCBtb2RpZmllciBrZXlzIG9uIGtleXVwXHJcbiAgZnVuY3Rpb24gY2xlYXJNb2RpZmllcihldmVudCl7XHJcbiAgICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZSwgayxcclxuICAgICAgICBpID0gaW5kZXgoX2Rvd25LZXlzLCBrZXkpO1xyXG5cclxuICAgIC8vIHJlbW92ZSBrZXkgZnJvbSBfZG93bktleXNcclxuICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBfZG93bktleXMuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGtleSA9PSA5MyB8fCBrZXkgPT0gMjI0KSBrZXkgPSA5MTtcclxuICAgIGlmKGtleSBpbiBfbW9kcykge1xyXG4gICAgICBfbW9kc1trZXldID0gZmFsc2U7XHJcbiAgICAgIGZvcihrIGluIF9NT0RJRklFUlMpIGlmKF9NT0RJRklFUlNba10gPT0ga2V5KSBhc3NpZ25LZXlba10gPSBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiByZXNldE1vZGlmaWVycygpIHtcclxuICAgIGZvcihrIGluIF9tb2RzKSBfbW9kc1trXSA9IGZhbHNlO1xyXG4gICAgZm9yKGsgaW4gX01PRElGSUVSUykgYXNzaWduS2V5W2tdID0gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLy8gcGFyc2UgYW5kIGFzc2lnbiBzaG9ydGN1dFxyXG4gIGZ1bmN0aW9uIGFzc2lnbktleShrZXksIHNjb3BlLCBtZXRob2Qpe1xyXG4gICAgdmFyIGtleXMsIG1vZHM7XHJcbiAgICBrZXlzID0gZ2V0S2V5cyhrZXkpO1xyXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG1ldGhvZCA9IHNjb3BlO1xyXG4gICAgICBzY29wZSA9ICdhbGwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvciBlYWNoIHNob3J0Y3V0XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gc2V0IG1vZGlmaWVyIGtleXMgaWYgYW55XHJcbiAgICAgIG1vZHMgPSBbXTtcclxuICAgICAga2V5ID0ga2V5c1tpXS5zcGxpdCgnKycpO1xyXG4gICAgICBpZiAoa2V5Lmxlbmd0aCA+IDEpe1xyXG4gICAgICAgIG1vZHMgPSBnZXRNb2RzKGtleSk7XHJcbiAgICAgICAga2V5ID0gW2tleVtrZXkubGVuZ3RoLTFdXTtcclxuICAgICAgfVxyXG4gICAgICAvLyBjb252ZXJ0IHRvIGtleWNvZGUgYW5kLi4uXHJcbiAgICAgIGtleSA9IGtleVswXVxyXG4gICAgICBrZXkgPSBjb2RlKGtleSk7XHJcbiAgICAgIC8vIC4uLnN0b3JlIGhhbmRsZXJcclxuICAgICAgaWYgKCEoa2V5IGluIF9oYW5kbGVycykpIF9oYW5kbGVyc1trZXldID0gW107XHJcbiAgICAgIF9oYW5kbGVyc1trZXldLnB1c2goeyBzaG9ydGN1dDoga2V5c1tpXSwgc2NvcGU6IHNjb3BlLCBtZXRob2Q6IG1ldGhvZCwga2V5OiBrZXlzW2ldLCBtb2RzOiBtb2RzIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIHVuYmluZCBhbGwgaGFuZGxlcnMgZm9yIGdpdmVuIGtleSBpbiBjdXJyZW50IHNjb3BlXHJcbiAgZnVuY3Rpb24gdW5iaW5kS2V5KGtleSwgc2NvcGUpIHtcclxuICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcrJyksXHJcbiAgICAgIG1vZHMgPSBbXSxcclxuICAgICAgaSwgb2JqO1xyXG5cclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgbW9kcyA9IGdldE1vZHMoa2V5cyk7XHJcbiAgICAgIGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuXHJcbiAgICBrZXkgPSBjb2RlKGtleSk7XHJcblxyXG4gICAgaWYgKHNjb3BlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2NvcGUgPSBnZXRTY29wZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFfaGFuZGxlcnNba2V5XSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgaW4gX2hhbmRsZXJzW2tleV0pIHtcclxuICAgICAgb2JqID0gX2hhbmRsZXJzW2tleV1baV07XHJcbiAgICAgIC8vIG9ubHkgY2xlYXIgaGFuZGxlcnMgaWYgY29ycmVjdCBzY29wZSBhbmQgbW9kcyBtYXRjaFxyXG4gICAgICBpZiAob2JqLnNjb3BlID09PSBzY29wZSAmJiBjb21wYXJlQXJyYXkob2JqLm1vZHMsIG1vZHMpKSB7XHJcbiAgICAgICAgX2hhbmRsZXJzW2tleV1baV0gPSB7fTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHdpdGggY29kZSAna2V5Q29kZScgaXMgY3VycmVudGx5IGRvd25cclxuICAvLyBDb252ZXJ0cyBzdHJpbmdzIGludG8ga2V5IGNvZGVzLlxyXG4gIGZ1bmN0aW9uIGlzUHJlc3NlZChrZXlDb2RlKSB7XHJcbiAgICAgIGlmICh0eXBlb2Yoa2V5Q29kZSk9PSdzdHJpbmcnKSB7XHJcbiAgICAgICAga2V5Q29kZSA9IGNvZGUoa2V5Q29kZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGluZGV4KF9kb3duS2V5cywga2V5Q29kZSkgIT0gLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQcmVzc2VkS2V5Q29kZXMoKSB7XHJcbiAgICAgIHJldHVybiBfZG93bktleXMuc2xpY2UoMCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWx0ZXIoZXZlbnQpe1xyXG4gICAgdmFyIHRhZ05hbWUgPSAoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQpLnRhZ05hbWU7XHJcbiAgICAvLyBpZ25vcmUga2V5cHJlc3NlZCBpbiBhbnkgZWxlbWVudHMgdGhhdCBzdXBwb3J0IGtleWJvYXJkIGRhdGEgaW5wdXRcclxuICAgIHJldHVybiAhKHRhZ05hbWUgPT0gJ0lOUFVUJyB8fCB0YWdOYW1lID09ICdTRUxFQ1QnIHx8IHRhZ05hbWUgPT0gJ1RFWFRBUkVBJyk7XHJcbiAgfVxyXG5cclxuICAvLyBpbml0aWFsaXplIGtleS48bW9kaWZpZXI+IHRvIGZhbHNlXHJcbiAgZm9yKGsgaW4gX01PRElGSUVSUykgYXNzaWduS2V5W2tdID0gZmFsc2U7XHJcblxyXG4gIC8vIHNldCBjdXJyZW50IHNjb3BlIChkZWZhdWx0ICdhbGwnKVxyXG4gIGZ1bmN0aW9uIHNldFNjb3BlKHNjb3BlKXsgX3Njb3BlID0gc2NvcGUgfHwgJ2FsbCcgfTtcclxuICBmdW5jdGlvbiBnZXRTY29wZSgpeyByZXR1cm4gX3Njb3BlIHx8ICdhbGwnIH07XHJcblxyXG4gIC8vIGRlbGV0ZSBhbGwgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gc2NvcGVcclxuICBmdW5jdGlvbiBkZWxldGVTY29wZShzY29wZSl7XHJcbiAgICB2YXIga2V5LCBoYW5kbGVycywgaTtcclxuXHJcbiAgICBmb3IgKGtleSBpbiBfaGFuZGxlcnMpIHtcclxuICAgICAgaGFuZGxlcnMgPSBfaGFuZGxlcnNba2V5XTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldLnNjb3BlID09PSBzY29wZSkgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGVsc2UgaSsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gYWJzdHJhY3Qga2V5IGxvZ2ljIGZvciBhc3NpZ24gYW5kIHVuYXNzaWduXHJcbiAgZnVuY3Rpb24gZ2V0S2V5cyhrZXkpIHtcclxuICAgIHZhciBrZXlzO1xyXG4gICAga2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XHJcbiAgICBrZXlzID0ga2V5LnNwbGl0KCcsJyk7XHJcbiAgICBpZiAoKGtleXNba2V5cy5sZW5ndGggLSAxXSkgPT0gJycpIHtcclxuICAgICAga2V5c1trZXlzLmxlbmd0aCAtIDJdICs9ICcsJztcclxuICAgIH1cclxuICAgIHJldHVybiBrZXlzO1xyXG4gIH1cclxuXHJcbiAgLy8gYWJzdHJhY3QgbW9kcyBsb2dpYyBmb3IgYXNzaWduIGFuZCB1bmFzc2lnblxyXG4gIGZ1bmN0aW9uIGdldE1vZHMoa2V5KSB7XHJcbiAgICB2YXIgbW9kcyA9IGtleS5zbGljZSgwLCBrZXkubGVuZ3RoIC0gMSk7XHJcbiAgICBmb3IgKHZhciBtaSA9IDA7IG1pIDwgbW9kcy5sZW5ndGg7IG1pKyspXHJcbiAgICBtb2RzW21pXSA9IF9NT0RJRklFUlNbbW9kc1ttaV1dO1xyXG4gICAgcmV0dXJuIG1vZHM7XHJcbiAgfVxyXG5cclxuICAvLyBjcm9zcy1icm93c2VyIGV2ZW50c1xyXG4gIGZ1bmN0aW9uIGFkZEV2ZW50KG9iamVjdCwgZXZlbnQsIG1ldGhvZCkge1xyXG4gICAgaWYgKG9iamVjdC5hZGRFdmVudExpc3RlbmVyKVxyXG4gICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbWV0aG9kLCBmYWxzZSk7XHJcbiAgICBlbHNlIGlmKG9iamVjdC5hdHRhY2hFdmVudClcclxuICAgICAgb2JqZWN0LmF0dGFjaEV2ZW50KCdvbicrZXZlbnQsIGZ1bmN0aW9uKCl7IG1ldGhvZCh3aW5kb3cuZXZlbnQpIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIHNldCB0aGUgaGFuZGxlcnMgZ2xvYmFsbHkgb24gZG9jdW1lbnRcclxuICBhZGRFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkgeyBkaXNwYXRjaChldmVudCwgX3Njb3BlKSB9KTsgLy8gUGFzc2luZyBfc2NvcGUgdG8gYSBjYWxsYmFjayB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBieSBleGVjdXRpb24uIEZpeGVzICM0OFxyXG4gIGFkZEV2ZW50KGRvY3VtZW50LCAna2V5dXAnLCBjbGVhck1vZGlmaWVyKTtcclxuXHJcbiAgLy8gcmVzZXQgbW9kaWZpZXJzIHRvIGZhbHNlIHdoZW5ldmVyIHRoZSB3aW5kb3cgaXMgKHJlKWZvY3VzZWQuXHJcbiAgYWRkRXZlbnQod2luZG93LCAnZm9jdXMnLCByZXNldE1vZGlmaWVycyk7XHJcblxyXG4gIC8vIHN0b3JlIHByZXZpb3VzbHkgZGVmaW5lZCBrZXlcclxuICB2YXIgcHJldmlvdXNLZXkgPSBnbG9iYWwua2V5O1xyXG5cclxuICAvLyByZXN0b3JlIHByZXZpb3VzbHkgZGVmaW5lZCBrZXkgYW5kIHJldHVybiByZWZlcmVuY2UgdG8gb3VyIGtleSBvYmplY3RcclxuICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xyXG4gICAgdmFyIGsgPSBnbG9iYWwua2V5O1xyXG4gICAgZ2xvYmFsLmtleSA9IHByZXZpb3VzS2V5O1xyXG4gICAgcmV0dXJuIGs7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgd2luZG93LmtleSBhbmQgd2luZG93LmtleS5zZXQvZ2V0L2RlbGV0ZVNjb3BlLCBhbmQgdGhlIGRlZmF1bHQgZmlsdGVyXHJcbiAgZ2xvYmFsLmtleSA9IGFzc2lnbktleTtcclxuICBnbG9iYWwua2V5LnNldFNjb3BlID0gc2V0U2NvcGU7XHJcbiAgZ2xvYmFsLmtleS5nZXRTY29wZSA9IGdldFNjb3BlO1xyXG4gIGdsb2JhbC5rZXkuZGVsZXRlU2NvcGUgPSBkZWxldGVTY29wZTtcclxuICBnbG9iYWwua2V5LmZpbHRlciA9IGZpbHRlcjtcclxuICBnbG9iYWwua2V5LmlzUHJlc3NlZCA9IGlzUHJlc3NlZDtcclxuICBnbG9iYWwua2V5LmdldFByZXNzZWRLZXlDb2RlcyA9IGdldFByZXNzZWRLZXlDb2RlcztcclxuICBnbG9iYWwua2V5Lm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xyXG4gIGdsb2JhbC5rZXkudW5iaW5kID0gdW5iaW5kS2V5O1xyXG5cclxuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBrZXk7XHJcblxyXG59KSh0aGlzKTtcclxuXG59KSgpIiwiLyogU2VlIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMgb2YgdXNlICovXG5cbi8qXG4gKiBUZXh0IGRpZmYgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcbiAqIEpzRGlmZi5kaWZmQ2hhcnM6IENoYXJhY3RlciBieSBjaGFyYWN0ZXIgZGlmZlxuICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXGIgcmVnZXgpIGRpZmYgd2hpY2ggaWdub3JlcyB3aGl0ZXNwYWNlXG4gKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcbiAqXG4gKiBKc0RpZmYuZGlmZkNzczogRGlmZiB0YXJnZXRlZCBhdCBDU1MgY29udGVudFxuICpcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcIiAoTXllcnMsIDE5ODYpLlxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcbiAqL1xudmFyIEpzRGlmZiA9IChmdW5jdGlvbigpIHtcbiAgLypqc2hpbnQgbWF4cGFyYW1zOiA1Ki9cbiAgZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICAgIHZhciBuID0gcztcbiAgICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICAgIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXG4gICAgcmV0dXJuIG47XG4gIH1cblxuICB2YXIgRGlmZiA9IGZ1bmN0aW9uKGlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICB0aGlzLmlnbm9yZVdoaXRlc3BhY2UgPSBpZ25vcmVXaGl0ZXNwYWNlO1xuICB9O1xuICBEaWZmLnByb3RvdHlwZSA9IHtcbiAgICAgIGRpZmY6IGZ1bmN0aW9uKG9sZFN0cmluZywgbmV3U3RyaW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgaWRlbnRpdHkgY2FzZSAodGhpcyBpcyBkdWUgdG8gdW5yb2xsaW5nIGVkaXRMZW5ndGggPT0gMFxuICAgICAgICBpZiAobmV3U3RyaW5nID09PSBvbGRTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gW3sgdmFsdWU6IG5ld1N0cmluZyB9XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0cmluZykge1xuICAgICAgICAgIHJldHVybiBbeyB2YWx1ZTogb2xkU3RyaW5nLCByZW1vdmVkOiB0cnVlIH1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IHZhbHVlOiBuZXdTdHJpbmcsIGFkZGVkOiB0cnVlIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3U3RyaW5nID0gdGhpcy50b2tlbml6ZShuZXdTdHJpbmcpO1xuICAgICAgICBvbGRTdHJpbmcgPSB0aGlzLnRva2VuaXplKG9sZFN0cmluZyk7XG5cbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgICAgICB2YXIgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcblxuICAgICAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwXG4gICAgICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcysxID49IG5ld0xlbiAmJiBvbGRQb3MrMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgICByZXR1cm4gYmVzdFBhdGhbMF0uY29tcG9uZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGVkaXRMZW5ndGggPSAxOyBlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGg7IGVkaXRMZW5ndGgrKykge1xuICAgICAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xKmVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGgrPTIpIHtcbiAgICAgICAgICAgIHZhciBiYXNlUGF0aDtcbiAgICAgICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoLTFdLFxuICAgICAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGgrMV07XG4gICAgICAgICAgICBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGgtMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zKzEgPCBuZXdMZW47XG4gICAgICAgICAgICB2YXIgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IG9sZFBvcyAmJiBvbGRQb3MgPCBvbGRMZW47XG4gICAgICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG4gICAgICAgICAgICBpZiAoIWNhbkFkZCB8fCAoY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpKSB7XG4gICAgICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgICAgICB0aGlzLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgb2xkU3RyaW5nW29sZFBvc10sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYXNlUGF0aCA9IGNsb25lUGF0aChhZGRQYXRoKTtcbiAgICAgICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgICAgIHRoaXMucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdTdHJpbmdbYmFzZVBhdGgubmV3UG9zXSwgdHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MrMSA+PSBuZXdMZW4gJiYgb2xkUG9zKzEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlUGF0aC5jb21wb25lbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcHVzaENvbXBvbmVudDogZnVuY3Rpb24oY29tcG9uZW50cywgdmFsdWUsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aC0xXTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aC0xXSA9XG4gICAgICAgICAgICB7dmFsdWU6IHRoaXMuam9pbihsYXN0LnZhbHVlLCB2YWx1ZSksIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh7dmFsdWU6IHZhbHVlLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgICAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgICAgICBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgIHdoaWxlIChuZXdQb3MrMSA8IG5ld0xlbiAmJiBvbGRQb3MrMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zKzFdLCBvbGRTdHJpbmdbb2xkUG9zKzFdKSkge1xuICAgICAgICAgIG5ld1BvcysrO1xuICAgICAgICAgIG9sZFBvcysrO1xuXG4gICAgICAgICAgdGhpcy5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZ1tuZXdQb3NdLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xuICAgICAgICByZXR1cm4gb2xkUG9zO1xuICAgICAgfSxcblxuICAgICAgZXF1YWxzOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBqb2luOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgfSxcbiAgICAgIHRva2VuaXplOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gIH07XG5cbiAgdmFyIENoYXJEaWZmID0gbmV3IERpZmYoKTtcblxuICB2YXIgV29yZERpZmYgPSBuZXcgRGlmZih0cnVlKTtcbiAgdmFyIFdvcmRXaXRoU3BhY2VEaWZmID0gbmV3IERpZmYoKTtcbiAgV29yZERpZmYudG9rZW5pemUgPSBXb3JkV2l0aFNwYWNlRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHJlbW92ZUVtcHR5KHZhbHVlLnNwbGl0KC8oXFxzK3xcXGIpLykpO1xuICB9O1xuXG4gIHZhciBDc3NEaWZmID0gbmV3IERpZmYodHJ1ZSk7XG4gIENzc0RpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiByZW1vdmVFbXB0eSh2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKSk7XG4gIH07XG5cbiAgdmFyIExpbmVEaWZmID0gbmV3IERpZmYoKTtcbiAgTGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXRMaW5lcyA9IFtdLFxuICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KC9eL20pO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLFxuICAgICAgICAgIGxhc3RMaW5lID0gbGluZXNbaSAtIDFdO1xuXG4gICAgICAvLyBNZXJnZSBsaW5lcyB0aGF0IG1heSBjb250YWluIHdpbmRvd3MgbmV3IGxpbmVzXG4gICAgICBpZiAobGluZSA9PSAnXFxuJyAmJiBsYXN0TGluZSAmJiBsYXN0TGluZVtsYXN0TGluZS5sZW5ndGggLSAxXSA9PT0gJ1xccicpIHtcbiAgICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gJ1xcbic7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUpIHtcbiAgICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0TGluZXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBEaWZmOiBEaWZmLFxuXG4gICAgZGlmZkNoYXJzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0cikgeyByZXR1cm4gQ2hhckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0cik7IH0sXG4gICAgZGlmZldvcmRzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0cikgeyByZXR1cm4gV29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0cik7IH0sXG4gICAgZGlmZldvcmRzV2l0aFNwYWNlOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0cikgeyByZXR1cm4gV29yZFdpdGhTcGFjZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0cik7IH0sXG4gICAgZGlmZkxpbmVzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0cikgeyByZXR1cm4gTGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0cik7IH0sXG5cbiAgICBkaWZmQ3NzOiBmdW5jdGlvbihvbGRTdHIsIG5ld1N0cikgeyByZXR1cm4gQ3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyKTsgfSxcblxuICAgIGNyZWF0ZVBhdGNoOiBmdW5jdGlvbihmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIHJldC5wdXNoKCdJbmRleDogJyArIGZpbGVOYW1lKTtcbiAgICAgIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgICByZXQucHVzaCgnLS0tICcgKyBmaWxlTmFtZSArICh0eXBlb2Ygb2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBvbGRIZWFkZXIpKTtcbiAgICAgIHJldC5wdXNoKCcrKysgJyArIGZpbGVOYW1lICsgKHR5cGVvZiBuZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIG5ld0hlYWRlcikpO1xuXG4gICAgICB2YXIgZGlmZiA9IExpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIpO1xuICAgICAgaWYgKCFkaWZmW2RpZmYubGVuZ3RoLTFdLnZhbHVlKSB7XG4gICAgICAgIGRpZmYucG9wKCk7ICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmUgYWRkXG4gICAgICB9XG4gICAgICBkaWZmLnB1c2goe3ZhbHVlOiAnJywgbGluZXM6IFtdfSk7ICAgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcblxuICAgICAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICcgJyArIGVudHJ5OyB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVvZk5MKGN1clJhbmdlLCBpLCBjdXJyZW50KSB7XG4gICAgICAgIHZhciBsYXN0ID0gZGlmZltkaWZmLmxlbmd0aC0yXSxcbiAgICAgICAgICAgIGlzTGFzdCA9IGkgPT09IGRpZmYubGVuZ3RoLTIsXG4gICAgICAgICAgICBpc0xhc3RPZlR5cGUgPSBpID09PSBkaWZmLmxlbmd0aC0zICYmIChjdXJyZW50LmFkZGVkICE9PSBsYXN0LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCAhPT0gbGFzdC5yZW1vdmVkKTtcblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgdGhlIGxhc3QgbGluZSBmb3IgdGhlIGdpdmVuIGZpbGUgYW5kIG1pc3NpbmcgTkxcbiAgICAgICAgaWYgKCEvXFxuJC8udGVzdChjdXJyZW50LnZhbHVlKSAmJiAoaXNMYXN0IHx8IGlzTGFzdE9mVHlwZSkpIHtcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsIG5ld1JhbmdlU3RhcnQgPSAwLCBjdXJSYW5nZSA9IFtdLFxuICAgICAgICAgIG9sZExpbmUgPSAxLCBuZXdMaW5lID0gMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xuXG4gICAgICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBkaWZmW2ktMV07XG4gICAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xuXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBjdXJSYW5nZSA9IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC00KSk7XG4gICAgICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyUmFuZ2UucHVzaC5hcHBseShjdXJSYW5nZSwgbGluZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAoY3VycmVudC5hZGRlZD8nKyc6Jy0nKSArIGVudHJ5OyB9KSk7XG4gICAgICAgICAgZW9mTkwoY3VyUmFuZ2UsIGksIGN1cnJlbnQpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDggJiYgaSA8IGRpZmYubGVuZ3RoLTIpIHtcbiAgICAgICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaC5hcHBseShjdXJSYW5nZSwgY29udGV4dExpbmVzKGxpbmVzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCA0KTtcbiAgICAgICAgICAgICAgcmV0LnB1c2goXG4gICAgICAgICAgICAgICAgICAnQEAgLScgKyBvbGRSYW5nZVN0YXJ0ICsgJywnICsgKG9sZExpbmUtb2xkUmFuZ2VTdGFydCtjb250ZXh0U2l6ZSlcbiAgICAgICAgICAgICAgICAgICsgJyArJyArIG5ld1JhbmdlU3RhcnQgKyAnLCcgKyAobmV3TGluZS1uZXdSYW5nZVN0YXJ0K2NvbnRleHRTaXplKVxuICAgICAgICAgICAgICAgICAgKyAnIEBAJyk7XG4gICAgICAgICAgICAgIHJldC5wdXNoLmFwcGx5KHJldCwgY3VyUmFuZ2UpO1xuICAgICAgICAgICAgICByZXQucHVzaC5hcHBseShyZXQsIGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgZW9mTkwocmV0LCBpLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwOyAgbmV3UmFuZ2VTdGFydCA9IDA7IGN1clJhbmdlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbiAgICB9LFxuXG4gICAgYXBwbHlQYXRjaDogZnVuY3Rpb24ob2xkU3RyLCB1bmlEaWZmKSB7XG4gICAgICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGRpZmYgPSBbXTtcbiAgICAgIHZhciByZW1FT0ZOTCA9IGZhbHNlLFxuICAgICAgICAgIGFkZEVPRk5MID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAoZGlmZnN0clswXVswXT09PSdJJz80OjApOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihkaWZmc3RyW2ldWzBdID09PSAnQCcpIHtcbiAgICAgICAgICB2YXIgbWVoID0gZGlmZnN0cltpXS5zcGxpdCgvQEAgLShcXGQrKSwoXFxkKykgXFwrKFxcZCspLChcXGQrKSBAQC8pO1xuICAgICAgICAgIGRpZmYudW5zaGlmdCh7XG4gICAgICAgICAgICBzdGFydDptZWhbM10sXG4gICAgICAgICAgICBvbGRsZW5ndGg6bWVoWzJdLFxuICAgICAgICAgICAgb2xkbGluZXM6W10sXG4gICAgICAgICAgICBuZXdsZW5ndGg6bWVoWzRdLFxuICAgICAgICAgICAgbmV3bGluZXM6W11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmKGRpZmZzdHJbaV1bMF0gPT09ICcrJykge1xuICAgICAgICAgIGRpZmZbMF0ubmV3bGluZXMucHVzaChkaWZmc3RyW2ldLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSBpZihkaWZmc3RyW2ldWzBdID09PSAnLScpIHtcbiAgICAgICAgICBkaWZmWzBdLm9sZGxpbmVzLnB1c2goZGlmZnN0cltpXS5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2UgaWYoZGlmZnN0cltpXVswXSA9PT0gJyAnKSB7XG4gICAgICAgICAgZGlmZlswXS5uZXdsaW5lcy5wdXNoKGRpZmZzdHJbaV0uc3Vic3RyKDEpKTtcbiAgICAgICAgICBkaWZmWzBdLm9sZGxpbmVzLnB1c2goZGlmZnN0cltpXS5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2UgaWYoZGlmZnN0cltpXVswXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgaWYgKGRpZmZzdHJbaS0xXVswXSA9PT0gJysnKSB7XG4gICAgICAgICAgICByZW1FT0ZOTCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmKGRpZmZzdHJbaS0xXVswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBhZGRFT0ZOTCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHIgPSBvbGRTdHIuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yICh2YXIgaSA9IGRpZmYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGQgPSBkaWZmW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGQub2xkbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZihzdHJbZC5zdGFydC0xK2pdICE9PSBkLm9sZGxpbmVzW2pdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RyLFtkLnN0YXJ0LTEsK2Qub2xkbGVuZ3RoXS5jb25jYXQoZC5uZXdsaW5lcykpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtRU9GTkwpIHtcbiAgICAgICAgd2hpbGUgKCFzdHJbc3RyLmxlbmd0aC0xXSkge1xuICAgICAgICAgIHN0ci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgICAgICBzdHIucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJ1xcbicpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0Q2hhbmdlc1RvWE1MOiBmdW5jdGlvbihjaGFuZ2VzKXtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcblxuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuICAgIGNvbnZlcnRDaGFuZ2VzVG9ETVA6IGZ1bmN0aW9uKGNoYW5nZXMpe1xuICAgICAgdmFyIHJldCA9IFtdLCBjaGFuZ2U7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgIHJldC5wdXNoKFsoY2hhbmdlLmFkZGVkID8gMSA6IGNoYW5nZS5yZW1vdmVkID8gLTEgOiAwKSwgY2hhbmdlLnZhbHVlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSnNEaWZmO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaHJvbm8nKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xyXG4iLCIoZnVuY3Rpb24oKXtcblxuLy8gQ29tbW9uSlMgZXhwb3J0cy5cbnZhciBkYXRhID0gKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykgPyBleHBvcnRzIDoge307XG5cbmRhdGEudHpUb09mZnNldCA9IHtcbiAgJ0FDRFQnOiAtNjMwLFxuICAnQUNTVCc6IC01NzAsXG4gICdBQ1QnOiAtNDgwLFxuICAnQURUJzogKzE4MCxcbiAgJ0FFRFQnOiAtNjYwLFxuICAnQUVTVCc6IC02MDAsXG4gICdBRlQnOiAtMjcwLFxuICAnQUtEVCc6ICs0ODAsXG4gICdBS1NUJzogKzU0MCxcbiAgJ0FNU1QnOiAtMzAwLFxuICAnQU1UJzogLTI0MCxcbiAgJ0FSVCc6ICsxODAsXG4gICdBU1QnOiAtMjQwLCAvLyBBcmFiIFN0YW5kYXJkIFRpbWVcbiAgJ0FXRFQnOiAtNTQwLFxuICAnQVdTVCc6IC00ODAsXG4gICdBWk9TVCc6ICs2MCxcbiAgJ0FaVCc6IC0yNDAsXG4gICdCRFQnOiAtNDgwLFxuICAnQklPVCc6IC0zNjAsXG4gICdCSVQnOiArNzIwLFxuICAnQk9UJzogKzI0MCxcbiAgJ0JSVCc6ICsxODAsXG4gICdCU1QnOiAtNjAsIC8vIEJyaXRpc2ggU3VtbWVyIFRpbWVcbiAgJ0JUVCc6IC0zNjAsXG4gICdDQVQnOiAtMTIwLFxuICAnQ0NUJzogLTM5MCxcbiAgJ0NEVCc6ICszMDAsXG4gICdDRURUJzogLTEyMCxcbiAgJ0NFU1QnOiAtMTIwLFxuICAnQ0VUJzogLTYwLFxuICAnQ0hBU1QnOiAtNzY1LFxuICAnQ2hTVCc6IC02MDAsXG4gICdDSVNUJzogKzQ4MCxcbiAgJ0NLVCc6ICs2MDAsXG4gICdDTFNUJzogKzE4MCxcbiAgJ0NMVCc6ICsyNDAsXG4gICdDT1NUJzogKzI0MCxcbiAgJ0NPVCc6ICszMDAsXG4gICdDU1QnOiAtNDgwLFxuICAnQ1NUJzogKzM2MCxcbiAgJ0NWVCc6ICs2MCxcbiAgJ0NYVCc6IC00MjAsXG4gICdERlQnOiAtNjAsXG4gICdFQVNUJzogKzM2MCxcbiAgJ0VBVCc6IC0xODAsXG4gICdFQ1QnOiArMjQwLFxuICAnRUNUJzogKzMwMCxcbiAgJ0VEVCc6ICsyNDAsXG4gICdFRURUJzogLTE4MCxcbiAgJ0VFU1QnOiAtMTgwLFxuICAnRUVUJzogLTEyMCxcbiAgJ0VTVCc6ICszMDAsXG4gICdGSlQnOiAtNzIwLFxuICAnRktTVCc6ICsyNDAsXG4gICdHQUxUJzogKzM2MCxcbiAgJ0dFVCc6IC0yNDAsXG4gICdHRlQnOiArMTgwLFxuICAnR0lMVCc6IC03MjAsXG4gICdHSVQnOiArNTQwLFxuICAnR01UJzogMCxcbiAgJ0dTVCc6ICsxMjAsXG4gICdHWVQnOiArMjQwLFxuICAnSEFEVCc6ICs1NDAsXG4gICdIQVNUJzogKzYwMCxcbiAgJ0hLVCc6IC00ODAsXG4gICdITVQnOiAtMzAwLFxuICAnSFNUJzogKzYwMCxcbiAgJ0lSS1QnOiAtNDgwLFxuICAnSVJTVCc6IC0yMTAsXG4gICdJU1QnOiAtMTIwLFxuICAnSVNUJzogLTMzMCxcbiAgJ0lTVCc6IC02MCxcbiAgJ0pTVCc6IC01NDAsXG4gICdLUkFUJzogLTQyMCxcbiAgJ0tTVCc6IC01NDAsXG4gICdMSFNUJzogLTYzMCxcbiAgJ0xJTlQnOiAtODQwLFxuICAnTUFHVCc6IC02NjAsXG4gICdNRFQnOiArMzYwLFxuICAnTUlUJzogKzU3MCxcbiAgJ01TRCc6IC0yNDAsXG4gICdNU0snOiAtMTgwLFxuICAnTVNUJzogLTM5MCxcbiAgJ01TVCc6IC00ODAsXG4gICdNU1QnOiArNDIwLFxuICAnTVVUJzogLTI0MCxcbiAgJ05EVCc6ICsxNTAsXG4gICdORlQnOiAtNjkwLFxuICAnTlBUJzogLTM0NSxcbiAgJ05TVCc6ICsyMTAsXG4gICdOVCc6ICsyMTAsXG4gICdOWlNUJzogLTcyMCxcbiAgJ05aRFQnOiAtNzgwLFxuICAnT01TVCc6IC0zNjAsXG4gICdQRFQnOiArNDIwLFxuICAnUEVUVCc6IC03MjAsXG4gICdQSE9UJzogLTc4MCxcbiAgJ1BLVCc6IC0zMDAsXG4gICdQU1QnOiAtNDgwLFxuICAnUFNUJzogKzQ4MCxcbiAgJ1JFVCc6IC0yNDAsXG4gICdTQU1UJzogLTI0MCxcbiAgJ1NBU1QnOiAtMTIwLFxuICAnU0JUJzogLTY2MCxcbiAgJ1NDVCc6IC0yNDAsXG4gICdTTFQnOiAtMzMwLFxuICAnU1NUJzogLTQ4MCxcbiAgJ1NTVCc6ICs2NjAsXG4gICdUQUhUJzogKzYwMCxcbiAgJ1RIQSc6IC00MjAsXG4gICdVVEMnOiAwLFxuICAnVVlTVCc6ICsxMjAsXG4gICdVWVQnOiArMTgwLFxuICAnVkVUJzogKzI3MCxcbiAgJ1ZMQVQnOiAtNjAwLFxuICAnV0FUJzogLTYwLFxuICAnV0VEVCc6IC02MCxcbiAgJ1dFU1QnOiAtNjAsXG4gICdZQUtUJzogLTU0MCxcbiAgJ1lFS1QnOiAtMzAwXG59O1xuXG4vLyBXaGlsZSBpbmRpY2VzIGFyZSBzdHJpbmdzIGhlcmUsIG51bWJlcnMgd29yayBmaW5lIHRvbyB3aGVuIHJldHJpZXZpbmcuXG5kYXRhLm9mZnNldFRvVHogPSB7XG4gICc3MjAnOiAgWydCSVQnXSxcbiAgJzY2MCc6ICBbJ1NTVCddLFxuICAnNjAwJzogIFsnSFNUJywgJ0NLVCcsICdIQVNUJywgJ1RBSFQnXSxcbiAgJzU3MCc6ICBbJ01JVCddLFxuICAnNTQwJzogIFsnQUtTVCcsICdHSVQnLCAnSEFEVCddLFxuICAnNDgwJzogIFsnUFNUJywgJ0FLRFQnLCAnQ0lTVCddLFxuICAnNDIwJzogIFsnTVNUJywgJ1BEVCddLFxuICAnMzYwJzogIFsnQ1NUJywgJ0VBU1QnLCAnR0FMVCcsICdNRFQnXSxcbiAgJzMwMCc6ICBbJ0VTVCcsICdDRFQnLCAnQ09UJywgJ0VDVCddLFxuICAnMjcwJzogIFsnVkVUJ10sXG4gICcyNDAnOiAgWydFQ1QnLCAnQVNUJywgJ0JPVCcsICdDTFQnLCAnQ09TVCcsICdFRFQnLCAnRktTVCcsICdHWVQnXSxcbiAgJzIxMCc6ICBbJ05UJywgJ05TVCddLFxuICAnMTgwJzogIFsnQlJUJywgJ0FEVCcsICdBUlQnLCAnQ0xTVCcsICdHRlQnLCAnVVlUJ10sXG4gICcxNTAnOiAgWydORFQnXSxcbiAgJzEyMCc6ICBbJ0dTVCcsICdVWVNUJ10sXG4gICc2MCc6ICAgWydBWk9TVCcsICdDVlQnXSxcbiAgJzAnOiAgICBbJ1VUQycsICdHTVQnXSxcbiAgJy02MCc6ICBbJ0NFVCcsICdCU1QnLCAnREZUJywgJ0lTVCcsICdXQVQnLCAnV0VEVCcsICdXRVNUJ10sXG4gICctMTIwJzogWydFRVQnLCAnQ0FUJywgJ0NFRFQnLCAnQ0VTVCcsICdJU1QnLCAnU0FTVCddLFxuICAnLTE4MCc6IFsnTVNLJywgJ0FTVCcsICdBU1QnLCAnRUFUJywgJ0VFRFQnLCAnRUVTVCddLFxuICAnLTIxMCc6IFsnSVJTVCddLFxuICAnLTI0MCc6IFsnQVNUJywgJ0FNVCcsICdBWlQnLCAnR0VUJywgJ01TRCcsICdNVVQnLCAnUkVUJywgJ1NBTVQnLCAnU0NUJ10sXG4gICctMjcwJzogWydBRlQnXSxcbiAgJy0zMDAnOiBbJ0FNU1QnLCAnSE1UJywgJ1BLVCcsICdZRUtUJ10sXG4gICctMzMwJzogWydJU1QnLCAnU0xUJ10sXG4gICctMzQ1JzogWydOUFQnXSxcbiAgJy0zNjAnOiBbJ0JJT1QnLCAnQlNUJywgJ0JUVCcsICdPTVNUJ10sXG4gICctMzkwJzogWydDQ1QnLCAnTVNUJ10sXG4gICctNDIwJzogWydDWFQnLCAnS1JBVCcsICdUSEEnXSxcbiAgJy00ODAnOiBbJ0FDVCcsICdBV1NUJywgJ0JEVCcsICdDU1QnLCAnSEtUJywgJ0lSS1QnLCAnTVNUJywgJ1BTVCcsICdTU1QnXSxcbiAgJy01NDAnOiBbJ0FXRFQnLCAnSlNUJywgJ0tTVCcsICdZQUtUJ10sXG4gICctNTcwJzogWydBQ1NUJ10sXG4gICctNjAwJzogWydBRVNUJywgJ0NoU1QnLCAnVkxBVCddLFxuICAnLTYzMCc6IFsnQUNEVCcsICdMSFNUJ10sXG4gICctNjYwJzogWydBRURUJywgJ01BR1QnLCAnU0JUJ10sXG4gICctNjkwJzogWydORlQnXSxcbiAgJy03MjAnOiBbJ0ZKVCcsICdHSUxUJywgJ1BFVFQnLCAnTlpTVCddLFxuICAnLTc2NSc6IFsnQ0hBU1QnXSxcbiAgJy03ODAnOiBbJ1BIT1QnLCAnTlpEVCddLFxuICAnLTg0MCc6IFsnTElOVCddXG59O1xuXG5kYXRhLndlZWtkYXlzID0gWyAnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknIF07XG5cbmRhdGEud2Vla2RheXNTaG9ydCA9IFsgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcgXTtcblxuZGF0YS5tb250aHMgPSBbICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJyBdO1xuXG5kYXRhLm1vbnRoc1Nob3J0ID0gWyAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnIF07XG5cbmRhdGEuaW50ZXJ2YWxzID0gW1xuICAgIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT09IDEgPyAneWVhcnMnIDogJ3llYXInOyB9LFxuICAgIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT09IDEgPyAnbW9udGhzJyA6ICdtb250aCc7IH0sXG4gICAgZnVuY3Rpb24obikgeyByZXR1cm4gbiAhPT0gMSA/ICd3ZWVrcycgOiAnd2Vlayc7IH0sXG4gICAgZnVuY3Rpb24obikgeyByZXR1cm4gbiAhPT0gMSA/ICdkYXlzJyA6ICdkYXknOyB9LFxuICAgIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT09IDEgPyAnaG91cnMnIDogJ2hvdXInOyB9LFxuICAgIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gIT09IDEgPyAnbWludXRlcycgOiAnbWludXRlJzsgfSxcbiAgICBmdW5jdGlvbihuKSB7IHJldHVybiBuICE9PSAxID8gJ3NlY29uZHMnIDogJ3NlY29uZCc7IH1cbl07XG5cbmRhdGEuaW50ZXJ2YWxGb3JtYXRzID0ge1xuICAgICdhZ28nOiAnJSBhZ28nLFxuICAgICdpbic6ICdpbiAlJ1xufTtcblxuZGF0YS5vcmRpbmFscyA9IGZ1bmN0aW9uKG51bWJlcikge1xuICBzd2l0Y2ggKG51bWJlciAlIDEwKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gKG51bWJlciAlIDEwMCAhPT0gMTEpID8gJ3N0JyA6ICd0aCc7XG4gICAgY2FzZSAyOiByZXR1cm4gKG51bWJlciAlIDEwMCAhPT0gMTIpID8gJ25kJyA6ICd0aCc7XG4gICAgY2FzZSAzOiByZXR1cm4gKG51bWJlciAlIDEwMCAhPT0gMTMpID8gJ3JkJyA6ICd0aCc7XG4gICAgZGVmYXVsdDogcmV0dXJuICd0aCc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhZDIoaSkge1xuICByZXR1cm4gaSA8IDEwID8gJzAnICsgaSA6IGk7XG59O1xuXG5mdW5jdGlvbiBwYWQyc2lnbihpKSB7XG4gIHZhciBzZ24gPSBpIDwgMCA/ICctJyA6ICcrJztcbiAgaSA9IE1hdGguYWJzKGkpO1xuICByZXR1cm4gc2duICsgKGkgPCAxMCA/ICcwJyArIGkgOiBpKTtcbn07XG5cbmZ1bmN0aW9uIHBhZDMoaSkge1xuICByZXR1cm4gaSA8IDEwID8gJzAwJyArIGkgOiBpIDwgMTAwID8gJzAnICsgaSA6IGk7XG59O1xuXG5mdW5jdGlvbiBwYWQ0c2lnbihpKSB7XG4gIHZhciBzZ24gPSBpIDwgMCA/ICctJyA6ICcrJztcbiAgaSA9IE1hdGguYWJzKGkpO1xuICByZXR1cm4gc2duICsgKGkgPCAxMCA/ICcwMDAnICsgaSA6IGkgPCAxMDAgPyAnMDAnICsgaSA6IGkgPCAxMDAwID8gJzAnICsgaSA6IGkpO1xufVxuXG5EYXRlLnByb3RvdHlwZS5pbnRlcnZhbCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBpbnZlcnNlID0gc2VsZiA+IG90aGVyO1xuICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIHNlbGYgPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IFtcbiAgICAgICAgb3RoZXIuZ2V0RnVsbFllYXIoKSAtIHNlbGYuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgb3RoZXIuZ2V0TW9udGgoKSAtIHNlbGYuZ2V0TW9udGgoKSxcbiAgICAgICAgMCwgLy8gd2Vla3NcbiAgICAgICAgb3RoZXIuZ2V0RGF0ZSgpIC0gc2VsZi5nZXREYXRlKCksXG4gICAgICAgIG90aGVyLmdldEhvdXJzKCkgLSBzZWxmLmdldEhvdXJzKCksXG4gICAgICAgIG90aGVyLmdldE1pbnV0ZXMoKSAtIHNlbGYuZ2V0TWludXRlcygpLFxuICAgICAgICBvdGhlci5nZXRTZWNvbmRzKCkgLSBzZWxmLmdldFNlY29uZHMoKVxuICAgIF07XG4gICAgaWYgKHBhcnRzWzZdIDwgMCkgeyBwYXJ0c1s1XS0tOyBwYXJ0c1s2XSArPSA2MDsgfVxuICAgIGlmIChwYXJ0c1s1XSA8IDApIHsgcGFydHNbNF0tLTsgcGFydHNbNV0gKz0gNjA7IH1cbiAgICBpZiAocGFydHNbNF0gPCAwKSB7IHBhcnRzWzNdLS07IHBhcnRzWzRdICs9IDI0OyB9XG4gICAgaWYgKHBhcnRzWzNdIDwgMCkgeyBwYXJ0c1sxXS0tOyBwYXJ0c1szXSArPSBzZWxmLmdldFVUQ0RheXNPZk1vbnRoKCk7IH1cbiAgICBpZiAocGFydHNbMV0gPCAwKSB7IHBhcnRzWzBdLS07IHBhcnRzWzFdICs9IDEyOyB9XG4gICAgcGFydHNbMl0gPSAocGFydHNbM10gLyA3KSB8IDA7XG4gICAgcGFydHNbM10gLT0gcGFydHNbMl0gKiA3O1xuXG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldKSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChwYXJ0c1tpXSArICcgJyArIGRhdGEuaW50ZXJ2YWxzW2ldKHBhcnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50cztcbn07XG5cbkRhdGUucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCwgdHopIHtcbiAgdmFyIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblxuICBpZiAodHogPT09IHVuZGVmaW5lZCkge1xuICAgIHR6ID0gdGhpcy5nZXRUaW1lem9uZSgpO1xuICAgIHR6TmFtZSA9IHRoaXMuZ2V0VGltZXpvbmVOYW1lKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHR6RGF0YSA9IHBhcnNlVGltZXpvbmUodHopO1xuICAgIHR6ID0gdHpEYXRhWzBdO1xuICAgIHZhciB0ek5hbWUgPSB0ekRhdGFbMV07XG4gIH1cblxuICAvLyBVc2UgY29ycmVjdCB0aW1lem9uZS5cbiAgdGhpcy5zZXRUaW1lKHRpbWUgLSB0eiAqIDYwMDAwKTtcblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChmb3JtYXQuY2hhckF0KGkpKSB7XG4gICAgICAvLyBEYXlcbiAgICAgIGNhc2UgJ2QnOiByZXN1bHQgKz0gcGFkMih0aGlzLmdldFVUQ0RhdGUoKSk7IGJyZWFrO1xuICAgICAgY2FzZSAnRCc6IHJlc3VsdCArPSBkYXRhLndlZWtkYXlzU2hvcnRbdGhpcy5nZXRVVENEYXkoKV07IGJyZWFrO1xuICAgICAgY2FzZSAnaic6IHJlc3VsdCArPSB0aGlzLmdldFVUQ0RhdGUoKTsgYnJlYWs7XG4gICAgICBjYXNlICdsJzogcmVzdWx0ICs9IGRhdGEud2Vla2RheXNbdGhpcy5nZXRVVENEYXkoKV07IGJyZWFrO1xuICAgICAgY2FzZSAnTic6IHJlc3VsdCArPSB0aGlzLmdldFVUQ0RheSgpIHx8IDc7IGJyZWFrO1xuICAgICAgY2FzZSAnUyc6IHJlc3VsdCArPSBkYXRhLm9yZGluYWxzKHRoaXMuZ2V0VVRDRGF0ZSgpKTsgYnJlYWs7XG4gICAgICBjYXNlICd3JzogcmVzdWx0ICs9IHRoaXMuZ2V0VVRDRGF5KCk7IGJyZWFrO1xuICAgICAgY2FzZSAneic6IHJlc3VsdCArPSB0aGlzLmdldFVUQ0RheU9mWWVhcigpOyBicmVhaztcblxuICAgICAgLy8gV2Vla1xuICAgICAgY2FzZSAnVyc6IHJlc3VsdCArPSBwYWQyKHRoaXMuZ2V0VVRDSVNPV2VlaygpKTsgYnJlYWs7XG5cbiAgICAgIC8vIE1vbnRoXG4gICAgICBjYXNlICdGJzogcmVzdWx0ICs9IGRhdGEubW9udGhzW3RoaXMuZ2V0VVRDTW9udGgoKV07IGJyZWFrO1xuICAgICAgY2FzZSAnbSc6IHJlc3VsdCArPSBwYWQyKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpOyBicmVhaztcbiAgICAgIGNhc2UgJ00nOiByZXN1bHQgKz0gZGF0YS5tb250aHNTaG9ydFt0aGlzLmdldFVUQ01vbnRoKCldOyBicmVhaztcbiAgICAgIGNhc2UgJ24nOiByZXN1bHQgKz0gdGhpcy5nZXRVVENNb250aCgpICsgMTsgYnJlYWs7XG4gICAgICBjYXNlICd0JzogcmVzdWx0ICs9IHRoaXMuZ2V0VVRDRGF5c09mTW9udGgoKTsgYnJlYWs7XG5cbiAgICAgIC8vIFllYXJcbiAgICAgIGNhc2UgJ0wnOiByZXN1bHQgKz0gdGhpcy5pc0xlYXBZZWFyKCkgPyAxIDogMDsgYnJlYWs7XG4gICAgICBjYXNlICdvJzogcmVzdWx0ICs9IHRoaXMuZ2V0VVRDSVNPRnVsbFllYXIoKTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogcmVzdWx0ICs9IHRoaXMuZ2V0VVRDRnVsbFllYXIoKTsgYnJlYWs7XG4gICAgICBjYXNlICd5JzogcmVzdWx0ICs9IHBhZDIodGhpcy5nZXRVVENGdWxsWWVhcigpICUgMTAwKTsgYnJlYWs7XG5cbiAgICAgIC8vIFRpbWVcbiAgICAgIGNhc2UgJ2EnOiByZXN1bHQgKz0gdGhpcy5nZXRVVENIb3VycygpID49IDEyID8gJ3BtJyA6ICdhbSc7IGJyZWFrO1xuICAgICAgY2FzZSAnQSc6IHJlc3VsdCArPSB0aGlzLmdldFVUQ0hvdXJzKCkgPj0gMTIgPyAnUE0nIDogJ0FNJzsgYnJlYWs7XG4gICAgICBjYXNlICdnJzogcmVzdWx0ICs9IHRoaXMuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyOyBicmVhaztcbiAgICAgIGNhc2UgJ0cnOiByZXN1bHQgKz0gdGhpcy5nZXRVVENIb3VycygpOyBicmVhaztcbiAgICAgIGNhc2UgJ2gnOiByZXN1bHQgKz0gcGFkMih0aGlzLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMik7IGJyZWFrO1xuICAgICAgY2FzZSAnSCc6IHJlc3VsdCArPSBwYWQyKHRoaXMuZ2V0VVRDSG91cnMoKSk7IGJyZWFrO1xuICAgICAgY2FzZSAnaSc6IHJlc3VsdCArPSBwYWQyKHRoaXMuZ2V0VVRDTWludXRlcygpKTsgYnJlYWs7XG4gICAgICBjYXNlICdzJzogcmVzdWx0ICs9IHBhZDIodGhpcy5nZXRVVENTZWNvbmRzKCkpOyBicmVhaztcbiAgICAgIGNhc2UgJ3UnOiByZXN1bHQgKz0gcGFkMyh0aGlzLmdldFVUQ01pbGxpc2Vjb25kcygpKTsgYnJlYWs7XG5cbiAgICAgIC8vIFRpbWV6b25lXG4gICAgICBjYXNlICdPJzogcmVzdWx0ICs9IHBhZDRzaWduKCh0eiA8IDAgPyAxIDogLTEpICogKE1hdGguZmxvb3IoTWF0aC5hYnModHopIC8gNjApICogMTAwICsgTWF0aC5hYnModHopICUgNjApKTsgYnJlYWs7XG4gICAgICBjYXNlICdQJzogcmVzdWx0ICs9IHBhZDJzaWduKCh0eiA8IDAgPyAxIDogLTEpICogKE1hdGguZmxvb3IoTWF0aC5hYnModHopIC8gNjApKSkgKyAnOicgKyBwYWQyKE1hdGguYWJzKHR6KSAlIDYwKTsgYnJlYWs7XG4gICAgICBjYXNlICdUJzogcmVzdWx0ICs9IHR6TmFtZTsgYnJlYWs7XG4gICAgICBjYXNlICdaJzogcmVzdWx0ICs9IC10eiAqIDYwOyBicmVhaztcblxuICAgICAgLy8gRnVsbCBEYXRlL1RpbWVcbiAgICAgIGNhc2UgJ2MnOiB0aGlzLnNldFRpbWUodGltZSk7IHJlc3VsdCArPSB0aGlzLmZvcm1hdCgnWS1tLWRcXFxcVEg6aTpzUCcsIHR6KTsgYnJlYWs7XG4gICAgICBjYXNlICdyJzogdGhpcy5zZXRUaW1lKHRpbWUpOyByZXN1bHQgKz0gdGhpcy5mb3JtYXQoJ0QsIGQgTSB5IEg6aTpzIE8nLCB0eik7IGJyZWFrO1xuICAgICAgY2FzZSAnVSc6IHJlc3VsdCArPSBNYXRoLmZsb29yKHRoaXMuZ2V0VGltZSgpIC8gMTAwMCk7IGJyZWFrO1xuXG4gICAgICBjYXNlICdcXFxcJzogaWYgKGZvcm1hdC5jaGFyQXQoKytpKSAhPT0gdW5kZWZpbmVkKSByZXN1bHQgKz0gZm9ybWF0LmNoYXJBdChpKTsgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IHJlc3VsdCArPSBmb3JtYXQuY2hhckF0KGkpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnNldFRpbWUodGltZSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmUodHopIHtcbiAgaWYgKHR5cGVvZiB0eiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW3R6LCB0eiBpbiBkYXRhLm9mZnNldFRvVHogPyBkYXRhLm9mZnNldFRvVHpbdHpdWzBdIDogJyddO1xuICB9XG4gIHZhciBudW1iZXIgPSBwYXJzZUludCh0eiwgMTApO1xuICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiBbZGF0YS50elRvT2Zmc2V0W3R6XSwgdHpdO1xuICB9XG4gIGVsc2Uge1xuICAgIHR6ID0gKG51bWJlciA8IDAgPyAxIDogLTEpICogKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAvIDEwMCkgKiA2MCArIE1hdGguYWJzKG51bWJlcikgJSAxMDApO1xuICAgIHJldHVybiBbdHosIHR6IGluIGRhdGEub2Zmc2V0VG9UeiA/IGRhdGEub2Zmc2V0VG9Uelt0el1bMF0gOiAnJ107XG4gIH1cbn1cblxuRGF0ZS5wcm90b3R5cGUuaXNMZWFwWWVhciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeSA9IHRoaXMuZ2V0VVRDRnVsbFllYXIoKTtcbiAgcmV0dXJuICh5ICUgNDAwID09PSAwKSB8fCAoeSAlIDQgPT09IDAgJiYgeSAlIDEwMCAhPT0gMCk7XG59O1xuXG5EYXRlLnByb3RvdHlwZS5nZXRVVENJU09XZWVrID0gZnVuY3Rpb24oKSB7XG4gIC8vIEdvIHRvIHRoZSB3ZWVrJ3MgdGh1cnNkYXkuXG4gIHZhciBkID0gbmV3IERhdGUodGhpcyk7XG4gIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSAtIChkLmdldFVUQ0RheSgpIHx8IDcpICsgNCk7XG4gIHJldHVybiBNYXRoLmNlaWwoKGQuZ2V0VGltZSgpIC0gRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwKSkgLyA4NjQwMDAwMCAvIDcpO1xufTtcblxuRGF0ZS5wcm90b3R5cGUuZ2V0VVRDSVNPRnVsbFllYXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gR28gdG8gdGhlIHdlZWsncyB0aHVyc2RheS5cbiAgdmFyIGQgPSBuZXcgRGF0ZSh0aGlzKTtcbiAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpIC0gKGQuZ2V0VVRDRGF5KCkgfHwgNykgKyA0KTtcbiAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbn07XG5cbkRhdGUucHJvdG90eXBlLmdldFVUQ0RheXNPZk1vbnRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gbmV3IERhdGUodGhpcyk7XG4gIGQuc2V0VVRDRGF0ZSgxKTtcbiAgZC5zZXRVVENNb250aChkLmdldFVUQ01vbnRoKCkgKyAxKTtcbiAgZC5zZXRVVENEYXRlKDApO1xuICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG59O1xuXG5EYXRlLnByb3RvdHlwZS5nZXRVVENEYXlPZlllYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuZ2V0VGltZSgpIC0gRGF0ZS5VVEModGhpcy5nZXRVVENGdWxsWWVhcigpLCAwKSkgLyA4NjQwMDAwMCk7XG59O1xuXG5EYXRlLnByb3RvdHlwZS5nZXRUaW1lem9uZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoISgnX3R6JyBpbiB0aGlzKSkge1xuICAgIHRoaXMuc2V0VGltZXpvbmUobmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdHo7XG59O1xuXG5EYXRlLnByb3RvdHlwZS5nZXRUaW1lem9uZU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nZXRUaW1lem9uZSgpOyAvLyBNYWtlIHN1cmUgdGhlIHR6IGRhdGEgaXMgcG9wdWxhdGVkLlxuICByZXR1cm4gdGhpcy5fdHpOYW1lO1xufTtcblxuRGF0ZS5wcm90b3R5cGUuc2V0VGltZXpvbmUgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHR6RGF0YSA9IHBhcnNlVGltZXpvbmUodmFsKTtcbiAgdGhpcy5fdHogPSB0ekRhdGFbMF07XG4gIHRoaXMuX3R6TmFtZSA9IHR6RGF0YVsxXTtcbn07XG5cbn0pKCk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xyXG59KTtcclxuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBCcmFuY2ggPSByZXF1aXJlKCcuLi9tb2RlbHMvYnJhbmNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuICBtb2RlbDogQnJhbmNoLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbztcclxuICB9LFxyXG5cclxuICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG1hcCA9IF8ubWFwKHJlc3AsIChmdW5jdGlvbihicmFuY2gpIHtcclxuICAgICByZXR1cm4gIF8uZXh0ZW5kKGJyYW5jaCwge1xyXG4gICAgICAgIHJlcG86IHRoaXMucmVwb1xyXG4gICAgICB9KVxyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgfSxcclxuXHJcbiAgdXJsOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcG8udXJsKCkgKyAnL2JyYW5jaGVzJztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubG9hZGluZyxcclxuXHJcbiAgcXVldWU6IDAsXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIHN0YXJ0OiBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICB0aGlzLnF1ZXVlKys7XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UpIHtcclxuICAgICAgdGhpcy4kZWwuZmluZCgnLm1lc3NhZ2UnKS5odG1sKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJGVsLnNob3coKTtcclxuICB9LFxyXG5cclxuICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucXVldWUgPSAwO1xyXG4gICAgdGhpcy4kZWwuZmFkZU91dCgxNTApO1xyXG4gIH0sXHJcblxyXG4gIGRvbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5kZWZlcigoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMucXVldWUtLTtcclxuICAgICAgaWYgKHRoaXMucXVldWUgPCAxKSB0aGlzLnN0b3AoKTtcclxuICAgIH0pLmJpbmQodGhpcykpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC5odG1sKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwge30sIHsgdmFyaWFibGU6ICdkYXRhJyB9KSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLm5hdixcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnY2xpY2sgYS5lZGl0JzogJ2VtaXQnLFxyXG4gICAgJ2NsaWNrIGEucHJldmlldyc6ICdlbWl0JyxcclxuICAgICdjbGljayBhLm1ldGEnOiAnZW1pdCcsXHJcbiAgICAnY2xpY2sgYS5zZXR0aW5ncyc6ICdlbWl0JyxcclxuICAgICdjbGljayBhLnNhdmUnOiAnZW1pdCcsXHJcbiAgICAnY2xpY2sgLm1vYmlsZSAudG9nZ2xlJzogJ3RvZ2dsZU1vYmlsZSdcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xyXG4gICAgdGhpcy5zaWRlYmFyID0gb3B0aW9ucy5zaWRlYmFyO1xyXG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC5odG1sKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwge1xyXG4gICAgICBsb2dpbjogY29uZmlnLnNpdGUgKyAnL2xvZ2luL29hdXRoL2F1dGhvcml6ZT9jbGllbnRfaWQ9JyArIGNvbmZpZy5pZCArICcmc2NvcGU9cmVwbydcclxuICAgIH0sIHsgdmFyaWFibGU6ICdkYXRhJyB9KSk7XHJcblxyXG4gICAgdGhpcy4kc2F2ZSA9IHRoaXMuJGVsLmZpbmQoJy5maWxlIC5zYXZlIC5wb3B1cCcpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgZW1pdDogZnVuY3Rpb24oZSkge1xyXG4gICAgLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGhhY2sgZXhjZXB0aW9uXHJcbiAgICBpZiAoZSAmJiAhJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKCdwcmV2aWV3JykpIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICB2YXIgc3RhdGUgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnc3RhdGUnKTtcclxuICAgIGlmICgkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcbiAgICAgIC8vIHJldHVybiB0byBmaWxlIHN0YXRlXHJcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFjdGl2ZShzdGF0ZSk7XHJcbiAgICB0aGlzLnRvZ2dsZShzdGF0ZSwgZSk7XHJcbiAgfSxcclxuXHJcbiAgc2V0RmlsZVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgdGhpcy5hY3RpdmUoc3RhdGUpO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbihsYWJlbCwgY2xhc3Nlcywga2lsbCkge1xyXG5cclxuICAgIGlmICghbGFiZWwpIGxhYmVsID0gdCgnbmF2aWdhdGlvbi5zYXZlJyk7XHJcbiAgICB0aGlzLiRzYXZlLmh0bWwobGFiZWwpO1xyXG5cclxuICAgIC8vIEFkZCwgcmVtb3ZlIGNsYXNzZXMgdG8gdGhlIGZpbGUgbmF2IGdyb3VwXHJcbiAgICB0aGlzLiRlbC5maW5kKCcuZmlsZScpXHJcbiAgICAgIC5yZW1vdmVDbGFzcygnZXJyb3Igc2F2aW5nIHNhdmVkIHNhdmUnKVxyXG4gICAgICAuYWRkQ2xhc3MoY2xhc3Nlcyk7XHJcblxyXG4gICAgaWYgKGtpbGwpIHtcclxuICAgICAgXy5kZWxheSgoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnLmZpbGUnKS5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgbW9kZTogZnVuY3Rpb24obW9kZSkge1xyXG4gICAgdGhpcy4kZWwuYXR0cignY2xhc3MnLCBtb2RlKTtcclxuICB9LFxyXG5cclxuICBhY3RpdmU6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAvLyBDb2VyY2UgJ25ldycgdG8gJ2VkaXQnIHRvIGFjdGl2YXRlIGNvcnJlY3QgaWNvblxyXG4gICAgc3RhdGUgPSAoc3RhdGUgPT09ICduZXcnID8gJ2VkaXQnIDogc3RhdGUpO1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLmZpbGUgYScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgIHRoaXMuJGVsLmZpbmQoJy5maWxlIGFbZGF0YS1zdGF0ZT0nICsgc3RhdGUgKyAnXScpLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcclxuICB9LFxyXG5cclxuICB0b2dnbGU6IGZ1bmN0aW9uKHN0YXRlLCBlKSB7XHJcbiAgICB0aGlzLnRyaWdnZXIoc3RhdGUsIGUpO1xyXG4gIH0sXHJcblxyXG4gIHRvZ2dsZU1vYmlsZTogZnVuY3Rpb24oZSkge1xyXG4gICAgdGhpcy5zaWRlYmFyLnRvZ2dsZU1vYmlsZSgpO1xyXG4gICAgJChlLnRhcmdldCkudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuXHJcbnZhciB2aWV3cyA9IHtcclxuICBicmFuY2hlczogcmVxdWlyZSgnLi9zaWRlYmFyL2JyYW5jaGVzJyksXHJcbiAgaGlzdG9yeTogcmVxdWlyZSgnLi9zaWRlYmFyL2hpc3RvcnknKSxcclxuICBkcmFmdHM6IHJlcXVpcmUoJy4vc2lkZWJhci9kcmFmdHMnKSxcclxuICBvcmdzOiByZXF1aXJlKCcuL3NpZGViYXIvb3JncycpLFxyXG4gIHNhdmU6IHJlcXVpcmUoJy4vc2lkZWJhci9zYXZlJyksXHJcbiAgc2V0dGluZ3M6IHJlcXVpcmUoJy4vc2lkZWJhci9zZXR0aW5ncycpXHJcbn07XHJcblxyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMuZHJhd2VyLFxyXG5cclxuICBzdWJ2aWV3czoge30sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB7fSwgeyB2YXJpYWJsZTogJ3NpZGViYXInIH0pKTtcclxuICAgIF8uaW52b2tlKHRoaXMuc3Vidmlld3MsICdyZW5kZXInKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGluaXRTdWJ2aWV3OiBmdW5jdGlvbihzdWJ2aWV3LCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIXZpZXdzW3N1YnZpZXddKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgdmFyIHZpZXcgPSBuZXcgdmlld3Nbc3Vidmlld10ob3B0aW9ucyk7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcjJyArIHN1YnZpZXcpLmh0bWwodmlldy5lbCk7XHJcblxyXG4gICAgdGhpcy5zdWJ2aWV3c1tzdWJ2aWV3XSA9IHZpZXc7XHJcblxyXG4gICAgcmV0dXJuIHZpZXc7XHJcbiAgfSxcclxuXHJcbiAgZmlsZXBhdGhHZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoJy5maWxlcGF0aCcpLnZhbCgpO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbihsYWJlbCkge1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLmJ1dHRvbi5zYXZlJykuaHRtbChsYWJlbCk7XHJcbiAgfSxcclxuXHJcbiAgb3BlbjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnb3BlbicsIHRydWUpO1xyXG4gIH0sXHJcblxyXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdvcGVuJywgZmFsc2UpO1xyXG4gIH0sXHJcblxyXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnb3BlbicpO1xyXG4gIH0sXHJcblxyXG4gIHRvZ2dsZU1vYmlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnbW9iaWxlJyk7XHJcbiAgfSxcclxuXHJcbiAgbW9kZTogZnVuY3Rpb24obW9kZSkge1xyXG4gICAgLy8gU2V0IGRhdGEtbW9kZSBhdHRyaWJ1dGUgdG8gdG9nZ2xlIG5hdiBidXR0b25zIGluIENTU1xyXG4gICAgdGhpcy4kZWwuYXR0cignZGF0YS1zaWRlYmFyJywgbW9kZSk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIF8uaW52b2tlKHRoaXMuc3Vidmlld3MsICdyZW1vdmUnKTtcclxuICAgIHRoaXMuc3Vidmlld3MgPSB7fTtcclxuXHJcbiAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIENvbW1pdCA9IHJlcXVpcmUoJy4uL21vZGVscy9jb21taXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xyXG4gIG1vZGVsOiBDb21taXQsXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xyXG4gICAgdGhpcy5yZXBvID0gb3B0aW9ucy5yZXBvO1xyXG4gIH0sXHJcblxyXG4gIHNldEJyYW5jaDogZnVuY3Rpb24oYnJhbmNoLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLmJyYW5jaCA9IGJyYW5jaDtcclxuICAgIHRoaXMuZmV0Y2gob3B0aW9ucyk7XHJcbiAgfSxcclxuXHJcbiAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBtYXAgPSBfLm1hcChyZXNwLCAoZnVuY3Rpb24oY29tbWl0KSB7XHJcbiAgICAgcmV0dXJuICBfLmV4dGVuZChjb21taXQsIHtcclxuICAgICAgICByZXBvOiB0aGlzLnJlcG9cclxuICAgICAgfSlcclxuICAgIH0pLmJpbmQodGhpcykpO1xyXG4gIH0sXHJcblxyXG4gIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvLnVybCgpICsgJy9jb21taXRzP3NoYT0nICsgdGhpcy5icmFuY2g7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5oZWFkZXIsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2ZvY3VzIGlucHV0JzogJ2NoZWNrUGxhY2Vob2xkZXInLFxyXG4gICAgJ2NoYW5nZSBpbnB1dFtkYXRhLW1vZGU9XCJwYXRoXCJdJzogJ3VwZGF0ZVBhdGgnLFxyXG4gICAgJ2NoYW5nZSBpbnB1dFtkYXRhLW1vZGU9XCJ0aXRsZVwiXSc6ICd1cGRhdGVUaXRsZSdcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG4gICAgdGhpcy5yZXBvID0gb3B0aW9ucy5yZXBvO1xyXG4gICAgdGhpcy5maWxlID0gb3B0aW9ucy5maWxlO1xyXG4gICAgdGhpcy5pbnB1dCA9IG9wdGlvbnMuaW5wdXQ7XHJcbiAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuICAgIHRoaXMucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xyXG4gICAgdGhpcy5hbHRlcmFibGUgPSBvcHRpb25zLmFsdGVyYWJsZTtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVzZXIgPSB0aGlzLnVzZXIgPyB0aGlzLnVzZXIuZ2V0KCdsb2dpbicpIDogdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbjtcclxuICAgIHZhciBwZXJtaXNzaW9ucyA9IHRoaXMucmVwbyA/IHRoaXMucmVwby5nZXQoJ3Blcm1pc3Npb25zJykgOiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgaXNQcml2YXRlID0gdGhpcy5yZXBvICYmIHRoaXMucmVwby5nZXQoJ3ByaXZhdGUnKSA/IHRydWUgOiBmYWxzZTtcclxuICAgIHZhciB0aXRsZSA9IHQoJ2hlYWRpbmcuZXhwbG9yZScpO1xyXG4gICAgdmFyIGF2YXRhcjtcclxuICAgIHZhciBwYXRoID0gdXNlcjtcclxuXHJcbiAgICBpZiAodGhpcy51c2VyKSB7XHJcbiAgICAgIGF2YXRhciA9ICc8aW1nIHNyYz1cIicgKyB0aGlzLnVzZXIuZ2V0KCdhdmF0YXJfdXJsJykgKyAnXCIgd2lkdGg9XCI0MFwiIGhlaWdodD1cIjQwXCIgYWx0PVwiQXZhdGFyXCIgLz4nO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbGUpIHtcclxuICAgICAgLy8gRmlsZSBWaWV3XHJcbiAgICAgIGF2YXRhciA9ICc8c3BhbiBjbGFzcz1cImljbyByb3VuZCBkb2N1bWVudCAnICsgdGhpcy5maWxlLmdldCgnbGFuZycpICsgJ1wiPjwvc3Bhbj4nO1xyXG4gICAgICB0aXRsZSA9IHRoaXMuZmlsZS5nZXQoJ3BhdGgnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlcG8gVmlld1xyXG4gICAgICB2YXIgbG9jayA9IChpc1ByaXZhdGUpID8gJyBwcml2YXRlJyA6ICcnO1xyXG5cclxuICAgICAgdGl0bGUgPSB0aGlzLnJlcG8uZ2V0KCduYW1lJyk7XHJcbiAgICAgIHBhdGggPSBwYXRoICsgJy8nICsgdGl0bGU7XHJcbiAgICAgIGF2YXRhciA9ICc8ZGl2IGNsYXNzPVwiYXZhdGFyIHJvdW5kXCI+PHNwYW4gY2xhc3M9XCJpY29uIHJvdW5kIHJlcG8nICsgbG9jayArICdcIj48L3NwYW4+PC9kaXY+JztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgYWx0ZXJhYmxlOiB0aGlzLmFsdGVyYWJsZSxcclxuICAgICAgYXZhdGFyOiBhdmF0YXIsXHJcbiAgICAgIHJlcG86IHRoaXMucmVwbyA/IHRoaXMucmVwby5hdHRyaWJ1dGVzIDogdW5kZWZpbmVkLFxyXG4gICAgICBpc1ByaXZhdGU6IGlzUHJpdmF0ZSxcclxuICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXHJcbiAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxyXG4gICAgICB1c2VyOiB1c2VyLFxyXG4gICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgIG1vZGU6IHRoaXMudGl0bGUgPyAndGl0bGUnIDogJ3BhdGgnLFxyXG4gICAgICB0cmFuc2xhdGU6IHRoaXMuZmlsZSA/IHRoaXMuZmlsZS5nZXQoJ3RyYW5zbGF0ZScpIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgZGF0YSwge1xyXG4gICAgICB2YXJpYWJsZTogJ2RhdGEnXHJcbiAgICB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgY2hlY2tQbGFjZWhvbGRlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgaWYgKHRoaXMuZmlsZS5pc05ldygpKSB7XHJcbiAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCwgdGhpcy5lbCk7XHJcbiAgICAgIGlmICghJHRhcmdldC52YWwoKSkge1xyXG4gICAgICAgICR0YXJnZXQudmFsKCR0YXJnZXQuYXR0cigncGxhY2Vob2xkZXInKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVQYXRoOiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XHJcblxyXG4gICAgdGhpcy5maWxlLnNldCgncGF0aCcsIHZhbHVlKTtcclxuICAgIHRoaXMudHJpZ2dlcignbWFrZURpcnR5Jyk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlVGl0bGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gVE9ETzogdXBkYXRlIG1ldGFkYXRhIHRpdGxlIGhlcmUsIGRvbid0IHJlbHkgb24gbWFrZURpXHJcblxyXG4gICAgLy8gT25seSB1cGRhdGUgcGF0aCBvbiBuZXcgZmlsZXMgdGhhdCBhcmUgbm90IGNsb25lZFxyXG4gICAgaWYgKHRoaXMuZmlsZS5pc05ldygpICYmICF0aGlzLmZpbGUuaXNDbG9uZSgpKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcclxuXHJcbiAgICAgIHZhciBwYXRoID0gdGhpcy5maWxlLmdldCgncGF0aCcpO1xyXG4gICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgIHZhciBuYW1lID0gcGFydHMucG9wKCk7XHJcblxyXG4gICAgICAvLyBQcmVzZXJ2ZSB0aGUgZGF0ZSBhbmQgdGhlIGV4dGVuc2lvblxyXG4gICAgICB2YXIgZGF0ZSA9IHV0aWwuZXh0cmFjdERhdGUobmFtZSk7XHJcbiAgICAgIHZhciBleHRlbnNpb24gPSBuYW1lLnNwbGl0KCcuJykucG9wKCk7XHJcblxyXG4gICAgICBwYXRoID0gcGFydHMuam9pbignLycpICsgJy8nICsgZGF0ZSArICctJyArXHJcbiAgICAgICAgdXRpbC5zdHJpbmdUb1VybCh2YWx1ZSkgKyAnLicgKyBleHRlbnNpb247XHJcblxyXG4gICAgICB0aGlzLmZpbGUuc2V0KCdwYXRoJywgcGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKCdtYWtlRGlydHknKTtcclxuICB9LFxyXG5cclxuICBpbnB1dEdldDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kZWwuZmluZCgnLmhlYWRlcmlucHV0JykudmFsKCk7XHJcbiAgfSxcclxuXHJcbiAgaGVhZGVySW5wdXRGb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcuaGVhZGVyaW5wdXQnKS5mb2N1cygpO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL2ZpbGUnKTtcclxudmFyIEZvbGRlciA9IHJlcXVpcmUoJy4uL21vZGVscy9mb2xkZXInKTtcclxudmFyIEZpbGVWaWV3ID0gcmVxdWlyZSgnLi9saS9maWxlJyk7XHJcbnZhciBGb2xkZXJWaWV3ID0gcmVxdWlyZSgnLi9saS9mb2xkZXInKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi91dGlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICBjbGFzc05hbWU6ICdsaXN0aW5ncycsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMuZmlsZXMsXHJcblxyXG4gIHN1YnZpZXdzOiB7fSxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnbW91c2VvdmVyIC5pdGVtJzogJ2FjdGl2ZUxpc3RpbmcnLFxyXG4gICAgJ21vdXNlb3ZlciAuaXRlbSBhJzogJ2FjdGl2ZUxpc3RpbmcnLFxyXG4gICAgJ2NsaWNrIC5icmVhZGNydW1iIGEnOiAnbmF2aWdhdGUnLFxyXG4gICAgJ2NsaWNrIC5pdGVtIGEnOiAnbmF2aWdhdGUnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHZhciBhcHAgPSBvcHRpb25zLmFwcDtcclxuICAgIGFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgIHRoaXMuYnJhbmNoID0gb3B0aW9ucy5icmFuY2ggfHwgb3B0aW9ucy5yZXBvLmdldCgnZGVmYXVsdF9icmFuY2gnKTtcclxuICAgIHRoaXMuYnJhbmNoZXMgPSBvcHRpb25zLmJyYW5jaGVzO1xyXG4gICAgdGhpcy5oaXN0b3J5ID0gb3B0aW9ucy5oaXN0b3J5O1xyXG4gICAgdGhpcy5uYXYgPSBvcHRpb25zLm5hdjtcclxuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCAnJztcclxuICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbztcclxuICAgIHRoaXMucm91dGVyID0gb3B0aW9ucy5yb3V0ZXI7XHJcbiAgICB0aGlzLnNlYXJjaCA9IG9wdGlvbnMuc2VhcmNoO1xyXG4gICAgdGhpcy5zaWRlYmFyID0gb3B0aW9ucy5zaWRlYmFyO1xyXG5cclxuICAgIHRoaXMuYnJhbmNoZXMuZmV0Y2goe1xyXG4gICAgICBzdWNjZXNzOiB0aGlzLnNldE1vZGVsLFxyXG4gICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnJvdXRlci5lcnJvcih4aHIpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBjb21wbGV0ZTogdGhpcy5hcHAubG9hZGVyLmRvbmVcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHNldE1vZGVsOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYXBwLmxvYWRlci5zdGFydCgpO1xyXG5cclxuICAgIHRoaXMubW9kZWwgPSB0aGlzLmJyYW5jaGVzLmZpbmRXaGVyZSh7IG5hbWU6IHRoaXMuYnJhbmNoIH0pLmZpbGVzO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZmV0Y2goe1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoaXMucGF0aCB3aXRoIHJvb3R1cmxcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tb2RlbC5jb25maWc7XHJcbiAgICAgICAgdGhpcy5yb290dXJsID0gY29uZmlnICYmIGNvbmZpZy5yb290dXJsID8gY29uZmlnLnJvb3R1cmwgOiAnJztcclxuXHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Nb2RlbCA9IHRoaXMubW9kZWwuZmlsdGVyZWRNb2RlbCB8fCB0aGlzLm1vZGVsO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoLm1vZGVsID0gdGhpcy5wcmVzZW50YXRpb25Nb2RlbDtcclxuICAgICAgICAvLyBSZW5kZXIgb24gZmV0Y2ggYW5kIG9uIHNlYXJjaFxyXG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5zZWFyY2gsICdzZWFyY2gnLCB0aGlzLnJlbmRlcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgY29tcGxldGU6IHRoaXMuYXBwLmxvYWRlci5kb25lLFxyXG4gICAgICByZXNldDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgbmV3RmlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGF0aCA9IFtcclxuICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgdGhpcy5yZXBvLmdldCgnbmFtZScpLFxyXG4gICAgICAnbmV3JyxcclxuICAgICAgdGhpcy5icmFuY2gsXHJcbiAgICAgIHRoaXMucGF0aCA/IHRoaXMucGF0aCA6IHRoaXMucm9vdHVybFxyXG4gICAgXVxyXG5cclxuICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKF8uY29tcGFjdChwYXRoKS5qb2luKCcvJyksIHRydWUpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggJiYgdGhpcy5zZWFyY2guaW5wdXQgJiYgdGhpcy5zZWFyY2guaW5wdXQudmFsKCk7XHJcbiAgICB2YXIgcm9vdHVybCA9IHRoaXMucm9vdHVybCA/IHRoaXMucm9vdHVybCArICcvJyA6ICcnO1xyXG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGggPyB0aGlzLnBhdGggKyAnLycgOiAnJztcclxuICAgIHZhciBkcmFmdHM7XHJcblxyXG4gICAgdmFyIHVybCA9IFtcclxuICAgICAgdGhpcy5yZXBvLmdldCgnb3duZXInKS5sb2dpbixcclxuICAgICAgdGhpcy5yZXBvLmdldCgnbmFtZScpLFxyXG4gICAgICAndHJlZScsXHJcbiAgICAgIHRoaXMuYnJhbmNoXHJcbiAgICBdLmpvaW4oJy8nKTtcclxuXHJcbiAgICAvLyBTZXQgcm9vdHVybCBqYWlsIGZyb20gY29sbGVjdGlvbiBjb25maWdcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgKHBhdGggPyBwYXRoIDogcm9vdHVybCkgKyAnW15cXC9dKiQnKTtcclxuXHJcbiAgICAvLyBSZW5kZXIgZHJhZnRzIGxpbmsgaW4gc2lkZWJhciBhcyBzdWJ2aWV3XHJcbiAgICAvLyBpZiBfcG9zdHMgZGlyZWN0b3J5IGV4aXN0cyBhbmQgcGF0aCBkb2VzIG5vdCBiZWdpbiB3aXRoIF9kcmFmdHNcclxuICAgIGlmICh0aGlzLnByZXNlbnRhdGlvbk1vZGVsLmdldCgnX3Bvc3RzJykgJiYgL14oPyFfZHJhZnRzKS8udGVzdCh0aGlzLnBhdGgpKSB7XHJcbiAgICAgIGRyYWZ0cyA9IHRoaXMuc2lkZWJhci5pbml0U3VidmlldygnZHJhZnRzJywge1xyXG4gICAgICAgIGxpbms6IFt1cmwsICdfZHJhZnRzJ10uam9pbignLycpLFxyXG4gICAgICAgIHNpZGViYXI6IHRoaXMuc2lkZWJhclxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc3Vidmlld3NbJ2RyYWZ0cyddID0gZHJhZnRzO1xyXG4gICAgICBkcmFmdHMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgIHBhcnRzOiB1dGlsLmNodW5rZWRQYXRoKHRoaXMucGF0aCksXHJcbiAgICAgIHJvb3R1cmw6IHJvb3R1cmwsXHJcbiAgICAgIHVybDogdXJsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBkYXRhLCB7dmFyaWFibGU6ICdkYXRhJ30pKTtcclxuXHJcbiAgICAvLyBpZiBub3Qgc2VhcmNoaW5nLCBmaWx0ZXIgdG8gb25seSBzaG93IGN1cnJlbnQgbGV2ZWxcclxuICAgIHZhciBjb2xsZWN0aW9uID0gc2VhcmNoID8gdGhpcy5zZWFyY2guc2VhcmNoKCkgOiB0aGlzLnByZXNlbnRhdGlvbk1vZGVsLmZpbHRlcigoZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICByZXR1cm4gcmVnZXgudGVzdChmaWxlLmdldCgncGF0aCcpKTtcclxuICAgIH0pLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuICAgIGNvbGxlY3Rpb24uZWFjaCgoZnVuY3Rpb24oZmlsZSwgaW5kZXgpIHtcclxuICAgICAgdmFyIHZpZXc7XHJcblxyXG4gICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcclxuICAgICAgICB2aWV3ID0gbmV3IEZpbGVWaWV3KHtcclxuICAgICAgICAgIGJyYW5jaDogdGhpcy5icmFuY2gsXHJcbiAgICAgICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXHJcbiAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICBtb2RlbDogZmlsZSxcclxuICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcclxuICAgICAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgRm9sZGVyKSB7XHJcbiAgICAgICAgdmlldyA9IG5ldyBGb2xkZXJWaWV3KHtcclxuICAgICAgICAgIGJyYW5jaDogdGhpcy5icmFuY2gsXHJcbiAgICAgICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXHJcbiAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICBtb2RlbDogZmlsZSxcclxuICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcclxuICAgICAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnJhZy5hcHBlbmRDaGlsZCh2aWV3LnJlbmRlcigpLmVsKTtcclxuICAgICAgdGhpcy5zdWJ2aWV3c1tmaWxlLmlkXSA9IHZpZXc7XHJcbiAgICB9KS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLiRlbC5maW5kKCd1bCcpLmh0bWwoZnJhZyk7XHJcblxyXG4gICAgdGhpcy5hcHAubG9hZGVyLmRvbmUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBhY3RpdmVMaXN0aW5nOiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgJGxpc3RpbmcgPSAkKGUudGFyZ2V0KTtcclxuXHJcbiAgICBpZiAoISRsaXN0aW5nLmhhc0NsYXNzKCdpdGVtJykpIHtcclxuICAgICAgJGxpc3RpbmcgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdsaScpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJGVsLmZpbmQoJy5pdGVtJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgJGxpc3RpbmcuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgIC8vIEJsdXIgb3V0IHNlYXJjaCBpZiBpdHMgc2VsZWN0ZWRcclxuICAgIHRoaXMuc2VhcmNoLiRlbC5ibHVyKCk7XHJcbiAgfSxcclxuXHJcbiAgbmF2aWdhdGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XHJcbiAgICB2YXIgcGF0aCA9IHRhcmdldC5ocmVmLnNwbGl0KCcjJylbMV07XHJcbiAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKC90cmVlXFwvKFteXFwvXSopXFwvPyguKikkLyk7XHJcblxyXG4gICAgaWYgKGUgJiYgbWF0Y2gpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgdGhpcy5wYXRoID0gbWF0Y2ggPyBtYXRjaFsyXSA6IHBhdGg7XHJcbiAgICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShwYXRoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5pbnZva2UodGhpcy5zdWJ2aWV3cywgJ3JlbW92ZScpO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IHt9O1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgY2xhc3NOYW1lOiAnbW9kYWwgb3ZlcmxheScsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubW9kYWwsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIC5nb3QtaXQnOiAnY29uZmlybSdcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbW9kYWwgPSB7XHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxyXG4gICAgfTtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1vZGFsLCBtb2RhbCwge1xyXG4gICAgICB2YXJpYWJsZTogJ21vZGFsJ1xyXG4gICAgfSkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGNvbmZpcm06IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXcgPSB0aGlzO1xyXG4gICAgdGhpcy4kZWwuZmFkZU91dCgnZmFzdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2aWV3LnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgY2hvc2VuID0gcmVxdWlyZSgnY2hvc2VuLWpxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHRvb2xiYXIgPSByZXF1aXJlKCcuLi90b29sYmFyL21hcmtkb3duLmpzJyk7XHJcbnZhciB1cGxvYWQgPSByZXF1aXJlKCcuLi91cGxvYWQnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLnRvb2xiYXIsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIC5ncm91cCBhJzogJ21hcmtkb3duU25pcHBldCcsXHJcbiAgICAnY2xpY2sgLnB1Ymxpc2gtZmxhZyc6ICd0b2dnbGVQdWJsaXNoaW5nJyxcclxuICAgICdjaGFuZ2UgI3VwbG9hZCc6ICdmaWxlSW5wdXQnLFxyXG4gICAgJ2NsaWNrIC5kaWFsb2cgLmluc2VydCc6ICdkaWFsb2dJbnNlcnQnLFxyXG4gICAgJ2NsaWNrIC5kcmFmdC10by1wb3N0JzogJ3Bvc3QnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5maWxlID0gb3B0aW9ucy5maWxlO1xyXG4gICAgdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3O1xyXG4gICAgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xyXG4gICAgdmFyIGNvbmZpZyA9IG9wdGlvbnMuY29uZmlnO1xyXG5cclxuICAgIGlmIChjb25maWcpIHtcclxuICAgICAgdGhpcy5oYXNNZWRpYSA9IChjb25maWcubWVkaWEpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICB0aGlzLnNpdGVVcmwgPSAoY29uZmlnLnNpdGVVcmwpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKGNvbmZpZy5tZWRpYSkge1xyXG4gICAgICAgIC8vIEZldGNoIHRoZSBtZWRpYSBkaXJlY3RvcnkgdG8gZGlzcGxheSBpdHMgY29udGVudHNcclxuICAgICAgICB0aGlzLm1lZGlhRGlyZWN0b3J5UGF0aCA9IGNvbmZpZy5tZWRpYTtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubWVkaWFEaXJlY3RvcnlQYXRoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZWRpYSA9IHRoaXMuY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24obSkge1xyXG4gICAgICAgICAgdmFyIHBhdGggPSBtLmdldCgncGF0aCcpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBtLmdldCgndHlwZScpID09PSAnZmlsZScgJiYgbWF0Y2gudGVzdChwYXRoKSAmJlxyXG4gICAgICAgICAgICAodXRpbC5pc0JpbmFyeShwYXRoKSB8fCB1dGlsLmlzSW1hZ2UobS5nZXQoJ2V4dGVuc2lvbicpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb25maWcucmVsYXRpdmVMaW5rcykge1xyXG4gICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICAgIGRhdGFUeXBlOiAnanNvbnAnLFxyXG4gICAgICAgICAganNvbnA6IGZhbHNlLFxyXG4gICAgICAgICAganNvbnBDYWxsYmFjazogY29uZmlnLnJlbGF0aXZlTGlua3Muc3BsaXQoJz9jYWxsYmFjaz0nKVsxXSB8fCAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgdXJsOiBjb25maWcucmVsYXRpdmVMaW5rcyxcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGxpbmtzKSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVsYXRpdmVMaW5rcyA9IGxpbmtzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0b29sYmFyID0ge1xyXG4gICAgICBtYXJrZG93bjogdGhpcy5maWxlLmdldCgnbWFya2Rvd24nKSxcclxuICAgICAgd3JpdGFibGU6IHRoaXMuZmlsZS5nZXQoJ3dyaXRhYmxlJyksXHJcbiAgICAgIGxhbmc6IHRoaXMuZmlsZS5nZXQoJ2xhbmcnKSxcclxuICAgICAgZHJhZnQ6IHRoaXMuZmlsZS5nZXQoJ2RyYWZ0JyksXHJcbiAgICAgIG1ldGFkYXRhOiB0aGlzLmZpbGUuZ2V0KCdtZXRhZGF0YScpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB0b29sYmFyLCB7IHZhcmlhYmxlOiAndG9vbGJhcicgfSkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGZpbGVJbnB1dDogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHZpZXcgPSB0aGlzO1xyXG4gICAgdXBsb2FkLmZpbGVTZWxlY3QoZSwgZnVuY3Rpb24oZSwgZmlsZSwgY29udGVudCkge1xyXG4gICAgICB2YXIgcGF0aCA9ICh2aWV3Lm1lZGlhRGlyZWN0b3J5UGF0aCkgPyB2aWV3Lm1lZGlhRGlyZWN0b3J5UGF0aCA6IHV0aWwuZXh0cmFjdEZpbGVuYW1lKHZpZXcuZmlsZS5hdHRyaWJ1dGVzLnBhdGgpWzBdO1xyXG4gICAgICB2YXIgc3JjID0gcGF0aCArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChmaWxlLm5hbWUpO1xyXG5cclxuICAgICAgdmlldy4kZWwuZmluZCgnaW5wdXRbbmFtZT1cInVybFwiXScpLnZhbChzcmMpO1xyXG4gICAgICB2aWV3LiRlbC5maW5kKCdpbnB1dFtuYW1lPVwiYWx0XCJdJykudmFsKCcnKTtcclxuICAgICAgdmlldy50cmlnZ2VyKCd1cGRhdGVJbWFnZUluc2VydCcsIGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLmdyb3VwIGEnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICBpZiAoYXJndW1lbnRzKSB0aGlzLiRlbC5maW5kKCdbZGF0YS1rZXk9XCInICsgdHlwZSArICdcIl0nKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgfSxcclxuXHJcbiAgcG9zdDogZnVuY3Rpb24oZSkge1xyXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIHRoaXMudHJpZ2dlcigncG9zdCcsIGUpO1xyXG4gIH0sXHJcblxyXG4gIG1hcmtkb3duU25pcHBldDogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdhJyk7XHJcbiAgICB2YXIgJGRpYWxvZyA9IHRoaXMuJGVsLmZpbmQoJyNkaWFsb2cnKTtcclxuICAgIHZhciAkc25pcHBldHMgPSB0aGlzLiRlbC5maW5kKCcuZ3JvdXAgYScpO1xyXG4gICAgdmFyIGtleSA9ICR0YXJnZXQuZGF0YSgna2V5Jyk7XHJcbiAgICB2YXIgc25pcHBldCA9ICR0YXJnZXQuZGF0YSgnc25pcHBldCcpO1xyXG4gICAgdmFyIHNlbGVjdGlvbiA9IHV0aWwudHJpbSh0aGlzLnZpZXcuZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuXHJcbiAgICAkZGlhbG9nLnJlbW92ZUNsYXNzKCkuZW1wdHkoKTtcclxuXHJcbiAgICBpZiAoc25pcHBldCkge1xyXG4gICAgICAkc25pcHBldHMucmVtb3ZlQ2xhc3MoJ29uJyk7XHJcblxyXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdib2xkJzpcclxuICAgICAgICAgIHRoaXMuYm9sZChzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcclxuICAgICAgICAgIHRoaXMuaXRhbGljKHNlbGVjdGlvbik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcclxuICAgICAgICAgIHRoaXMuaGVhZGluZyhzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3ViLWhlYWRpbmcnOlxyXG4gICAgICAgICAgdGhpcy5zdWJIZWFkaW5nKHNlbGVjdGlvbik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdxdW90ZSc6XHJcbiAgICAgICAgICB0aGlzLnF1b3RlKHNlbGVjdGlvbik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy52aWV3LmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHNuaXBwZXQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlldy5lZGl0b3IuZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnZpZXcuZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oc25pcHBldCk7XHJcbiAgICAgICAgdGhpcy52aWV3LmVkaXRvci5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCR0YXJnZXQuZGF0YSgnZGlhbG9nJykpIHtcclxuXHJcbiAgICAgIHZhciB0bXBsLCBjbGFzc05hbWU7XHJcbiAgICAgIGlmIChrZXkgPT09ICdtZWRpYScgJiYgIXRoaXMubWVkaWFEaXJlY3RvcnlQYXRoIHx8XHJcbiAgICAgICAgICBrZXkgPT09ICdtZWRpYScgJiYgIXRoaXMubWVkaWEubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjbGFzc05hbWUgPSBrZXkgKyAnIG5vLWRpcmVjdG9yeSc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjbGFzc05hbWUgPSBrZXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoaXMgY29uZGl0aW9uIGhhbmRsZXMgdGhlIGxpbmsgYW5kIG1lZGlhIGxpbmsgaW4gdGhlIHRvb2xiYXIuXHJcbiAgICAgIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKCdvbicpKSB7XHJcbiAgICAgICAgJHRhcmdldC5yZW1vdmVDbGFzcygnb24nKTtcclxuICAgICAgICAkZGlhbG9nLnJlbW92ZUNsYXNzKCkuZW1wdHkoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkc25pcHBldHMucmVtb3ZlQ2xhc3MoJ29uJyk7XHJcbiAgICAgICAgJHRhcmdldC5hZGRDbGFzcygnb24nKTtcclxuICAgICAgICAkZGlhbG9nXHJcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdkaWFsb2cgJyArIGNsYXNzTmFtZSlcclxuICAgICAgICAgIC5lbXB0eSgpO1xyXG5cclxuICAgICAgICBzd2l0Y2goa2V5KSB7XHJcbiAgICAgICAgICBjYXNlICdsaW5rJzpcclxuICAgICAgICAgICAgdG1wbCA9IF8odGVtcGxhdGVzLmRpYWxvZ3MubGluaykudGVtcGxhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICRkaWFsb2cuYXBwZW5kKHRtcGwoe1xyXG4gICAgICAgICAgICAgIHJlbGF0aXZlTGlua3M6IHNlbGYucmVsYXRpdmVMaW5rc1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5yZWxhdGl2ZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgJCgnLmNoem4tc2VsZWN0JywgJGRpYWxvZykuY2hvc2VuKCkuY2hhbmdlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJCgnLmNoem4tc2luZ2xlIHNwYW4nKS50ZXh0KCdJbnNlcnQgYSBsb2NhbCBsaW5rLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9ICQodGhpcykudmFsKCkuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICQoJ2lucHV0W25hbWU9aHJlZl0nLCAkZGlhbG9nKS52YWwocGFydHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgJCgnaW5wdXRbbmFtZT10ZXh0XScsICRkaWFsb2cpLnZhbChwYXJ0c1sxXSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAvLyB0ZXN0IGlmIHRoaXMgaXMgYSBtYXJrZG93biBsaW5rOiBbdGV4dF0obGluaylcclxuICAgICAgICAgICAgICB2YXIgbGluayA9IC9cXFsoW15cXF1dKylcXF1cXCgoW14pXSspXFwpLztcclxuICAgICAgICAgICAgICB2YXIgcXVvdGVkID0gL1wiLio/XCIvO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgdGV4dCA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICB2YXIgaHJlZjtcclxuICAgICAgICAgICAgICB2YXIgdGl0bGU7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChsaW5rLnRlc3Qoc2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbGluay5leGVjKHNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgICAgICBocmVmID0gcGFydHNbMl07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhIHRpdGxlIGF0dHJidXRlIHdpdGhpbiB0aGUgdXJsIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlZC50ZXN0KHBhcnRzWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgICBocmVmID0gcGFydHNbMl0uc3BsaXQocXVvdGVkKVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvdWxkIGJlIGltcHJvdmVkXHJcbiAgICAgICAgICAgICAgICAgIHRpdGxlID0gcGFydHNbMl0ubWF0Y2gocXVvdGVkKVswXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAkKCdpbnB1dFtuYW1lPXRleHRdJywgJGRpYWxvZykudmFsKHRleHQpO1xyXG4gICAgICAgICAgICAgIGlmIChocmVmKSAkKCdpbnB1dFtuYW1lPWhyZWZdJywgJGRpYWxvZykudmFsKGhyZWYpO1xyXG4gICAgICAgICAgICAgIGlmICh0aXRsZSkgJCgnaW5wdXRbbmFtZT10aXRsZV0nLCAkZGlhbG9nKS52YWwodGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ21lZGlhJzpcclxuICAgICAgICAgICAgdG1wbCA9IF8odGVtcGxhdGVzLmRpYWxvZ3MubWVkaWEpLnRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgICRkaWFsb2cuYXBwZW5kKHRtcGwoe1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0KCdkaWFsb2dzLm1lZGlhLmRlc2NyaXB0aW9uJywge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICc8aW5wdXQgaWQ9XCJ1cGxvYWRcIiBjbGFzcz1cInVwbG9hZFwiIHR5cGU9XCJmaWxlXCIgLz4nXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgYXNzZXRzRGlyZWN0b3J5OiAoc2VsZi5tZWRpYSAmJiBzZWxmLm1lZGlhLmxlbmd0aCkgPyB0cnVlIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHNlbGYuZmlsZS5nZXQoJ3dyaXRhYmxlJylcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYubWVkaWEgJiYgc2VsZi5tZWRpYS5sZW5ndGgpIHNlbGYucmVuZGVyTWVkaWEoc2VsZi5tZWRpYSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGltYWdlID0gL1xcIVxcWyhbXlxcW10qKVxcXVxcKChbXlxcKV0rKVxcKS87XHJcbiAgICAgICAgICAgICAgdmFyIHNyYztcclxuICAgICAgICAgICAgICB2YXIgYWx0O1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaW1hZ2UudGVzdChzZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VQYXJ0cyA9IGltYWdlLmV4ZWMoc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGFsdCA9IGltYWdlUGFydHNbMV07XHJcbiAgICAgICAgICAgICAgICBzcmMgPSBpbWFnZVBhcnRzWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICQoJ2lucHV0W25hbWU9dXJsXScsICRkaWFsb2cpLnZhbChzcmMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFsdCkgJCgnaW5wdXRbbmFtZT1hbHRdJywgJGRpYWxvZykudmFsKGFsdCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2hlbHAnOlxyXG4gICAgICAgICAgICB0bXBsID0gXyh0ZW1wbGF0ZXMuZGlhbG9ncy5oZWxwKS50ZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICAkZGlhbG9nLmFwcGVuZCh0bXBsKHtcclxuICAgICAgICAgICAgICBoZWxwOiB0b29sYmFyLmhlbHBcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGFnZSB0aHJvdWdoIGRpZmZlcmVudCBoZWxwIHNlY3Rpb25zXHJcbiAgICAgICAgICAgIHZhciAkbWFpbk1lbnUgPSB0aGlzLiRlbC5maW5kKCcubWFpbi1tZW51IGEnKTtcclxuICAgICAgICAgICAgdmFyICRzdWJNZW51ID0gdGhpcy4kZWwuZmluZCgnLnN1Yi1tZW51Jyk7XHJcbiAgICAgICAgICAgIHZhciAkY29udGVudCA9IHRoaXMuJGVsLmZpbmQoJy5oZWxwLWNvbnRlbnQnKTtcclxuXHJcbiAgICAgICAgICAgICRtYWluTWVudS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAoISQodGhpcykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgJG1haW5NZW51LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICRjb250ZW50LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICRzdWJNZW51XHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCdhJylcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVsYXZlbnQgc3ViIG1lbnVcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpLmRhdGEoJ2lkJyk7XHJcbiAgICAgICAgICAgICAgICAkKCcuJyArIHBhcmVudCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbiBhY3RpdmUgY2xhc3MgYW5kIHBvcHVsYXRlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxyXG4gICAgICAgICAgICAgICAgdmFyICRmaXJzdFN1YkVsZW1lbnQgPSAkKCcuJyArIHBhcmVudCArICcgYTpmaXJzdCcsIHRoaXMuZWwpO1xyXG4gICAgICAgICAgICAgICAgJGZpcnN0U3ViRWxlbWVudC5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHN1YlBhcmVudCA9ICRmaXJzdFN1YkVsZW1lbnQuZGF0YSgnaWQnKTtcclxuICAgICAgICAgICAgICAgICQoJy5oZWxwLScgKyBzdWJQYXJlbnQpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICRzdWJNZW51LmZpbmQoJ2EnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAoISQodGhpcykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgJHN1Yk1lbnUuZmluZCgnYScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICRjb250ZW50LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVsYXZlbnQgY29udGVudCBzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gJCh0aGlzKS5kYXRhKCdpZCcpO1xyXG4gICAgICAgICAgICAgICAgJCgnLmhlbHAtJyArIHBhcmVudCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgcHVibGlzaFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLiRlbC5maW5kKCdwdWJsaXNoLXN0YXRlJykgPT09ICd0cnVlJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVQdWJsaXNoU3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gVXBkYXRlIHRoZSBwdWJsaXNoIGtleSB3b3JkaW5nIGRlcGVuaW5nIG9uIHdoYXQgd2FzIHNhdmVkXHJcbiAgICB2YXIgJHB1Ymxpc2hrZXkgPSB0aGlzLiRlbC5maW5kKCcucHVibGlzaC1mbGFnJyk7XHJcbiAgICB2YXIga2V5ID0gJHB1Ymxpc2hLZXkuYXR0cignZGF0YS1zdGF0ZScpO1xyXG5cclxuICAgIGlmIChrZXkgPT09ICd0cnVlJykge1xyXG4gICAgICAkcHVibGlzaEtleS5odG1sKHQoJ2FjdGlvbnMucHVibGlzaGluZy5wdWJsaXNoZWQnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpY28gc21hbGwgY2hlY2ttYXJrXCI+PC9zcGFuPicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHB1Ymxpc2hLZXkuaHRtbCh0KCdhY3Rpb25zLnB1Ymxpc2hpbmcudW5wdWJsaXNoZWQnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpY28gc21hbGwgY2hlY2ttYXJrXCI+PC9zcGFuPicpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRvZ2dsZVB1Ymxpc2hpbmc6IGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciAkdGFyZ2V0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgdmFyIG1ldGFkYXRhID0gdGhpcy5maWxlLmdldCgnbWV0YWRhdGEnKTtcclxuICAgIHZhciBwdWJsaXNoZWQgPSBtZXRhZGF0YS5wdWJsaXNoZWQ7XHJcblxyXG4gICAgLy8gVE9ETzogcmVtb3ZlIEhUTUwgZnJvbSB2aWV3XHJcbiAgICAvLyBUb2dnbGluZyBwdWJsaXNoIHN0YXRlIHdoZW4gdGhlIGN1cnJlbnQgZmlsZSBpcyBwdWJsaXNoZWQgbGl2ZVxyXG4gICAgaWYgKHB1Ymxpc2hlZCkge1xyXG4gICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcygncHVibGlzaGVkJykpIHtcclxuICAgICAgICAkdGFyZ2V0XHJcbiAgICAgICAgICAuZW1wdHkoKVxyXG4gICAgICAgICAgLmFwcGVuZCh0KCdhY3Rpb25zLnB1Ymxpc2hpbmcudW5wdWJsaXNoJykgK1xyXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaWNvIHNtYWxsIGNoZWNrbWFya1wiPjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInBvcHVwIHJvdW5kIGFycm93LXRvcFwiPicgK1xyXG4gICAgICAgICAgICAgICAgdCgnYWN0aW9ucy5wdWJsaXNoaW5nLnVucHVibGlzaEluZm8nKSArXHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPicpXHJcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3B1Ymxpc2hlZCcpXHJcbiAgICAgICAgICAuYXR0cignZGF0YS1zdGF0ZScsIGZhbHNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkdGFyZ2V0XHJcbiAgICAgICAgICAuZW1wdHkoKVxyXG4gICAgICAgICAgLmFwcGVuZCh0KCdhY3Rpb25zLnB1Ymxpc2hpbmcucHVibGlzaGVkJykgK1xyXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaWNvIHNtYWxsIGNoZWNrbWFya1wiPjwvc3Bhbj4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdwdWJsaXNoZWQnKVxyXG4gICAgICAgICAgLmF0dHIoJ2RhdGEtc3RhdGUnLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ3B1Ymxpc2hlZCcpKSB7XHJcbiAgICAgICAgJHRhcmdldFxyXG4gICAgICAgICAgLmVtcHR5KClcclxuICAgICAgICAgIC5hcHBlbmQodCgnYWN0aW9ucy5wdWJsaXNoaW5nLnVucHVibGlzaGVkJykgK1xyXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaWNvIHNtYWxsIGNoZWNrbWFya1wiPjwvc3Bhbj4nKVxyXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdwdWJsaXNoZWQnKVxyXG4gICAgICAgICAgLmF0dHIoJ2RhdGEtc3RhdGUnLCBmYWxzZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJHRhcmdldFxyXG4gICAgICAgICAgLmVtcHR5KClcclxuICAgICAgICAgIC5hcHBlbmQodCgnYWN0aW9ucy5wdWJsaXNoaW5nLnB1Ymxpc2gnKSArXHJcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpY28gc21hbGwgY2hlY2ttYXJrXCI+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwicG9wdXAgcm91bmQgYXJyb3ctdG9wXCI+JyArXHJcbiAgICAgICAgICAgICAgICB0KCdhY3Rpb25zLnB1Ymxpc2hpbmcucHVibGlzaEluZm8nKSArXHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPicpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoJ3B1Ymxpc2hlZCcpXHJcbiAgICAgICAgICAuYXR0cignZGF0YS1zdGF0ZScsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5maWxlLnNldCgnbWV0YWRhdGEnLCBfLmV4dGVuZChtZXRhZGF0YSwge1xyXG4gICAgICBwdWJsaXNoZWQ6ICFwdWJsaXNoZWRcclxuICAgIH0pKTtcclxuXHJcbiAgICB0aGlzLnZpZXcubWFrZURpcnR5KCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgZGlhbG9nSW5zZXJ0OiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgJGRpYWxvZyA9ICQoJyNkaWFsb2cnLCB0aGlzLmVsKTtcclxuICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCwgdGhpcy5lbCk7XHJcbiAgICB2YXIgdHlwZSA9ICR0YXJnZXQuZGF0YSgndHlwZScpO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnbGluaycpIHtcclxuICAgICAgdmFyIGhyZWYgPSAkKCdpbnB1dFtuYW1lPVwiaHJlZlwiXScpLnZhbCgpO1xyXG4gICAgICB2YXIgdGV4dCA9ICQoJ2lucHV0W25hbWU9XCJ0ZXh0XCJdJykudmFsKCk7XHJcbiAgICAgIHZhciB0aXRsZSA9ICQoJ2lucHV0W25hbWU9XCJ0aXRsZVwiXScpLnZhbCgpO1xyXG5cclxuICAgICAgaWYgKCF0ZXh0KSB0ZXh0ID0gaHJlZjtcclxuXHJcbiAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignWycgKyB0ZXh0ICsgJ10oJyArIGhyZWYgKyAnIFwiJyArIHRpdGxlICsgJ1wiKScpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignWycgKyB0ZXh0ICsgJ10oJyArIGhyZWYgKyAnKScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnZpZXcuZWRpdG9yLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdtZWRpYScpIHtcclxuICAgICAgaWYgKHRoaXMucXVldWUpIHtcclxuICAgICAgICB2YXIgdXNlckRlZmluZWRQYXRoID0gJCgnaW5wdXRbbmFtZT1cInVybFwiXScpLnZhbCgpO1xyXG4gICAgICAgIHRoaXMudmlldy51cGxvYWQodGhpcy5xdWV1ZS5lLCB0aGlzLnF1ZXVlLmZpbGUsIHRoaXMucXVldWUuY29udGVudCwgdXNlckRlZmluZWRQYXRoKTtcclxuXHJcbiAgICAgICAgLy8gRmluYWxseSwgY2xlYXIgdGhlIHF1ZXVlIG9iamVjdFxyXG4gICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHNyYyA9ICQoJ2lucHV0W25hbWU9XCJ1cmxcIl0nKS52YWwoKTtcclxuICAgICAgICB2YXIgYWx0ID0gJCgnaW5wdXRbbmFtZT1cImFsdFwiXScpLnZhbCgpO1xyXG4gICAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignIVsnICsgYWx0ICsgJ10oLycgKyBzcmMgKyAnKScpO1xyXG4gICAgICAgIHRoaXMudmlldy5lZGl0b3IuZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBoZWFkaW5nOiBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAocy5jaGFyQXQoMCkgPT09ICcjJyAmJiBzLmNoYXJBdCgyKSAhPT0gJyMnKSB7XHJcbiAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbih1dGlsLmxUcmltKHMucmVwbGFjZSgvIy9nLCAnJykpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignIyMgJyArIHMucmVwbGFjZSgvIy9nLCAnJykpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHN1YkhlYWRpbmc6IGZ1bmN0aW9uKHMpIHtcclxuICAgIGlmIChzLmNoYXJBdCgwKSA9PT0gJyMnICYmIHMuY2hhckF0KDMpICE9PSAnIycpIHtcclxuICAgICAgdGhpcy52aWV3LmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHV0aWwubFRyaW0ocy5yZXBsYWNlKC8jL2csICcnKSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy52aWV3LmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKCcjIyMgJyArIHMucmVwbGFjZSgvIy9nLCAnJykpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGl0YWxpYzogZnVuY3Rpb24ocykge1xyXG4gICAgaWYgKHMuY2hhckF0KDApID09PSAnXycgJiYgcy5jaGFyQXQocy5sZW5ndGggLSAxID09PSAnXycpKSB7XHJcbiAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihzLnJlcGxhY2UoL18vZywgJycpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignXycgKyBzLnJlcGxhY2UoL18vZywgJycpICsgJ18nKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBib2xkOiBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAocy5jaGFyQXQoMCkgPT09ICcqJyAmJiBzLmNoYXJBdChzLmxlbmd0aCAtIDEgPT09ICcqJykpIHtcclxuICAgICAgdGhpcy52aWV3LmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHMucmVwbGFjZSgvXFwqL2csICcnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnZpZXcuZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oJyoqJyArIHMucmVwbGFjZSgvXFwqL2csICcnKSArICcqKicpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHF1b3RlOiBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAocy5jaGFyQXQoMCkgPT09ICc+Jykge1xyXG4gICAgICB0aGlzLnZpZXcuZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24odXRpbC5sVHJpbShzLnJlcGxhY2UoL1xcPi9nLCAnJykpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudmlldy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbignPiAnICsgcy5yZXBsYWNlKC9cXD4vZywgJycpKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICByZW5kZXJNZWRpYTogZnVuY3Rpb24oZGF0YSwgYmFjaykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyICRtZWRpYSA9IHRoaXMuJGVsLmZpbmQoJyNtZWRpYScpO1xyXG4gICAgdmFyIHRtcGwgPSBfKHRlbXBsYXRlcy5kaWFsb2dzLm1lZGlhZGlyZWN0b3J5KS50ZW1wbGF0ZSgpO1xyXG5cclxuICAgIC8vIFJlc2V0IHNvbWUgc3R1ZmZcclxuICAgICRtZWRpYS5lbXB0eSgpO1xyXG5cclxuICAgIGlmIChiYWNrICYmIChiYWNrLmpvaW4oKSAhPT0gdGhpcy5hc3NldHNEaXJlY3RvcnkpKSB7XHJcbiAgICAgIHZhciBsaW5rID0gYmFjay5zbGljZSgwLCBiYWNrLmxlbmd0aCAtIDEpLmpvaW4oJy8nKTtcclxuICAgICAgJG1lZGlhLmFwcGVuZCgnPGxpIGNsYXNzPVwiZGlyZWN0b3J5IGJhY2tcIj48YSBocmVmPVwiJyArIGxpbmsgKyAnXCI+PHNwYW4gY2xhc3M9XCJpY28gZmwgc21hbGwgaW5saW5lIGJhY2tcIj48L3NwYW4+QmFjazwvYT48L2xpPicpO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGEuZWFjaChmdW5jdGlvbihkKSB7XHJcbiAgICAgIHZhciBwYXJ0cyA9IGQuZ2V0KCdwYXRoJykuc3BsaXQoJy8nKTtcclxuICAgICAgdmFyIHBhdGggPSBwYXJ0cy5zbGljZSgwLCBwYXJ0cy5sZW5ndGggLSAxKS5qb2luKCcvJyk7XHJcblxyXG4gICAgICAkbWVkaWEuYXBwZW5kKHRtcGwoe1xyXG4gICAgICAgIG5hbWU6IGQuZ2V0KCduYW1lJyksXHJcbiAgICAgICAgdHlwZTogZC5nZXQoJ3R5cGUnKSxcclxuICAgICAgICBwYXRoOiBwYXRoICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGQuZ2V0KCduYW1lJykpLFxyXG4gICAgICAgIGlzTWVkaWE6IHV0aWwuaXNNZWRpYShkLmdldCgnbmFtZScpLnNwbGl0KCcuJykucG9wKCkpXHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJy5hc3NldCBhJywgJG1lZGlhKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciBocmVmID0gJCh0aGlzKS5hdHRyKCdocmVmJyk7XHJcbiAgICAgIHZhciBhbHQgPSB1dGlsLnRyaW0oJCh0aGlzKS50ZXh0KCkpO1xyXG5cclxuICAgICAgaWYgKHV0aWwuaXNJbWFnZShocmVmLnNwbGl0KCcuJykucG9wKCkpKSB7XHJcbiAgICAgICAgc2VsZi4kZWwuZmluZCgnaW5wdXRbbmFtZT1cInVybFwiXScpLnZhbChocmVmKTtcclxuICAgICAgICBzZWxmLiRlbC5maW5kKCdpbnB1dFtuYW1lPVwiYWx0XCJdJykudmFsKGFsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi52aWV3LmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKGhyZWYpO1xyXG4gICAgICAgIHNlbGYudmlldy5lZGl0b3IuZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBjaG9zZW4gPSByZXF1aXJlKCdjaG9zZW4tanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbl8ubWVyZ2UgPSByZXF1aXJlKCdkZWVwbWVyZ2UnKTtcclxudmFyIGpzeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi91dGlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLm1ldGFkYXRhLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjaGFuZ2UgLm1ldGFmaWVsZCc6ICd1cGRhdGVNb2RlbCcsXHJcbiAgICAnY2xpY2sgLmNyZWF0ZS1zZWxlY3QnOiAnY3JlYXRlU2VsZWN0JyxcclxuICAgICdjbGljayAuZmluaXNoJzogJ2V4aXQnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgdGhpcy50aXRsZUFzSGVhZGluZyA9IG9wdGlvbnMudGl0bGVBc0hlYWRpbmc7XHJcbiAgICB0aGlzLnZpZXcgPSBvcHRpb25zLnZpZXc7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSkpO1xyXG5cclxuICAgIHZhciBmb3JtID0gdGhpcy4kZWwuZmluZCgnLmZvcm0nKTtcclxuXHJcbiAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKTtcclxuICAgIHZhciBsYW5nID0gbWV0YWRhdGEgJiYgbWV0YWRhdGEubGFuZyA/IG1ldGFkYXRhLmxhbmcgOiAnZW4nO1xyXG5cclxuICAgIC8vIFRoaXMgcmVuZGVycyBhbnkgZmllbGRzIGRlZmluZWQgaW4gdGhlIG1ldGFkYXRhIGVudHJ5XHJcbiAgICAvLyBvZiBhIGdpdmVuIHByb3NlIGNvbmZpZ3VyYXRpb24gZmlsZS5cclxuICAgIF8uZWFjaCh0aGlzLm1vZGVsLmdldCgnZGVmYXVsdHMnKSwgKGZ1bmN0aW9uKGRhdGEsIGtleSkge1xyXG4gICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKSB8fCB7fTtcclxuICAgICAgdmFyIHJlbmRlclRpdGxlID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubmFtZSA9PT0gJ3RpdGxlJyAmJiB0aGlzLnRpdGxlQXNIZWFkaW5nKSB7XHJcbiAgICAgICAgcmVuZGVyVGl0bGUgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbmRlclRpdGxlKSB7XHJcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5maWVsZCkge1xyXG4gICAgICAgICAgc3dpdGNoIChkYXRhLmZpZWxkLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICB2YXIgYnV0dG9uID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGRhdGEuZmllbGQubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBoZWxwOiBkYXRhLmZpZWxkLmhlbHAsXHJcbiAgICAgICAgICAgICAgICBvbjogZGF0YS5maWVsZC5vbixcclxuICAgICAgICAgICAgICAgIG9mZjogZGF0YS5maWVsZC5vZmZcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICBmb3JtLmFwcGVuZChfLnRlbXBsYXRlKHRlbXBsYXRlcy5tZXRhLmJ1dHRvbiwgYnV0dG9uLCB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogJ21ldGEnXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgdmFyIGNoZWNrYm94ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGRhdGEuZmllbGQubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBoZWxwOiBkYXRhLmZpZWxkLmhlbHAsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogZGF0YS5maWVsZC52YWx1ZVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1ldGEuY2hlY2tib3gsIGNoZWNrYm94LCB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogJ21ldGEnXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICB2YXIgdGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRhLmZpZWxkLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgaGVscDogZGF0YS5maWVsZC5oZWxwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEuZmllbGQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZGF0YS5maWVsZC5wbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0J1xyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1ldGEudGV4dCwgdGV4dCwge1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6ICdtZXRhJ1xyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgICAgICAgIHZhciBpZCA9IHV0aWwuc3RyaW5nVG9VcmwoZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgICB2YXIgdGV4dGFyZWEgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS5maWVsZC52YWx1ZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRhLmZpZWxkLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgaGVscDogZGF0YS5maWVsZC5oZWxwLFxyXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGRhdGEuZmllbGQucGxhY2Vob2xkZXIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoXy50ZW1wbGF0ZSh0ZW1wbGF0ZXMubWV0YS50ZXh0YXJlYSwgdGV4dGFyZWEsIHtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiAnbWV0YSdcclxuICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICAgIHZhciB0ZXh0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuXHJcbiAgICAgICAgICAgICAgdGhpc1tpZF0gPSBDb2RlTWlycm9yKGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbCwgdGV4dEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZWwuaWQgPSBpZDtcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAnIGlubmVyICc7XHJcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScsIGRhdGEubmFtZSk7XHJcbiAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogaWQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dEVsZW1lbnQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBsaW5lV3JhcHBpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB0aGVtZTogJ3Byb3NlLWJyaWdodCdcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgdmFyIG51bWJlciA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRhLmZpZWxkLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgaGVscDogZGF0YS5maWVsZC5oZWxwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEuZmllbGQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1ldGEudGV4dCwgbnVtYmVyLCB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogJ21ldGEnXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgICAgICAgIHZhciBzZWxlY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogZGF0YS5maWVsZC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIGhlbHA6IGRhdGEuZmllbGQuaGVscCxcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBkYXRhLmZpZWxkLnBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZGF0YS5maWVsZC5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgbGFuZzogbGFuZ1xyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1ldGEuc2VsZWN0LCBzZWxlY3QsIHtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiAnbWV0YSdcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ211bHRpc2VsZWN0JzpcclxuICAgICAgICAgICAgICB2YXIgbXVsdGlzZWxlY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogZGF0YS5maWVsZC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIGhlbHA6IGRhdGEuZmllbGQuaGVscCxcclxuICAgICAgICAgICAgICAgIGFsdGVyYWJsZTogZGF0YS5maWVsZC5hbHRlcmFibGUsXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZGF0YS5maWVsZC5wbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGRhdGEuZmllbGQub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGxhbmc6IGxhbmdcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICBmb3JtLmFwcGVuZChfLnRlbXBsYXRlKHRlbXBsYXRlcy5tZXRhLm11bHRpc2VsZWN0LCBtdWx0aXNlbGVjdCwge1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6ICdtZXRhJ1xyXG4gICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XHJcbiAgICAgICAgICAgICAgdmFyIHRtcGwgPSB7fTtcclxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtZXRhZGF0YVtkYXRhLm5hbWVdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQW55IGRlZmF1bHRzIG5vdCBjdXJyZW50bHkgaW4gbWV0YWRhdGE/XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IF8uZGlmZmVyZW5jZShkYXRhLmZpZWxkLnZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0bXBsW2RhdGEubmFtZV0gPSBkaWZmLmxlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICAgIF8udW5pb24oZGF0YS5maWVsZC52YWx1ZSwgdmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRtcGxbZGF0YS5uYW1lXSA9IGRhdGEuZmllbGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldCgnbWV0YWRhdGEnLCBfLmV4dGVuZCh0bXBsLCB0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKSB8fCB7fSkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgdHh0ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgIGxhYmVsOiBrZXksXHJcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxyXG4gICAgICAgICAgICB0eXBlOiAndGV4dCdcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZm9ybS5hcHBlbmQoXy50ZW1wbGF0ZSh0ZW1wbGF0ZXMubWV0YS50ZXh0LCB0eHQsIHtcclxuICAgICAgICAgICAgdmFyaWFibGU6ICdtZXRhJ1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdGhpcy4kZWwuZmluZCgnLmNoem4tc2VsZWN0JykuY2hvc2VuKCkuY2hhbmdlKHRoaXMudXBkYXRlTW9kZWwpO1xyXG4gICAgdGhpcy5yZW5kZXJSYXcoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICB1cGRhdGVNb2RlbDogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcclxuICAgIHZhciBrZXkgPSB0YXJnZXQubmFtZTtcclxuICAgIHZhciB2YWx1ZSA9IHRhcmdldC52YWx1ZTtcclxuICAgIHZhciBkZWx0YSA9IHt9O1xyXG4gICAgZGVsdGFba2V5XSA9IHZhbHVlO1xyXG5cclxuICAgIHZhciBtZXRhZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdtZXRhZGF0YScpO1xyXG4gICAgdGhpcy5tb2RlbC5zZXQoJ21ldGFkYXRhJywgXy5leHRlbmQobWV0YWRhdGEsIGRlbHRhKSk7XHJcbiAgICB0aGlzLnZpZXcubWFrZURpcnR5KCk7XHJcbiAgfSxcclxuXHJcbiAgcmF3S2V5TWFwOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICdDdHJsLVMnOiB0aGlzLnZpZXcudXBkYXRlRmlsZVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICByZW5kZXJSYXc6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHlhbWwgPSB0aGlzLm1vZGVsLmdldCgnbGFuZycpID09PSAneWFtbCc7XHJcbiAgICB2YXIgJGVsO1xyXG5cclxuICAgIGlmICh5YW1sKSB7XHJcbiAgICAgICRlbCA9IHRoaXMudmlldy4kZWwuZmluZCgnI2NvZGUnKTtcclxuICAgICAgJGVsLmVtcHR5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLiRlbC5maW5kKCcuZm9ybScpLmFwcGVuZChfLnRlbXBsYXRlKHRlbXBsYXRlcy5tZXRhLnJhdykpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbCA9ICh5YW1sID8gJGVsIDogdGhpcy4kZWwuZmluZCgnI3JhdycpKVswXTtcclxuXHJcbiAgICB0aGlzLnJhdyA9IENvZGVNaXJyb3IoZWwsIHtcclxuICAgICAgbW9kZTogJ3lhbWwnLFxyXG4gICAgICB2YWx1ZTogJycsXHJcbiAgICAgIGxpbmVXcmFwcGluZzogdHJ1ZSxcclxuICAgICAgbGluZU51bWJlcnM6IHlhbWwsXHJcbiAgICAgIGV4dHJhS2V5czogdGhpcy5yYXdLZXlNYXAoKSxcclxuICAgICAgdGhlbWU6ICdwcm9zZS1icmlnaHQnXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucmF3LCAnYmx1cicsIChmdW5jdGlvbihjbSkge1xyXG4gICAgICB2YXIgdmFsdWUgPSBjbS5nZXRWYWx1ZSgpO1xyXG4gICAgICB2YXIgcmF3O1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICByYXcgPSBqc3lhbWwuc2FmZUxvYWQodmFsdWUpO1xyXG4gICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgcGFyc2luZyBDb2RlTWlycm9yIGVkaXRvciB0ZXh0XCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyYXcpIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldCgnbWV0YWRhdGEnLCBfLmV4dGVuZChtZXRhZGF0YSwgcmF3KSk7XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5tYWtlRGlydHkoKTtcclxuICAgICAgfVxyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKSk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXcgPSB0aGlzO1xyXG4gICAgdmFyIG1ldGFkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ21ldGFkYXRhJykgfHwge307XHJcblxyXG4gICAgaWYgKHRoaXMudmlldy50b29sYmFyICYmXHJcbiAgICAgICB0aGlzLnZpZXcudG9vbGJhci5wdWJsaXNoU3RhdGUoKSB8fFxyXG4gICAgICAgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnB1Ymxpc2hlZCkpIHtcclxuICAgICAgbWV0YWRhdGEucHVibGlzaGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1ldGFkYXRhLnB1Ymxpc2hlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgdGl0bGUgdmFsdWUgZnJvbSBoZWFkaW5nIGlmIHdlIG5lZWQgdG8uXHJcbiAgICBpZiAodGhpcy50aXRsZUFzSGVhZGluZykge1xyXG4gICAgICBtZXRhZGF0YS50aXRsZSA9ICh0aGlzLnZpZXcuaGVhZGVyKSA/XHJcbiAgICAgICAgdGhpcy52aWV3LmhlYWRlci5pbnB1dEdldCgpIDpcclxuICAgICAgICB0aGlzLm1vZGVsLmdldCgnbWV0YWRhdGEnKS50aXRsZVswXTtcclxuICAgIH1cclxuXHJcbiAgICBfLmVhY2godGhpcy4kZWwuZmluZCgnW25hbWVdJyksIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcclxuICAgICAgdmFyIHZhbHVlID0gJGl0ZW0udmFsKCk7XHJcblxyXG4gICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XHJcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XHJcbiAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gJGl0ZW0uZGF0YSgndHlwZScpID09PSAnbnVtYmVyJyA/IE51bWJlcih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKF8uaGFzKG1ldGFkYXRhLCBpdGVtLm5hbWUpICYmIG1ldGFkYXRhW2l0ZW0ubmFtZV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgbWV0YWRhdGFbaXRlbS5uYW1lXSA9IF8udW5pb24obWV0YWRhdGFbaXRlbS5uYW1lXSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1ldGFkYXRhW2l0ZW0ubmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgaWYgKGl0ZW0uY2hlY2tlZCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKF8uaGFzKG1ldGFkYXRhLCBpdGVtLm5hbWUpICYmIGl0ZW0ubmFtZSAhPT0gaXRlbS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgIG1ldGFkYXRhW2l0ZW0ubmFtZV0gPSBfLnVuaW9uKG1ldGFkYXRhW2l0ZW0ubmFtZV0sIGl0ZW0udmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udmFsdWUgPT09IGl0ZW0ubmFtZSkge1xyXG4gICAgICAgICAgICAgIG1ldGFkYXRhW2l0ZW0ubmFtZV0gPSBpdGVtLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbWV0YWRhdGFbaXRlbS5uYW1lXSA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFfLmhhcyhtZXRhZGF0YSwgaXRlbS5uYW1lKSAmJiBpdGVtLm5hbWUgPT09IGl0ZW0udmFsdWUpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGFbaXRlbS5uYW1lXSA9IGl0ZW0uY2hlY2tlZDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhW2l0ZW0ubmFtZV0gPSBpdGVtLmNoZWNrZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGFbaXRlbS5uYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhW2l0ZW0ubmFtZV0gPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBMb2FkIGFueSBkYXRhIGNvbWluZyBmcm9tIGEgeWFtbC1ibG9jayBvZiBjb250ZW50LlxyXG4gICAgdGhpcy4kZWwuZmluZCgnLnlhbWwtYmxvY2snKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgZWRpdG9yID0gJCh0aGlzKS5maW5kKCcuQ29kZU1pcnJvcicpLmF0dHIoJ2lkJyk7XHJcbiAgICAgIHZhciBuYW1lID0gJCgnIycgKyBlZGl0b3IpLmRhdGEoJ25hbWUnKTtcclxuXHJcbiAgICAgIGlmICh2aWV3W2VkaXRvcl0pIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbWV0YWRhdGFbbmFtZV0gPSBqc3lhbWwuc2FmZUxvYWQodmlld1tlZGl0b3JdLmdldFZhbHVlKCkpO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHBhcnNpbmcgeWFtbCBmcm9udCBtYXR0ZXJcIik7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTG9hZCBhbnkgZGF0YSBjb21pbmcgZnJvbSBub3QgZGVmaW5lZCByYXcgeWFtbCBmcm9udCBtYXR0ZXIuXHJcbiAgICBpZiAodGhpcy5yYXcpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtZXRhZGF0YSA9IF8ubWVyZ2UobWV0YWRhdGEsIGpzeWFtbC5zYWZlTG9hZCh0aGlzLnJhdy5nZXRWYWx1ZSgpKSB8fCB7fSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgcGFyc2luZyBub3QgZGVmaW5lZCByYXcgeWFtbCBmcm9udCBtYXR0ZXJcIik7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtZXRhZGF0YTtcclxuICB9LFxyXG5cclxuICBzZXRWYWx1ZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgdmFyIGZvcm0gPSB0aGlzLiRlbC5maW5kKCcuZm9ybScpO1xyXG4gICAgdmFyIG1pc3NpbmcgPSB7fTtcclxuICAgIHZhciByYXc7XHJcblxyXG4gICAgXy5lYWNoKGRhdGEsIChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuJGVsLmZpbmQoJ1tuYW1lPVwiJyArIGtleSArICdcIl0nKTtcclxuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgdmFyIG9wdGlvbnM7XHJcblxyXG4gICAgICBpZiAobGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBtYXRjaGluZyBmaWVsZHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgLy8gaWYgdmFsdWUgaXMgYW4gYXJyYXlcclxuICAgICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdmFsdWVzIGluIGFycmF5XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0W2ldLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcclxuICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQoaW5wdXRbaV0pLmZpbmQoJ29wdGlvblt2YWx1ZT1cIicgKyB2YWx1ZVtqXSArICdcIl0nKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvcHRpb25zLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tdLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgICAgICAgICAgIGlucHV0W2ldLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0W2ldLnZhbHVlID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0W2ldLmNoZWNrZWQgPSAnY2hlY2tlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXRbaV0udHlwZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gJChpbnB1dFtpXSkuZmluZCgnb3B0aW9uW3ZhbHVlPVwiJyArIHZhbHVlICsgJ1wiXScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgb3B0aW9ucy5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbV0uc2VsZWN0ZWQgPSAnc2VsZWN0ZWQnO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgIGlucHV0W2ldLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgIGlucHV0W2ldLmNoZWNrZWQgPSB2YWx1ZSA/ICdjaGVja2VkJyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgaW5wdXRbaV0udmFsdWUgPSB2YWx1ZSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlucHV0W2ldLmlubmVySFRNTCA9IHZhbHVlID8gaW5wdXRbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLW9uJykgOiBpbnB1dFtpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2ZmJyk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFtYXRjaGVkICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBpZiAobWlzc2luZy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG1pc3Npbmdba2V5XSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgbWlzc2luZ1trZXldID0gXy51bmlvbihtaXNzaW5nW2tleV0sIHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1pc3Npbmdba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgcmVuZGVyIHRoZSAncHVibGlzaGVkJyBmaWVsZCBvciBoaWRkZW4gbWV0YWRhdGFcclxuICAgICAgICAvLyBUT0RPOiByZW5kZXIgbWV0YWRhdGEgdmFsdWVzIHRoYXQgc2hhcmUgYSBrZXkgd2l0aCBhIGhpZGRlbiB2YWx1ZVxyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IF8uZmluZCh0aGlzLm1vZGVsLmdldCgnZGVmYXVsdHMnKSwgZnVuY3Rpb24oZGF0YSkgeyByZXR1cm4gZGF0YSAmJiAoZGF0YS5uYW1lID09PSBrZXkpOyB9KTtcclxuICAgICAgICB2YXIgZGlmZiA9IGRlZmF1bHRzICYmIF8uaXNBcnJheSh2YWx1ZSkgPyBfLmRpZmZlcmVuY2UodmFsdWUsIGRlZmF1bHRzLmZpZWxkLnZhbHVlKSA6IHZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoa2V5ICE9PSAncHVibGlzaGVkJyAmJiBrZXkgIT09ICd0aXRsZScgJiYgIWRlZmF1bHRzKSB7XHJcbiAgICAgICAgICByYXcgPSB7fTtcclxuICAgICAgICAgIHJhd1trZXldID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMucmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmF3LnNldFZhbHVlKHRoaXMucmF3LmdldFZhbHVlKCkgKyBqc3lhbWwuc2FmZUR1bXAocmF3KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICBfLmVhY2gobWlzc2luZywgKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgdmFyIGJvb2wgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGtleSxcclxuICAgICAgICAgICAgbGFiZWw6IHZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIGNoZWNrZWQ6IHZhbHVlID8gJ2NoZWNrZWQnIDogZmFsc2VcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZm9ybS5hcHBlbmQoXy50ZW1wbGF0ZSh0ZW1wbGF0ZXMubWV0YS5jaGVja2JveCwgYm9vbCwge1xyXG4gICAgICAgICAgICB2YXJpYWJsZTogJ21ldGEnXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgdmFyIHN0cmluZyA9IHtcclxuICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgdHlwZTogJ3RleHQnXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGZvcm0uYXBwZW5kKF8udGVtcGxhdGUodGVtcGxhdGVzLm1ldGEudGV4dCwgc3RyaW5nLCB7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlOiAnbWV0YSdcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICB2YXIgb2JqID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBrZXksXHJcbiAgICAgICAgICAgIGxhYmVsOiBrZXksXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBrZXksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHZhbHVlLFxyXG4gICAgICAgICAgICBsYW5nOiBkYXRhLmxhbmcgfHwgJ2VuJ1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBmb3JtLmFwcGVuZChfLnRlbXBsYXRlKHRlbXBsYXRlcy5tZXRhLm11bHRpc2VsZWN0LCBvYmosIHtcclxuICAgICAgICAgICAgdmFyaWFibGU6ICdtZXRhJ1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUiBjb3VsZCBub3QgY3JlYXRlIG1ldGFkYXRhIGZpZWxkIGZvciAnICsgdHlwZW9mIHZhbHVlLCBrZXkgKyAnOiAnICsgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJGVsLmZpbmQoJy5jaHpuLXNlbGVjdCcpLmNob3NlbigpLmNoYW5nZSh0aGlzLnVwZGF0ZU1vZGVsKTtcclxuICAgIH0pLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHRoaXMuJGVsLmZpbmQoJy5jaHpuLXNlbGVjdCcpLnRyaWdnZXIoJ2xpc3p0OnVwZGF0ZWQnKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgbW9kZWwgd2l0aCBkZWZhdWx0c1xyXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgbWFrZURpcnR5IGlmIGFueSBkaWZmZXJlbmNlcz9cclxuICAgIHRoaXMubW9kZWwuc2V0KCdtZXRhZGF0YScsIHRoaXMuZ2V0VmFsdWUoKSk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UmF3OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBqc3lhbWwuc2FmZUR1bXAodGhpcy5nZXRWYWx1ZSgpKS50cmltKCk7XHJcbiAgfSxcclxuXHJcbiAgc2V0UmF3OiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnJhdy5zZXRWYWx1ZShqc3lhbWwuc2FmZUR1bXAoZGF0YSkpO1xyXG4gICAgICB0aGlzLnJlZnJlc2g7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXcgPSB0aGlzO1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLnlhbWwtYmxvY2snKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgZWRpdG9yID0gJCh0aGlzKS5maW5kKCcuQ29kZU1pcnJvcicpLmF0dHIoJ2lkJyk7XHJcbiAgICAgIGlmICh2aWV3W2VkaXRvcl0pIHZpZXdbZWRpdG9yXS5yZWZyZXNoKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWZyZXNoIENvZGVNaXJyb3JcclxuICAgIGlmICh0aGlzLnJhdykgdGhpcy5yYXcucmVmcmVzaCgpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZVNlbGVjdDogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyICRwYXJlbnQgPSAkKGUudGFyZ2V0KS5wYXJlbnQoKTtcclxuICAgIHZhciAkaW5wdXQgPSAkcGFyZW50LmZpbmQoJ2lucHV0Jyk7XHJcbiAgICB2YXIgc2VsZWN0VGFyZ2V0ID0gJChlLnRhcmdldCkuZGF0YSgnc2VsZWN0Jyk7XHJcbiAgICB2YXIgJHNlbGVjdCA9IHRoaXMuJGVsLmZpbmQoJyMnICsgc2VsZWN0VGFyZ2V0KTtcclxuICAgIHZhciB2YWx1ZSA9IF8oJGlucHV0LnZhbCgpKS5lc2NhcGUoKTtcclxuXHJcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICB2YXIgb3B0aW9uID0gJzxvcHRpb24gdmFsdWU9XCInICsgdmFsdWUgKyAnXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPicgKyB2YWx1ZSArICc8L29wdGlvbj4nO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHRoaXMgbmV3IG9wdGlvbiB0byB0aGUgc2VsZWN0IGxpc3QuXHJcbiAgICAgICRzZWxlY3QuYXBwZW5kKG9wdGlvbik7XHJcblxyXG4gICAgICAvLyBDbGVhciB0aGUgbm93IGFkZGVkIHZhbHVlLlxyXG4gICAgICAkaW5wdXQuYXR0cigndmFsdWUnLCAnJyk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGxpc3RcclxuICAgICAgJHNlbGVjdC50cmlnZ2VyKCdsaXN6dDp1cGRhdGVkJyk7XHJcbiAgICAgICRzZWxlY3QudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGV4aXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy52aWV3Lm5hdi5hY3RpdmUodGhpcy52aWV3Lm1vZGUpO1xyXG5cclxuICAgIGlmICh0aGlzLnZpZXcubW9kZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgIHRoaXMudmlldy5ibG9iKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnZpZXcuZWRpdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlICh0YXJnZXQsIHNyYykge1xuICAgIHZhciBhcnJheSA9IEFycmF5LmlzQXJyYXkoc3JjKVxuICAgIHZhciBkc3QgPSBhcnJheSAmJiBbXSB8fCB7fVxuXG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBbXVxuICAgICAgICBkc3QgPSBkc3QuY29uY2F0KHRhcmdldClcbiAgICAgICAgc3JjLmZvckVhY2goZnVuY3Rpb24oZSwgaSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZHN0W2ldID0gZVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBkc3RbaV0gPSBtZXJnZSh0YXJnZXRbaV0sIGUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZHN0LnB1c2goZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IHRhcmdldFtrZXldXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyY1trZXldICE9PSAnb2JqZWN0JyB8fCAhc3JjW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IG1lcmdlKHRhcmdldFtrZXldLCBzcmNba2V5XSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxufVxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuLi8uLi9jb29raWUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMuc2lkZWJhci5vcmdzLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICB0aGlzLnJvdXRlciA9IG9wdGlvbnMucm91dGVyO1xyXG4gICAgdGhpcy5zaWRlYmFyID0gb3B0aW9ucy5zaWRlYmFyO1xyXG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZmV0Y2goe1xyXG4gICAgICBzdWNjZXNzOiB0aGlzLnJlbmRlcixcclxuICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgfSkuYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvcmdzID0ge1xyXG4gICAgICBsb2dpbjoge1xyXG4gICAgICAgIHVzZXI6IGNvb2tpZS5nZXQoJ2xvZ2luJyksXHJcbiAgICAgICAgaWQ6IGNvb2tpZS5nZXQoJ2lkJylcclxuICAgICAgfSxcclxuICAgICAgdXNlcjogdGhpcy51c2VyLnRvSlNPTigpLFxyXG4gICAgICBvcmdzOiB0aGlzLm1vZGVsLnRvSlNPTigpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBvcmdzLCB7XHJcbiAgICAgIHZhcmlhYmxlOiAnb3JncydcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWN0aXZlIHVzZXIgb3Igb3JnYW5pemF0aW9uXHJcbiAgICB0aGlzLiRlbC5maW5kKCdsaSBhJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgdGhpcy4kZWwuZmluZCgnbGkgYVtkYXRhLWlkPVwiJyArIHRoaXMudXNlci5nZXQoJ2lkJykgKyAnXCJdJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgdGhpcy5zaWRlYmFyLm9wZW4oKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgY29va2llID0gcmVxdWlyZSgnLi4vLi4vY29va2llJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGFnTmFtZTogJ2xpJyxcclxuXHJcbiAgY2xhc3NOYW1lOiAnaXRlbSBjbGVhcmZpeCcsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubGkucmVwbyxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICB0aGlzLiRlbC5hdHRyKCdkYXRhLWluZGV4Jywgb3B0aW9ucy5pbmRleCk7XHJcbiAgICB0aGlzLiRlbC5hdHRyKCdkYXRhLWlkJywgdGhpcy5tb2RlbC5pZCk7XHJcbiAgICB0aGlzLiRlbC5hdHRyKCdkYXRhLW5hdmlnYXRlJywgJyMnICsgdGhpcy5tb2RlbC5nZXQoJ293bmVyJykubG9naW4gKyAnLycgKyB0aGlzLm1vZGVsLmdldCgnbmFtZScpKTtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRhdGEgPSBfLmV4dGVuZCh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMsIHtcclxuICAgICAgbG9naW46IGNvb2tpZS5nZXQoJ2xvZ2luJylcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgZGF0YSwge1xyXG4gICAgICB2YXJpYWJsZTogJ3JlcG8nXHJcbiAgICB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvbG9hZGVyJyk7XHJcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gJyArIG5hbWUgKyAnIGlzIGRlcHJlY2F0ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLicpO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5OSUwgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2NvbW1vbicpLk5JTDtcclxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XHJcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hJyk7XHJcbm1vZHVsZS5leHBvcnRzLkZBSUxTQUZFX1NDSEVNQSAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XHJcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcclxubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvY29yZScpO1xyXG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcclxubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XHJcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcclxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xyXG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xyXG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xyXG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XHJcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XHJcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvZXhjZXB0aW9uJyk7XHJcblxyXG4vLyBEZXByZWNhcmVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcclxubW9kdWxlLmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XHJcbm1vZHVsZS5leHBvcnRzLlNBRkVfU0NIRU1BICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcclxubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xyXG5cclxuLy8gRGVwcmVjYXRlZCBmdW5jdGlvbnMgZnJvbSBKUy1ZQU1MIDEueC54XHJcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xyXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XHJcbm1vZHVsZS5leHBvcnRzLmNvbXBvc2UgICAgICAgID0gZGVwcmVjYXRlZCgnY29tcG9zZScpO1xyXG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XHJcblxyXG5cclxucmVxdWlyZSgnLi9qcy15YW1sL3JlcXVpcmUnKTtcclxuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIEZpbGVzID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvZmlsZXMnKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMucmVwbyA9IGF0dHJpYnV0ZXMucmVwbztcclxuXHJcbiAgICB0aGlzLnNldCgnbmFtZScsIGF0dHJpYnV0ZXMubmFtZSk7XHJcblxyXG4gICAgdmFyIHNoYSA9IGF0dHJpYnV0ZXMuY29tbWl0LnNoYTtcclxuICAgIHRoaXMuc2V0KCdzaGEnLCBzaGEpO1xyXG5cclxuICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXMoW10sIHtcclxuICAgICAgcmVwbzogdGhpcy5yZXBvLFxyXG4gICAgICBicmFuY2g6IHRoaXMsXHJcbiAgICAgIHNoYTogc2hhXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICB1cmw6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVwby51cmwoKSArICcvYnJhbmNoZXMvJyArIHRoaXMuZ2V0KCduYW1lJyk7XHJcbiAgfVxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBOSUwgPSB7fTtcclxuXHJcblxyXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xyXG4gIHJldHVybiAodW5kZWZpbmVkID09PSBzdWJqZWN0KSB8fCAobnVsbCA9PT0gc3ViamVjdCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XHJcbiAgcmV0dXJuICgnb2JqZWN0JyA9PT0gdHlwZW9mIHN1YmplY3QpICYmIChudWxsICE9PSBzdWJqZWN0KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcclxuICAgIHJldHVybiBzZXF1ZW5jZTtcclxuICB9IGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcclxuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xyXG5cclxuICBpZiAoc291cmNlKSB7XHJcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuXHJcbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xyXG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XHJcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcclxuXHJcbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcclxuICAgIHJlc3VsdCArPSBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMuTklMICAgICAgICA9IE5JTDtcclxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICA9IGlzTm90aGluZztcclxubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICA9IGlzT2JqZWN0O1xyXG5tb2R1bGUuZXhwb3J0cy50b0FycmF5ICAgID0gdG9BcnJheTtcclxubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICA9IHJlcGVhdDtcclxubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICA9IGV4dGVuZDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XHJcbiAgdGhpcy5uYW1lICAgID0gJ1lBTUxFeGNlcHRpb24nO1xyXG4gIHRoaXMucmVhc29uICA9IHJlYXNvbjtcclxuICB0aGlzLm1hcmsgICAgPSBtYXJrO1xyXG4gIHRoaXMubWVzc2FnZSA9IHRoaXMudG9TdHJpbmcoZmFsc2UpO1xyXG59XHJcblxyXG5cclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XHJcbiAgdmFyIHJlc3VsdDtcclxuXHJcbiAgcmVzdWx0ID0gJ0pTLVlBTUw6ICcgKyAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKTtcclxuXHJcbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xyXG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFlBTUxFeGNlcHRpb247XHJcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4vdXRpbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xyXG4gIGlkQXR0cmlidXRlOiAncGF0aCcsXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmJyYW5jaCA9IGF0dHJpYnV0ZXMuYnJhbmNoO1xyXG4gICAgdGhpcy5jb2xsZWN0aW9uID0gYXR0cmlidXRlcy5jb2xsZWN0aW9uO1xyXG4gICAgdGhpcy5yZXBvID0gYXR0cmlidXRlcy5yZXBvO1xyXG5cclxuICAgIHRoaXMuc2V0KHtcclxuICAgICAgJ25hbWUnOiB1dGlsLmV4dHJhY3RGaWxlbmFtZShhdHRyaWJ1dGVzLnBhdGgpWzFdLFxyXG4gICAgICAncGF0aCc6IGF0dHJpYnV0ZXMucGF0aCxcclxuICAgICAgJ3R5cGUnOiBhdHRyaWJ1dGVzLnR5cGVcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvLnVybCgpICsgJy9jb250ZW50cy8nICsgdGhpcy5nZXQoJ3BhdGgnKSArICc/cmVmPScgKyB0aGlzLmJyYW5jaC5nZXQoJ25hbWUnKTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5yZXBvID0gYXR0cmlidXRlcy5yZXBvO1xyXG4gIH0sXHJcblxyXG4gIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvLnVybCgpICsgJy9jb21taXRzLycgKyB0aGlzLmdldCgnc2hhJyk7XHJcbiAgfVxyXG59KTtcclxuIiwiKGZ1bmN0aW9uKCl7LyogQ29weXJpZ2h0IChjKSAyMDEyIEpvc2hmaXJlIC0gTUlUIGxpY2Vuc2UgKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgQ29yZSBvZiB0aGUgSlNPTiBGb3JtIGNsaWVudC1zaWRlIGxpYnJhcnkuXHJcbiAqXHJcbiAqIEdlbmVyYXRlcyBhbiBIVE1MIGZvcm0gZnJvbSBhIHN0cnVjdHVyZWQgZGF0YSBtb2RlbCBhbmQgYSBsYXlvdXQgZGVzY3JpcHRpb24uXHJcbiAqXHJcbiAqIFRoZSBsaWJyYXJ5IG1heSBhbHNvIHZhbGlkYXRlIGlucHV0cyBlbnRlcmVkIGJ5IHRoZSB1c2VyIGFnYWluc3QgdGhlIGRhdGEgbW9kZWxcclxuICogdXBvbiBmb3JtIHN1Ym1pc3Npb24gYW5kIGNyZWF0ZSB0aGUgc3RydWN0dXJlZCBkYXRhIG9iamVjdCBpbml0aWFsaXplZCB3aXRoIHRoZVxyXG4gKiB2YWx1ZXMgdGhhdCB3ZXJlIHN1Ym1pdHRlZC5cclxuICpcclxuICogVGhlIGxpYnJhcnkgZGVwZW5kcyBvbjpcclxuICogIC0galF1ZXJ5XHJcbiAqICAtIHRoZSB1bmRlcnNjb3JlIGxpYnJhcnlcclxuICogIC0gYSBKU09OIHBhcnNlci9zZXJpYWxpemVyLiBOb3RoaW5nIHRvIHdvcnJ5IGFib3V0IGluIG1vZGVybiBicm93c2Vycy5cclxuICogIC0gdGhlIEpTT05Gb3JtVmFsaWRhdGlvbiBsaWJyYXJ5IChpbiBqc3YuanMpIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VcclxuICpcclxuICogU2VlIGRvY3VtZW50YXRpb24gYXQ6XHJcbiAqIGh0dHA6Ly9kZXZlbG9wZXIuam9zaGZpcmUuY29tL2RvYy9kZXYvcmVmL2pzb25mb3JtXHJcbiAqXHJcbiAqIFRoZSBsaWJyYXJ5IGNyZWF0ZXMgYW5kIG1haW50YWlucyBhbiBpbnRlcm5hbCBkYXRhIHRyZWUgYWxvbmcgd2l0aCB0aGUgRE9NLlxyXG4gKiBUaGF0IHN0cnVjdHVyZSBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGFycmF5cyAoYW5kIG5lc3RlZCBhcnJheXMhKSB0aGF0IGFyZVxyXG4gKiBkeW5hbWljIGJ5IGVzc2VuY2UuXHJcbiAqL1xyXG5cclxuIC8qZ2xvYmFsIHdpbmRvdyovXHJcblxyXG4oZnVuY3Rpb24oc2VydmVyc2lkZSwgZ2xvYmFsLCAkLCBfLCBKU09OKSB7XHJcbiAgaWYgKHNlcnZlcnNpZGUpIHtcclxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgdG8gZXh0cmFjdCBhcnJheSBpbmRleGVzIGluIGlucHV0IGZpZWxkIG5hbWVzXHJcbiAgICovXHJcbiAgdmFyIHJlQXJyYXkgPSAvXFxbKFswLTldKilcXF0oPz1cXFt8XFwufCQpL2c7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlbXBsYXRlIHNldHRpbmdzIGZvciBmb3JtIHZpZXdzXHJcbiAgICovXHJcbiAgdmFyIGZpZWxkVGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2dcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUZW1wbGF0ZSBzZXR0aW5ncyBmb3IgdmFsdWUgcmVwbGFjZW1lbnRcclxuICAgKi9cclxuICB2YXIgdmFsdWVUZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgZXZhbHVhdGUgICAgOiAvXFx7XFxbKFtcXHNcXFNdKz8pXFxdXFx9L2csXHJcbiAgICBpbnRlcnBvbGF0ZSA6IC9cXHtcXHsoW1xcc1xcU10rPylcXH1cXH0vZ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiB2YWx1ZSBpcyBuZWl0aGVyIFwidW5kZWZpbmVkXCIgbm9yIG51bGxcclxuICAgKi9cclxuICB2YXIgaXNTZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiAhKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IF8uaXNOdWxsKHZhbHVlKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGpzb25mb3JtIG9iamVjdCB3aG9zZSBtZXRob2RzIHdpbGwgYmUgZXhwb3NlZCB0byB0aGUgd2luZG93IG9iamVjdFxyXG4gICAqL1xyXG4gIHZhciBqc29uZm9ybSA9IHt1dGlsOnt9fTtcclxuXHJcblxyXG4gIC8vIEZyb20gYmFja2JvbmVqc1xyXG4gIHZhciBlc2NhcGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgaWYgKCFpc1NldChzdHJpbmcpKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xyXG4gICAgaWYgKCFzdHJpbmcpIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cmluZ1xyXG4gICAgICAucmVwbGFjZSgvJig/IVxcdys7fCNcXGQrO3wjeFtcXGRhLWZdKzspL2dpLCAnJmFtcDsnKVxyXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXHJcbiAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JylcclxuICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnJiN4MkY7Jyk7XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGVzIHNlbGVjdG9yIG5hbWUgZm9yIHVzZSB3aXRoIGpRdWVyeVxyXG4gKlxyXG4gKiBBbGwgbWV0YS1jaGFyYWN0ZXJzIGxpc3RlZCBpbiBqUXVlcnkgZG9jIGFyZSBlc2NhcGVkOlxyXG4gKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vY2F0ZWdvcnkvc2VsZWN0b3JzL1xyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIFRoZSBqUXVlcnkgc2VsZWN0b3IgdG8gZXNjYXBlXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVzY2FwZWQgc2VsZWN0b3IuXHJcbiAqL1xyXG52YXIgZXNjYXBlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZSgvKFsgXFwhXFxcIlxcI1xcJFxcJVxcJlxcJ1xcKFxcKVxcKlxcK1xcLFxcLlxcL1xcOlxcOzxcXD1cXD5cXD9cXEBcXFtcXFxcXFxdXFxeXFxgXFx7XFx8XFx9XFx+XSkvZywgJ1xcXFwkMScpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0YWJ1bGFyIHNlY3Rpb25zIGluIGZvcm1zLiBTdWNoIHNlY3Rpb25zIGFyZSBnZW5lcmF0ZWQgYnkgdGhlXHJcbiAqICdzZWxlY3RmaWVsZHNldCcgdHlwZSBvZiBlbGVtZW50cyBpbiBKU09OIEZvcm0uXHJcbiAqXHJcbiAqIElucHV0IGZpZWxkcyB0aGF0IGFyZSBub3QgdmlzaWJsZSBhcmUgYXV0b21hdGljYWxseSBkaXNhYmxlZFxyXG4gKiBub3QgdG8gYXBwZWFyIGluIHRoZSBzdWJtaXR0ZWQgZm9ybS4gVGhhdCdzIG9uIHB1cnBvc2UsIGFzIHRhYnNcclxuICogYXJlIG1lYW50IHRvIGNvbnZleSBhbiBhbHRlcm5hdGl2ZSAoYW5kIG5vdCBhIHNlcXVlbmNlIG9mIHN0ZXBzKS5cclxuICpcclxuICogVGhlIHRhYnMgbWVudSBpcyBub3QgcmVuZGVyZWQgYXMgdGFicyBidXQgcmF0aGVyIGFzIGEgc2VsZWN0IGZpZWxkIGJlY2F1c2VcclxuICogaXQncyBlYXNpZXIgdG8gZ3Jhc3AgdGhhdCBpdCdzIGFuIGFsdGVybmF0aXZlLlxyXG4gKlxyXG4gKiBDb2RlIGJhc2VkIG9uIGJvb3RzdHJhcC10YWJzLmpzLCB1cGRhdGVkIHRvOlxyXG4gKiAtIHJlYWN0IHRvIG9wdGlvbiBzZWxlY3Rpb24gaW5zdGVhZCBvZiB0YWIgY2xpY2tcclxuICogLSBkaXNhYmxlIGlucHV0IGZpZWxkcyBpbiBub24gdmlzaWJsZSB0YWJzXHJcbiAqIC0gZGlzYWJsZSB0aGUgcG9zc2liaWxpdHkgdG8gaGF2ZSBkcm9wZG93biBtZW51cyAobm8gbWVhbmluZyBoZXJlKVxyXG4gKiAtIGFjdCBhcyBhIHJlZ3VsYXIgZnVuY3Rpb24gaW5zdGVhZCBvZiBhcyBhIGpRdWVyeSBwbHVnLWluLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHRhYnMgalF1ZXJ5IG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB0YWJ1bGFyIHNlY3Rpb25zXHJcbiAqICB0byBpbml0aWFsaXplLiBUaGUgb2JqZWN0IG1heSByZWZlcmVuY2UgbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxyXG4gKi9cclxudmFyIGluaXRpYWxpemVUYWJzID0gZnVuY3Rpb24gKHRhYnMpIHtcclxuICB2YXIgYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyKSB7XHJcbiAgICBjb250YWluZXJcclxuICAgICAgLmZpbmQoJz4gLmFjdGl2ZScpXHJcbiAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICBlbGVtZW50LmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICB9O1xyXG5cclxuICB2YXIgZW5hYmxlRmllbGRzID0gZnVuY3Rpb24gKCR0YXJnZXQsIHRhcmdldEluZGV4KSB7XHJcbiAgICAvLyBFbmFibGUgYWxsIGZpZWxkcyBpbiB0aGUgdGFyZ2V0ZWQgdGFiXHJcbiAgICAkdGFyZ2V0LmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcclxuXHJcbiAgICAvLyBEaXNhYmxlIGFsbCBmaWVsZHMgaW4gb3RoZXIgdGFic1xyXG4gICAgJHRhcmdldC5wYXJlbnQoKVxyXG4gICAgICAuY2hpbGRyZW4oJzpub3QoW2RhdGEtaWR4PScgKyB0YXJnZXRJbmRleCArICddKScpXHJcbiAgICAgIC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpXHJcbiAgICAgIC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gIH07XHJcblxyXG4gIHZhciBvcHRpb25TZWxlY3RlZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgJG9wdGlvbiA9ICQoXCJvcHRpb246c2VsZWN0ZWRcIiwgJCh0aGlzKSksXHJcbiAgICAgICRzZWxlY3QgPSAkKHRoaXMpLFxyXG4gICAgICAvLyBkbyBub3QgdXNlIC5hdHRyKCkgYXMgaXQgc29tZXRpbWVzIHVuZXhwbGljYWJseSBmYWlsc1xyXG4gICAgICB0YXJnZXRJZHggPSAkb3B0aW9uLmdldCgwKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWR4JykgfHwgJG9wdGlvbi5hdHRyKCd2YWx1ZScpLFxyXG4gICAgICAkdGFyZ2V0O1xyXG5cclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGlmICgkb3B0aW9uLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgJHRhcmdldCA9ICQodGhpcykucGFyZW50cygnLnRhYmJhYmxlJykuZXEoMCkuZmluZCgnLnRhYi1jb250ZW50IFtkYXRhLWlkeD0nICsgdGFyZ2V0SWR4ICsgJ10nKTtcclxuXHJcbiAgICBhY3RpdmF0ZSgkb3B0aW9uLCAkc2VsZWN0KTtcclxuICAgIGFjdGl2YXRlKCR0YXJnZXQsICR0YXJnZXQucGFyZW50KCkpO1xyXG4gICAgZW5hYmxlRmllbGRzKCR0YXJnZXQsIHRhcmdldElkeCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHRhYkNsaWNrZWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyICRhID0gJCgnYScsICQodGhpcykpO1xyXG4gICAgdmFyICRjb250ZW50ID0gJCh0aGlzKS5wYXJlbnRzKCcudGFiYmFibGUnKS5maXJzdCgpXHJcbiAgICAgIC5maW5kKCcudGFiLWNvbnRlbnQnKS5maXJzdCgpO1xyXG4gICAgdmFyIHRhcmdldElkeCA9ICQodGhpcykuaW5kZXgoKTtcclxuICAgIHZhciAkdGFyZ2V0ID0gJGNvbnRlbnQuZmluZCgnW2RhdGEtaWR4PScgKyB0YXJnZXRJZHggKyAnXScpO1xyXG5cclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGFjdGl2YXRlKCQodGhpcyksICQodGhpcykucGFyZW50KCkpO1xyXG4gICAgYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSk7XHJcbiAgICBpZiAoJCh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcygnanNvbmZvcm0tYWx0ZXJuYXRpdmUnKSkge1xyXG4gICAgICBlbmFibGVGaWVsZHMoJHRhcmdldCwgdGFyZ2V0SWR4KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0YWJzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgJCh0aGlzKS5kZWxlZ2F0ZSgnc2VsZWN0Lm5hdicsICdjaGFuZ2UnLCBvcHRpb25TZWxlY3RlZCk7XHJcbiAgICAkKHRoaXMpLmZpbmQoJ3NlbGVjdC5uYXYnKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgJCh0aGlzKS52YWwoJCh0aGlzKS5maW5kKCcuYWN0aXZlJykuYXR0cigndmFsdWUnKSk7XHJcbiAgICAgIC8vIGRvIG5vdCB1c2UgLmF0dHIoKSBhcyBpdCBzb21ldGltZXMgdW5leHBsaWNhYmx5IGZhaWxzXHJcbiAgICAgIHZhciB0YXJnZXRJZHggPSAkKHRoaXMpLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmdldCgwKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWR4JykgfHxcclxuICAgICAgICAkKHRoaXMpLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmF0dHIoJ3ZhbHVlJyk7XHJcbiAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKS5wYXJlbnRzKCcudGFiYmFibGUnKS5lcSgwKS5maW5kKCcudGFiLWNvbnRlbnQgW2RhdGEtaWR4PScgKyB0YXJnZXRJZHggKyAnXScpO1xyXG4gICAgICBlbmFibGVGaWVsZHMoJHRhcmdldCwgdGFyZ2V0SWR4KTtcclxuICAgIH0pO1xyXG5cclxuICAgICQodGhpcykuZGVsZWdhdGUoJ3VsLm5hdiBsaScsICdjbGljaycsIHRhYkNsaWNrZWQpO1xyXG4gICAgJCh0aGlzKS5maW5kKCd1bC5uYXYgbGkuYWN0aXZlJykuY2xpY2soKTtcclxuICB9KTtcclxufTtcclxuXHJcblxyXG4vLyBUd2l0dGVyIGJvb3RzdHJhcC1mcmllbmRseSBIVE1MIGJvaWxlcnBsYXRlIGZvciBzdGFuZGFyZCBpbnB1dHNcclxuanNvbmZvcm0uZmllbGRUZW1wbGF0ZSA9IGZ1bmN0aW9uKGlubmVyKSB7XHJcbiAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cCBqc29uZm9ybS1lcnJvci08JT0ga2V5ZGFzaCAlPicgK1xyXG4gICAgJzwlPSBlbHQuaHRtbENsYXNzID8gXCIgXCIgKyBlbHQuaHRtbENsYXNzIDogXCJcIiAlPicgK1xyXG4gICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCAmJiAobm9kZS5zY2hlbWFFbGVtZW50LnR5cGUgIT09IFwiYm9vbGVhblwiKSA/IFwiIGpzb25mb3JtLXJlcXVpcmVkXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgJzwlPSAobm9kZS5yZWFkT25seSA/IFwiIGpzb25mb3JtLXJlYWRvbmx5XCIgOiBcIlwiKSAlPicgK1xyXG4gICAgJzwlPSAobm9kZS5kaXNhYmxlZCA/IFwiIGpzb25mb3JtLWRpc2FibGVkXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgJ1wiPicgK1xyXG4gICAgJzwlIGlmIChub2RlLnRpdGxlICYmICFlbHQubm90aXRsZSkgeyAlPicgK1xyXG4gICAgICAnPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiIGZvcj1cIjwlPSBub2RlLmlkICU+XCI+PCU9IG5vZGUudGl0bGUgJT48L2xhYmVsPicgK1xyXG4gICAgJzwlIH0gJT4nICtcclxuICAgICc8ZGl2IGNsYXNzPVwiY29udHJvbHNcIj4nICtcclxuICAgICAgJzwlIGlmIChub2RlLnByZXBlbmQgfHwgbm9kZS5hcHBlbmQpIHsgJT4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCI8JSBpZiAobm9kZS5wcmVwZW5kKSB7ICU+aW5wdXQtcHJlcGVuZDwlIH0gJT4nICtcclxuICAgICAgICAnPCUgaWYgKG5vZGUuYXBwZW5kKSB7ICU+IGlucHV0LWFwcGVuZDwlIH0gJT5cIj4nICtcclxuICAgICAgICAnPCUgaWYgKG5vZGUucHJlcGVuZCkgeyAlPicgK1xyXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PCU9IG5vZGUucHJlcGVuZCAlPjwvc3Bhbj4nICtcclxuICAgICAgICAnPCUgfSAlPicgK1xyXG4gICAgICAnPCUgfSAlPicgK1xyXG4gICAgICBpbm5lciArXHJcbiAgICAgICc8JSBpZiAobm9kZS5hcHBlbmQpIHsgJT4nICtcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJhZGQtb25cIj48JT0gbm9kZS5hcHBlbmQgJT48L3NwYW4+JyArXHJcbiAgICAgICc8JSB9ICU+JyArXHJcbiAgICAgICc8JSBpZiAobm9kZS5wcmVwZW5kIHx8IG5vZGUuYXBwZW5kKSB7ICU+JyArXHJcbiAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPCUgfSAlPicgK1xyXG4gICAgICAnPCUgaWYgKG5vZGUuZGVzY3JpcHRpb24pIHsgJT4nICtcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJoZWxwLWlubGluZVwiPjwlPSBub2RlLmRlc2NyaXB0aW9uICU+PC9zcGFuPicgK1xyXG4gICAgICAnPCUgfSAlPicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrIGpzb25mb3JtLWVycm9ydGV4dFwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvc3Bhbj4nICtcclxuICAgICc8L2Rpdj48L2Rpdj4nO1xyXG59O1xyXG5cclxudmFyIGZpbGVEaXNwbGF5VGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cIl9qc29uZm9ybS1wcmV2aWV3XCI+JyArXHJcbiAgJzwlIGlmICh2YWx1ZS50eXBlPT1cImltYWdlXCIpIHsgJT4nICtcclxuICAnPGltZyBjbGFzcz1cImpzb25mb3JtLXByZXZpZXdcIiBpZD1cImpzb25mb3JtcHJldmlldy08JT0gaWQgJT5cIiBzcmM9XCI8JT0gdmFsdWUudXJsICU+XCIgLz4nICtcclxuICAnPCUgfSBlbHNlIHsgJT4nICtcclxuICAnPGEgaHJlZj1cIjwlPSB2YWx1ZS51cmwgJT5cIj48JT0gdmFsdWUubmFtZSAlPjwvYT4gKDwlPSBNYXRoLmNlaWwodmFsdWUuc2l6ZS8xMDI0KSAlPmtCKScgK1xyXG4gICc8JSB9ICU+JyArXHJcbiAgJzwvZGl2PicgK1xyXG4gICc8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIF9qc29uZm9ybS1kZWxldGVcIj48aSBjbGFzcz1cImljb24tcmVtb3ZlXCIgdGl0bGU9XCJSZW1vdmVcIj48L2k+PC9hPiAnO1xyXG5cclxudmFyIGlucHV0RmllbGRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgICd0ZW1wbGF0ZSc6ICc8aW5wdXQgdHlwZT1cIicgKyB0eXBlICsgJ1wiICcgK1xyXG4gICAgICAnPCU9IChmaWVsZEh0bWxDbGFzcyA/IFwiY2xhc3M9XFwnXCIgKyBmaWVsZEh0bWxDbGFzcyArIFwiXFwnIFwiIDogXCJcIikgJT4nICtcclxuICAgICAgJ25hbWU9XCI8JT0gbm9kZS5uYW1lICU+XCIgdmFsdWU9XCI8JT0gZXNjYXBlKHZhbHVlKSAlPlwiIGlkPVwiPCU9IGlkICU+XCInICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5yZWFkT25seSA/IFwiIHJlYWRvbmx5PVxcJ3JlYWRvbmx5XFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnNjaGVtYUVsZW1lbnQgJiYgbm9kZS5zY2hlbWFFbGVtZW50Lm1heExlbmd0aCA/IFwiIG1heGxlbmd0aD1cXCdcIiArIG5vZGUuc2NoZW1hRWxlbWVudC5tYXhMZW5ndGggKyBcIlxcJ1wiIDogXCJcIikgJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCAmJiAobm9kZS5zY2hlbWFFbGVtZW50LnR5cGUgIT09IFwiYm9vbGVhblwiKSA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnBsYWNlaG9sZGVyPyBcInBsYWNlaG9sZGVyPVwiICsgXFwnXCJcXCcgKyBlc2NhcGUobm9kZS5wbGFjZWhvbGRlcikgKyBcXCdcIlxcJyA6IFwiXCIpJT4nICtcclxuICAgICAgJyAvPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWVcclxuICB9XHJcbn07XHJcblxyXG5qc29uZm9ybS5lbGVtZW50VHlwZXMgPSB7XHJcbiAgJ25vbmUnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnJ1xyXG4gIH0sXHJcbiAgJ3Jvb3QnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGRpdj48JT0gY2hpbGRyZW4gJT48L2Rpdj4nXHJcbiAgfSxcclxuICAndGV4dCc6IGlucHV0RmllbGRUZW1wbGF0ZSgndGV4dCcpLFxyXG4gICdwYXNzd29yZCc6IGlucHV0RmllbGRUZW1wbGF0ZSgncGFzc3dvcmQnKSxcclxuICAnZGF0ZSc6IGlucHV0RmllbGRUZW1wbGF0ZSgnZGF0ZScpLFxyXG4gICdkYXRldGltZSc6IGlucHV0RmllbGRUZW1wbGF0ZSgnZGF0ZXRpbWUnKSxcclxuICAnZGF0ZXRpbWUtbG9jYWwnOiBpbnB1dEZpZWxkVGVtcGxhdGUoJ2RhdGV0aW1lLWxvY2FsJyksXHJcbiAgJ2VtYWlsJzogaW5wdXRGaWVsZFRlbXBsYXRlKCdlbWFpbCcpLFxyXG4gICdtb250aCc6IGlucHV0RmllbGRUZW1wbGF0ZSgnbW9udGgnKSxcclxuICAnbnVtYmVyJzogaW5wdXRGaWVsZFRlbXBsYXRlKCdudW1iZXInKSxcclxuICAnc2VhcmNoJzogaW5wdXRGaWVsZFRlbXBsYXRlKCdzZWFyY2gnKSxcclxuICAndGVsJzogaW5wdXRGaWVsZFRlbXBsYXRlKCd0ZWwnKSxcclxuICAndGltZSc6IGlucHV0RmllbGRUZW1wbGF0ZSgndGltZScpLFxyXG4gICd1cmwnOiBpbnB1dEZpZWxkVGVtcGxhdGUoJ3VybCcpLFxyXG4gICd3ZWVrJzogaW5wdXRGaWVsZFRlbXBsYXRlKCd3ZWVrJyksXHJcbiAgJ3JhbmdlJzoge1xyXG4gICAgJ3RlbXBsYXRlJzogJzxpbnB1dCB0eXBlPVwicmFuZ2VcIiAnICtcclxuICAgICAgJzwlPSAoZmllbGRIdG1sQ2xhc3MgPyBcImNsYXNzPVxcJ1wiICsgZmllbGRIdG1sQ2xhc3MgKyBcIlxcJyBcIiA6IFwiXCIpICU+JyArXHJcbiAgICAgICduYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIHZhbHVlPVwiPCU9IGVzY2FwZSh2YWx1ZSkgJT5cIiBpZD1cIjwlPSBpZCAlPlwiJyArXHJcbiAgICAgICc8JT0gKG5vZGUuZGlzYWJsZWQ/IFwiIGRpc2FibGVkXCIgOiBcIlwiKSU+JyArXHJcbiAgICAgICcgbWluPTwlPSByYW5nZS5taW4gJT4nICtcclxuICAgICAgJyBtYXg9PCU9IHJhbmdlLm1heCAlPicgK1xyXG4gICAgICAnIHN0ZXA9PCU9IHJhbmdlLnN0ZXAgJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnIC8+JyxcclxuICAgICdmaWVsZHRlbXBsYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdvbkJlZm9yZVJlbmRlcic6IGZ1bmN0aW9uIChkYXRhLCBub2RlKSB7XHJcbiAgICAgIGRhdGEucmFuZ2UgPSB7XHJcbiAgICAgICAgbWluOiAxLFxyXG4gICAgICAgIG1heDogMTAwLFxyXG4gICAgICAgIHN0ZXA6IDFcclxuICAgICAgfTtcclxuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnNjaGVtYUVsZW1lbnQpIHJldHVybjtcclxuICAgICAgaWYgKG5vZGUuZm9ybUVsZW1lbnQgJiYgbm9kZS5mb3JtRWxlbWVudC5zdGVwKSB7XHJcbiAgICAgICAgZGF0YS5yYW5nZS5zdGVwID0gbm9kZS5mb3JtRWxlbWVudC5zdGVwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2hlbWFFbGVtZW50Lm1pbmltdW0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuc2NoZW1hRWxlbWVudC5leGNsdXNpdmVNaW5pbXVtKSB7XHJcbiAgICAgICAgICBkYXRhLnJhbmdlLm1pbiA9IG5vZGUuc2NoZW1hRWxlbWVudC5taW5pbXVtICsgZGF0YS5yYW5nZS5zdGVwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGRhdGEucmFuZ2UubWluID0gbm9kZS5zY2hlbWFFbGVtZW50Lm1pbmltdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2hlbWFFbGVtZW50Lm1heGltdW0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuc2NoZW1hRWxlbWVudC5leGNsdXNpdmVNYXhpbXVtKSB7XHJcbiAgICAgICAgICBkYXRhLnJhbmdlLm1heCA9IG5vZGUuc2NoZW1hRWxlbWVudC5tYXhpbXVtICsgZGF0YS5yYW5nZS5zdGVwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGRhdGEucmFuZ2UubWF4ID0gbm9kZS5zY2hlbWFFbGVtZW50Lm1heGltdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICAnY29sb3InOntcclxuICAgICd0ZW1wbGF0ZSc6JzxpbnB1dCB0eXBlPVwidGV4dFwiICcgK1xyXG4gICAgICAnPCU9IChmaWVsZEh0bWxDbGFzcyA/IFwiY2xhc3M9XFwnXCIgKyBmaWVsZEh0bWxDbGFzcyArIFwiXFwnIFwiIDogXCJcIikgJT4nICtcclxuICAgICAgJ25hbWU9XCI8JT0gbm9kZS5uYW1lICU+XCIgdmFsdWU9XCI8JT0gZXNjYXBlKHZhbHVlKSAlPlwiIGlkPVwiPCU9IGlkICU+XCInICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnIC8+JyxcclxuICAgICdmaWVsZHRlbXBsYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdvbkluc2VydCc6IGZ1bmN0aW9uKGV2dCwgbm9kZSkge1xyXG4gICAgICAkKG5vZGUuZWwpLmZpbmQoJyMnICsgZXNjYXBlU2VsZWN0b3Iobm9kZS5pZCkpLnNwZWN0cnVtKHtcclxuICAgICAgICBwcmVmZXJyZWRGb3JtYXQ6IFwiaGV4XCIsXHJcbiAgICAgICAgc2hvd0lucHV0OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgJ3RleHRhcmVhJzp7XHJcbiAgICAndGVtcGxhdGUnOic8dGV4dGFyZWEgaWQ9XCI8JT0gaWQgJT5cIiBuYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiICcgK1xyXG4gICAgICAnc3R5bGU9XCJoZWlnaHQ6PCU9IGVsdC5oZWlnaHQgfHwgXCIxNTBweFwiICU+O3dpZHRoOjwlPSBlbHQud2lkdGggfHwgXCIxMDAlXCIgJT47XCInICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5yZWFkT25seSA/IFwiIHJlYWRvbmx5PVxcJ3JlYWRvbmx5XFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnNjaGVtYUVsZW1lbnQgJiYgbm9kZS5zY2hlbWFFbGVtZW50Lm1heExlbmd0aCA/IFwiIG1heGxlbmd0aD1cXCdcIiArIG5vZGUuc2NoZW1hRWxlbWVudC5tYXhMZW5ndGggKyBcIlxcJ1wiIDogXCJcIikgJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnBsYWNlaG9sZGVyPyBcInBsYWNlaG9sZGVyPVwiICsgXFwnXCJcXCcgKyBlc2NhcGUobm9kZS5wbGFjZWhvbGRlcikgKyBcXCdcIlxcJyA6IFwiXCIpJT4nICtcclxuICAgICAgJz48JT0gdmFsdWUgJT48L3RleHRhcmVhPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWVcclxuICB9LFxyXG4gICd3eXNpaHRtbDUnOntcclxuICAgICd0ZW1wbGF0ZSc6Jzx0ZXh0YXJlYSBpZD1cIjwlPSBpZCAlPlwiIG5hbWU9XCI8JT0gbm9kZS5uYW1lICU+XCIgc3R5bGU9XCJoZWlnaHQ6PCU9IGVsdC5oZWlnaHQgfHwgXCIzMDBweFwiICU+O3dpZHRoOjwlPSBlbHQud2lkdGggfHwgXCIxMDAlXCIgJT47XCInICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5yZWFkT25seSA/IFwiIHJlYWRvbmx5PVxcJ3JlYWRvbmx5XFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnNjaGVtYUVsZW1lbnQgJiYgbm9kZS5zY2hlbWFFbGVtZW50Lm1heExlbmd0aCA/IFwiIG1heGxlbmd0aD1cXCdcIiArIG5vZGUuc2NoZW1hRWxlbWVudC5tYXhMZW5ndGggKyBcIlxcJ1wiIDogXCJcIikgJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPCU9IChub2RlLnBsYWNlaG9sZGVyPyBcInBsYWNlaG9sZGVyPVwiICsgXFwnXCJcXCcgKyBlc2NhcGUobm9kZS5wbGFjZWhvbGRlcikgKyBcXCdcIlxcJyA6IFwiXCIpJT4nICtcclxuICAgICAgJz48JT0gdmFsdWUgJT48L3RleHRhcmVhPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWUsXHJcbiAgICAnb25JbnNlcnQnOiBmdW5jdGlvbiAoZXZ0LCBub2RlKSB7XHJcbiAgICAgIHZhciBzZXR1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3Byb3RlY3QgZnJvbSBkb3VibGUgaW5pdFxyXG4gICAgICAgIGlmICgkKG5vZGUuZWwpLmRhdGEoXCJ3eXNpaHRtbDVcIikpIHJldHVybjtcclxuICAgICAgICAkKG5vZGUuZWwpLmRhdGEoXCJ3eXNpaHRtbDVfbG9hZGVkXCIsdHJ1ZSk7XHJcblxyXG4gICAgICAgICQobm9kZS5lbCkuZmluZCgnIycgKyBlc2NhcGVTZWxlY3Rvcihub2RlLmlkKSkud3lzaWh0bWw1KHtcclxuICAgICAgICAgIFwiaHRtbFwiOiB0cnVlLFxyXG4gICAgICAgICAgXCJsaW5rXCI6IHRydWUsXHJcbiAgICAgICAgICBcImZvbnQtc3R5bGVzXCI6dHJ1ZSxcclxuICAgICAgICAgIFwiaW1hZ2VcIjogdHJ1ZSxcclxuICAgICAgICAgIFwiZXZlbnRzXCI6IHtcclxuICAgICAgICAgICAgXCJsb2FkXCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAvLyBJbiBjaHJvbWUsIGlmIGFuIGVsZW1lbnQgaXMgcmVxdWlyZWQgYW5kIGhpZGRlbiwgaXQgbGVhZHMgdG9cclxuICAgICAgICAgICAgICAvLyB0aGUgZXJyb3IgJ0FuIGludmFsaWQgZm9ybSBjb250cm9sIHdpdGggbmFtZT0nJyBpcyBub3QgZm9jdXNhYmxlJ1xyXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcxNjg2NDUvaW52YWxpZC1mb3JtLWNvbnRyb2wtb25seS1pbi1nb29nbGUtY2hyb21lXHJcbiAgICAgICAgICAgICAgJCh0aGlzLnRleHRhcmVhRWxlbWVudCkucmVtb3ZlQXR0cigncmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gSXMgdGhlcmUgYSBzZXR1cCBob29rP1xyXG4gICAgICBpZiAod2luZG93Lmpzb25mb3JtX3d5c2lodG1sNV9zZXR1cCkge1xyXG4gICAgICAgIHdpbmRvdy5qc29uZm9ybV93eXNpaHRtbDVfc2V0dXAoc2V0dXApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2FpdCB1bnRpbCB3eXNpaHRtbDUgaXMgbG9hZGVkXHJcbiAgICAgIHZhciBpdHYgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy53eXNpaHRtbDUpIHtcclxuICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGl0dik7XHJcbiAgICAgICAgICBzZXR1cCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwxMDAwKTtcclxuICAgIH1cclxuICB9LFxyXG4gICdhY2UnOntcclxuICAgICd0ZW1wbGF0ZSc6JzxkaXYgaWQ9XCI8JT0gaWQgJT5cIiBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDo8JT0gZWx0LmhlaWdodCB8fCBcIjMwMHB4XCIgJT47XCI+PGRpdiBpZD1cIjwlPSBpZCAlPl9fYWNlXCIgc3R5bGU9XCJ3aWR0aDo8JT0gZWx0LndpZHRoIHx8IFwiMTAwJVwiICU+O2hlaWdodDo8JT0gZWx0LmhlaWdodCB8fCBcIjMwMHB4XCIgJT47XCI+PC9kaXY+PGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIGlkPVwiPCU9IGlkICU+X19oaWRkZW5cIiB2YWx1ZT1cIjwlPSBlc2NhcGUodmFsdWUpICU+XCIvPjwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWUsXHJcbiAgICAnb25JbnNlcnQnOiBmdW5jdGlvbiAoZXZ0LCBub2RlKSB7XHJcbiAgICAgIHZhciBzZXR1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9ybUVsZW1lbnQgPSBub2RlLmZvcm1FbGVtZW50IHx8IHt9O1xyXG4gICAgICAgIHZhciBhY2UgPSB3aW5kb3cuYWNlO1xyXG4gICAgICAgIHZhciBlZGl0b3IgPSBhY2UuZWRpdCgkKG5vZGUuZWwpLmZpbmQoJyMnICsgZXNjYXBlU2VsZWN0b3Iobm9kZS5pZCkgKyAnX19hY2UnKS5nZXQoMCkpO1xyXG4gICAgICAgIHZhciBpZFNlbGVjdG9yID0gJyMnICsgZXNjYXBlU2VsZWN0b3Iobm9kZS5pZCkgKyAnX19oaWRkZW4nO1xyXG4gICAgICAgIC8vIEZvcmNlIGVkaXRvciB0byB1c2UgXCJcXG5cIiBmb3IgbmV3IGxpbmVzLCBub3QgdG8gYnVtcCBpbnRvIEFDRSBcIlxcclwiIGNvbnZlcnNpb24gaXNzdWVcclxuICAgICAgICAvLyAoQUNFIGlzIG9rIHdpdGggXCJcXHJcIiBvbiBwYXN0aW5nIGJ1dCBmYWlscyB0byByZXR1cm4gXCJcXHJcIiB3aGVuIHZhbHVlIGlzIGV4dHJhY3RlZClcclxuICAgICAgICBlZGl0b3IuZ2V0U2Vzc2lvbigpLnNldE5ld0xpbmVNb2RlKCd1bml4Jyk7XHJcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNldFNob3dQcmludE1hcmdpbihmYWxzZSk7XHJcbiAgICAgICAgZWRpdG9yLnNldFRoZW1lKFwiYWNlL3RoZW1lL1wiKyhmb3JtRWxlbWVudC5hY2VUaGVtZXx8XCJ0d2lsaWdodFwiKSk7XHJcblxyXG4gICAgICAgIGlmIChmb3JtRWxlbWVudC5hY2VNb2RlKSB7XHJcbiAgICAgICAgICBlZGl0b3IuZ2V0U2Vzc2lvbigpLnNldE1vZGUoXCJhY2UvbW9kZS9cIitmb3JtRWxlbWVudC5hY2VNb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRUYWJTaXplKDIpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBpbml0aWFsIG1hbmlmZXN0IGZpbGVcclxuICAgICAgICBlZGl0b3IuZ2V0U2Vzc2lvbigpLnNldFZhbHVlKG5vZGUudmFsdWV8fFwiXCIpO1xyXG5cclxuICAgICAgICAvL1RPRE8gdGhpcyBpcyBjbGVhcmx5IHN1Yi1vcHRpbWFsXHJcbiAgICAgICAgLy8gJ0xhemlseScgYmluZCB0byB0aGUgb25jaGFuZ2UgJ2FjZScgZXZlbnQgdG8gZ2l2ZVxyXG4gICAgICAgIC8vIHByaW9yaXR5IHRvIHVzZXIgZWRpdHNcclxuICAgICAgICB2YXIgbGF6eUNoYW5nZWQgPSBfLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZChpZFNlbGVjdG9yKS52YWwoZWRpdG9yLmdldFNlc3Npb24oKS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZChpZFNlbGVjdG9yKS5jaGFuZ2UoKTtcclxuICAgICAgICB9LCA2MDApO1xyXG4gICAgICAgIGVkaXRvci5nZXRTZXNzaW9uKCkub24oJ2NoYW5nZScsIGxhenlDaGFuZ2VkKTtcclxuICAgICAgICBcclxuICAgICAgICBlZGl0b3Iub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZChpZFNlbGVjdG9yKS5jaGFuZ2UoKTtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZChpZFNlbGVjdG9yKS50cmlnZ2VyKFwiYmx1clwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlZGl0b3Iub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAkKG5vZGUuZWwpLmZpbmQoaWRTZWxlY3RvcikudHJpZ2dlcihcImZvY3VzXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gSXMgdGhlcmUgYSBzZXR1cCBob29rP1xyXG4gICAgICBpZiAod2luZG93Lmpzb25mb3JtX2FjZV9zZXR1cCkge1xyXG4gICAgICAgIHdpbmRvdy5qc29uZm9ybV9hY2Vfc2V0dXAoc2V0dXApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2FpdCB1bnRpbCBBQ0UgaXMgbG9hZGVkXHJcbiAgICAgIHZhciBpdHYgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5hY2UpIHtcclxuICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGl0dik7XHJcbiAgICAgICAgICBzZXR1cCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwxMDAwKTtcclxuICAgIH1cclxuICB9LFxyXG4gICdjaGVja2JveCc6e1xyXG4gICAgJ3RlbXBsYXRlJzogJzxsYWJlbCBjbGFzcz1cImNoZWNrYm94XCI+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiPCU9IGlkICU+XCIgJyArXHJcbiAgICAgICduYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIHZhbHVlPVwiMVwiIDwlIGlmICh2YWx1ZSkgeyU+Y2hlY2tlZDwlIH0gJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCAmJiAobm9kZS5zY2hlbWFFbGVtZW50LnR5cGUgIT09IFwiYm9vbGVhblwiKSA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnIC8+PHNwYW4+PCU9IG5vZGUuaW5saW5ldGl0bGUgfHwgXCJcIiAlPjwvc3Bhbj4nICtcclxuICAgICAgJzwvbGFiZWw+JyxcclxuICAgICdmaWVsZHRlbXBsYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdnZXRFbGVtZW50JzogZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIHJldHVybiAkKGVsKS5wYXJlbnQoKS5nZXQoMCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAnZmlsZSc6e1xyXG4gICAgJ3RlbXBsYXRlJzonPGlucHV0IGNsYXNzPVwiaW5wdXQtZmlsZVwiIGlkPVwiPCU9IGlkICU+XCIgbmFtZT1cIjwlPSBub2RlLm5hbWUgJT5cIiB0eXBlPVwiZmlsZVwiICcgK1xyXG4gICAgICAnPCU9IChub2RlLnNjaGVtYUVsZW1lbnQgJiYgbm9kZS5zY2hlbWFFbGVtZW50LnJlcXVpcmVkID8gXCIgcmVxdWlyZWQ9XFwncmVxdWlyZWRcXCdcIiA6IFwiXCIpICU+JyArXHJcbiAgICAgICcvPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWVcclxuICB9LFxyXG4gICdmaWxlLWhvc3RlZC1wdWJsaWMnOntcclxuICAgICd0ZW1wbGF0ZSc6JzxzcGFuPjwlIGlmICh2YWx1ZSAmJiAodmFsdWUudHlwZXx8dmFsdWUudXJsKSkgeyAlPicrZmlsZURpc3BsYXlUZW1wbGF0ZSsnPCUgfSAlPjxpbnB1dCBjbGFzcz1cImlucHV0LWZpbGVcIiBpZD1cIl90cmFuc2xvYWRpdF88JT0gaWQgJT5cIiB0eXBlPVwiZmlsZVwiIG5hbWU9XCI8JT0gdHJhbnNsb2FkaXRuYW1lICU+XCIgLz48aW5wdXQgZGF0YS10cmFuc2xvYWRpdC1uYW1lPVwiX3RyYW5zbG9hZGl0XzwlPSB0cmFuc2xvYWRpdG5hbWUgJT5cIiB0eXBlPVwiaGlkZGVuXCIgaWQ9XCI8JT0gaWQgJT5cIiBuYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIHZhbHVlPVxcJzwlPSBlc2NhcGUoSlNPTi5zdHJpbmdpZnkobm9kZS52YWx1ZSkpICU+XFwnIC8+PC9zcGFuPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWUsXHJcbiAgICAnZ2V0RWxlbWVudCc6IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICByZXR1cm4gJChlbCkucGFyZW50KCkuZ2V0KDApO1xyXG4gICAgfSxcclxuICAgICdvbkJlZm9yZVJlbmRlcic6IGZ1bmN0aW9uIChkYXRhLCBub2RlKSB7XHJcblxyXG4gICAgICBpZiAoIW5vZGUub3duZXJUcmVlLl90cmFuc2xvYWRpdF9nZW5lcmljX3B1YmxpY19pbmRleCkge1xyXG4gICAgICAgIG5vZGUub3duZXJUcmVlLl90cmFuc2xvYWRpdF9nZW5lcmljX3B1YmxpY19pbmRleD0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGUub3duZXJUcmVlLl90cmFuc2xvYWRpdF9nZW5lcmljX3B1YmxpY19pbmRleCsrO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBkYXRhLnRyYW5zbG9hZGl0bmFtZSA9IFwiX3RyYW5zbG9hZGl0X2pzb25mb3JtX2dlbmVyaWN1cGxvYWRfcHVibGljX1wiK25vZGUub3duZXJUcmVlLl90cmFuc2xvYWRpdF9nZW5lcmljX3B1YmxpY19pbmRleDtcclxuXHJcbiAgICAgIGlmICghbm9kZS5vd25lclRyZWUuX3RyYW5zbG9hZGl0X2dlbmVyaWNfZWx0cykgbm9kZS5vd25lclRyZWUuX3RyYW5zbG9hZGl0X2dlbmVyaWNfZWx0cyA9IHt9O1xyXG4gICAgICBub2RlLm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfZ2VuZXJpY19lbHRzW2RhdGEudHJhbnNsb2FkaXRuYW1lXSA9IG5vZGU7XHJcbiAgICB9LFxyXG4gICAgJ29uQ2hhbmdlJzogZnVuY3Rpb24oZXZ0LGVsdCkge1xyXG4gICAgICAvLyBUaGUgXCJ0cmFuc2xvYWRpdFwiIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHRvIGVuYWJsZVxyXG4gICAgICAvLyB0aGUgc2VydmljZSB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC4gSGFzIGl0IGFscmVhZHkgYmVlbiBkb25lP1xyXG4gICAgICBpZiAoZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gQ2FsbCB0aGUgXCJ0cmFuc2xvYWRpdFwiIGZ1bmN0aW9uIG9uIHRoZSBmb3JtIGVsZW1lbnRcclxuICAgICAgdmFyIGZvcm1FbHQgPSAkKGVsdC5vd25lclRyZWUuZG9tUm9vdCk7XHJcbiAgICAgIGZvcm1FbHQudHJhbnNsb2FkaXQoe1xyXG4gICAgICAgIGF1dG9TdWJtaXQ6IGZhbHNlLFxyXG4gICAgICAgIHdhaXQ6IHRydWUsXHJcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcclxuICAgICAgICAgIC8vIEltYWdlIGhhcyBiZWVuIHVwbG9hZGVkLiBDaGVjayB0aGUgXCJyZXN1bHRzXCIgcHJvcGVydHkgdGhhdFxyXG4gICAgICAgICAgLy8gY29udGFpbnMgdGhlIGxpc3Qgb2YgZmlsZXMgdGhhdCBUcmFuc2xvYWRpdCBwcm9kdWNlZC4gVGhlcmVcclxuICAgICAgICAgIC8vIHNob3VsZCBiZSBvbmUgaW1hZ2UgcGVyIGZpbGUgaW5wdXQgaW4gdGhlIGZvcm0gYXQgbW9zdC5cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGFzc2VtYmx5LnJlc3VsdHMpO1xyXG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBfLnZhbHVlcyhhc3NlbWJseS5yZXN1bHRzKTtcclxuICAgICAgICAgIHJlc3VsdHMgPSBfLmZsYXR0ZW4ocmVzdWx0cyk7XHJcbiAgICAgICAgICBfLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBhc3NlbWJseSByZXN1bHQgaW4gdGhlIHJpZ2h0IGhpZGRlbiBpbnB1dCBmaWVsZFxyXG4gICAgICAgICAgICB2YXIgaWQgPSBlbHQub3duZXJUcmVlLl90cmFuc2xvYWRpdF9nZW5lcmljX2VsdHNbcmVzdWx0LmZpZWxkXS5pZDtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZm9ybUVsdC5maW5kKCcjJyArIGVzY2FwZVNlbGVjdG9yKGlkKSk7XHJcbiAgICAgICAgICAgIHZhciBub25FbXB0eUtleXMgPSBfLmZpbHRlcihfLmtleXMocmVzdWx0Lm1ldGEpLCBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICEhaXNTZXQocmVzdWx0Lm1ldGFba2V5XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQubWV0YSA9IF8ucGljayhyZXN1bHQubWV0YSwgbm9uRW1wdHlLZXlzKTtcclxuICAgICAgICAgICAgaW5wdXQudmFsKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gVW5iaW5kIHRyYW5zbG9hZGl0IGZyb20gdGhlIGZvcm1cclxuICAgICAgICAgIGVsdC5vd25lclRyZWUuX3RyYW5zbG9hZGl0X2JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICBmb3JtRWx0LnVuYmluZCgnc3VibWl0LnRyYW5zbG9hZGl0Jyk7XHJcblxyXG4gICAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtIG9uIG5leHQgdGlja1xyXG4gICAgICAgICAgXy5kZWxheShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdWJtaXQgZm9ybScpO1xyXG4gICAgICAgICAgICBlbHQub3duZXJUcmVlLnN1Ym1pdCgpO1xyXG4gICAgICAgICAgfSwgMTApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGFzc2VtYmx5KSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiByZXBvcnQgdGhlIGVycm9yIHRvIHRoZSB1c2VyXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnYXNzZW1ibHkgZXJyb3InLCBhc3NlbWJseSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAnb25JbnNlcnQnOiBmdW5jdGlvbiAoZXZ0LCBub2RlKSB7XHJcbiAgICAgICQobm9kZS5lbCkuZmluZCgnYS5fanNvbmZvcm0tZGVsZXRlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICQobm9kZS5lbCkuZmluZCgnLl9qc29uZm9ybS1wcmV2aWV3JykucmVtb3ZlKCk7XHJcbiAgICAgICAgJChub2RlLmVsKS5maW5kKCdhLl9qc29uZm9ybS1kZWxldGUnKS5yZW1vdmUoKTtcclxuICAgICAgICAkKG5vZGUuZWwpLmZpbmQoJyMnICsgZXNjYXBlU2VsZWN0b3Iobm9kZS5pZCkpLnZhbCgnJyk7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAnb25TdWJtaXQnOmZ1bmN0aW9uKGV2dCwgZWx0KSB7XHJcbiAgICAgIGlmIChlbHQub3duZXJUcmVlLl90cmFuc2xvYWRpdF9ib3VuZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgfSxcclxuICAnZmlsZS10cmFuc2xvYWRpdCc6IHtcclxuICAgICd0ZW1wbGF0ZSc6ICc8c3Bhbj48JSBpZiAodmFsdWUgJiYgKHZhbHVlLnR5cGV8fHZhbHVlLnVybCkpIHsgJT4nK2ZpbGVEaXNwbGF5VGVtcGxhdGUrJzwlIH0gJT48aW5wdXQgY2xhc3M9XCJpbnB1dC1maWxlXCIgaWQ9XCJfdHJhbnNsb2FkaXRfPCU9IGlkICU+XCIgdHlwZT1cImZpbGVcIiBuYW1lPVwiX3RyYW5zbG9hZGl0XzwlPSBub2RlLm5hbWUgJT5cIiAvPjxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgaWQ9XCI8JT0gaWQgJT5cIiBuYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIHZhbHVlPVxcJzwlPSBlc2NhcGUoSlNPTi5zdHJpbmdpZnkobm9kZS52YWx1ZSkpICU+XFwnIC8+PC9zcGFuPicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWUsXHJcbiAgICAnZ2V0RWxlbWVudCc6IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICByZXR1cm4gJChlbCkucGFyZW50KCkuZ2V0KDApO1xyXG4gICAgfSxcclxuICAgICdvbkNoYW5nZSc6IGZ1bmN0aW9uIChldnQsIGVsdCkge1xyXG4gICAgICAvLyBUaGUgXCJ0cmFuc2xvYWRpdFwiIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHRvIGVuYWJsZVxyXG4gICAgICAvLyB0aGUgc2VydmljZSB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC4gSGFzIGl0IGFscmVhZHkgYmVlbiBkb25lP1xyXG4gICAgICBpZiAoZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gQ2FsbCB0aGUgXCJ0cmFuc2xvYWRpdFwiIGZ1bmN0aW9uIG9uIHRoZSBmb3JtIGVsZW1lbnRcclxuICAgICAgdmFyIGZvcm1FbHQgPSAkKGVsdC5vd25lclRyZWUuZG9tUm9vdCk7XHJcbiAgICAgIGZvcm1FbHQudHJhbnNsb2FkaXQoe1xyXG4gICAgICAgIGF1dG9TdWJtaXQ6IGZhbHNlLFxyXG4gICAgICAgIHdhaXQ6IHRydWUsXHJcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcclxuICAgICAgICAgIC8vIEltYWdlIGhhcyBiZWVuIHVwbG9hZGVkLiBDaGVjayB0aGUgXCJyZXN1bHRzXCIgcHJvcGVydHkgdGhhdFxyXG4gICAgICAgICAgLy8gY29udGFpbnMgdGhlIGxpc3Qgb2YgZmlsZXMgdGhhdCBUcmFuc2xvYWRpdCBwcm9kdWNlZC4gTm90ZVxyXG4gICAgICAgICAgLy8gSlNPTkZvcm0gb25seSBzdXBwb3J0cyAxLXRvLTEgYXNzb2NpYXRpb25zLCBtZWFuaW5nIGl0XHJcbiAgICAgICAgICAvLyBleHBlY3RzIHRoZSBcInJlc3VsdHNcIiBwcm9wZXJ0eSB0byBjb250YWluIG9ubHkgb25lIGltYWdlXHJcbiAgICAgICAgICAvLyBwZXIgZmlsZSBpbnB1dCBpbiB0aGUgZm9ybS5cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGFzc2VtYmx5LnJlc3VsdHMpO1xyXG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBfLnZhbHVlcyhhc3NlbWJseS5yZXN1bHRzKTtcclxuICAgICAgICAgIHJlc3VsdHMgPSBfLmZsYXR0ZW4ocmVzdWx0cyk7XHJcbiAgICAgICAgICBfLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBhc3NlbWJseSByZXN1bHQgaW4gdGhlIHJpZ2h0IGhpZGRlbiBpbnB1dCBmaWVsZFxyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmb3JtRWx0LmZpbmQoJ2lucHV0W25hbWU9XCInICtcclxuICAgICAgICAgICAgICByZXN1bHQuZmllbGQucmVwbGFjZSgvXl90cmFuc2xvYWRpdF8vLCAnJykgK1xyXG4gICAgICAgICAgICAgICdcIl0nKTtcclxuICAgICAgICAgICAgdmFyIG5vbkVtcHR5S2V5cyA9IF8uZmlsdGVyKF8ua2V5cyhyZXN1bHQubWV0YSksIGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gISFpc1NldChyZXN1bHQubWV0YVtrZXldKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5tZXRhID0gXy5waWNrKHJlc3VsdC5tZXRhLCBub25FbXB0eUtleXMpO1xyXG4gICAgICAgICAgICBpbnB1dC52YWwoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBVbmJpbmQgdHJhbnNsb2FkaXQgZnJvbSB0aGUgZm9ybVxyXG4gICAgICAgICAgZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgIGZvcm1FbHQudW5iaW5kKCdzdWJtaXQudHJhbnNsb2FkaXQnKTtcclxuXHJcbiAgICAgICAgICAvLyBTdWJtaXQgdGhlIGZvcm0gb24gbmV4dCB0aWNrXHJcbiAgICAgICAgICBfLmRlbGF5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3N1Ym1pdCBmb3JtJyk7XHJcbiAgICAgICAgICAgIGVsdC5vd25lclRyZWUuc3VibWl0KCk7XHJcbiAgICAgICAgICB9LCAxMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcclxuICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCB0aGUgZXJyb3IgdG8gdGhlIHVzZXJcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdhc3NlbWJseSBlcnJvcicsIGFzc2VtYmx5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgICdvbkluc2VydCc6IGZ1bmN0aW9uIChldnQsIG5vZGUpIHtcclxuICAgICAgJChub2RlLmVsKS5maW5kKCdhLl9qc29uZm9ybS1kZWxldGUnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgJChub2RlLmVsKS5maW5kKCcuX2pzb25mb3JtLXByZXZpZXcnKS5yZW1vdmUoKTtcclxuICAgICAgICAkKG5vZGUuZWwpLmZpbmQoJ2EuX2pzb25mb3JtLWRlbGV0ZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICQobm9kZS5lbCkuZmluZCgnIycgKyBlc2NhcGVTZWxlY3Rvcihub2RlLmlkKSkudmFsKCcnKTtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgICdvblN1Ym1pdCc6IGZ1bmN0aW9uIChldnQsIGVsdCkge1xyXG4gICAgICBpZiAoZWx0Lm93bmVyVHJlZS5fdHJhbnNsb2FkaXRfYm91bmQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSxcclxuICAnc2VsZWN0Jzp7XHJcbiAgICAndGVtcGxhdGUnOic8c2VsZWN0IG5hbWU9XCI8JT0gbm9kZS5uYW1lICU+XCIgaWQ9XCI8JT0gaWQgJT5cIicgK1xyXG4gICAgICAnPCU9IChmaWVsZEh0bWxDbGFzcyA/IFwiIGNsYXNzPVxcJ1wiICsgZmllbGRIdG1sQ2xhc3MgKyBcIlxcJ1wiIDogXCJcIikgJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5kaXNhYmxlZD8gXCIgZGlzYWJsZWRcIiA6IFwiXCIpJT4nICtcclxuICAgICAgJzwlPSAobm9kZS5zY2hlbWFFbGVtZW50ICYmIG5vZGUuc2NoZW1hRWxlbWVudC5yZXF1aXJlZCA/IFwiIHJlcXVpcmVkPVxcJ3JlcXVpcmVkXFwnXCIgOiBcIlwiKSAlPicgK1xyXG4gICAgICAnPiAnICtcclxuICAgICAgJzwlIF8uZWFjaChub2RlLm9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsKSB7IGlmKGtleSBpbnN0YW5jZW9mIE9iamVjdCkgeyBpZiAodmFsdWUgPT09IGtleS52YWx1ZSkgeyAlPiA8b3B0aW9uIHNlbGVjdGVkIHZhbHVlPVwiPCU9IGtleS52YWx1ZSAlPlwiPjwlPSBrZXkudGl0bGUgJT48L29wdGlvbj4gPCUgfSBlbHNlIHsgJT4gPG9wdGlvbiB2YWx1ZT1cIjwlPSBrZXkudmFsdWUgJT5cIj48JT0ga2V5LnRpdGxlICU+PC9vcHRpb24+IDwlIH19IGVsc2UgeyBpZiAodmFsdWUgPT09IGtleSkgeyAlPiA8b3B0aW9uIHNlbGVjdGVkIHZhbHVlPVwiPCU9IGtleSAlPlwiPjwlPSBrZXkgJT48L29wdGlvbj4gPCUgfSBlbHNlIHsgJT48b3B0aW9uIHZhbHVlPVwiPCU9IGtleSAlPlwiPjwlPSBrZXkgJT48L29wdGlvbj4gPCUgfX19KTsgJT4gJyArXHJcbiAgICAgICc8L3NlbGVjdD4nLFxyXG4gICAgJ2ZpZWxkdGVtcGxhdGUnOiB0cnVlLFxyXG4gICAgJ2lucHV0ZmllbGQnOiB0cnVlXHJcbiAgfSxcclxuICAnaW1hZ2VzZWxlY3QnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGRpdj4nICtcclxuICAgICAgJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIjwlPSBub2RlLm5hbWUgJT5cIiBpZD1cIjwlPSBub2RlLmlkICU+XCIgdmFsdWU9XCI8JT0gdmFsdWUgJT5cIiAvPicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cImRyb3Bkb3duXCI+JyArXHJcbiAgICAgICc8YSBjbGFzcz1cImJ0bjwlIGlmIChidXR0b25DbGFzcyAmJiBub2RlLnZhbHVlKSB7ICU+IDwlPSBidXR0b25DbGFzcyAlPjwlIH0gJT5cIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgaHJlZj1cIiNcIjwlIGlmIChub2RlLnZhbHVlKSB7ICU+IHN0eWxlPVwibWF4LXdpZHRoOjwlPSB3aWR0aCAlPnB4O21heC1oZWlnaHQ6PCU9IGhlaWdodCAlPnB4XCI8JSB9ICU+PicgK1xyXG4gICAgICAgICc8JSBpZiAobm9kZS52YWx1ZSkgeyAlPjxpbWcgc3JjPVwiPCUgaWYgKCFub2RlLnZhbHVlLm1hdGNoKC9eaHR0cHM/Oi8pKSB7ICU+PCU9IHByZWZpeCAlPjwlIH0gJT48JT0gbm9kZS52YWx1ZSAlPjwlPSBzdWZmaXggJT5cIiBhbHQ9XCJcIiAvPjwlIH0gZWxzZSB7ICU+PCU9IGJ1dHRvblRpdGxlICU+PCUgfSAlPicgK1xyXG4gICAgICAnPC9hPicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgbmF2YmFyXCIgaWQ9XCI8JT0gbm9kZS5pZCAlPl9kcm9wZG93blwiPicgK1xyXG4gICAgICAgICc8ZGl2PicgK1xyXG4gICAgICAgICc8JSBfLmVhY2gobm9kZS5vcHRpb25zLCBmdW5jdGlvbihrZXksIGlkeCkgeyBpZiAoKGlkeCA+IDApICYmICgoaWR4ICUgY29sdW1ucykgPT09IDApKSB7ICU+PC9kaXY+PGRpdj48JSB9ICU+PGEgY2xhc3M9XCJidG48JSBpZiAoYnV0dG9uQ2xhc3MpIHsgJT4gPCU9IGJ1dHRvbkNsYXNzICU+PCUgfSAlPlwiIHN0eWxlPVwibWF4LXdpZHRoOjwlPSB3aWR0aCAlPnB4O21heC1oZWlnaHQ6PCU9IGhlaWdodCAlPnB4XCI+PCUgaWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkgeyAlPjxpbWcgc3JjPVwiPCUgaWYgKCFrZXkudmFsdWUubWF0Y2goL15odHRwcz86LykpIHsgJT48JT0gcHJlZml4ICU+PCUgfSAlPjwlPSBrZXkudmFsdWUgJT48JT0gc3VmZml4ICU+XCIgYWx0PVwiPCU9IGtleS50aXRsZSAlPlwiIC8+PC9hPjwlIH0gZWxzZSB7ICU+PGltZyBzcmM9XCI8JSBpZiAoIWtleS5tYXRjaCgvXmh0dHBzPzovKSkgeyAlPjwlPSBwcmVmaXggJT48JSB9ICU+PCU9IGtleSAlPjwlPSBzdWZmaXggJT5cIiBhbHQ9XCJcIiAvPjwlIH0gJT48L2E+IDwlIH0pOyAlPicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cInBhZ2luYXRpb24tcmlnaHRcIj48YSBjbGFzcz1cImJ0blwiPlJlc2V0PC9hPjwvZGl2PicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWUsXHJcbiAgICAnb25CZWZvcmVSZW5kZXInOiBmdW5jdGlvbiAoZGF0YSwgbm9kZSkge1xyXG4gICAgICB2YXIgZWx0ID0gbm9kZS5mb3JtRWxlbWVudCB8fCB7fTtcclxuICAgICAgdmFyIG5iUm93cyA9IG51bGw7XHJcbiAgICAgIHZhciBtYXhDb2x1bW5zID0gZWx0LmltYWdlU2VsZWN0b3JDb2x1bW5zIHx8IDU7XHJcbiAgICAgIGRhdGEuYnV0dG9uVGl0bGUgPSBlbHQuaW1hZ2VTZWxlY3RvclRpdGxlIHx8ICdTZWxlY3QuLi4nO1xyXG4gICAgICBkYXRhLnByZWZpeCA9IGVsdC5pbWFnZVByZWZpeCB8fCAnJztcclxuICAgICAgZGF0YS5zdWZmaXggPSBlbHQuaW1hZ2VTdWZmaXggfHwgJyc7XHJcbiAgICAgIGRhdGEud2lkdGggPSBlbHQuaW1hZ2VXaWR0aCB8fCAzMjtcclxuICAgICAgZGF0YS5oZWlnaHQgPSBlbHQuaW1hZ2VIZWlnaHQgfHwgMzI7XHJcbiAgICAgIGRhdGEuYnV0dG9uQ2xhc3MgPSBlbHQuaW1hZ2VCdXR0b25DbGFzcyB8fCBmYWxzZTtcclxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5sZW5ndGggPiBtYXhDb2x1bW5zKSB7XHJcbiAgICAgICAgbmJSb3dzID0gTWF0aC5jZWlsKG5vZGUub3B0aW9ucy5sZW5ndGggLyBtYXhDb2x1bW5zKTtcclxuICAgICAgICBkYXRhLmNvbHVtbnMgPSBNYXRoLmNlaWwobm9kZS5vcHRpb25zLmxlbmd0aCAvIG5iUm93cyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZGF0YS5jb2x1bW5zID0gbWF4Q29sdW1ucztcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgICdnZXRFbGVtZW50JzogZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIHJldHVybiAkKGVsKS5wYXJlbnQoKS5nZXQoMCk7XHJcbiAgICB9LFxyXG4gICAgJ29uSW5zZXJ0JzogZnVuY3Rpb24gKGV2dCwgbm9kZSkge1xyXG4gICAgICAkKG5vZGUuZWwpLm9uKCdjbGljaycsICcuZHJvcGRvd24tbWVudSBhJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB2YXIgaW1nID0gKGV2dC50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpID9cclxuICAgICAgICAgICQoZXZ0LnRhcmdldCkgOlxyXG4gICAgICAgICAgJChldnQudGFyZ2V0KS5maW5kKCdpbWcnKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBpbWcuYXR0cignc3JjJyk7XHJcbiAgICAgICAgdmFyIGVsdCA9IG5vZGUuZm9ybUVsZW1lbnQgfHwge307XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IGVsdC5pbWFnZVByZWZpeCB8fCAnJztcclxuICAgICAgICB2YXIgc3VmZml4ID0gZWx0LmltYWdlU3VmZml4IHx8ICcnO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGVsdC5pbWFnZVdpZHRoIHx8IDMyO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBlbHQuaW1hZ2VIZWlnaHQgfHwgMzI7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XHJcbiAgICAgICAgICAkKG5vZGUuZWwpLmZpbmQoJ2lucHV0JykuYXR0cigndmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAkKG5vZGUuZWwpLmZpbmQoJ2FbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcyhlbHQuaW1hZ2VCdXR0b25DbGFzcylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ21heC13aWR0aDonICsgd2lkdGggKyAncHg7bWF4LWhlaWdodDonICsgaGVpZ2h0ICsgJ3B4JylcclxuICAgICAgICAgICAgLmh0bWwoJzxpbWcgc3JjPVwiJyArICghdmFsdWUubWF0Y2goL15odHRwcz86LykgPyBwcmVmaXggOiAnJykgKyB2YWx1ZSArIHN1ZmZpeCArICdcIiBhbHQ9XCJcIiAvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZCgnaW5wdXQnKS5hdHRyKCd2YWx1ZScsICcnKTtcclxuICAgICAgICAgICQobm9kZS5lbCkuZmluZCgnYVtkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJylcclxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGVsdC5pbWFnZUJ1dHRvbkNsYXNzKVxyXG4gICAgICAgICAgICAucmVtb3ZlQXR0cignc3R5bGUnKVxyXG4gICAgICAgICAgICAuaHRtbChlbHQuaW1hZ2VTZWxlY3RvclRpdGxlIHx8ICdTZWxlY3QuLi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgJ3JhZGlvcyc6e1xyXG4gICAgJ3RlbXBsYXRlJzogJzxkaXYgaWQ9XCI8JT0gbm9kZS5pZCAlPlwiPjwlIF8uZWFjaChub2RlLm9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsKSB7ICU+PGxhYmVsIGNsYXNzPVwicmFkaW9cIj48aW5wdXQgdHlwZT1cInJhZGlvXCIgPCUgaWYgKCgoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSAmJiAodmFsdWUgPT09IGtleS52YWx1ZSkpIHx8ICh2YWx1ZSA9PT0ga2V5KSkgeyAlPiBjaGVja2VkPVwiY2hlY2tlZFwiIDwlIH0gJT4gbmFtZT1cIjwlPSBub2RlLm5hbWUgJT5cIiB2YWx1ZT1cIjwlPSAoa2V5IGluc3RhbmNlb2YgT2JqZWN0ID8ga2V5LnZhbHVlIDoga2V5KSAlPlwiJyArXHJcbiAgICAgICc8JT0gKG5vZGUuZGlzYWJsZWQ/IFwiIGRpc2FibGVkXCIgOiBcIlwiKSU+JyArXHJcbiAgICAgICc8JT0gKG5vZGUuc2NoZW1hRWxlbWVudCAmJiBub2RlLnNjaGVtYUVsZW1lbnQucmVxdWlyZWQgPyBcIiByZXF1aXJlZD1cXCdyZXF1aXJlZFxcJ1wiIDogXCJcIikgJT4nICtcclxuICAgICAgJy8+PHNwYW4+PCU9IChrZXkgaW5zdGFuY2VvZiBPYmplY3QgPyBrZXkudGl0bGUgOiBrZXkpICU+PC9zcGFuPjwvbGFiZWw+IDwlIH0pOyAlPjwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnaW5wdXRmaWVsZCc6IHRydWVcclxuICB9LFxyXG4gICdyYWRpb2J1dHRvbnMnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGRpdiBpZD1cIjwlPSBub2RlLmlkICU+XCI+JyArXHJcbiAgICAgICc8JSBfLmVhY2gobm9kZS5vcHRpb25zLCBmdW5jdGlvbihrZXksIHZhbCkgeyAlPicgK1xyXG4gICAgICAgICc8bGFiZWwgY2xhc3M9XCJyYWRpbyBidG5cIj4nICtcclxuICAgICAgICAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotOTk5OXB4O1wiICcgK1xyXG4gICAgICAgICc8JSBpZiAoKChrZXkgaW5zdGFuY2VvZiBPYmplY3QpICYmICh2YWx1ZSA9PT0ga2V5LnZhbHVlKSkgfHwgKHZhbHVlID09PSBrZXkpKSB7ICU+IGNoZWNrZWQ9XCJjaGVja2VkXCIgPCUgfSAlPiBuYW1lPVwiPCU9IG5vZGUubmFtZSAlPlwiIHZhbHVlPVwiPCU9IChrZXkgaW5zdGFuY2VvZiBPYmplY3QgPyBrZXkudmFsdWUgOiBrZXkpICU+XCIgLz4nICtcclxuICAgICAgICAnPHNwYW4+PCU9IChrZXkgaW5zdGFuY2VvZiBPYmplY3QgPyBrZXkudGl0bGUgOiBrZXkpICU+PC9zcGFuPjwvbGFiZWw+ICcgK1xyXG4gICAgICAgICc8JSB9KTsgJT4nICtcclxuICAgICAgJzwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdvbkluc2VydCc6IGZ1bmN0aW9uIChldnQsIG5vZGUpIHtcclxuICAgICAgdmFyIGFjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XHJcbiAgICAgIHZhciBlbHQgPSBub2RlLmZvcm1FbGVtZW50IHx8IHt9O1xyXG4gICAgICBpZiAoZWx0LmFjdGl2ZUNsYXNzKSB7XHJcbiAgICAgICAgYWN0aXZlQ2xhc3MgKz0gJyAnICsgZWx0LmFjdGl2ZUNsYXNzO1xyXG4gICAgICB9XHJcbiAgICAgICQobm9kZS5lbCkuZmluZCgnbGFiZWwnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5maW5kKCdsYWJlbCcpLnJlbW92ZUNsYXNzKGFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAkKHRoaXMpLmFkZENsYXNzKGFjdGl2ZUNsYXNzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAnY2hlY2tib3hlcyc6e1xyXG4gICAgJ3RlbXBsYXRlJzogJzxkaXY+PCU9IGNob2ljZXNodG1sICU+PC9kaXY+JyxcclxuICAgICdmaWVsZHRlbXBsYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdvbkJlZm9yZVJlbmRlcic6IGZ1bmN0aW9uIChkYXRhLCBub2RlKSB7XHJcbiAgICAgIC8vIEJ1aWxkIHVwIGNob2ljZXMgZnJvbSB0aGUgZW51bWVyYXRpb24gbGlzdFxyXG4gICAgICB2YXIgY2hvaWNlcyA9IG51bGw7XHJcbiAgICAgIHZhciBjaG9pY2VzaHRtbCA9IG51bGw7XHJcbiAgICAgIHZhciB0ZW1wbGF0ZSA9ICc8bGFiZWwgY2xhc3M9XCJjaGVja2JveFwiPicgK1xyXG4gICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgPCUgaWYgKHZhbHVlKSB7ICU+IGNoZWNrZWQ9XCJjaGVja2VkXCIgPCUgfSAlPiBuYW1lPVwiPCU9IG5hbWUgJT5cIiB2YWx1ZT1cIjFcIicgK1xyXG4gICAgICAgICc8JT0gKG5vZGUuZGlzYWJsZWQ/IFwiIGRpc2FibGVkXCIgOiBcIlwiKSU+JyArXHJcbiAgICAgICAgJy8+PHNwYW4+PCU9IHRpdGxlICU+PC9zcGFuPjwvbGFiZWw+JztcclxuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnNjaGVtYUVsZW1lbnQgfHwgIW5vZGUuc2NoZW1hRWxlbWVudC5pdGVtcykgcmV0dXJuO1xyXG4gICAgICBjaG9pY2VzID0gbm9kZS5zY2hlbWFFbGVtZW50Lml0ZW1zWydlbnVtJ10gfHxcclxuICAgICAgICBub2RlLnNjaGVtYUVsZW1lbnQuaXRlbXNbMF1bJ2VudW0nXTtcclxuICAgICAgaWYgKCFjaG9pY2VzKSByZXR1cm47XHJcblxyXG4gICAgICBjaG9pY2VzaHRtbCA9ICcnO1xyXG4gICAgICBfLmVhY2goY2hvaWNlcywgZnVuY3Rpb24gKGNob2ljZSwgaWR4KSB7XHJcbiAgICAgICAgY2hvaWNlc2h0bWwgKz0gXy50ZW1wbGF0ZSh0ZW1wbGF0ZSwge1xyXG4gICAgICAgICAgbmFtZTogbm9kZS5rZXkgKyAnWycgKyBpZHggKyAnXScsXHJcbiAgICAgICAgICB2YWx1ZTogXy5pbmNsdWRlKG5vZGUudmFsdWUsIGNob2ljZSksXHJcbiAgICAgICAgICB0aXRsZTogbm9kZS5mb3JtRWxlbWVudC50aXRsZU1hcCA/IG5vZGUuZm9ybUVsZW1lbnQudGl0bGVNYXBbY2hvaWNlXSA6IGNob2ljZSxcclxuICAgICAgICAgIG5vZGU6IG5vZGVcclxuICAgICAgICB9LCBmaWVsZFRlbXBsYXRlU2V0dGluZ3MpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGRhdGEuY2hvaWNlc2h0bWwgPSBjaG9pY2VzaHRtbDtcclxuICAgIH1cclxuICB9LFxyXG4gICdhcnJheSc6IHtcclxuICAgICd0ZW1wbGF0ZSc6ICc8ZGl2IGlkPVwiPCU9IGlkICU+XCI+PHVsIGNsYXNzPVwiX2pzb25mb3JtLWFycmF5LXVsXCIgc3R5bGU9XCJsaXN0LXN0eWxlLXR5cGU6bm9uZTtcIj48JT0gY2hpbGRyZW4gJT48L3VsPicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJfanNvbmZvcm0tYXJyYXktYnV0dG9uc1wiPicgK1xyXG4gICAgICAgICc8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIF9qc29uZm9ybS1hcnJheS1hZGRtb3JlXCI+PGkgY2xhc3M9XCJpY29uLXBsdXMtc2lnblwiIHRpdGxlPVwiQWRkIG5ld1wiPjwvaT48L2E+ICcgK1xyXG4gICAgICAgICc8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIF9qc29uZm9ybS1hcnJheS1kZWxldGVsYXN0XCI+PGkgY2xhc3M9XCJpY29uLW1pbnVzLXNpZ25cIiB0aXRsZT1cIkRlbGV0ZSBsYXN0XCI+PC9pPjwvYT4nICtcclxuICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgJzwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnYXJyYXknOiB0cnVlLFxyXG4gICAgJ2NoaWxkVGVtcGxhdGUnOiBmdW5jdGlvbiAoaW5uZXIpIHtcclxuICAgICAgaWYgKCQoJycpLnNvcnRhYmxlKSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IGEgXCJkcmFnZ2FibGVcIiBpY29uXHJcbiAgICAgICAgLy8gZmxvYXRpbmcgdG8gdGhlIGxlZnQgb2YgdGhlIG1haW4gZWxlbWVudFxyXG4gICAgICAgIHJldHVybiAnPGxpIGRhdGEtaWR4PVwiPCU9IG5vZGUuY2hpbGRQb3MgJT5cIj4nICtcclxuICAgICAgICAgICc8c3BhbiBjbGFzcz1cImRyYWdnYWJsZSBsaW5lXCI+PGkgY2xhc3M9XCJpY29uLWxpc3RcIiB0aXRsZT1cIk1vdmUgaXRlbVwiPjwvaT48L3NwYW4+JyArXHJcbiAgICAgICAgICBpbm5lciArXHJcbiAgICAgICAgICAnPC9saT4nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnPGxpIGRhdGEtaWR4PVwiPCU9IG5vZGUuY2hpbGRQb3MgJT5cIj4nICtcclxuICAgICAgICAgIGlubmVyICtcclxuICAgICAgICAgICc8L2xpPic7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAnb25JbnNlcnQnOiBmdW5jdGlvbiAoZXZ0LCBub2RlKSB7XHJcbiAgICAgIHZhciAkbm9kZWlkID0gJChub2RlLmVsKS5maW5kKCcjJyArIGVzY2FwZVNlbGVjdG9yKG5vZGUuaWQpKTtcclxuICAgICAgdmFyIGJvdW5kYXJpZXMgPSBub2RlLmdldEFycmF5Qm91bmRhcmllcygpO1xyXG5cclxuICAgICAgLy8gU3dpdGNoIHR3byBub2RlcyBpbiBhbiBhcnJheVxyXG4gICAgICB2YXIgbW92ZU5vZGVUbyA9IGZ1bmN0aW9uIChmcm9tSWR4LCB0b0lkeCkge1xyXG4gICAgICAgIC8vIE5vdGUgXCJzd2l0Y2hWYWx1ZXNXaXRoXCIgZXh0cmFjdHMgdmFsdWVzIGZyb20gdGhlIERPTSBzaW5jZSBmaWVsZFxyXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgbm90IHN5bmNocm9uaXplZCB3aXRoIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlLCBzbyBjYWxsc1xyXG4gICAgICAgIC8vIHRvIHJlbmRlciBhcmUgbmVlZGVkIGF0IGVhY2ggc3RlcCB0byBmb3JjZSB2YWx1ZXMgZG93biB0byB0aGUgRE9NXHJcbiAgICAgICAgLy8gYmVmb3JlIG5leHQgbW92ZS5cclxuICAgICAgICAvLyBUT0RPOiBzeW5jaHJvbml6ZSBmaWVsZCB2YWx1ZXMgYW5kIGRhdGEgc3RydWN0dXJlIGNvbXBsZXRlbHkgYW5kXHJcbiAgICAgICAgLy8gY2FsbCByZW5kZXIgb25seSBvbmNlIHRvIGltcHJvdmUgZWZmaWNpZW5jeS5cclxuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gdG9JZHgpIHJldHVybjtcclxuICAgICAgICB2YXIgaW5jciA9IChmcm9tSWR4IDwgdG9JZHgpID8gMTogLTE7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBwYXJlbnRFbCA9ICQoJz4gdWwnLCAkbm9kZWlkKTtcclxuICAgICAgICBmb3IgKGkgPSBmcm9tSWR4OyBpICE9PSB0b0lkeDsgaSArPSBpbmNyKSB7XHJcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLnN3aXRjaFZhbHVlc1dpdGgobm9kZS5jaGlsZHJlbltpICsgaW5jcl0pO1xyXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yZW5kZXIocGFyZW50RWwuZ2V0KDApKTtcclxuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baSArIGluY3JdLnJlbmRlcihwYXJlbnRFbC5nZXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gc2ltcGxlIHdheSB0byBwcmV2ZW50IERPTSByZW9yZGVyaW5nIHdpdGggalF1ZXJ5IFVJIFNvcnRhYmxlLFxyXG4gICAgICAgIC8vIHNvIHdlJ3JlIGdvaW5nIHRvIG5lZWQgdG8gbW92ZSBzb3J0ZWQgRE9NIGVsZW1lbnRzIGJhY2sgdG8gdGhlaXJcclxuICAgICAgICAvLyBvcmlnaW4gcG9zaXRpb24gaW4gdGhlIERPTSBvdXJzZWx2ZXMgKHdlIHN3aXRjaGVkIHZhbHVlcyBidXQgbm90XHJcbiAgICAgICAgLy8gRE9NIGVsZW1lbnRzKVxyXG4gICAgICAgIHZhciBmcm9tRWwgPSAkKG5vZGUuY2hpbGRyZW5bZnJvbUlkeF0uZWwpO1xyXG4gICAgICAgIHZhciB0b0VsID0gJChub2RlLmNoaWxkcmVuW3RvSWR4XS5lbCk7XHJcbiAgICAgICAgZnJvbUVsLmRldGFjaCgpO1xyXG4gICAgICAgIHRvRWwuZGV0YWNoKCk7XHJcbiAgICAgICAgaWYgKGZyb21JZHggPCB0b0lkeCkge1xyXG4gICAgICAgICAgaWYgKGZyb21JZHggPT09IDApIHBhcmVudEVsLnByZXBlbmQoZnJvbUVsKTtcclxuICAgICAgICAgIGVsc2UgJChub2RlLmNoaWxkcmVuW2Zyb21JZHgtMV0uZWwpLmFmdGVyKGZyb21FbCk7XHJcbiAgICAgICAgICAkKG5vZGUuY2hpbGRyZW5bdG9JZHgtMV0uZWwpLmFmdGVyKHRvRWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICh0b0lkeCA9PT0gMCkgcGFyZW50RWwucHJlcGVuZCh0b0VsKTtcclxuICAgICAgICAgIGVsc2UgJChub2RlLmNoaWxkcmVuW3RvSWR4LTFdLmVsKS5hZnRlcih0b0VsKTtcclxuICAgICAgICAgICQobm9kZS5jaGlsZHJlbltmcm9tSWR4LTFdLmVsKS5hZnRlcihmcm9tRWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgICQoJz4gc3BhbiA+IGEuX2pzb25mb3JtLWFycmF5LWFkZG1vcmUnLCAkbm9kZWlkKS5jbGljayhmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHZhciBpZHggPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBpZiAoYm91bmRhcmllcy5tYXhJdGVtcyA+PSAwKSB7XHJcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiBib3VuZGFyaWVzLm1heEl0ZW1zIC0gMikge1xyXG4gICAgICAgICAgICAkbm9kZWlkLmZpbmQoJz4gc3BhbiA+IGEuX2pzb25mb3JtLWFycmF5LWFkZG1vcmUnKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IGJvdW5kYXJpZXMubWF4SXRlbXMgLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5pbnNlcnRBcnJheUl0ZW0oaWR4LCAkKCc+IHVsJywgJG5vZGVpZCkuZ2V0KDApKTtcclxuICAgICAgICBpZiAoKGJvdW5kYXJpZXMubWluSXRlbXMgPD0gMCkgfHxcclxuICAgICAgICAgICAgKChib3VuZGFyaWVzLm1pbkl0ZW1zID4gMCkgJiZcclxuICAgICAgICAgICAgICAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiBib3VuZGFyaWVzLm1pbkl0ZW1zIC0gMSkpKSB7XHJcbiAgICAgICAgICAkbm9kZWlkLmZpbmQoJz4gc3BhbiA+IGEuX2pzb25mb3JtLWFycmF5LWRlbGV0ZWxhc3QnKVxyXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vU2ltdWxhdGUgVXNlcnMgY2xpY2sgdG8gc2V0dXAgdGhlIGZvcm0gd2l0aCBpdHMgbWluSXRlbXNcclxuICAgICAgdmFyIGN1ckl0ZW1zID0gJCgnPiB1bCA+IGxpJywgJG5vZGVpZCkubGVuZ3RoO1xyXG4gICAgICBpZiAoKGJvdW5kYXJpZXMubWluSXRlbXMgPiAwKSAmJlxyXG4gICAgICAgICAgKGN1ckl0ZW1zIDwgYm91bmRhcmllcy5taW5JdGVtcykpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChib3VuZGFyaWVzLm1pbkl0ZW1zIC0gMSkgJiYgKCRub2RlaWQuZmluZCgnPiB1bCA+IGxpJykubGVuZ3RoIDwgYm91bmRhcmllcy5taW5JdGVtcyk7IGkrKykge1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnQ2FsbGluZyBjbGljazogJywkbm9kZWlkKTtcclxuICAgICAgICAgIC8vJCgnPiBzcGFuID4gYS5fanNvbmZvcm0tYXJyYXktYWRkbW9yZScsICRub2RlaWQpLmNsaWNrKCk7XHJcbiAgICAgICAgICBub2RlLmluc2VydEFycmF5SXRlbShjdXJJdGVtcywgJG5vZGVpZC5maW5kKCc+IHVsJykuZ2V0KDApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChib3VuZGFyaWVzLm1pbkl0ZW1zID4gMCkgJiZcclxuICAgICAgICAgIChub2RlLmNoaWxkcmVuLmxlbmd0aCA8PSBib3VuZGFyaWVzLm1pbkl0ZW1zKSkge1xyXG4gICAgICAgICRub2RlaWQuZmluZCgnPiBzcGFuID4gYS5fanNvbmZvcm0tYXJyYXktZGVsZXRlbGFzdCcpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICQoJz4gc3BhbiA+IGEuX2pzb25mb3JtLWFycmF5LWRlbGV0ZWxhc3QnLCAkbm9kZWlkKS5jbGljayhmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgaWYgKGJvdW5kYXJpZXMubWluSXRlbXMgPiAwKSB7XHJcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPCBib3VuZGFyaWVzLm1pbkl0ZW1zICsgMikge1xyXG4gICAgICAgICAgICAkbm9kZWlkLmZpbmQoJz4gc3BhbiA+IGEuX2pzb25mb3JtLWFycmF5LWRlbGV0ZWxhc3QnKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA8PSBib3VuZGFyaWVzLm1pbkl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiBzcGFuID4gYS5fanNvbmZvcm0tYXJyYXktZGVsZXRlbGFzdCcpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5kZWxldGVBcnJheUl0ZW0oaWR4KTtcclxuICAgICAgICBpZiAoKGJvdW5kYXJpZXMubWF4SXRlbXMgPj0gMCkgJiYgKGlkeCA8PSBib3VuZGFyaWVzLm1heEl0ZW1zIC0gMSkpIHtcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiBzcGFuID4gYS5fanNvbmZvcm0tYXJyYXktYWRkbW9yZScpXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCQobm9kZS5lbCkuc29ydGFibGUpIHtcclxuICAgICAgICAkKCc+IHVsJywgJG5vZGVpZCkuc29ydGFibGUoKTtcclxuICAgICAgICAkKCc+IHVsJywgJG5vZGVpZCkuYmluZCgnc29ydHN0b3AnLCBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcbiAgICAgICAgICB2YXIgaWR4ID0gJCh1aS5pdGVtKS5kYXRhKCdpZHgnKTtcclxuICAgICAgICAgIHZhciBuZXdJZHggPSAkKHVpLml0ZW0pLmluZGV4KCk7XHJcbiAgICAgICAgICBtb3ZlTm9kZVRvKGlkeCwgbmV3SWR4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgJ3RhYmFycmF5Jzoge1xyXG4gICAgJ3RlbXBsYXRlJzogJzxkaXYgaWQ9XCI8JT0gaWQgJT5cIj48ZGl2IGNsYXNzPVwidGFiYmFibGUgdGFicy1sZWZ0XCI+JyArXHJcbiAgICAgICc8dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIj4nICtcclxuICAgICAgICAnPCU9IHRhYnMgJT4nICtcclxuICAgICAgJzwvdWw+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAnPCU9IGNoaWxkcmVuICU+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0biBfanNvbmZvcm0tYXJyYXktYWRkbW9yZVwiPjxpIGNsYXNzPVwiaWNvbi1wbHVzLXNpZ25cIiB0aXRsZT1cIkFkZCBuZXdcIj48L2k+PC9hPiAnICtcclxuICAgICAgJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG4gX2pzb25mb3JtLWFycmF5LWRlbGV0ZWl0ZW1cIj48aSBjbGFzcz1cImljb24tbWludXMtc2lnblwiIHRpdGxlPVwiRGVsZXRlIGl0ZW1cIj48L2k+PC9hPjwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnYXJyYXknOiB0cnVlLFxyXG4gICAgJ2NoaWxkVGVtcGxhdGUnOiBmdW5jdGlvbiAoaW5uZXIpIHtcclxuICAgICAgcmV0dXJuICc8ZGl2IGRhdGEtaWR4PVwiPCU9IG5vZGUuY2hpbGRQb3MgJT5cIiBjbGFzcz1cInRhYi1wYW5lXCI+JyArXHJcbiAgICAgICAgaW5uZXIgK1xyXG4gICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfSxcclxuICAgICdvbkJlZm9yZVJlbmRlcic6IGZ1bmN0aW9uIChkYXRhLCBub2RlKSB7XHJcbiAgICAgIC8vIEdlbmVyYXRlIHRoZSBpbml0aWFsICd0YWJzJyBmcm9tIHRoZSBjaGlsZHJlblxyXG4gICAgICB2YXIgdGFicyA9ICcnO1xyXG4gICAgICBfLmVhY2gobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcclxuICAgICAgICB2YXIgdGl0bGUgPSBjaGlsZC5sZWdlbmQgfHxcclxuICAgICAgICAgIGNoaWxkLnRpdGxlIHx8XHJcbiAgICAgICAgICAoJ0l0ZW0gJyArIChpZHgrMSkpO1xyXG4gICAgICAgIHRhYnMgKz0gJzxsaSBkYXRhLWlkeD1cIicgKyBpZHggKyAnXCInICtcclxuICAgICAgICAgICgoaWR4ID09PSAwKSA/ICcgY2xhc3M9XCJhY3RpdmVcIicgOiAnJykgK1xyXG4gICAgICAgICAgJz48YSBjbGFzcz1cImRyYWdnYWJsZSB0YWJcIiBkYXRhLXRvZ2dsZT1cInRhYlwiPicgK1xyXG4gICAgICAgICAgZXNjYXBlSFRNTCh0aXRsZSkgK1xyXG4gICAgICAgICAgJzwvYT48L2xpPic7XHJcbiAgICAgIH0pO1xyXG4gICAgICBkYXRhLnRhYnMgPSB0YWJzO1xyXG4gICAgfSxcclxuICAgICdvbkluc2VydCc6IGZ1bmN0aW9uIChldnQsIG5vZGUpIHtcclxuICAgICAgdmFyICRub2RlaWQgPSAkKG5vZGUuZWwpLmZpbmQoJyMnICsgZXNjYXBlU2VsZWN0b3Iobm9kZS5pZCkpO1xyXG4gICAgICB2YXIgYm91bmRhcmllcyA9IG5vZGUuZ2V0QXJyYXlCb3VuZGFyaWVzKCk7XHJcblxyXG4gICAgICB2YXIgbW92ZU5vZGVUbyA9IGZ1bmN0aW9uIChmcm9tSWR4LCB0b0lkeCkge1xyXG4gICAgICAgIC8vIE5vdGUgXCJzd2l0Y2hWYWx1ZXNXaXRoXCIgZXh0cmFjdHMgdmFsdWVzIGZyb20gdGhlIERPTSBzaW5jZSBmaWVsZFxyXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgbm90IHN5bmNocm9uaXplZCB3aXRoIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlLCBzbyBjYWxsc1xyXG4gICAgICAgIC8vIHRvIHJlbmRlciBhcmUgbmVlZGVkIGF0IGVhY2ggc3RlcCB0byBmb3JjZSB2YWx1ZXMgZG93biB0byB0aGUgRE9NXHJcbiAgICAgICAgLy8gYmVmb3JlIG5leHQgbW92ZS5cclxuICAgICAgICAvLyBUT0RPOiBzeW5jaHJvbml6ZSBmaWVsZCB2YWx1ZXMgYW5kIGRhdGEgc3RydWN0dXJlIGNvbXBsZXRlbHkgYW5kXHJcbiAgICAgICAgLy8gY2FsbCByZW5kZXIgb25seSBvbmNlIHRvIGltcHJvdmUgZWZmaWNpZW5jeS5cclxuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gdG9JZHgpIHJldHVybjtcclxuICAgICAgICB2YXIgaW5jciA9IChmcm9tSWR4IDwgdG9JZHgpID8gMTogLTE7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciB0YWJFbCA9ICQoJz4gLnRhYmJhYmxlID4gLnRhYi1jb250ZW50JywgJG5vZGVpZCkuZ2V0KDApO1xyXG4gICAgICAgIGZvciAoaSA9IGZyb21JZHg7IGkgIT09IHRvSWR4OyBpICs9IGluY3IpIHtcclxuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0uc3dpdGNoVmFsdWVzV2l0aChub2RlLmNoaWxkcmVuW2kgKyBpbmNyXSk7XHJcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLnJlbmRlcih0YWJFbCk7XHJcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2kgKyBpbmNyXS5yZW5kZXIodGFiRWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICAvLyBSZWZyZXNoZXMgdGhlIGxpc3Qgb2YgdGFic1xyXG4gICAgICB2YXIgdXBkYXRlVGFicyA9IGZ1bmN0aW9uIChzZWxJZHgpIHtcclxuICAgICAgICB2YXIgdGFicyA9ICcnO1xyXG4gICAgICAgIHZhciBhY3RpdmF0ZUZpcnN0VGFiID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHNlbElkeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBzZWxJZHggPSAkKCc+IC50YWJiYWJsZSA+IC5uYXYtdGFicyAuYWN0aXZlJywgJG5vZGVpZCkuZGF0YSgnaWR4Jyk7XHJcbiAgICAgICAgICBpZiAoc2VsSWR4KSB7XHJcbiAgICAgICAgICAgIHNlbElkeCA9IHBhcnNlSW50KHNlbElkeCwgMTApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFjdGl2YXRlRmlyc3RUYWIgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZWxJZHggPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsSWR4ID49IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxJZHggPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF8uZWFjaChub2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xyXG4gICAgICAgICAgdmFyIHRpdGxlID0gY2hpbGQubGVnZW5kIHx8XHJcbiAgICAgICAgICAgIGNoaWxkLnRpdGxlIHx8XHJcbiAgICAgICAgICAgICgnSXRlbSAnICsgKGlkeCsxKSk7XHJcbiAgICAgICAgICB0YWJzICs9ICc8bGkgZGF0YS1pZHg9XCInICsgaWR4ICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGEgY2xhc3M9XCJkcmFnZ2FibGUgdGFiXCIgZGF0YS10b2dnbGU9XCJ0YWJcIj4nICtcclxuICAgICAgICAgICAgZXNjYXBlSFRNTCh0aXRsZSkgK1xyXG4gICAgICAgICAgICAnPC9hPjwvbGk+JztcclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCc+IC50YWJiYWJsZSA+IC5uYXYtdGFicycsICRub2RlaWQpLmh0bWwodGFicyk7XHJcbiAgICAgICAgaWYgKGFjdGl2YXRlRmlyc3RUYWIpIHtcclxuICAgICAgICAgICQoJz4gLnRhYmJhYmxlID4gLm5hdi10YWJzIFtkYXRhLWlkeD1cIjBcIl0nLCAkbm9kZWlkKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoJz4gLnRhYmJhYmxlID4gLm5hdi10YWJzIFtkYXRhLXRvZ2dsZT1cInRhYlwiXScsICRub2RlaWQpLmVxKHNlbElkeCkuY2xpY2soKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgICQoJz4gYS5fanNvbmZvcm0tYXJyYXktZGVsZXRlaXRlbScsICRub2RlaWQpLmNsaWNrKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB2YXIgaWR4ID0gJCgnPiAudGFiYmFibGUgPiAubmF2LXRhYnMgLmFjdGl2ZScsICRub2RlaWQpLmRhdGEoJ2lkeCcpO1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpZiAoYm91bmRhcmllcy5taW5JdGVtcyA+IDApIHtcclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA8IGJvdW5kYXJpZXMubWluSXRlbXMgKyAxKSB7XHJcbiAgICAgICAgICAgICRub2RlaWQuZmluZCgnPiBhLl9qc29uZm9ybS1hcnJheS1kZWxldGVpdGVtJylcclxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPD0gYm91bmRhcmllcy5taW5JdGVtcykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmRlbGV0ZUFycmF5SXRlbShpZHgpO1xyXG4gICAgICAgIHVwZGF0ZVRhYnMoKTtcclxuICAgICAgICBpZiAoKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDwgYm91bmRhcmllcy5taW5JdGVtcyArIDEpIHx8XHJcbiAgICAgICAgICAgIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkpIHtcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiBhLl9qc29uZm9ybS1hcnJheS1kZWxldGVpdGVtJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoYm91bmRhcmllcy5tYXhJdGVtcyA+PSAwKSAmJlxyXG4gICAgICAgICAgICAobm9kZS5jaGlsZHJlbi5sZW5ndGggPD0gYm91bmRhcmllcy5tYXhJdGVtcykpIHtcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiBhLl9qc29uZm9ybS1hcnJheS1hZGRtb3JlJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoJz4gYS5fanNvbmZvcm0tYXJyYXktYWRkbW9yZScsICRub2RlaWQpLmNsaWNrKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB2YXIgaWR4ID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGJvdW5kYXJpZXMubWF4SXRlbXM+PTApIHtcclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aD5ib3VuZGFyaWVzLm1heEl0ZW1zLTIpIHtcclxuICAgICAgICAgICAgJCgnPiBhLl9qc29uZm9ybS1hcnJheS1hZGRtb3JlJywgJG5vZGVpZCkuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IGJvdW5kYXJpZXMubWF4SXRlbXMgLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIG5vZGUuaW5zZXJ0QXJyYXlJdGVtKGlkeCxcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiAudGFiYmFibGUgPiAudGFiLWNvbnRlbnQnKS5nZXQoMCkpO1xyXG4gICAgICAgIHVwZGF0ZVRhYnMoaWR4KTtcclxuICAgICAgICBpZiAoKGJvdW5kYXJpZXMubWluSXRlbXMgPD0gMCkgfHxcclxuICAgICAgICAgICAgKChib3VuZGFyaWVzLm1pbkl0ZW1zID4gMCkgJiYgKGlkeCA+IGJvdW5kYXJpZXMubWluSXRlbXMgLSAxKSkpIHtcclxuICAgICAgICAgICRub2RlaWQuZmluZCgnPiBhLl9qc29uZm9ybS1hcnJheS1kZWxldGVpdGVtJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQobm9kZS5lbCkub24oJ2xlZ2VuZFVwZGF0ZWQnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdXBkYXRlVGFicygpO1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoJChub2RlLmVsKS5zb3J0YWJsZSkge1xyXG4gICAgICAgICQoJz4gLnRhYmJhYmxlID4gLm5hdi10YWJzJywgJG5vZGVpZCkuc29ydGFibGUoe1xyXG4gICAgICAgICAgY29udGFpbm1lbnQ6IG5vZGUuZWwsXHJcbiAgICAgICAgICB0b2xlcmFuY2U6ICdwb2ludGVyJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQoJz4gLnRhYmJhYmxlID4gLm5hdi10YWJzJywgJG5vZGVpZCkuYmluZCgnc29ydHN0b3AnLCBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcbiAgICAgICAgICB2YXIgaWR4ID0gJCh1aS5pdGVtKS5kYXRhKCdpZHgnKTtcclxuICAgICAgICAgIHZhciBuZXdJZHggPSAkKHVpLml0ZW0pLmluZGV4KCk7XHJcbiAgICAgICAgICBtb3ZlTm9kZVRvKGlkeCwgbmV3SWR4KTtcclxuICAgICAgICAgIHVwZGF0ZVRhYnMobmV3SWR4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2ltdWxhdGUgVXNlcidzIGNsaWNrIHRvIHNldHVwIHRoZSBmb3JtIHdpdGggaXRzIG1pbkl0ZW1zXHJcbiAgICAgIGlmIChib3VuZGFyaWVzLm1pbkl0ZW1zID49IDApIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChib3VuZGFyaWVzLm1pbkl0ZW1zIC0gMSk7IGkrKykge1xyXG4gICAgICAgICAgJG5vZGVpZC5maW5kKCc+IGEuX2pzb25mb3JtLWFycmF5LWFkZG1vcmUnKS5jbGljaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkbm9kZWlkLmZpbmQoJz4gYS5fanNvbmZvcm0tYXJyYXktZGVsZXRlaXRlbScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIHVwZGF0ZVRhYnMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChib3VuZGFyaWVzLm1heEl0ZW1zID49IDApICYmXHJcbiAgICAgICAgICAobm9kZS5jaGlsZHJlbi5sZW5ndGggPj0gYm91bmRhcmllcy5tYXhJdGVtcykpIHtcclxuICAgICAgICAkbm9kZWlkLmZpbmQoJz4gYS5fanNvbmZvcm0tYXJyYXktYWRkbW9yZScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoYm91bmRhcmllcy5taW5JdGVtcyA+PSAwKSAmJlxyXG4gICAgICAgICAgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDw9IGJvdW5kYXJpZXMubWluSXRlbXMpKSB7XHJcbiAgICAgICAgJG5vZGVpZC5maW5kKCc+IGEuX2pzb25mb3JtLWFycmF5LWRlbGV0ZWl0ZW0nKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgJ2hlbHAnOntcclxuICAgICd0ZW1wbGF0ZSc6JzxzcGFuIGNsYXNzPVwiaGVscC1ibG9ja1wiIHN0eWxlPVwicGFkZGluZy10b3A6NXB4XCI+PCU9IGVsdC5oZWxwdmFsdWUgJT48L3NwYW4+JyxcclxuICAgICdmaWVsZHRlbXBsYXRlJzogdHJ1ZVxyXG4gIH0sXHJcbiAgJ21zZyc6IHtcclxuICAgICd0ZW1wbGF0ZSc6ICc8JT0gZWx0Lm1zZyAlPidcclxuICB9LFxyXG4gICdmaWVsZHNldCc6e1xyXG4gICAgJ3RlbXBsYXRlJzogJzxmaWVsZHNldCBjbGFzcz1cImNvbnRyb2wtZ3JvdXAganNvbmZvcm0tZXJyb3ItPCU9IGtleWRhc2ggJT4gPCUgaWYgKGVsdC5leHBhbmRhYmxlKSB7ICU+ZXhwYW5kYWJsZTwlIH0gJT4gPCU9IGVsdC5odG1sQ2xhc3M/ZWx0Lmh0bWxDbGFzczpcIlwiICU+XCIgJyArXHJcbiAgICAgICc8JSBpZiAoaWQpIHsgJT4gaWQ9XCI8JT0gaWQgJT5cIjwlIH0gJT4nICtcclxuICAgICAgJz4nICtcclxuICAgICAgJzwlIGlmIChub2RlLnRpdGxlIHx8IG5vZGUubGVnZW5kKSB7ICU+PGxlZ2VuZD48JT0gbm9kZS50aXRsZSB8fCBub2RlLmxlZ2VuZCAlPjwvbGVnZW5kPjwlIH0gJT4nICtcclxuICAgICAgJzwlIGlmIChlbHQuZXhwYW5kYWJsZSkgeyAlPjxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+PCUgfSAlPicgK1xyXG4gICAgICAnPCU9IGNoaWxkcmVuICU+JyArXHJcbiAgICAgICc8JSBpZiAoZWx0LmV4cGFuZGFibGUpIHsgJT48L2Rpdj48JSB9ICU+JyArXHJcbiAgICAgICc8L2ZpZWxkc2V0PidcclxuICB9LFxyXG4gICdhZHZhbmNlZGZpZWxkc2V0Jzoge1xyXG4gICAgJ3RlbXBsYXRlJzogJzxmaWVsZHNldCcgK1xyXG4gICAgICAnPCUgaWYgKGlkKSB7ICU+IGlkPVwiPCU9IGlkICU+XCI8JSB9ICU+JyArXHJcbiAgICAgICcgY2xhc3M9XCJleHBhbmRhYmxlIDwlPSBlbHQuaHRtbENsYXNzP2VsdC5odG1sQ2xhc3M6XCJcIiAlPlwiPicgK1xyXG4gICAgICAnPGxlZ2VuZD5BZHZhbmNlZCBvcHRpb25zPC9sZWdlbmQ+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPicgK1xyXG4gICAgICAnPCU9IGNoaWxkcmVuICU+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZmllbGRzZXQ+J1xyXG4gIH0sXHJcbiAgJ2F1dGhmaWVsZHNldCc6IHtcclxuICAgICd0ZW1wbGF0ZSc6ICc8ZmllbGRzZXQnICtcclxuICAgICAgJzwlIGlmIChpZCkgeyAlPiBpZD1cIjwlPSBpZCAlPlwiPCUgfSAlPicgK1xyXG4gICAgICAnIGNsYXNzPVwiZXhwYW5kYWJsZSA8JT0gZWx0Lmh0bWxDbGFzcz9lbHQuaHRtbENsYXNzOlwiXCIgJT5cIj4nICtcclxuICAgICAgJzxsZWdlbmQ+QXV0aGVudGljYXRpb24gc2V0dGluZ3M8L2xlZ2VuZD4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+JyArXHJcbiAgICAgICc8JT0gY2hpbGRyZW4gJT4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPC9maWVsZHNldD4nXHJcbiAgfSxcclxuICAnc3VibWl0Jzp7XHJcbiAgICAndGVtcGxhdGUnOic8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIDwlIGlmIChpZCkgeyAlPiBpZD1cIjwlPSBpZCAlPlwiIDwlIH0gJT4gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgPCU9IGVsdC5odG1sQ2xhc3M/ZWx0Lmh0bWxDbGFzczpcIlwiICU+XCIgdmFsdWU9XCI8JT0gdmFsdWUgfHwgbm9kZS50aXRsZSAlPlwiPCU9IChub2RlLmRpc2FibGVkPyBcIiBkaXNhYmxlZFwiIDogXCJcIiklPi8+J1xyXG4gIH0sXHJcbiAgJ2J1dHRvbic6e1xyXG4gICAgJ3RlbXBsYXRlJzonIDxidXR0b24gPCUgaWYgKGlkKSB7ICU+IGlkPVwiPCU9IGlkICU+XCIgPCUgfSAlPiBjbGFzcz1cImJ0biA8JT0gZWx0Lmh0bWxDbGFzcz9lbHQuaHRtbENsYXNzOlwiXCIgJT5cIj48JT0gbm9kZS50aXRsZSAlPjwvYnV0dG9uPiAnXHJcbiAgfSxcclxuICAnYWN0aW9ucyc6e1xyXG4gICAgJ3RlbXBsYXRlJzonPGRpdiBjbGFzcz1cImZvcm0tYWN0aW9ucyA8JT0gZWx0Lmh0bWxDbGFzcz9lbHQuaHRtbENsYXNzOlwiXCIgJT5cIj48JT0gY2hpbGRyZW4gJT48L2Rpdj4nXHJcbiAgfSxcclxuICAnaGlkZGVuJzp7XHJcbiAgICAndGVtcGxhdGUnOic8aW5wdXQgdHlwZT1cImhpZGRlblwiIGlkPVwiPCU9IGlkICU+XCIgbmFtZT1cIjwlPSBub2RlLm5hbWUgJT5cIiB2YWx1ZT1cIjwlPSBlc2NhcGUodmFsdWUpICU+XCIgLz4nLFxyXG4gICAgJ2lucHV0ZmllbGQnOiB0cnVlXHJcbiAgfSxcclxuICAnc2VsZWN0ZmllbGRzZXQnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGZpZWxkc2V0IGNsYXNzPVwidGFiLWNvbnRhaW5lciA8JT0gZWx0Lmh0bWxDbGFzcz9lbHQuaHRtbENsYXNzOlwiXCIgJT5cIj4nICtcclxuICAgICAgJzwlIGlmIChub2RlLmxlZ2VuZCkgeyAlPjxsZWdlbmQ+PCU9IG5vZGUubGVnZW5kICU+PC9sZWdlbmQ+PCUgfSAlPicgK1xyXG4gICAgICAnPCUgaWYgKG5vZGUuZm9ybUVsZW1lbnQua2V5KSB7ICU+PGlucHV0IHR5cGU9XCJoaWRkZW5cIiBpZD1cIjwlPSBub2RlLmlkICU+XCIgbmFtZT1cIjwlPSBub2RlLm5hbWUgJT5cIiB2YWx1ZT1cIjwlPSBlc2NhcGUodmFsdWUpICU+XCIgLz48JSB9IGVsc2UgeyAlPicgK1xyXG4gICAgICAgICc8YSBpZD1cIjwlPSBub2RlLmlkICU+XCI+PC9hPjwlIH0gJT4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJ0YWJiYWJsZVwiPicgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cDwlPSBub2RlLmZvcm1FbGVtZW50LmhpZGVNZW51ID8gXCIgaGlkZVwiIDogXCJcIiAlPlwiPicgK1xyXG4gICAgICAgICAgJzwlIGlmIChub2RlLnRpdGxlICYmICFlbHQubm90aXRsZSkgeyAlPjxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBmb3I9XCI8JT0gbm9kZS5pZCAlPlwiPjwlPSBub2RlLnRpdGxlICU+PC9sYWJlbD48JSB9ICU+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbnRyb2xzXCI+PCU9IHRhYnMgJT48L2Rpdj4nICtcclxuICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ0YWItY29udGVudFwiPicgK1xyXG4gICAgICAgICAgJzwlPSBjaGlsZHJlbiAlPicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPC9maWVsZHNldD4nLFxyXG4gICAgJ2lucHV0ZmllbGQnOiB0cnVlLFxyXG4gICAgJ2dldEVsZW1lbnQnOiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgcmV0dXJuICQoZWwpLnBhcmVudCgpLmdldCgwKTtcclxuICAgIH0sXHJcbiAgICAnY2hpbGRUZW1wbGF0ZSc6IGZ1bmN0aW9uIChpbm5lcikge1xyXG4gICAgICByZXR1cm4gJzxkaXYgZGF0YS1pZHg9XCI8JT0gbm9kZS5jaGlsZFBvcyAlPlwiIGNsYXNzPVwidGFiLXBhbmUnICtcclxuICAgICAgICAnPCUgaWYgKG5vZGUuYWN0aXZlKSB7ICU+IGFjdGl2ZTwlIH0gJT5cIj4nICtcclxuICAgICAgICBpbm5lciArXHJcbiAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9LFxyXG4gICAgJ29uQmVmb3JlUmVuZGVyJzogZnVuY3Rpb24gKGRhdGEsIG5vZGUpIHtcclxuICAgICAgLy8gQmVmb3JlIHJlbmRlcmluZywgdGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQ6XHJcbiAgICAgIC8vIDEuIGRpcmVjdCBjaGlsZHJlbiBoYXZlIElEcyAodXNlZCB0byBzaG93L2hpZGUgdGhlIHRhYnMgY29udGVudHMpXHJcbiAgICAgIC8vIDIuIHRoZSB0YWIgdG8gYWN0aXZlIGlzIGZsYWdnZWQgYWNjb3JkaW5nbHkuIFRoZSBhY3RpdmUgdGFiIGlzXHJcbiAgICAgIC8vIHRoZSBmaXJzdCBvbmUsIGV4Y2VwdCBpZiBmb3JtIHZhbHVlcyBhcmUgYXZhaWxhYmxlLCBpbiB3aGljaCBjYXNlXHJcbiAgICAgIC8vIGl0J3MgdGhlIGZpcnN0IHRhYiBmb3Igd2hpY2ggdGhlcmUgaXMgc29tZSB2YWx1ZSBhdmFpbGFibGUgKG9yIGJhY2tcclxuICAgICAgLy8gdG8gdGhlIGZpcnN0IG9uZSBpZiB0aGVyZSBhcmUgbm9uZSlcclxuICAgICAgLy8gMy4gdGhlIEhUTUwgb2YgdGhlIHNlbGVjdCBmaWVsZCB1c2VkIHRvIHNlbGVjdCB0YWJzIGlzIGV4cG9zZWQgaW4gdGhlXHJcbiAgICAgIC8vIEhUTUwgdGVtcGxhdGUgZGF0YSBhcyBcInRhYnNcIlxyXG5cclxuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgdmFyIGNob2ljZXMgPSBbXTtcclxuICAgICAgaWYgKG5vZGUuc2NoZW1hRWxlbWVudCkge1xyXG4gICAgICAgIGNob2ljZXMgPSBub2RlLnNjaGVtYUVsZW1lbnRbJ2VudW0nXSB8fCBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobm9kZS5vcHRpb25zKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBfLm1hcChub2RlLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24sIGlkeCkge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpZHhdO1xyXG4gICAgICAgICAgaWYgKG9wdGlvbiBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG4gICAgICAgICAgICBvcHRpb24gPSBfLmV4dGVuZCh7IG5vZGU6IGNoaWxkIH0sIG9wdGlvbik7XHJcbiAgICAgICAgICAgIG9wdGlvbi50aXRsZSA9IG9wdGlvbi50aXRsZSB8fFxyXG4gICAgICAgICAgICAgIGNoaWxkLmxlZ2VuZCB8fFxyXG4gICAgICAgICAgICAgIGNoaWxkLnRpdGxlIHx8XHJcbiAgICAgICAgICAgICAgKCdPcHRpb24gJyArIChjaGlsZC5jaGlsZFBvcysxKSk7XHJcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IGlzU2V0KG9wdGlvbi52YWx1ZSkgPyBvcHRpb24udmFsdWUgOlxyXG4gICAgICAgICAgICAgIGlzU2V0KGNob2ljZXNbaWR4XSkgPyBjaG9pY2VzW2lkeF0gOiBpZHg7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICB0aXRsZTogb3B0aW9uLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBpc1NldChjaG9pY2VzW2NoaWxkLmNoaWxkUG9zXSkgP1xyXG4gICAgICAgICAgICAgICAgY2hvaWNlc1tjaGlsZC5jaGlsZFBvc10gOlxyXG4gICAgICAgICAgICAgICAgY2hpbGQuY2hpbGRQb3MsXHJcbiAgICAgICAgICAgICAgbm9kZTogY2hpbGRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjaGlsZHJlbiA9IF8ubWFwKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZTogY2hpbGQubGVnZW5kIHx8IGNoaWxkLnRpdGxlIHx8ICgnT3B0aW9uICcgKyAoY2hpbGQuY2hpbGRQb3MrMSkpLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2hvaWNlc1tjaGlsZC5jaGlsZFBvc10gfHwgY2hpbGQuY2hpbGRQb3MsXHJcbiAgICAgICAgICAgIG5vZGU6IGNoaWxkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWN0aXZlQ2hpbGQgPSBudWxsO1xyXG4gICAgICBpZiAoZGF0YS52YWx1ZSkge1xyXG4gICAgICAgIGFjdGl2ZUNoaWxkID0gXy5maW5kKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgIHJldHVybiAoY2hpbGQudmFsdWUgPT09IG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYWN0aXZlQ2hpbGQpIHtcclxuICAgICAgICBhY3RpdmVDaGlsZCA9IF8uZmluZChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZS5oYXNOb25EZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWFjdGl2ZUNoaWxkKSB7XHJcbiAgICAgICAgYWN0aXZlQ2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgfVxyXG4gICAgICBhY3RpdmVDaGlsZC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgIGRhdGEudmFsdWUgPSBhY3RpdmVDaGlsZC52YWx1ZTtcclxuXHJcbiAgICAgIHZhciBlbHQgPSBub2RlLmZvcm1FbGVtZW50O1xyXG4gICAgICB2YXIgdGFicyA9ICc8c2VsZWN0IGNsYXNzPVwibmF2XCInICtcclxuICAgICAgICAobm9kZS5kaXNhYmxlZCA/ICcgZGlzYWJsZWQnIDogJycpICtcclxuICAgICAgICAnPic7XHJcbiAgICAgIF8uZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcclxuICAgICAgICB0YWJzICs9ICc8b3B0aW9uIGRhdGEtaWR4PVwiJyArIGlkeCArICdcIiB2YWx1ZT1cIicgKyBjaGlsZC52YWx1ZSArICdcIicgK1xyXG4gICAgICAgICAgKGNoaWxkLm5vZGUuYWN0aXZlID8gJyBjbGFzcz1cImFjdGl2ZVwiJyA6ICcnKSArXHJcbiAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgZXNjYXBlSFRNTChjaGlsZC50aXRsZSkgK1xyXG4gICAgICAgICAgJzwvb3B0aW9uPic7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0YWJzICs9ICc8L3NlbGVjdD4nO1xyXG5cclxuICAgICAgZGF0YS50YWJzID0gdGFicztcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG4gICAgJ29uSW5zZXJ0JzogZnVuY3Rpb24gKGV2dCwgbm9kZSkge1xyXG4gICAgICAkKG5vZGUuZWwpLmZpbmQoJ3NlbGVjdC5uYXYnKS5maXJzdCgpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyICRvcHRpb24gPSAkKHRoaXMpLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO1xyXG4gICAgICAgICQobm9kZS5lbCkuZmluZCgnaW5wdXRbdHlwZT1cImhpZGRlblwiXScpLmZpcnN0KCkudmFsKCRvcHRpb24uYXR0cigndmFsdWUnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgJ29wdGlvbmZpZWxkc2V0Jzoge1xyXG4gICAgJ3RlbXBsYXRlJzogJzxkaXYnICtcclxuICAgICAgJzwlIGlmIChub2RlLmlkKSB7ICU+IGlkPVwiPCU9IG5vZGUuaWQgJT5cIjwlIH0gJT4nICtcclxuICAgICAgJz4nICtcclxuICAgICAgJzwlPSBjaGlsZHJlbiAlPicgK1xyXG4gICAgICAnPC9kaXY+J1xyXG4gIH0sXHJcbiAgJ3NlY3Rpb24nOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGRpdicgK1xyXG4gICAgICAnPCUgaWYgKG5vZGUuaWQpIHsgJT4gaWQ9XCI8JT0gbm9kZS5pZCAlPlwiPCUgfSAlPicgK1xyXG4gICAgICAnPjwlPSBjaGlsZHJlbiAlPjwvZGl2PidcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBIFwicXVlc3Rpb25zXCIgZmllbGQgcmVuZGVycyBhIHNlcmllcyBvZiBxdWVzdGlvbiBmaWVsZHMgYW5kIGJpbmRzIHRoZVxyXG4gICAqIHJlc3VsdCB0byB0aGUgdmFsdWUgb2YgYSBzY2hlbWEga2V5LlxyXG4gICAqL1xyXG4gICdxdWVzdGlvbnMnOiB7XHJcbiAgICAndGVtcGxhdGUnOiAnPGRpdj4nICtcclxuICAgICAgJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgaWQ9XCI8JT0gbm9kZS5pZCAlPlwiIG5hbWU9XCI8JT0gbm9kZS5uYW1lICU+XCIgdmFsdWU9XCI8JT0gZXNjYXBlKHZhbHVlKSAlPlwiIC8+JyArXHJcbiAgICAgICc8JT0gY2hpbGRyZW4gJT4nICtcclxuICAgICAgJzwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wYXRlJzogdHJ1ZSxcclxuICAgICdpbnB1dGZpZWxkJzogdHJ1ZSxcclxuICAgICdnZXRFbGVtZW50JzogZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIHJldHVybiAkKGVsKS5wYXJlbnQoKS5nZXQoMCk7XHJcbiAgICB9LFxyXG4gICAgJ29uSW5zZXJ0JzogZnVuY3Rpb24gKGV2dCwgbm9kZSkge1xyXG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkgcmV0dXJuO1xyXG4gICAgICBfLmVhY2gobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgJChjaGlsZC5lbCkuaGlkZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgJChub2RlLmNoaWxkcmVuWzBdLmVsKS5zaG93KCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQSBcInF1ZXN0aW9uXCIgZmllbGQgbGV0cyB1c2VyIGNob29zZSBhIHJlc3BvbnNlIGFtb25nIHBvc3NpYmxlIGNob2ljZXMuXHJcbiAgICogVGhlIGZpZWxkIGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IHNjaGVtYSBrZXkuIEEgcXVlc3Rpb24gc2hvdWxkIGJlXHJcbiAgICogcGFydCBvZiBhIFwicXVlc3Rpb25zXCIgZmllbGQgdGhhdCBiaW5kcyBhIHNlcmllcyBvZiBxdWVzdGlvbnMgdG8gYVxyXG4gICAqIHNjaGVtYSBrZXkuXHJcbiAgICovXHJcbiAgJ3F1ZXN0aW9uJzoge1xyXG4gICAgJ3RlbXBsYXRlJzogJzxkaXYgaWQ9XCI8JT0gbm9kZS5pZCAlPlwiPjwlIF8uZWFjaChub2RlLm9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsKSB7ICU+PGxhYmVsIGNsYXNzPVwicmFkaW88JT0gKG5vZGUuZm9ybUVsZW1lbnQub3B0aW9uc1R5cGUgPT09IFwicmFkaW9idXR0b25zXCIpID8gXCIgYnRuXCIgOiBcIlwiICU+PCU9ICgoa2V5IGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleS5odG1sQ2xhc3MpID8gXCIgXCIgKyBrZXkuaHRtbENsYXNzIDogXCJcIikgJT5cIj48aW5wdXQgdHlwZT1cInJhZGlvXCIgPCUgaWYgKG5vZGUuZm9ybUVsZW1lbnQub3B0aW9uc1R5cGUgPT09IFwicmFkaW9idXR0b25zXCIpIHsgJT4gc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5cHg7XCIgPCUgfSAlPm5hbWU9XCI8JT0gbm9kZS5pZCAlPlwiIHZhbHVlPVwiPCU9IHZhbCAlPlwiPCU9IChub2RlLmRpc2FibGVkPyBcIiBkaXNhYmxlZFwiIDogXCJcIiklPi8+PHNwYW4+PCU9IChrZXkgaW5zdGFuY2VvZiBPYmplY3QgPyBrZXkudGl0bGUgOiBrZXkpICU+PC9zcGFuPjwvbGFiZWw+IDwlIH0pOyAlPjwvZGl2PicsXHJcbiAgICAnZmllbGR0ZW1wbGF0ZSc6IHRydWUsXHJcbiAgICAnb25JbnNlcnQnOiBmdW5jdGlvbiAoZXZ0LCBub2RlKSB7XHJcbiAgICAgIHZhciBhY3RpdmVDbGFzcyA9ICdhY3RpdmUnO1xyXG4gICAgICB2YXIgZWx0ID0gbm9kZS5mb3JtRWxlbWVudCB8fCB7fTtcclxuICAgICAgaWYgKGVsdC5hY3RpdmVDbGFzcykge1xyXG4gICAgICAgIGFjdGl2ZUNsYXNzICs9ICcgJyArIGVsdC5hY3RpdmVDbGFzcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQmluZCB0byBjaGFuZ2UgZXZlbnRzIG9uIHJhZGlvIGJ1dHRvbnNcclxuICAgICAgJChub2RlLmVsKS5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHZhciBxdWVzdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgIHZhciBvcHRpb24gPSBub2RlLm9wdGlvbnNbJCh0aGlzKS52YWwoKV07XHJcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudE5vZGUgfHwgIW5vZGUucGFyZW50Tm9kZS5lbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAkKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJ2xhYmVsJykucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICQobm9kZS5lbCkubmV4dEFsbCgpLmhpZGUoKTtcclxuICAgICAgICAkKG5vZGUuZWwpLm5leHRBbGwoKS5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBFeGVjdXRlIHBvc3NpYmxlIGFjdGlvbnMgKHNldCBrZXkgdmFsdWUsIGZvcm0gc3VibWlzc2lvbiwgb3BlbiBsaW5rLFxyXG4gICAgICAgIC8vIG1vdmUgb24gdG8gbmV4dCBxdWVzdGlvbilcclxuICAgICAgICBpZiAob3B0aW9uLnZhbHVlKSB7XHJcbiAgICAgICAgICAvLyBTZXQgdGhlIGtleSBvZiB0aGUgJ1F1ZXN0aW9ucycgcGFyZW50XHJcbiAgICAgICAgICAkKG5vZGUucGFyZW50Tm9kZS5lbCkuZmluZCgnaW5wdXRbdHlwZT1cImhpZGRlblwiXScpLnZhbChvcHRpb24udmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uLm5leHQpIHtcclxuICAgICAgICAgIHF1ZXN0aW9uTm9kZSA9IF8uZmluZChub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNoaWxkLmZvcm1FbGVtZW50ICYmIChjaGlsZC5mb3JtRWxlbWVudC5xaWQgPT09IG9wdGlvbi5uZXh0KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgICQocXVlc3Rpb25Ob2RlLmVsKS5zaG93KCk7XHJcbiAgICAgICAgICAkKHF1ZXN0aW9uTm9kZS5lbCkubmV4dEFsbCgpLmhpZGUoKTtcclxuICAgICAgICAgICQocXVlc3Rpb25Ob2RlLmVsKS5uZXh0QWxsKCkuZmluZCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbi5ocmVmKSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9uLnRhcmdldCkge1xyXG4gICAgICAgICAgICB3aW5kb3cub3BlbihvcHRpb24uaHJlZiwgb3B0aW9uLnRhcmdldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gb3B0aW9uLmhyZWY7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb24uc3VibWl0KSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm9kZS5vd25lclRyZWUuc3VibWl0KCk7XHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vL0FsbG93IHRvIGFjY2VzcyBzdWJwcm9wZXJ0aWVzIGJ5IHNwbGl0dGluZyBcIi5cIlxyXG4vKipcclxuICogUmV0cmlldmVzIHRoZSBrZXkgaWRlbnRpZmllZCBieSBhIHBhdGggc2VsZWN0b3IgaW4gdGhlIHN0cnVjdHVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBMZXZlbHMgaW4gdGhlIHBhdGggYXJlIHNlcGFyYXRlZCBieSBhIGRvdC4gQXJyYXkgaXRlbXMgYXJlIG1hcmtlZFxyXG4gKiB3aXRoIFt4XS4gRm9yIGluc3RhbmNlOlxyXG4gKiAgZm9vLmJhclszXS5iYXpcclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogU3RydWN0dXJlZCBvYmplY3QgdG8gcGFyc2VcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBQYXRoIHRvIHRoZSBrZXkgdG8gcmV0cmlldmVcclxuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVBcnJheXMgVHJ1ZSB0byB1c2UgZmlyc3QgZWxlbWVudCBpbiBhbiBhcnJheSB3aGVuXHJcbiAqICAgc3R1Y2tlZCBvbiBhIHByb3BlcnR5LiBUaGlzIHBhcmFtZXRlciBpcyBiYXNpY2FsbHkgb25seSB1c2VmdWwgd2hlblxyXG4gKiAgIHBhcnNpbmcgYSBKU09OIHNjaGVtYSBmb3Igd2hpY2ggdGhlIFwiaXRlbXNcIiBwcm9wZXJ0eSBtYXkgZWl0aGVyIGJlIGFuXHJcbiAqICAgb2JqZWN0IG9yIGFuIGFycmF5IHdpdGggb25lIG9iamVjdCAob25seSBvbmUgYmVjYXVzZSBKU09OIGZvcm0gZG9lcyBub3RcclxuICogICBzdXBwb3J0IG1peCBvZiBpdGVtcyBmb3IgYXJyYXlzKS5cclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUga2V5J3MgdmFsdWUuXHJcbiAqL1xyXG5qc29uZm9ybS51dGlsLmdldE9iaktleSA9IGZ1bmN0aW9uIChvYmosIGtleSwgaWdub3JlQXJyYXlzKSB7XHJcbiAgdmFyIGlubmVyb2JqID0gb2JqO1xyXG4gIHZhciBrZXlwYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XHJcbiAgdmFyIHN1YmtleSA9IG51bGw7XHJcbiAgdmFyIGFycmF5TWF0Y2ggPSBudWxsO1xyXG4gIHZhciBwcm9wID0gbnVsbDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKChpbm5lcm9iaiA9PT0gbnVsbCkgfHwgKHR5cGVvZiBpbm5lcm9iaiAhPT0gXCJvYmplY3RcIikpIHJldHVybiBudWxsO1xyXG4gICAgc3Via2V5ID0ga2V5cGFydHNbaV07XHJcbiAgICBwcm9wID0gc3Via2V5LnJlcGxhY2UocmVBcnJheSwgJycpO1xyXG4gICAgcmVBcnJheS5sYXN0SW5kZXggPSAwO1xyXG4gICAgYXJyYXlNYXRjaCA9IHJlQXJyYXkuZXhlYyhzdWJrZXkpO1xyXG4gICAgaWYgKGFycmF5TWF0Y2gpIHtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoIV8uaXNBcnJheShpbm5lcm9ialtwcm9wXSkpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlubmVyb2JqID0gaW5uZXJvYmpbcHJvcF1bcGFyc2VJbnQoYXJyYXlNYXRjaFsxXSwgMTApXTtcclxuICAgICAgICBhcnJheU1hdGNoID0gcmVBcnJheS5leGVjKHN1YmtleSk7XHJcbiAgICAgICAgaWYgKCFhcnJheU1hdGNoKSBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaWdub3JlQXJyYXlzICYmXHJcbiAgICAgICAgIWlubmVyb2JqW3Byb3BdICYmXHJcbiAgICAgICAgXy5pc0FycmF5KGlubmVyb2JqKSAmJlxyXG4gICAgICAgIGlubmVyb2JqWzBdKSB7XHJcbiAgICAgIGlubmVyb2JqID0gaW5uZXJvYmpbMF1bcHJvcF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaW5uZXJvYmogPSBpbm5lcm9ialtwcm9wXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpZ25vcmVBcnJheXMgJiYgXy5pc0FycmF5KGlubmVyb2JqKSAmJiBpbm5lcm9ialswXSkge1xyXG4gICAgcmV0dXJuIGlubmVyb2JqWzBdO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHJldHVybiBpbm5lcm9iajtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGtleSBpZGVudGlmaWVkIGJ5IGEgcGF0aCBzZWxlY3RvciB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIExldmVscyBpbiB0aGUgcGF0aCBhcmUgc2VwYXJhdGVkIGJ5IGEgZG90LiBBcnJheSBpdGVtcyBhcmUgbWFya2VkXHJcbiAqIHdpdGggW3hdLiBGb3IgaW5zdGFuY2U6XHJcbiAqICBmb28uYmFyWzNdLmJhelxyXG4gKlxyXG4gKiBUaGUgaGllcmFyY2h5IGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdCB5ZXQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gYnVpbGRcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgcGF0aCB0byB0aGUga2V5IHRvIHNldCB3aGVyZSBlYWNoIGxldmVsXHJcbiAqICBpcyBzZXBhcmF0ZWQgYnkgYSBkb3QsIGFuZCBhcnJheSBpdGVtcyBhcmUgZmxhZ2dlZCB3aXRoIFt4XS5cclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQsIG1heSBiZSBvZiBhbnkgdHlwZS5cclxuICovXHJcbmpzb25mb3JtLnV0aWwuc2V0T2JqS2V5ID0gZnVuY3Rpb24ob2JqLGtleSx2YWx1ZSkge1xyXG4gIHZhciBpbm5lcm9iaiA9IG9iajtcclxuICB2YXIga2V5cGFydHMgPSBrZXkuc3BsaXQoXCIuXCIpO1xyXG4gIHZhciBzdWJrZXkgPSBudWxsO1xyXG4gIHZhciBhcnJheU1hdGNoID0gbnVsbDtcclxuICB2YXIgcHJvcCA9IG51bGw7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cGFydHMubGVuZ3RoLTE7IGkrKykge1xyXG4gICAgc3Via2V5ID0ga2V5cGFydHNbaV07XHJcbiAgICBwcm9wID0gc3Via2V5LnJlcGxhY2UocmVBcnJheSwgJycpO1xyXG4gICAgcmVBcnJheS5sYXN0SW5kZXggPSAwO1xyXG4gICAgYXJyYXlNYXRjaCA9IHJlQXJyYXkuZXhlYyhzdWJrZXkpO1xyXG4gICAgaWYgKGFycmF5TWF0Y2gpIHtcclxuICAgICAgLy8gU3Via2V5IGlzIHBhcnQgb2YgYW4gYXJyYXlcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoIV8uaXNBcnJheShpbm5lcm9ialtwcm9wXSkpIHtcclxuICAgICAgICAgIGlubmVyb2JqW3Byb3BdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlubmVyb2JqID0gaW5uZXJvYmpbcHJvcF07XHJcbiAgICAgICAgcHJvcCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICBhcnJheU1hdGNoID0gcmVBcnJheS5leGVjKHN1YmtleSk7XHJcbiAgICAgICAgaWYgKCFhcnJheU1hdGNoKSBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHR5cGVvZiBpbm5lcm9ialtwcm9wXSAhPT0gJ29iamVjdCcpIHx8XHJcbiAgICAgICAgKGlubmVyb2JqW3Byb3BdID09PSBudWxsKSkge1xyXG4gICAgICAgIGlubmVyb2JqW3Byb3BdID0ge307XHJcbiAgICAgIH1cclxuICAgICAgaW5uZXJvYmogPSBpbm5lcm9ialtwcm9wXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBcIk5vcm1hbFwiIHN1YmtleVxyXG4gICAgICBpZiAoKHR5cGVvZiBpbm5lcm9ialtwcm9wXSAhPT0gJ29iamVjdCcpIHx8XHJcbiAgICAgICAgKGlubmVyb2JqW3Byb3BdID09PSBudWxsKSkge1xyXG4gICAgICAgIGlubmVyb2JqW3Byb3BdID0ge307XHJcbiAgICAgIH1cclxuICAgICAgaW5uZXJvYmogPSBpbm5lcm9ialtwcm9wXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNldCB0aGUgZmluYWwgdmFsdWVcclxuICBzdWJrZXkgPSBrZXlwYXJ0c1trZXlwYXJ0cy5sZW5ndGggLSAxXTtcclxuICBwcm9wID0gc3Via2V5LnJlcGxhY2UocmVBcnJheSwgJycpO1xyXG4gIHJlQXJyYXkubGFzdEluZGV4ID0gMDtcclxuICBhcnJheU1hdGNoID0gcmVBcnJheS5leGVjKHN1YmtleSk7XHJcbiAgaWYgKGFycmF5TWF0Y2gpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGlmICghXy5pc0FycmF5KGlubmVyb2JqW3Byb3BdKSkge1xyXG4gICAgICAgIGlubmVyb2JqW3Byb3BdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgaW5uZXJvYmogPSBpbm5lcm9ialtwcm9wXTtcclxuICAgICAgcHJvcCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMV0sIDEwKTtcclxuICAgICAgYXJyYXlNYXRjaCA9IHJlQXJyYXkuZXhlYyhzdWJrZXkpO1xyXG4gICAgICBpZiAoIWFycmF5TWF0Y2gpIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaW5uZXJvYmpbcHJvcF0gPSB2YWx1ZTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBpbm5lcm9ialtwcm9wXSA9IHZhbHVlO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIHRoZSBrZXkgZGVmaW5pdGlvbiBmcm9tIHRoZSBnaXZlbiBzY2hlbWEuXHJcbiAqXHJcbiAqIFRoZSBrZXkgaXMgaWRlbnRpZmllZCBieSB0aGUgcGF0aCB0aGF0IGxlYWRzIHRvIHRoZSBrZXkgaW4gdGhlXHJcbiAqIHN0cnVjdHVyZWQgb2JqZWN0IHRoYXQgdGhlIHNjaGVtYSB3b3VsZCBnZW5lcmF0ZS4gRWFjaCBsZXZlbCBpc1xyXG4gKiBzZXBhcmF0ZWQgYnkgYSAnLicuIEFycmF5IGxldmVscyBhcmUgbWFya2VkIHdpdGggW10uIEZvciBpbnN0YW5jZTpcclxuICogIGZvby5iYXJbXS5iYXpcclxuICogLi4uIHRvIHJldHJpZXZlIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBrZXkgYXQgdGhlIGZvbGxvd2luZyBsb2NhdGlvblxyXG4gKiBpbiB0aGUgSlNPTiBzY2hlbWEgKHVzaW5nIGEgZG90dGVkIHBhdGggbm90YXRpb24pOlxyXG4gKiAgZm9vLnByb3BlcnRpZXMuYmFyLml0ZW1zLnByb3BlcnRpZXMuYmF6XHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hIFRoZSBKU09OIHNjaGVtYSB0byByZXRyaWV2ZSB0aGUga2V5IGZyb21cclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgcGF0aCB0byB0aGUga2V5LCBlYWNoIGxldmVsIGJlaW5nIHNlcGFyYXRlZFxyXG4gKiAgYnkgYSBkb3QgYW5kIGFycmF5IGl0ZW1zIGJlaW5nIGZsYWdnZWQgd2l0aCBbXS5cclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUga2V5IGRlZmluaXRpb24gaW4gdGhlIHNjaGVtYSwgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG52YXIgZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24oc2NoZW1hLGtleSkge1xyXG4gIHZhciBzY2hlbWFLZXkgPSBrZXlcclxuICAgIC5yZXBsYWNlKC9cXC4vZywgJy5wcm9wZXJ0aWVzLicpXHJcbiAgICAucmVwbGFjZSgvXFxbWzAtOV0qXFxdL2csICcuaXRlbXMnKTtcclxuICB2YXIgc2NoZW1hRGVmID0ganNvbmZvcm0udXRpbC5nZXRPYmpLZXkoc2NoZW1hLCBzY2hlbWFLZXksIHRydWUpO1xyXG4gIGlmIChzY2hlbWFEZWYgJiYgc2NoZW1hRGVmLiRyZWYpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSlNPTkZvcm0gZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NoZW1hcyB0aGF0IHVzZSB0aGUgJyArXHJcbiAgICAgICckcmVmIGtleXdvcmQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pvc2hmaXJlL2pzb25mb3JtL2lzc3Vlcy81NCcpO1xyXG4gIH1cclxuICByZXR1cm4gc2NoZW1hRGVmO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUcnVuY2F0ZXMgdGhlIGtleSBwYXRoIHRvIHRoZSByZXF1ZXN0ZWQgZGVwdGguXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgaWYgdGhlIGtleSBwYXRoIGlzOlxyXG4gKiAgZm9vLmJhcltdLmJhei50b3RvW10udHJ1Y1tdLmJpZHVsZVxyXG4gKiBhbmQgdGhlIHJlcXVlc3RlZCBkZXB0aCBpcyAxLCB0aGUgcmV0dXJuZWQga2V5IHdpbGwgYmU6XHJcbiAqICBmb28uYmFyW10uYmF6LnRvdG9cclxuICpcclxuICogTm90ZSB0aGUgZnVuY3Rpb24gaW5jbHVkZXMgdGhlIHBhdGggdXAgdG8gdGhlIG5leHQgZGVwdGggbGV2ZWwuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBwYXRoIHRvIHRoZSBrZXkgaW4gdGhlIHNjaGVtYSwgZWFjaCBsZXZlbCBiZWluZ1xyXG4gKiAgc2VwYXJhdGVkIGJ5IGEgZG90IGFuZCBhcnJheSBpdGVtcyBiZWluZyBmbGFnZ2VkIHdpdGggW10uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBUaGUgYXJyYXkgZGVwdGhcclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGF0aCB0byB0aGUga2V5IHRydW5jYXRlZCB0byB0aGUgZ2l2ZW4gZGVwdGguXHJcbiAqL1xyXG52YXIgdHJ1bmNhdGVUb0FycmF5RGVwdGggPSBmdW5jdGlvbiAoa2V5LCBhcnJheURlcHRoKSB7XHJcbiAgdmFyIGRlcHRoID0gMDtcclxuICB2YXIgcG9zID0gMDtcclxuICBpZiAoIWtleSkgcmV0dXJuIG51bGw7XHJcblxyXG4gIGlmIChhcnJheURlcHRoID4gMCkge1xyXG4gICAgd2hpbGUgKGRlcHRoIDwgYXJyYXlEZXB0aCkge1xyXG4gICAgICBwb3MgPSBrZXkuaW5kZXhPZignW10nLCBwb3MpO1xyXG4gICAgICBpZiAocG9zID09PSAtMSkge1xyXG4gICAgICAgIC8vIEtleSBwYXRoIGlzIG5vdCBcImRlZXBcIiBlbm91Z2gsIHNpbXBseSByZXR1cm4gdGhlIGZ1bGwga2V5XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgfVxyXG4gICAgICBwb3MgPSBwb3MgKyAyO1xyXG4gICAgICBkZXB0aCArPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBvbmUgc3RlcCBmdXJ0aGVyIHRvIHRoZSByaWdodCB3aXRob3V0IGluY2x1ZGluZyB0aGUgZmluYWwgW11cclxuICBwb3MgPSBrZXkuaW5kZXhPZignW10nLCBwb3MpO1xyXG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm4ga2V5O1xyXG4gIGVsc2UgcmV0dXJuIGtleS5zdWJzdHJpbmcoMCwgcG9zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBhcnJheSBwYXRoIHRvIHRoZSBrZXkgcGF0aC5cclxuICpcclxuICogRm9yIGluc3RhbmNlLCBpZiB0aGUga2V5IHBhdGggaXM6XHJcbiAqICBmb28uYmFyW10uYmF6LnRvdG9bXS50cnVjW10uYmlkdWxlXHJcbiAqIGFuZCB0aGUgYXJyYXlQYXRoIFs0LCAyXSwgdGhlIHJldHVybmVkIGtleSB3aWxsIGJlOlxyXG4gKiAgZm9vLmJhcls0XS5iYXoudG90b1syXS50cnVjW10uYmlkdWxlXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBwYXRoIHRvIHRoZSBrZXkgaW4gdGhlIHNjaGVtYSwgZWFjaCBsZXZlbCBiZWluZ1xyXG4gKiAgc2VwYXJhdGVkIGJ5IGEgZG90IGFuZCBhcnJheSBpdGVtcyBiZWluZyBmbGFnZ2VkIHdpdGggW10uXHJcbiAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gYXJyYXlQYXRoIFRoZSBhcnJheSBwYXRoIHRvIGFwcGx5LCBlLmcuIFs0LCAyXVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBrZXkgdGhhdCBtYXRjaGVzIHRoZSBhcnJheSBwYXRoLlxyXG4gKi9cclxudmFyIGFwcGx5QXJyYXlQYXRoID0gZnVuY3Rpb24gKGtleSwgYXJyYXlQYXRoKSB7XHJcbiAgdmFyIGRlcHRoID0gMDtcclxuICBpZiAoIWtleSkgcmV0dXJuIG51bGw7XHJcbiAgaWYgKCFhcnJheVBhdGggfHwgKGFycmF5UGF0aC5sZW5ndGggPT09IDApKSByZXR1cm4ga2V5O1xyXG4gIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZShyZUFycmF5LCBmdW5jdGlvbiAoc3RyLCBwMSkge1xyXG4gICAgLy8gTm90ZSB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIFt4XSBpbiB0aGUgSUQsXHJcbiAgICAvLyBmcm9tIGxlZnQgdG8gcmlnaHQgaW4gdGhlIHN0cmluZy4gVGhlIGdvYWwgaXMgdG8gcmVwbGFjZSB0aGUgW3hdIHdpdGhcclxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBpbmRleCBpbiB0aGUgbmV3IGFycmF5IHBhdGgsIGlmIGRlZmluZWQuXHJcbiAgICB2YXIgbmV3SW5kZXggPSBzdHI7XHJcbiAgICBpZiAoaXNTZXQoYXJyYXlQYXRoW2RlcHRoXSkpIHtcclxuICAgICAgbmV3SW5kZXggPSAnWycgKyBhcnJheVBhdGhbZGVwdGhdICsgJ10nO1xyXG4gICAgfVxyXG4gICAgZGVwdGggKz0gMTtcclxuICAgIHJldHVybiBuZXdJbmRleDtcclxuICB9KTtcclxuICByZXR1cm4gbmV3S2V5O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbml0aWFsIHZhbHVlIHRoYXQgYSBmaWVsZCBpZGVudGlmaWVkIGJ5IGl0cyBrZXlcclxuICogc2hvdWxkIHRha2UuXHJcbiAqXHJcbiAqIFRoZSBcImluaXRpYWxcIiB2YWx1ZSBpcyBkZWZpbmVkIGFzOlxyXG4gKiAxLiB0aGUgcHJldmlvdXNseSBzdWJtaXR0ZWQgdmFsdWUgaWYgYWxyZWFkeSBzdWJtaXR0ZWRcclxuICogMi4gdGhlIGRlZmF1bHQgdmFsdWUgZGVmaW5lZCBpbiB0aGUgbGF5b3V0IG9mIHRoZSBmb3JtXHJcbiAqIDMuIHRoZSBkZWZhdWx0IHZhbHVlIGRlZmluZWQgaW4gdGhlIHNjaGVtYVxyXG4gKlxyXG4gKiBUaGUgXCJ2YWx1ZVwiIHJldHVybmVkIGlzIGludGVuZGVkIGZvciByZW5kZXJpbmcgcHVycG9zZSxcclxuICogbWVhbmluZyB0aGF0LCBmb3IgZmllbGRzIHRoYXQgZGVmaW5lIGEgdGl0bGVNYXAgcHJvcGVydHksXHJcbiAqIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYWJlbCwgYW5kIG5vdCB0aGUgaW50cmluc2ljIHZhbHVlLlxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gaGFuZGxlcyB2YWx1ZXMgdGhhdCBjb250YWlucyB0ZW1wbGF0ZSBzdHJpbmdzLFxyXG4gKiBlLmcuIHt7dmFsdWVzLmZvb1tdLmJhcn19IG9yIHt7aWR4fX0uXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGZvcm0gaXMgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiB0cnVuY2F0ZXMgdGhlIHJlc3VsdGluZyBzdHJpbmdcclxuICogdG8gbWVldCBhIHBvdGVudGlhbCBcIm1heExlbmd0aFwiIGNvbnN0cmFpbnQgZGVmaW5lZCBpbiB0aGUgc2NoZW1hLCB1c2luZ1xyXG4gKiBcIi4uLlwiIHRvIG1hcmsgdGhlIHRydW5jYXRpb24uIE5vdGUgaXQgZG9lcyBub3QgdmFsaWRhdGUgdGhlIHJlc3VsdGluZ1xyXG4gKiBzdHJpbmcgYWdhaW5zdCBvdGhlciBjb25zdHJhaW50cyAoZS5nLiBtaW5MZW5ndGgsIHBhdHRlcm4pIGFzIGl0IHdvdWxkXHJcbiAqIGJlIGhhcmQgdG8gY29tZSB1cCB3aXRoIGFuIGF1dG9tYXRlZCBjb3Vyc2Ugb2YgYWN0aW9uIHRvIFwiZml4XCIgdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGZvcm1PYmplY3QgVGhlIEpTT04gRm9ybSBvYmplY3RcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgZ2VuZXJpYyBrZXkgcGF0aCAoZS5nLiBmb29bXS5iYXIuYmF6W10pXHJcbiAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gYXJyYXlQYXRoIFRoZSBhcnJheSBwYXRoIHRoYXQgaWRlbnRpZmllc1xyXG4gKiAgdGhlIHVuaXF1ZSB2YWx1ZSBpbiB0aGUgc3VibWl0dGVkIGZvcm0gKGUuZy4gWzEsIDNdKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdHBsZGF0YSBUZW1wbGF0ZSBkYXRhIG9iamVjdFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVByZXZpb3VzVmFsdWVzIHRydWUgdG8gdXNlIHByZXZpb3VzbHkgc3VibWl0dGVkIHZhbHVlc1xyXG4gKiAgaWYgZGVmaW5lZC5cclxuICovXHJcbnZhciBnZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAoZm9ybU9iamVjdCwga2V5LCBhcnJheVBhdGgsIHRwbGRhdGEsIHVzZVByZXZpb3VzVmFsdWVzKSB7XHJcbiAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHJcbiAgLy8gQ29tcGxldGUgdGVtcGxhdGUgZGF0YSBmb3IgdGVtcGxhdGUgZnVuY3Rpb25cclxuICB0cGxkYXRhID0gdHBsZGF0YSB8fCB7fTtcclxuICB0cGxkYXRhLmlkeCA9IHRwbGRhdGEuaWR4IHx8XHJcbiAgICAoYXJyYXlQYXRoID8gYXJyYXlQYXRoW2FycmF5UGF0aC5sZW5ndGgtMV0gOiAxKTtcclxuICB0cGxkYXRhLnZhbHVlID0gaXNTZXQodHBsZGF0YS52YWx1ZSkgPyB0cGxkYXRhLnZhbHVlIDogJyc7XHJcbiAgdHBsZGF0YS5nZXRWYWx1ZSA9IHRwbGRhdGEuZ2V0VmFsdWUgfHwgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGdldEluaXRpYWxWYWx1ZShmb3JtT2JqZWN0LCBrZXksIGFycmF5UGF0aCwgdHBsZGF0YSwgdXNlUHJldmlvdXNWYWx1ZXMpO1xyXG4gIH07XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZvcm0gZWxlbWVudCB0aGF0IGV4cGxpY2l0bHlcclxuICAvLyByZWZlcmVuY2VzIHRoZSBnaXZlbiBrZXkgaW4gdGhlIHNjaGVtYS5cclxuICB2YXIgZ2V0Rm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSkge1xyXG4gICAgdmFyIGZvcm1FbGVtZW50ID0gbnVsbDtcclxuICAgIGlmICghZWxlbWVudHMgfHwgIWVsZW1lbnRzLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcbiAgICBfLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uIChlbHQpIHtcclxuICAgICAgaWYgKGZvcm1FbGVtZW50KSByZXR1cm47XHJcbiAgICAgIGlmIChlbHQgPT09IGtleSkge1xyXG4gICAgICAgIGZvcm1FbGVtZW50ID0geyBrZXk6IGVsdCB9O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXy5pc1N0cmluZyhlbHQpKSByZXR1cm47XHJcbiAgICAgIGlmIChlbHQua2V5ID09PSBrZXkpIHtcclxuICAgICAgICBmb3JtRWxlbWVudCA9IGVsdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChlbHQuaXRlbXMpIHtcclxuICAgICAgICBmb3JtRWxlbWVudCA9IGdldEZvcm1FbGVtZW50KGVsdC5pdGVtcywga2V5KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZm9ybUVsZW1lbnQ7XHJcbiAgfTtcclxuICB2YXIgZm9ybUVsZW1lbnQgPSBnZXRGb3JtRWxlbWVudChmb3JtT2JqZWN0LmZvcm0gfHwgW10sIGtleSk7XHJcbiAgdmFyIHNjaGVtYUVsZW1lbnQgPSBnZXRTY2hlbWFLZXkoZm9ybU9iamVjdC5zY2hlbWEucHJvcGVydGllcywga2V5KTtcclxuXHJcbiAgaWYgKHVzZVByZXZpb3VzVmFsdWVzICYmIGZvcm1PYmplY3QudmFsdWUpIHtcclxuICAgIC8vIElmIHZhbHVlcyB3ZXJlIHByZXZpb3VzbHkgc3VibWl0dGVkLCB1c2UgdGhlbSBkaXJlY3RseSBpZiBkZWZpbmVkXHJcbiAgICB2YWx1ZSA9IGpzb25mb3JtLnV0aWwuZ2V0T2JqS2V5KGZvcm1PYmplY3QudmFsdWUsIGFwcGx5QXJyYXlQYXRoKGtleSwgYXJyYXlQYXRoKSk7XHJcbiAgfVxyXG4gIGlmICghaXNTZXQodmFsdWUpKSB7XHJcbiAgICBpZiAoZm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBmb3JtRWxlbWVudFsndmFsdWUnXSAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIGRlZmluaXRpb24gb2YgdGhlIGZvcm0gZmllbGQgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgIC8vIHRoZSBrZXkgYXMgaXQgbWF5IG92ZXJyaWRlIHRoZSBzY2hlbWEncyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgIC8vIChub3RlIGEgXCJudWxsXCIgdmFsdWUgb3ZlcnJpZGVzIGEgc2NoZW1hIGRlZmF1bHQgdmFsdWUgYXMgd2VsbClcclxuICAgICAgdmFsdWUgPSBmb3JtRWxlbWVudFsndmFsdWUnXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYUVsZW1lbnQpIHtcclxuICAgICAgLy8gU2ltcGx5IGV4dHJhY3QgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgc2NoZW1hXHJcbiAgICAgIGlmIChpc1NldChzY2hlbWFFbGVtZW50WydkZWZhdWx0J10pKSB7XHJcbiAgICAgICAgdmFsdWUgPSBzY2hlbWFFbGVtZW50WydkZWZhdWx0J107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5pbmRleE9mKCd7e3ZhbHVlcy4nKSAhPT0gLTEpIHtcclxuICAgICAgLy8gVGhpcyBsYWJlbCB3YW50cyB0byB1c2UgdGhlIHZhbHVlIG9mIGFub3RoZXIgaW5wdXQgZmllbGQuXHJcbiAgICAgIC8vIENvbnZlcnQgdGhhdCBjb25zdHJ1Y3QgaW50byB7e2dldFZhbHVlKGtleSl9fSBmb3JcclxuICAgICAgLy8gVW5kZXJzY29yZSB0byBjYWxsIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiBvZiBmb3JtRGF0YVxyXG4gICAgICAvLyB3aGVuIHRlbXBsYXRlIGdldHMgY2FsbGVkIChub3RlIGNhbGxpbmcgYSBmdW5jdGlvbiBpcyBub3RcclxuICAgICAgLy8gZXhhY3RseSBNdXN0YWNoZS1mcmllbmRseSBidXQgaXMgc3VwcG9ydGVkIGJ5IFVuZGVyc2NvcmUpLlxyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXHJcbiAgICAgICAgL1xce1xce3ZhbHVlc1xcLihbXlxcfV0rKVxcfVxcfS9nLFxyXG4gICAgICAgICd7e2dldFZhbHVlKFwiJDFcIil9fScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHZhbHVlID0gXy50ZW1wbGF0ZSh2YWx1ZSwgdHBsZGF0YSwgdmFsdWVUZW1wbGF0ZVNldHRpbmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHRpdGxlTWFwIGlmIG5lZWRlZFxyXG4gIGlmIChpc1NldCh2YWx1ZSkgJiYgZm9ybUVsZW1lbnQgJiZcclxuICAgICAgZm9ybUVsZW1lbnQudGl0bGVNYXAgJiZcclxuICAgICAgZm9ybUVsZW1lbnQudGl0bGVNYXBbdmFsdWVdKSB7XHJcbiAgICB2YWx1ZSA9IF8udGVtcGxhdGUoZm9ybUVsZW1lbnQudGl0bGVNYXBbdmFsdWVdLFxyXG4gICAgICB0cGxkYXRhLCB2YWx1ZVRlbXBsYXRlU2V0dGluZ3MpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgbWF4aW11bSBsZW5ndGggb2YgYSBzdHJpbmdcclxuICBpZiAodmFsdWUgJiYgXy5pc1N0cmluZyh2YWx1ZSkgJiZcclxuICAgIHNjaGVtYUVsZW1lbnQgJiYgc2NoZW1hRWxlbWVudC5tYXhMZW5ndGgpIHtcclxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBzY2hlbWFFbGVtZW50Lm1heExlbmd0aCkge1xyXG4gICAgICAvLyBUcnVuY2F0ZSB2YWx1ZSB0byBtYXhpbXVtIGxlbmd0aCwgYWRkaW5nIGNvbnRpbnVhdGlvbiBkb3RzXHJcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIHNjaGVtYUVsZW1lbnQubWF4TGVuZ3RoIC0gMSkgKyAn4oCmJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghaXNTZXQodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgZm9ybS5cclxuICpcclxuICogTm9kZXMgdGhhdCBoYXZlIGFuIElEIGFyZSBsaW5rZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgRE9NIGVsZW1lbnRcclxuICogd2hlbiByZW5kZXJlZFxyXG4gKlxyXG4gKiBOb3RlIHRoZSBmb3JtIGVsZW1lbnQgYW5kIHRoZSBzY2hlbWEgZWxlbWVudHMgdGhhdCBnYXZlIGJpcnRoIHRvIHRoZVxyXG4gKiBub2RlIG1heSBiZSBzaGFyZWQgYW1vbmcgbXVsdGlwbGUgbm9kZXMgKGluIHRoZSBjYXNlIG9mIGFycmF5cykuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxudmFyIGZvcm1Ob2RlID0gZnVuY3Rpb24gKCkge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBub2RlJ3MgSUQgKG1heSBub3QgYmUgc2V0KVxyXG4gICAqL1xyXG4gIHRoaXMuaWQgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgbm9kZSdzIGtleSBwYXRoIChtYXkgbm90IGJlIHNldClcclxuICAgKi9cclxuICB0aGlzLmtleSA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIERPTSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aHQgdGhlIGZvcm0gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIFRoZSBET00gZWxlbWVudCBpcyBzZXQgd2hlbiB0aGUgZm9ybSBlbGVtZW50IGlzIHJlbmRlcmVkLlxyXG4gICAqL1xyXG4gIHRoaXMuZWwgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBMaW5rIHRvIHRoZSBmb3JtIGVsZW1lbnQgdGhhdCBkZXNjcmliZXMgdGhlIG5vZGUncyBsYXlvdXRcclxuICAgKiAobm90ZSB0aGUgZm9ybSBlbGVtZW50IGlzIHNoYXJlZCBhbW9uZyBub2RlcyBpbiBhcnJheXMpXHJcbiAgICovXHJcbiAgdGhpcy5mb3JtRWxlbWVudCA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIExpbmsgdG8gdGhlIHNjaGVtYSBlbGVtZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBub2RlJ3MgdmFsdWUgY29uc3RyYWludHNcclxuICAgKiAobm90ZSB0aGUgc2NoZW1hIGVsZW1lbnQgaXMgc2hhcmVkIGFtb25nIG5vZGVzIGluIGFycmF5cylcclxuICAgKi9cclxuICB0aGlzLnNjaGVtYUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBQb2ludGVyIHRvIHRoZSBcInZpZXdcIiBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUsIHR5cGljYWxseSB0aGUgcmlnaHRcclxuICAgKiBvYmplY3QgaW4ganNvbmZvcm0uZWxlbWVudFR5cGVzXHJcbiAgICovXHJcbiAgdGhpcy52aWV3ID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogTm9kZSdzIHN1YnRyZWUgKGlmIG9uZSBpcyBkZWZpbmVkKVxyXG4gICAqL1xyXG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBwb2ludGVyIHRvIHRoZSBmb3JtIHRyZWUgdGhlIG5vZGUgaXMgYXR0YWNoZWQgdG9cclxuICAgKi9cclxuICB0aGlzLm93bmVyVHJlZSA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgcG9pbnRlciB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIG5vZGUgaW4gdGhlIHRyZWVcclxuICAgKi9cclxuICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBDaGlsZCB0ZW1wbGF0ZSBmb3IgYXJyYXktbGlrZSBub2Rlcy5cclxuICAgKlxyXG4gICAqIFRoZSBjaGlsZCB0ZW1wbGF0ZSBnZXRzIGNsb25lZCB0byBjcmVhdGUgbmV3IGFycmF5IGl0ZW1zLlxyXG4gICAqL1xyXG4gIHRoaXMuY2hpbGRUZW1wbGF0ZSA9IG51bGw7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEaXJlY3QgY2hpbGRyZW4gb2YgYXJyYXktbGlrZSBjb250YWluZXJzIG1heSB1c2UgdGhlIHZhbHVlIG9mIGFcclxuICAgKiBzcGVjaWZpYyBpbnB1dCBmaWVsZCBpbiB0aGVpciBzdWJ0cmVlIGFzIGxlZ2VuZC4gVGhlIGxpbmsgdG8gdGhlXHJcbiAgICogbGVnZW5kIGNoaWxkIGlzIGtlcHQgaGVyZSBhbmQgaW5pdGlhbGl6ZWQgaW4gY29tcHV0ZUluaXRpYWxWYWx1ZXNcclxuICAgKiB3aGVuIGEgY2hpbGQgc2V0cyBcInZhbHVlSW5MZWdlbmRcIlxyXG4gICAqL1xyXG4gIHRoaXMubGVnZW5kQ2hpbGQgPSBudWxsO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHBhdGggb2YgaW5kZXhlcyB0aGF0IGxlYWQgdG8gdGhlIGN1cnJlbnQgbm9kZSB3aGVuIHRoZVxyXG4gICAqIGZvcm0gZWxlbWVudCBpcyBub3QgYXQgdGhlIHJvb3QgYXJyYXkgbGV2ZWwuXHJcbiAgICpcclxuICAgKiBOb3RlIGEgZm9ybSBlbGVtZW50IG1heSB3ZWxsIGJlIG5lc3RlZCBlbGVtZW50IGFuZCBzdGlsbCBiZVxyXG4gICAqIGF0IHRoZSByb290IGFycmF5IGxldmVsLiBUaGF0J3MgdHlwaWNhbGx5IHRoZSBjYXNlIGZvciBcImZpZWxkc2V0XCJcclxuICAgKiBlbGVtZW50cy4gQW4gYXJyYXkgbGV2ZWwgb25seSBnZXRzIGNyZWF0ZWQgd2hlbiBhIGZvcm0gZWxlbWVudFxyXG4gICAqIGlzIG9mIHR5cGUgXCJhcnJheVwiIChvciBhIGRlcml2YXRlZCB0eXBlIHN1Y2ggYXMgXCJ0YWJhcnJheVwiKS5cclxuICAgKlxyXG4gICAqIFRoZSBhcnJheSBwYXRoIG9mIGEgZm9ybSBlbGVtZW50IGxpbmtlZCB0byB0aGUgZm9vWzJdLmJhci5iYXpbM10udG90b1xyXG4gICAqIGVsZW1lbnQgaW4gdGhlIHN1Ym1pdHRlZCB2YWx1ZXMgaXMgWzIsIDNdIGZvciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIFRoZSBhcnJheSBwYXRoIGlzIHR5cGljYWxseSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJpZ2h0IElEIGZvciBpbnB1dFxyXG4gICAqIGZpZWxkcy4gSXQgaXMgYWxzbyB1c2VkIHRvIHVwZGF0ZSBwb3NpdGlvbnMgd2hlbiBhbiBhcnJheSBpdGVtIGlzXHJcbiAgICogY3JlYXRlZCwgbW92ZWQgYXJvdW5kIG9yIHN1cHByZXNzZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXkoTnVtYmVyKX1cclxuICAgKi9cclxuICB0aGlzLmFycmF5UGF0aCA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvZiBpdHMgcGFyZW50c1xyXG4gICAqL1xyXG4gIHRoaXMuY2hpbGRQb3MgPSAwO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDbG9uZXMgYSBub2RlXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge2Zvcm1Ob2RlfSBOZXcgcGFyZW50IG5vZGUgdG8gYXR0YWNoIHRoZSBub2RlIHRvXHJcbiAqIEByZXR1cm4ge2Zvcm1Ob2RlfSBDbG9uZWQgbm9kZVxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcclxuICB2YXIgbm9kZSA9IG5ldyBmb3JtTm9kZSgpO1xyXG4gIG5vZGUuYXJyYXlQYXRoID0gXy5jbG9uZSh0aGlzLmFycmF5UGF0aCk7XHJcbiAgbm9kZS5vd25lclRyZWUgPSB0aGlzLm93bmVyVHJlZTtcclxuICBub2RlLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlIHx8IHRoaXMucGFyZW50Tm9kZTtcclxuICBub2RlLmZvcm1FbGVtZW50ID0gdGhpcy5mb3JtRWxlbWVudDtcclxuICBub2RlLnNjaGVtYUVsZW1lbnQgPSB0aGlzLnNjaGVtYUVsZW1lbnQ7XHJcbiAgbm9kZS52aWV3ID0gdGhpcy52aWV3O1xyXG4gIG5vZGUuY2hpbGRyZW4gPSBfLm1hcCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5jbG9uZShub2RlKTtcclxuICB9KTtcclxuICBpZiAodGhpcy5jaGlsZFRlbXBsYXRlKSB7XHJcbiAgICBub2RlLmNoaWxkVGVtcGxhdGUgPSB0aGlzLmNoaWxkVGVtcGxhdGUuY2xvbmUobm9kZSk7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1YnRyZWUgdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgbm9kZVxyXG4gKiBoYXMgc29tZSBub24gZW1wdHkgdmFsdWUgYXR0YWNoZWQgdG8gaXRcclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5oYXNOb25EZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8vIGhpZGRlbiBlbGVtZW50cyBkb24ndCBjb3VudCBiZWNhdXNlIHRoZXkgY291bGQgbWFrZSB0aGUgd3Jvbmcgc2VsZWN0ZmllbGRzZXQgZWxlbWVudCBhY3RpdmVcclxuICBpZiAodGhpcy5mb3JtRWxlbWVudCAmJiB0aGlzLmZvcm1FbGVtZW50LnR5cGU9PVwiaGlkZGVuXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKHRoaXMudmFsdWUgJiYgIXRoaXMuZGVmYXVsdFZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIGNoaWxkID0gXy5maW5kKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmhhc05vbkRlZmF1bHRWYWx1ZSgpO1xyXG4gIH0pO1xyXG4gIHJldHVybiAhIWNoaWxkO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBdHRhY2hlcyBhIGNoaWxkIG5vZGUgdG8gdGhlIGN1cnJlbnQgbm9kZS5cclxuICpcclxuICogVGhlIGNoaWxkIG5vZGUgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Zm9ybU5vZGV9IG5vZGUgVGhlIGNoaWxkIG5vZGUgdG8gYXBwZW5kXHJcbiAqIEByZXR1cm4ge2Zvcm1Ob2RlfSBUaGUgaW5zZXJ0ZWQgbm9kZSAoc2FtZSBhcyB0aGUgb25lIGdpdmVuIGFzIHBhcmFtZXRlcilcclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgbm9kZS5wYXJlbnROb2RlID0gdGhpcztcclxuICBub2RlLmNoaWxkUG9zID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgdGhpcy5jaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdO1xyXG4gIGlmICghY2hpbGQpIHJldHVybjtcclxuXHJcbiAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIHRoZSBET01cclxuICAkKGNoaWxkLmVsKS5yZW1vdmUoKTtcclxuXHJcbiAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIHRoZSBhcnJheVxyXG4gIHJldHVybiB0aGlzLmNoaWxkcmVuLnBvcCgpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNb3ZlcyB0aGUgdXNlciBlbnRlcmVkIHZhbHVlcyBzZXQgaW4gdGhlIGN1cnJlbnQgbm9kZSdzIHN1YnRyZWUgdG8gdGhlXHJcbiAqIGdpdmVuIG5vZGUncyBzdWJ0cmVlLlxyXG4gKlxyXG4gKiBUaGUgdGFyZ2V0IG5vZGUgbXVzdCBmb2xsb3cgdGhlIHNhbWUgc3RydWN0dXJlIGFzIHRoZSBjdXJyZW50IG5vZGVcclxuICogKHR5cGljYWxseSwgdGhleSBzaG91bGQgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmcm9tIHRoZSBzYW1lIG5vZGUgdGVtcGxhdGUpXHJcbiAqXHJcbiAqIFRoZSBjdXJyZW50IG5vZGUgTVVTVCBiZSByZW5kZXJlZCBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiBUT0RPOiB3aGVuIGN1cnJlbnQgbm9kZSBpcyBub3QgaW4gdGhlIERPTSwgZXh0cmFjdCB2YWx1ZXMgZnJvbSBmb3JtTm9kZS52YWx1ZVxyXG4gKiBwcm9wZXJ0aWVzLCBzbyB0aGF0IHRoZSBmdW5jdGlvbiBiZSBhdmFpbGFibGUgZXZlbiB3aGVuIGN1cnJlbnQgbm9kZSBpcyBub3RcclxuICogaW4gdGhlIERPTS5cclxuICpcclxuICogTW92aW5nIHZhbHVlcyBhcm91bmQgYWxsb3dzIHRvIGluc2VydC9yZW1vdmUgYXJyYXkgaXRlbXMgYXQgYXJiaXRyYXJ5XHJcbiAqIHBvc2l0aW9ucy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Zm9ybU5vZGV9IG5vZGUgVGFyZ2V0IG5vZGUuXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUubW92ZVZhbHVlc1RvID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtVmFsdWVzKG5vZGUuYXJyYXlQYXRoKTtcclxuICBub2RlLnJlc2V0VmFsdWVzKCk7XHJcbiAgbm9kZS5jb21wdXRlSW5pdGlhbFZhbHVlcyh2YWx1ZXMsIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTd2l0Y2hlcyBub2RlcyB1c2VyIGVudGVyZWQgdmFsdWVzLlxyXG4gKlxyXG4gKiBUaGUgdGFyZ2V0IG5vZGUgbXVzdCBmb2xsb3cgdGhlIHNhbWUgc3RydWN0dXJlIGFzIHRoZSBjdXJyZW50IG5vZGVcclxuICogKHR5cGljYWxseSwgdGhleSBzaG91bGQgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmcm9tIHRoZSBzYW1lIG5vZGUgdGVtcGxhdGUpXHJcbiAqXHJcbiAqIEJvdGggbm9kZXMgTVVTVCBiZSByZW5kZXJlZCBpbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiBUT0RPOiB1cGRhdGUgZ2V0Rm9ybVZhbHVlcyB0byB3b3JrIGV2ZW4gaWYgbm9kZSBpcyBub3QgcmVuZGVyZWQsIHVzaW5nXHJcbiAqIGZvcm1Ob2RlJ3MgXCJ2YWx1ZVwiIHByb3BlcnR5LlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtmb3JtTm9kZX0gbm9kZSBUYXJnZXQgbm9kZVxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLnN3aXRjaFZhbHVlc1dpdGggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1WYWx1ZXMobm9kZS5hcnJheVBhdGgpO1xyXG4gIHZhciBub2RlVmFsdWVzID0gbm9kZS5nZXRGb3JtVmFsdWVzKHRoaXMuYXJyYXlQYXRoKTtcclxuICBub2RlLnJlc2V0VmFsdWVzKCk7XHJcbiAgbm9kZS5jb21wdXRlSW5pdGlhbFZhbHVlcyh2YWx1ZXMsIHRydWUpO1xyXG4gIHRoaXMucmVzZXRWYWx1ZXMoKTtcclxuICB0aGlzLmNvbXB1dGVJbml0aWFsVmFsdWVzKG5vZGVWYWx1ZXMsIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgYWxsIERPTSB2YWx1ZXMgaW4gdGhlIG5vZGUncyBzdWJ0cmVlLlxyXG4gKlxyXG4gKiBUaGlzIG9wZXJhdGlvbiBhbHNvIGRyb3BzIGFsbCBhcnJheSBpdGVtIG5vZGVzLlxyXG4gKiBOb3RlIHZhbHVlcyBhcmUgbm90IHJlc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCB0aGV5IGFyZSByYXRoZXIgcmVtb3ZlZCFcclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUucmVzZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHBhcmFtcyA9IG51bGw7XHJcbiAgdmFyIGlkeCA9IDA7XHJcblxyXG4gIC8vIFJlc2V0IHZhbHVlXHJcbiAgdGhpcy52YWx1ZSA9IG51bGw7XHJcblxyXG4gIC8vIFByb3BhZ2F0ZSB0aGUgYXJyYXkgcGF0aCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxyXG4gIC8vIChhZGRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaGlsZCBmb3Igbm9kZXMgdGhhdCBhcmUgZGlyZWN0XHJcbiAgLy8gY2hpbGRyZW4gb2YgYXJyYXktbGlrZSBub2RlcylcclxuICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICB0aGlzLmFycmF5UGF0aCA9IF8uY2xvbmUodGhpcy5wYXJlbnROb2RlLmFycmF5UGF0aCk7XHJcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlLnZpZXcgJiYgdGhpcy5wYXJlbnROb2RlLnZpZXcuYXJyYXkpIHtcclxuICAgICAgdGhpcy5hcnJheVBhdGgucHVzaCh0aGlzLmNoaWxkUG9zKTtcclxuICAgIH1cclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB0aGlzLmFycmF5UGF0aCA9IFtdO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMudmlldyAmJiB0aGlzLnZpZXcuaW5wdXRmaWVsZCkge1xyXG4gICAgLy8gU2ltcGxlIGlucHV0IGZpZWxkLCBleHRyYWN0IHRoZSB2YWx1ZSBmcm9tIHRoZSBvcmlnaW4sXHJcbiAgICAvLyBzZXQgdGhlIHRhcmdldCB2YWx1ZSBhbmQgcmVzZXQgdGhlIG9yaWdpbiB2YWx1ZVxyXG4gICAgcGFyYW1zID0gJCgnOmlucHV0JywgdGhpcy5lbCkuc2VyaWFsaXplQXJyYXkoKTtcclxuICAgIF8uZWFjaChwYXJhbXMsIGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAvLyBUT0RPOiBjaGVjayB0aGlzLCB0aGVyZSBtYXkgZXhpc3QgY29ybmVyIGNhc2VzIHdpdGggdGhpcyBhcHByb2FjaFxyXG4gICAgICAvLyAod2l0aCBtdWx0aXBsZSBjaGVja2JveGVzIGZvciBpbnN0YW5jZSlcclxuICAgICAgJCgnW25hbWU9XCInICsgZXNjYXBlU2VsZWN0b3IocGFyYW0ubmFtZSkgKyAnXCJdJywgJCh0aGlzLmVsKSkudmFsKCcnKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gIH1cclxuICBlbHNlIGlmICh0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmFycmF5KSB7XHJcbiAgICAvLyBUaGUgY3VycmVudCBub2RlIGlzIGFuIGFycmF5LCBkcm9wIGFsbCBjaGlsZHJlblxyXG4gICAgd2hpbGUgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZWN1cnNlIGRvd24gdGhlIHRyZWVcclxuICBfLmVhY2godGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICBjaGlsZC5yZXNldFZhbHVlcygpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBjaGlsZCB0ZW1wbGF0ZSBub2RlIGZvciB0aGUgY3VycmVudCBub2RlLlxyXG4gKlxyXG4gKiBUaGUgY2hpbGQgdGVtcGxhdGUgbm9kZSBpcyB1c2VkIHRvIGNyZWF0ZSBhZGRpdGlvbmFsIGNoaWxkcmVuXHJcbiAqIGluIGFuIGFycmF5LWxpa2UgZm9ybSBlbGVtZW50LiBUaGUgdGVtcGxhdGUgaXMgbmV2ZXIgcmVuZGVyZWQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge2Zvcm1Ob2RlfSBub2RlIFRoZSBjaGlsZCB0ZW1wbGF0ZSBub2RlIHRvIHNldFxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLnNldENoaWxkVGVtcGxhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHRoaXMuY2hpbGRUZW1wbGF0ZSA9IG5vZGU7XHJcbiAgbm9kZS5wYXJlbnROb2RlID0gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgc2V0cyB2YWx1ZXMgdG8gYWxsIG5vZGVzIG9mIHRoZSBjdXJyZW50IHN1YnRyZWVcclxuICogYmFzZWQgb24gcHJldmlvdXNseSBzdWJtaXR0ZWQgdmFsdWVzLCBvciBiYXNlZCBvbiBkZWZhdWx0XHJcbiAqIHZhbHVlcyB3aGVuIHRoZSBzdWJtaXR0ZWQgdmFsdWVzIGFyZSBub3QgZW5vdWdoXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIGEgbm9kZVxyXG4gKiBpbiB0aGUgdHJlZS4gSXQgZXhwZWN0cyBpdHMgcGFyZW50J3MgYXJyYXlQYXRoIHRvIGJlIHVwIHRvIGRhdGUuXHJcbiAqXHJcbiAqIFRocmVlIGNhc2VzIG1heSBhcmlzZTpcclxuICogMS4gaWYgdGhlIGZvcm0gZWxlbWVudCBpcyBhIHNpbXBsZSBpbnB1dCBmaWVsZCwgdGhlIHZhbHVlIGlzXHJcbiAqIGV4dHJhY3RlZCBmcm9tIHByZXZpb3VzbHkgc3VibWl0dGVkIHZhbHVlcyBvZiBmcm9tIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRlZmluZWQgaW4gdGhlIHNjaGVtYS5cclxuICogMi4gaWYgdGhlIGZvcm0gZWxlbWVudCBpcyBhbiBhcnJheS1saWtlIG5vZGUsIHRoZSBjaGlsZCB0ZW1wbGF0ZVxyXG4gKiBpcyB1c2VkIHRvIGNyZWF0ZSBhcyBtYW55IGNoaWxkcmVuIGFzIHBvc3NpYmxlIChhbmQgYXQgbGVhc3Qgb25lKS5cclxuICogMy4gdGhlIGZ1bmN0aW9uIHNpbXBseSByZWN1cnNlcyBkb3duIHRoZSBub2RlJ3Mgc3VidHJlZSBvdGhlcndpc2VcclxuICogKHRoaXMgaGFwcGVucyB3aGVuIHRoZSBmb3JtIGVsZW1lbnQgaXMgYSBmaWVsZHNldC1saWtlIGVsZW1lbnQpLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyBQcmV2aW91c2x5IHN1Ym1pdHRlZCB2YWx1ZXMgZm9yIHRoZSBmb3JtXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlRGVmYXVsdFZhbHVlcyBJZ25vcmUgZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBpbiB0aGVcclxuICogIHNjaGVtYSB3aGVuIHNldC5cclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbFZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIGlnbm9yZURlZmF1bHRWYWx1ZXMpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIG5vZGUgPSBudWxsO1xyXG4gIHZhciBuYkNoaWxkcmVuID0gMTtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGZvcm1EYXRhID0gdGhpcy5vd25lclRyZWUuZm9ybURlc2MudHBsZGF0YSB8fCB7fTtcclxuXHJcbiAgLy8gUHJvcGFnYXRlIHRoZSBhcnJheSBwYXRoIGZyb20gdGhlIHBhcmVudCBub2RlXHJcbiAgLy8gKGFkZGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGNoaWxkIGZvciBub2RlcyB0aGF0IGFyZSBkaXJlY3RcclxuICAvLyBjaGlsZHJlbiBvZiBhcnJheS1saWtlIG5vZGVzKVxyXG4gIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgIHRoaXMuYXJyYXlQYXRoID0gXy5jbG9uZSh0aGlzLnBhcmVudE5vZGUuYXJyYXlQYXRoKTtcclxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUudmlldyAmJiB0aGlzLnBhcmVudE5vZGUudmlldy5hcnJheSkge1xyXG4gICAgICB0aGlzLmFycmF5UGF0aC5wdXNoKHRoaXMuY2hpbGRQb3MpO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHRoaXMuYXJyYXlQYXRoID0gW107XHJcbiAgfVxyXG5cclxuICAvLyBQcmVwYXJlIHNwZWNpYWwgZGF0YSBwYXJhbSBcImlkeFwiIGZvciB0ZW1wbGF0ZWQgdmFsdWVzXHJcbiAgLy8gKGlzIGlzIHRoZSBpbmRleCBvZiB0aGUgY2hpbGQgaW4gaXRzIHdyYXBwaW5nIGFycmF5LCBzdGFydGluZ1xyXG4gIC8vIGF0IDEgc2luY2UgdGhhdCdzIG1vcmUgaHVtYW4tZnJpZW5kbHkgdGhhbiBhIHplcm8tYmFzZWQgaW5kZXgpXHJcbiAgZm9ybURhdGEuaWR4ID0gKHRoaXMuYXJyYXlQYXRoLmxlbmd0aCA+IDApID9cclxuICAgIHRoaXMuYXJyYXlQYXRoW3RoaXMuYXJyYXlQYXRoLmxlbmd0aC0xXSArIDEgOlxyXG4gICAgdGhpcy5jaGlsZFBvcyArIDE7XHJcblxyXG4gIC8vIFByZXBhcmUgc3BlY2lhbCBkYXRhIHBhcmFtIFwidmFsdWVcIiBmb3IgdGVtcGxhdGVkIHZhbHVlc1xyXG4gIGZvcm1EYXRhLnZhbHVlID0gJyc7XHJcblxyXG4gIC8vIFByZXBhcmUgc3BlY2lhbCBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSB2YWx1ZSBvZiBhbm90aGVyIGZpZWxkXHJcbiAgZm9ybURhdGEuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFZhbHVlKHNlbGYub3duZXJUcmVlLmZvcm1EZXNjLFxyXG4gICAgICBrZXksIHNlbGYuYXJyYXlQYXRoLFxyXG4gICAgICBmb3JtRGF0YSwgISF2YWx1ZXMpO1xyXG4gIH07XHJcblxyXG4gIGlmICh0aGlzLmZvcm1FbGVtZW50KSB7XHJcbiAgICAvLyBDb21wdXRlIHRoZSBJRCBvZiB0aGUgZmllbGQgKGlmIG5lZWRlZClcclxuICAgIGlmICh0aGlzLmZvcm1FbGVtZW50LmlkKSB7XHJcbiAgICAgIHRoaXMuaWQgPSBhcHBseUFycmF5UGF0aCh0aGlzLmZvcm1FbGVtZW50LmlkLCB0aGlzLmFycmF5UGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmFycmF5KSB7XHJcbiAgICAgIHRoaXMuaWQgPSBlc2NhcGVTZWxlY3Rvcih0aGlzLm93bmVyVHJlZS5mb3JtRGVzYy5wcmVmaXgpICtcclxuICAgICAgICAnLWVsdC1jb3VudGVyLScgKyBfLnVuaXF1ZUlkKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLnZpZXcgJiZcclxuICAgICAgdGhpcy5wYXJlbnROb2RlLnZpZXcuYXJyYXkpIHtcclxuICAgICAgLy8gQXJyYXkgaXRlbXMgbmVlZCBhbiBhcnJheSB0byBhc3NvY2lhdGUgdGhlIHJpZ2h0IERPTSBlbGVtZW50XHJcbiAgICAgIC8vIHRvIHRoZSBmb3JtIG5vZGUgd2hlbiB0aGUgcGFyZW50IGlzIHJlbmRlcmVkLlxyXG4gICAgICB0aGlzLmlkID0gZXNjYXBlU2VsZWN0b3IodGhpcy5vd25lclRyZWUuZm9ybURlc2MucHJlZml4KSArXHJcbiAgICAgICAgJy1lbHQtY291bnRlci0nICsgXy51bmlxdWVJZCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHRoaXMuZm9ybUVsZW1lbnQudHlwZSA9PT0gJ2J1dHRvbicpIHx8XHJcbiAgICAgICh0aGlzLmZvcm1FbGVtZW50LnR5cGUgPT09ICdzZWxlY3RmaWVsZHNldCcpIHx8XHJcbiAgICAgICh0aGlzLmZvcm1FbGVtZW50LnR5cGUgPT09ICdxdWVzdGlvbicpIHx8XHJcbiAgICAgICh0aGlzLmZvcm1FbGVtZW50LnR5cGUgPT09ICdidXR0b25xdWVzdGlvbicpKSB7XHJcbiAgICAgIC8vIEJ1dHRvbnMgZG8gbmVlZCBhbiBpZCBmb3IgXCJvbkNsaWNrXCIgcHVycG9zZVxyXG4gICAgICB0aGlzLmlkID0gZXNjYXBlU2VsZWN0b3IodGhpcy5vd25lclRyZWUuZm9ybURlc2MucHJlZml4KSArXHJcbiAgICAgICAgJy1lbHQtY291bnRlci0nICsgXy51bmlxdWVJZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXB1dGUgdGhlIGFjdHVhbCBrZXkgKHRoZSBmb3JtIGVsZW1lbnQncyBrZXkgaXMgaW5kZXgtZnJlZSxcclxuICAgIC8vIGkuZS4gaXQgbG9va3MgbGlrZSBmb29bXS5iYXIuYmF6W10udHJ1Yywgc28gd2UgbmVlZCB0byBhcHBseVxyXG4gICAgLy8gdGhlIGFycmF5IHBhdGggb2YgdGhlIG5vZGUgdG8gZ2V0IGZvb1s0XS5iYXIuYmF6WzJdLnRydWMpXHJcbiAgICBpZiAodGhpcy5mb3JtRWxlbWVudC5rZXkpIHtcclxuICAgICAgdGhpcy5rZXkgPSBhcHBseUFycmF5UGF0aCh0aGlzLmZvcm1FbGVtZW50LmtleSwgdGhpcy5hcnJheVBhdGgpO1xyXG4gICAgICB0aGlzLmtleWRhc2ggPSB0aGlzLmtleS5yZXBsYWNlKC9cXC4vZywgJy0tLScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhbWUgaWRlYSBmb3IgdGhlIGZpZWxkJ3MgbmFtZVxyXG4gICAgdGhpcy5uYW1lID0gYXBwbHlBcnJheVBhdGgodGhpcy5mb3JtRWxlbWVudC5uYW1lLCB0aGlzLmFycmF5UGF0aCk7XHJcblxyXG4gICAgLy8gQ29uc2lkZXIgdGhhdCBsYWJlbCB2YWx1ZXMgYXJlIHRlbXBsYXRlIHZhbHVlcyBhbmQgYXBwbHkgdGhlXHJcbiAgICAvLyBmb3JtJ3MgZGF0YSBhcHByb3ByaWF0ZWx5IChub3RlIHdlIGFsc28gYXBwbHkgdGhlIGFycmF5IHBhdGhcclxuICAgIC8vIGFsdGhvdWdoIHRoYXQgcHJvYmFibHkgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgZm9yIGxhYmVscy4uLilcclxuICAgIF8uZWFjaChbXHJcbiAgICAgICd0aXRsZScsXHJcbiAgICAgICdsZWdlbmQnLFxyXG4gICAgICAnZGVzY3JpcHRpb24nLFxyXG4gICAgICAnYXBwZW5kJyxcclxuICAgICAgJ3ByZXBlbmQnLFxyXG4gICAgICAnaW5saW5ldGl0bGUnLFxyXG4gICAgICAnaGVscHZhbHVlJyxcclxuICAgICAgJ3ZhbHVlJyxcclxuICAgICAgJ2Rpc2FibGVkJyxcclxuICAgICAgJ3BsYWNlaG9sZGVyJyxcclxuICAgICAgJ3JlYWRPbmx5J1xyXG4gICAgXSwgZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgaWYgKF8uaXNTdHJpbmcodGhpcy5mb3JtRWxlbWVudFtwcm9wXSkpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JtRWxlbWVudFtwcm9wXS5pbmRleE9mKCd7e3ZhbHVlcy4nKSAhPT0gLTEpIHtcclxuICAgICAgICAgIC8vIFRoaXMgbGFiZWwgd2FudHMgdG8gdXNlIHRoZSB2YWx1ZSBvZiBhbm90aGVyIGlucHV0IGZpZWxkLlxyXG4gICAgICAgICAgLy8gQ29udmVydCB0aGF0IGNvbnN0cnVjdCBpbnRvIHt7anNvbmZvcm0uZ2V0VmFsdWUoa2V5KX19IGZvclxyXG4gICAgICAgICAgLy8gVW5kZXJzY29yZSB0byBjYWxsIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiBvZiBmb3JtRGF0YVxyXG4gICAgICAgICAgLy8gd2hlbiB0ZW1wbGF0ZSBnZXRzIGNhbGxlZCAobm90ZSBjYWxsaW5nIGEgZnVuY3Rpb24gaXMgbm90XHJcbiAgICAgICAgICAvLyBleGFjdGx5IE11c3RhY2hlLWZyaWVuZGx5IGJ1dCBpcyBzdXBwb3J0ZWQgYnkgVW5kZXJzY29yZSkuXHJcbiAgICAgICAgICB0aGlzW3Byb3BdID0gdGhpcy5mb3JtRWxlbWVudFtwcm9wXS5yZXBsYWNlKFxyXG4gICAgICAgICAgICAvXFx7XFx7dmFsdWVzXFwuKFteXFx9XSspXFx9XFx9L2csXHJcbiAgICAgICAgICAgICd7e2dldFZhbHVlKFwiJDFcIil9fScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIE5vdGUgYXBwbHlpbmcgdGhlIGFycmF5IHBhdGggcHJvYmFibHkgZG9lc24ndCBtYWtlIGFueSBzZW5zZSxcclxuICAgICAgICAgIC8vIGJ1dCBzb21lIGdlZWsgbWlnaHQgd2FudCB0byBoYXZlIGEgbGFiZWwgXCJmb29bXS5iYXJbXS5iYXpcIixcclxuICAgICAgICAgIC8vIHdpdGggdGhlIFtdIHJlcGxhY2VkIGJ5IHRoZSBhcHByb3ByaWF0ZSBhcnJheSBwYXRoLlxyXG4gICAgICAgICAgdGhpc1twcm9wXSA9IGFwcGx5QXJyYXlQYXRoKHRoaXMuZm9ybUVsZW1lbnRbcHJvcF0sIHRoaXMuYXJyYXlQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0pIHtcclxuICAgICAgICAgIHRoaXNbcHJvcF0gPSBfLnRlbXBsYXRlKHRoaXNbcHJvcF0sIGZvcm1EYXRhLCB2YWx1ZVRlbXBsYXRlU2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzW3Byb3BdID0gdGhpcy5mb3JtRWxlbWVudFtwcm9wXTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgLy8gQXBwbHkgdGVtcGxhdGluZyB0byBvcHRpb25zIGNyZWF0ZWQgd2l0aCBcInRpdGxlTWFwXCIgYXMgd2VsbFxyXG4gICAgaWYgKHRoaXMuZm9ybUVsZW1lbnQub3B0aW9ucykge1xyXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfLm1hcCh0aGlzLmZvcm1FbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICB2YXIgdGl0bGUgPSBudWxsO1xyXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KG9wdGlvbikgJiYgb3B0aW9uLnRpdGxlKSB7XHJcbiAgICAgICAgICAvLyBTZWUgYSBmZXcgbGluZXMgYWJvdmUgZm9yIG1vcmUgZGV0YWlscyBhYm91dCB0ZW1wbGF0aW5nXHJcbiAgICAgICAgICAvLyBwcmVwYXJhdGlvbiBoZXJlLlxyXG4gICAgICAgICAgaWYgKG9wdGlvbi50aXRsZS5pbmRleE9mKCd7e3ZhbHVlcy4nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBvcHRpb24udGl0bGUucmVwbGFjZShcclxuICAgICAgICAgICAgICAvXFx7XFx7dmFsdWVzXFwuKFteXFx9XSspXFx9XFx9L2csXHJcbiAgICAgICAgICAgICAgJ3t7Z2V0VmFsdWUoXCIkMVwiKX19Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBhcHBseUFycmF5UGF0aChvcHRpb24udGl0bGUsIHNlbGYuYXJyYXlQYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgb3B0aW9uLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAoaXNTZXQob3B0aW9uLnZhbHVlKSA/IG9wdGlvbi52YWx1ZSA6ICcnKSxcclxuICAgICAgICAgICAgdGl0bGU6IF8udGVtcGxhdGUodGl0bGUsIGZvcm1EYXRhLCB2YWx1ZVRlbXBsYXRlU2V0dGluZ3MpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy52aWV3ICYmIHRoaXMudmlldy5pbnB1dGZpZWxkICYmIHRoaXMuc2NoZW1hRWxlbWVudCkge1xyXG4gICAgLy8gQ2FzZSAxOiBzaW1wbGUgaW5wdXQgZmllbGRcclxuICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgLy8gRm9ybSBoYXMgYWxyZWFkeSBiZWVuIHN1Ym1pdHRlZCwgdXNlIGZvcm1lciB2YWx1ZSBpZiBkZWZpbmVkLlxyXG4gICAgICAvLyBOb3RlIHdlIHdvbid0IHNldCB0aGUgZmllbGQgdG8gaXRzIGRlZmF1bHQgdmFsdWUgb3RoZXJ3aXNlXHJcbiAgICAgIC8vIChzaW5jZSB0aGUgdXNlciBoYXMgYWxyZWFkeSByZWplY3RlZCBpdClcclxuICAgICAgaWYgKGlzU2V0KGpzb25mb3JtLnV0aWwuZ2V0T2JqS2V5KHZhbHVlcywgdGhpcy5rZXkpKSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBqc29uZm9ybS51dGlsLmdldE9iaktleSh2YWx1ZXMsIHRoaXMua2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlnbm9yZURlZmF1bHRWYWx1ZXMpIHtcclxuICAgICAgLy8gTm8gcHJldmlvdXNseSBzdWJtaXR0ZWQgZm9ybSByZXN1bHQsIHVzZSBkZWZhdWx0IHZhbHVlXHJcbiAgICAgIC8vIGRlZmluZWQgaW4gdGhlIHNjaGVtYSBpZiBpdCdzIGF2YWlsYWJsZSBhbmQgbm90IGFscmVhZHlcclxuICAgICAgLy8gZGVmaW5lZCBpbiB0aGUgZm9ybSBlbGVtZW50XHJcbiAgICAgIGlmICghaXNTZXQodGhpcy52YWx1ZSkgJiYgaXNTZXQodGhpcy5zY2hlbWFFbGVtZW50WydkZWZhdWx0J10pKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2NoZW1hRWxlbWVudFsnZGVmYXVsdCddO1xyXG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMudmFsdWUpKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZS5pbmRleE9mKCd7e3ZhbHVlcy4nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBsYWJlbCB3YW50cyB0byB1c2UgdGhlIHZhbHVlIG9mIGFub3RoZXIgaW5wdXQgZmllbGQuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhhdCBjb25zdHJ1Y3QgaW50byB7e2pzb25mb3JtLmdldFZhbHVlKGtleSl9fSBmb3JcclxuICAgICAgICAgICAgLy8gVW5kZXJzY29yZSB0byBjYWxsIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvbiBvZiBmb3JtRGF0YVxyXG4gICAgICAgICAgICAvLyB3aGVuIHRlbXBsYXRlIGdldHMgY2FsbGVkIChub3RlIGNhbGxpbmcgYSBmdW5jdGlvbiBpcyBub3RcclxuICAgICAgICAgICAgLy8gZXhhY3RseSBNdXN0YWNoZS1mcmllbmRseSBidXQgaXMgc3VwcG9ydGVkIGJ5IFVuZGVyc2NvcmUpLlxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgIC9cXHtcXHt2YWx1ZXNcXC4oW15cXH1dKylcXH1cXH0vZyxcclxuICAgICAgICAgICAgICAne3tnZXRWYWx1ZShcIiQxXCIpfX0nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOb3RlIGFwcGx5aW5nIHRoZSBhcnJheSBwYXRoIHByb2JhYmx5IGRvZXNuJ3QgbWFrZSBhbnkgc2Vuc2UsXHJcbiAgICAgICAgICAgIC8vIGJ1dCBzb21lIGdlZWsgbWlnaHQgd2FudCB0byBoYXZlIGEgbGFiZWwgXCJmb29bXS5iYXJbXS5iYXpcIixcclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgW10gcmVwbGFjZWQgYnkgdGhlIGFwcHJvcHJpYXRlIGFycmF5IHBhdGguXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcHBseUFycmF5UGF0aCh0aGlzLnZhbHVlLCB0aGlzLmFycmF5UGF0aCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXy50ZW1wbGF0ZSh0aGlzLnZhbHVlLCBmb3JtRGF0YSwgdmFsdWVUZW1wbGF0ZVNldHRpbmdzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVsc2UgaWYgKHRoaXMudmlldyAmJiB0aGlzLnZpZXcuYXJyYXkpIHtcclxuICAgIC8vIENhc2UgMjogYXJyYXktbGlrZSBub2RlXHJcbiAgICBuYkNoaWxkcmVuID0gMDtcclxuICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgbmJDaGlsZHJlbiA9IHRoaXMuZ2V0UHJldmlvdXNOdW1iZXJPZkl0ZW1zKHZhbHVlcywgdGhpcy5hcnJheVBhdGgpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogdXNlIGRlZmF1bHQgdmFsdWVzIGF0IHRoZSBhcnJheSBsZXZlbCB3aGVuIGZvcm0gaGFzIG5vdCBiZWVuXHJcbiAgICAvLyBzdWJtaXR0ZWQgYmVmb3JlLiBOb3RlIGl0J3Mgbm90IHRoYXQgZWFzeSBiZWNhdXNlIGVhY2ggdmFsdWUgbWF5XHJcbiAgICAvLyBiZSBhIGNvbXBsZXggc3RydWN0dXJlIHRoYXQgbmVlZHMgdG8gYmUgcHVzaGVkIGRvd24gdGhlIHN1YnRyZWUuXHJcbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgaXMgcHJvYmFibHkgdG8gZ2VuZXJhdGUgYSBcInZhbHVlc1wiIG9iamVjdCBhbmRcclxuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCB2YWx1ZXMgZnJvbSB0aGF0IG9iamVjdFxyXG4gICAgLypcclxuICAgIGVsc2UgaWYgKHRoaXMuc2NoZW1hRWxlbWVudFsnZGVmYXVsdCddKSB7XHJcbiAgICAgIG5iQ2hpbGRyZW4gPSB0aGlzLnNjaGVtYUVsZW1lbnRbJ2RlZmF1bHQnXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgZWxzZSBpZiAobmJDaGlsZHJlbiA9PT0gMCkge1xyXG4gICAgICAvLyBJZiBmb3JtIGhhcyBhbHJlYWR5IGJlZW4gc3VibWl0dGVkIHdpdGggbm8gY2hpbGRyZW4sIHRoZSBhcnJheVxyXG4gICAgICAvLyBuZWVkcyB0byBiZSByZW5kZXJlZCB3aXRob3V0IGNoaWxkcmVuLiBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXNseVxyXG4gICAgICAvLyBzdWJtaXR0ZWQgdmFsdWVzLCB0aGUgYXJyYXkgZ2V0cyByZW5kZXJlZCB3aXRoIG9uZSBlbXB0eSBpdGVtIGFzXHJcbiAgICAgIC8vIGl0J3MgbW9yZSBuYXR1cmFsIGZyb20gYSB1c2VyIGV4cGVyaWVuY2UgcGVyc3BlY3RpdmUuIFRoYXQgaXRlbSBjYW5cclxuICAgICAgLy8gYmUgcmVtb3ZlZCB3aXRoIGEgY2xpY2sgb24gdGhlIFwiLVwiIGJ1dHRvbi5cclxuICAgICAgbmJDaGlsZHJlbiA9IDE7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmJDaGlsZHJlbjsgaSsrKSB7XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZFRlbXBsYXRlLmNsb25lKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2FzZSAzIGFuZCBpbiBhbnkgY2FzZTogcmVjdXJzZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgXy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgY2hpbGQuY29tcHV0ZUluaXRpYWxWYWx1ZXModmFsdWVzLCBpZ25vcmVEZWZhdWx0VmFsdWVzKTtcclxuICB9KTtcclxuXHJcbiAgLy8gSWYgdGhlIG5vZGUncyB2YWx1ZSBpcyB0byBiZSB1c2VkIGFzIGxlZ2VuZCBmb3IgaXRzIFwiY29udGFpbmVyXCJcclxuICAvLyAodHlwaWNhbGx5IHRoZSBhcnJheSB0aGUgbm9kZSBiZWxvbmdzIHRvKSwgZW5zdXJlIHRoYXQgdGhlIGNvbnRhaW5lclxyXG4gIC8vIGhhcyBhIGRpcmVjdCBsaW5rIHRvIHRoZSBub2RlIGZvciB0aGUgY29ycmVzcG9uZGluZyB0YWIuXHJcbiAgaWYgKHRoaXMuZm9ybUVsZW1lbnQgJiYgdGhpcy5mb3JtRWxlbWVudC52YWx1ZUluTGVnZW5kKSB7XHJcbiAgICBub2RlID0gdGhpcztcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgJiZcclxuICAgICAgICBub2RlLnBhcmVudE5vZGUudmlldyAmJlxyXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS52aWV3LmFycmF5KSB7XHJcbiAgICAgICAgbm9kZS5sZWdlbmRDaGlsZCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG5vZGUuZm9ybUVsZW1lbnQgJiYgbm9kZS5mb3JtRWxlbWVudC5sZWdlbmQpIHtcclxuICAgICAgICAgIG5vZGUubGVnZW5kID0gYXBwbHlBcnJheVBhdGgobm9kZS5mb3JtRWxlbWVudC5sZWdlbmQsIG5vZGUuYXJyYXlQYXRoKTtcclxuICAgICAgICAgIGZvcm1EYXRhLmlkeCA9IChub2RlLmFycmF5UGF0aC5sZW5ndGggPiAwKSA/XHJcbiAgICAgICAgICAgIG5vZGUuYXJyYXlQYXRoW25vZGUuYXJyYXlQYXRoLmxlbmd0aC0xXSArIDEgOlxyXG4gICAgICAgICAgICBub2RlLmNoaWxkUG9zICsgMTtcclxuICAgICAgICAgIGZvcm1EYXRhLnZhbHVlID0gaXNTZXQodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlIDogJyc7XHJcbiAgICAgICAgICBub2RlLmxlZ2VuZCA9IF8udGVtcGxhdGUobm9kZS5sZWdlbmQsIGZvcm1EYXRhLCB2YWx1ZVRlbXBsYXRlU2V0dGluZ3MpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCB0aGUgYXJyYXkgbm9kZSBzaG91bGQgaGF2ZSBiYXNlZCBvblxyXG4gKiBwcmV2aW91c2x5IHN1Ym1pdHRlZCB2YWx1ZXMuXHJcbiAqXHJcbiAqIFRoZSB3aG9sZSBkaWZmaWN1bHR5IGlzIHRoYXQgdmFsdWVzIG1heSBiZSBoaWRkZW4gZGVlcCBpbiB0aGUgc3VidHJlZVxyXG4gKiBvZiB0aGUgbm9kZSBhbmQgbWF5IGFjdHVhbGx5IHRhcmdldCBkaWZmZXJlbnQgYXJyYXlzIGluIHRoZSBKU09OIHNjaGVtYS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgUHJldmlvdXNseSBzdWJtaXR0ZWQgdmFsdWVzXHJcbiAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gYXJyYXlQYXRoIHRoZSBhcnJheSBwYXRoIHdlJ3JlIGludGVyZXN0ZWQgaW5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBhcnJheVxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLmdldFByZXZpb3VzTnVtYmVyT2ZJdGVtcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIGFycmF5UGF0aCkge1xyXG4gIHZhciBrZXkgPSBudWxsO1xyXG4gIHZhciBhcnJheVZhbHVlID0gbnVsbDtcclxuICB2YXIgY2hpbGROdW1iZXJzID0gbnVsbDtcclxuICB2YXIgaWR4ID0gMDtcclxuXHJcbiAgaWYgKCF2YWx1ZXMpIHtcclxuICAgIC8vIE5vIHByZXZpb3VzbHkgc3VibWl0dGVkIHZhbHVlcywgbm8gbmVlZCB0byBnbyBhbnkgZnVydGhlclxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy52aWV3LmlucHV0ZmllbGQgJiYgdGhpcy5zY2hlbWFFbGVtZW50KSB7XHJcbiAgICAvLyBDYXNlIDE6IG5vZGUgaXMgYSBzaW1wbGUgaW5wdXQgZmllbGQgdGhhdCBsaW5rcyB0byBhIGtleSBpbiB0aGUgc2NoZW1hLlxyXG4gICAgLy8gVGhlIHNjaGVtYSBrZXkgbG9va3MgdHlwaWNhbGx5IGxpa2U6XHJcbiAgICAvLyAgZm9vLmJhcltdLmJhei50b3RvW10udHJ1Y1tdLmJpZHVsZVxyXG4gICAgLy8gVGhlIGdvYWwgaXMgdG8gYXBwbHkgdGhlIGFycmF5IHBhdGggYW5kIHRydW5jYXRlIHRoZSBrZXkgdG8gdGhlIGxhc3RcclxuICAgIC8vIGFycmF5IHdlJ3JlIGludGVyZXN0ZWQgaW4sIGUuZy4gd2l0aCBhbiBhcnJheVBhdGggWzQsIDJdOlxyXG4gICAgLy8gIGZvby5iYXJbNF0uYmF6LnRvdG9bMl1cclxuICAgIGtleSA9IHRydW5jYXRlVG9BcnJheURlcHRoKHRoaXMuZm9ybUVsZW1lbnQua2V5LCBhcnJheVBhdGgubGVuZ3RoKTtcclxuICAgIGtleSA9IGFwcGx5QXJyYXlQYXRoKGtleSwgYXJyYXlQYXRoKTtcclxuICAgIGFycmF5VmFsdWUgPSBqc29uZm9ybS51dGlsLmdldE9iaktleSh2YWx1ZXMsIGtleSk7XHJcbiAgICBpZiAoIWFycmF5VmFsdWUpIHtcclxuICAgICAgLy8gTm8ga2V5PyBUaGF0IG1lYW5zIHRoaXMgZmllbGQgaGFkIGJlZW4gbGVmdCBlbXB0eVxyXG4gICAgICAvLyBpbiBwcmV2aW91cyBzdWJtaXRcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBjaGlsZE51bWJlcnMgPSBfLm1hcCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkLmdldFByZXZpb3VzTnVtYmVyT2ZJdGVtcyh2YWx1ZXMsIGFycmF5UGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfLm1heChbXy5tYXgoY2hpbGROdW1iZXJzKSB8fCAwLCBhcnJheVZhbHVlLmxlbmd0aF0pO1xyXG4gIH1cclxuICBlbHNlIGlmICh0aGlzLnZpZXcuYXJyYXkpIHtcclxuICAgIC8vIENhc2UgMjogbm9kZSBpcyBhbiBhcnJheS1saWtlIG5vZGUsIGxvb2sgZm9yIGlucHV0IGZpZWxkc1xyXG4gICAgLy8gaW4gaXRzIGNoaWxkIHRlbXBsYXRlXHJcbiAgICByZXR1cm4gdGhpcy5jaGlsZFRlbXBsYXRlLmdldFByZXZpb3VzTnVtYmVyT2ZJdGVtcyh2YWx1ZXMsIGFycmF5UGF0aCk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gQ2FzZSAzOiBub2RlIGlzIGEgbGVhZiBvciBhIGNvbnRhaW5lcixcclxuICAgIC8vIHJlY3Vyc2UgdGhyb3VnaCB0aGUgbGlzdCBvZiBjaGlsZHJlbiBhbmQgcmV0dXJuIHRoZSBtYXhpbXVtXHJcbiAgICAvLyBudW1iZXIgb2YgaXRlbXMgZm91bmQgaW4gZWFjaCBzdWJ0cmVlXHJcbiAgICBjaGlsZE51bWJlcnMgPSBfLm1hcCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkLmdldFByZXZpb3VzTnVtYmVyT2ZJdGVtcyh2YWx1ZXMsIGFycmF5UGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfLm1heChjaGlsZE51bWJlcnMpIHx8IDA7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdHJ1Y3R1cmVkIG9iamVjdCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBmb3JtIHZhbHVlcyBlbnRlcmVkXHJcbiAqIGJ5IHRoZSB1c2VyIGZvciB0aGUgbm9kZSdzIHN1YnRyZWUuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBvYmplY3QgZm9sbG93cyB0aGUgc3RydWN0dXJlIG9mIHRoZSBKU09OIHNjaGVtYSB0aGF0IGdhdmVcclxuICogYmlydGggdG8gdGhlIGZvcm0uXHJcbiAqXHJcbiAqIE9idmlvdXNseSwgdGhlIG5vZGUgbXVzdCBoYXZlIGJlZW4gcmVuZGVyZWQgYmVmb3JlIHRoYXQgZnVuY3Rpb24gbWF5XHJcbiAqIGJlIGNhbGxlZC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdXBkYXRlQXJyYXlQYXRoIEFycmF5IHBhdGggdG8gdXNlIHRvIHByZXRlbmQgdGhhdFxyXG4gKiAgdGhlIGVudGVyZWQgdmFsdWVzIHdlcmUgYWN0dWFsbHkgZW50ZXJlZCBmb3IgYW5vdGhlciBpdGVtIGluIGFuIGFycmF5XHJcbiAqICAodGhpcyBpcyB1c2VkIHRvIG1vdmUgdmFsdWVzIGFyb3VuZCB3aGVuIGFuIGl0ZW0gaXMgaW5zZXJ0ZWQvcmVtb3ZlZC9tb3ZlZFxyXG4gKiAgaW4gYW4gYXJyYXkpXHJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IGZvbGxvd3MgdGhlIGRhdGEgc2NoZW1hIGFuZCBtYXRjaGVzIHRoZVxyXG4gKiAgdmFsdWVzIGVudGVyZWQgYnkgdGhlIHVzZXIuXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUuZ2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uICh1cGRhdGVBcnJheVBhdGgpIHtcclxuICAvLyBUaGUgdmFsdWVzIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcclxuICB2YXIgdmFsdWVzID0ge307XHJcblxyXG4gIGlmICghdGhpcy5lbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtTm9kZS5nZXRGb3JtVmFsdWVzIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBub2RlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYSBET00gZWxlbWVudCBpbiB0aGUgdHJlZScpO1xyXG4gIH1cclxuXHJcbiAgLy8gRm9ybSBmaWVsZHMgdmFsdWVzXHJcbiAgdmFyIGZvcm1BcnJheSA9ICQoJzppbnB1dCcsIHRoaXMuZWwpLnNlcmlhbGl6ZUFycmF5KCk7XHJcblxyXG4gIC8vIFNldCB2YWx1ZXMgdG8gZmFsc2UgZm9yIHVuc2V0IGNoZWNrYm94ZXMgYW5kIHJhZGlvIGJ1dHRvbnNcclxuICAvLyBiZWNhdXNlIHNlcmlhbGl6ZUFycmF5KCkgaWdub3JlcyB0aGVtXHJcbiAgZm9ybUFycmF5ID0gZm9ybUFycmF5LmNvbmNhdChcclxuICAgICQoJzppbnB1dFt0eXBlPWNoZWNrYm94XTpub3QoOmRpc2FibGVkKTpub3QoOmNoZWNrZWQpJywgdGhpcy5lbCkubWFwKCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHtcIm5hbWVcIjogdGhpcy5uYW1lLCBcInZhbHVlXCI6IHRoaXMuY2hlY2tlZH1cclxuICAgIH0pLmdldCgpXHJcbiAgKTtcclxuXHJcbiAgaWYgKHVwZGF0ZUFycmF5UGF0aCkge1xyXG4gICAgXy5lYWNoKGZvcm1BcnJheSwgZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgIHBhcmFtLm5hbWUgPSBhcHBseUFycmF5UGF0aChwYXJhbS5uYW1lLCB1cGRhdGVBcnJheVBhdGgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgdW5kZXJseWluZyBkYXRhIHNjaGVtYVxyXG4gIHZhciBmb3JtU2NoZW1hID0gdGhpcy5vd25lclRyZWUuZm9ybURlc2Muc2NoZW1hO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1BcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgLy8gUmV0cmlldmUgdGhlIGtleSBkZWZpbml0aW9uIGZyb20gdGhlIGRhdGEgc2NoZW1hXHJcbiAgICB2YXIgbmFtZSA9IGZvcm1BcnJheVtpXS5uYW1lO1xyXG4gICAgdmFyIGVsdFNjaGVtYSA9IGdldFNjaGVtYUtleShmb3JtU2NoZW1hLnByb3BlcnRpZXMsIG5hbWUpO1xyXG4gICAgdmFyIGFycmF5TWF0Y2ggPSBudWxsO1xyXG4gICAgdmFyIGN2YWwgPSBudWxsO1xyXG5cclxuICAgIC8vIFNraXAgdGhlIGlucHV0IGZpZWxkIGlmIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNjaGVtYVxyXG4gICAgaWYgKCFlbHRTY2hlbWEpIGNvbnRpbnVlO1xyXG5cclxuICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBjaGVja2JveGVzIHNlcGFyYXRlbHkgYXMgdGhlIGlkZWEgaXMgdG8gZ2VuZXJhdGVcclxuICAgIC8vIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgZW51bWVyYXRpb24gaXRlbXMgdGhhdCB0aGUgdXNlclxyXG4gICAgLy8gc2VsZWN0ZWQuXHJcbiAgICBpZiAoZWx0U2NoZW1hLl9qc29uZm9ybV9jaGVja2JveGVzX2FzX2FycmF5KSB7XHJcbiAgICAgIGFycmF5TWF0Y2ggPSBuYW1lLm1hdGNoKC9cXFsoWzAtOV0qKVxcXSQvKTtcclxuICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXFsoWzAtOV0qKVxcXSQvLCAnJyk7XHJcbiAgICAgICAgY3ZhbCA9IGpzb25mb3JtLnV0aWwuZ2V0T2JqS2V5KHZhbHVlcywgbmFtZSkgfHwgW107XHJcbiAgICAgICAgaWYgKGZvcm1BcnJheVtpXS52YWx1ZSA9PT0gJzEnKSB7XHJcbiAgICAgICAgICAvLyBWYWx1ZSBzZWxlY3RlZCwgcHVzaCB0aGUgY29ycmVzcG9uZGluZyBlbnVtZXJhdGlvbiBpdGVtXHJcbiAgICAgICAgICAvLyB0byB0aGUgZGF0YSByZXN1bHRcclxuICAgICAgICAgIGN2YWwucHVzaChlbHRTY2hlbWFbJ2VudW0nXVtwYXJzZUludChhcnJheU1hdGNoWzFdLDEwKV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBqc29uZm9ybS51dGlsLnNldE9iaktleSh2YWx1ZXMsIG5hbWUsIGN2YWwpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHlwZSBjYXN0aW5nXHJcbiAgICBpZiAoZWx0U2NoZW1hLnR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICBpZiAoZm9ybUFycmF5W2ldLnZhbHVlID09PSAnMCcpIHtcclxuICAgICAgICBmb3JtQXJyYXlbaV0udmFsdWUgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JtQXJyYXlbaV0udmFsdWUgPSAhIWZvcm1BcnJheVtpXS52YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChlbHRTY2hlbWEudHlwZSA9PT0gJ251bWJlcicpIHx8XHJcbiAgICAgIChlbHRTY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInKSkge1xyXG4gICAgICBpZiAoXy5pc1N0cmluZyhmb3JtQXJyYXlbaV0udmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKCFmb3JtQXJyYXlbaV0udmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICBmb3JtQXJyYXlbaV0udmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcihmb3JtQXJyYXlbaV0udmFsdWUpKSkge1xyXG4gICAgICAgICAgZm9ybUFycmF5W2ldLnZhbHVlID0gTnVtYmVyKGZvcm1BcnJheVtpXS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKGVsdFNjaGVtYS50eXBlID09PSAnc3RyaW5nJykgJiZcclxuICAgICAgKGZvcm1BcnJheVtpXS52YWx1ZSA9PT0gJycpICYmXHJcbiAgICAgICFlbHRTY2hlbWEuX2pzb25mb3JtX2FsbG93RW1wdHkpIHtcclxuICAgICAgZm9ybUFycmF5W2ldLnZhbHVlPW51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoKGVsdFNjaGVtYS50eXBlID09PSAnb2JqZWN0JykgJiZcclxuICAgICAgXy5pc1N0cmluZyhmb3JtQXJyYXlbaV0udmFsdWUpICYmXHJcbiAgICAgIChmb3JtQXJyYXlbaV0udmFsdWUuc3Vic3RyaW5nKDAsMSkgPT09ICd7JykpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3JtQXJyYXlbaV0udmFsdWUgPSBKU09OLnBhcnNlKGZvcm1BcnJheVtpXS52YWx1ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBmb3JtQXJyYXlbaV0udmFsdWUgPSB7fTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9UT0RPIGlzIHRoaXMgZHVlIHRvIGEgc2VyaWFsaXphdGlvbiBidWc/XHJcbiAgICBpZiAoKGVsdFNjaGVtYS50eXBlID09PSAnb2JqZWN0JykgJiZcclxuICAgICAgKGZvcm1BcnJheVtpXS52YWx1ZSA9PT0gJ251bGwnIHx8IGZvcm1BcnJheVtpXS52YWx1ZSA9PT0gJycpKSB7XHJcbiAgICAgIGZvcm1BcnJheVtpXS52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZvcm1BcnJheVtpXS5uYW1lICYmIChmb3JtQXJyYXlbaV0udmFsdWUgIT09IG51bGwpKSB7XHJcbiAgICAgIGpzb25mb3JtLnV0aWwuc2V0T2JqS2V5KHZhbHVlcywgZm9ybUFycmF5W2ldLm5hbWUsIGZvcm1BcnJheVtpXS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNvbnNvbGUubG9nKFwiRm9ybSB2YWx1ZVwiLHZhbHVlcyk7XHJcbiAgcmV0dXJuIHZhbHVlcztcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIG5vZGUuXHJcbiAqXHJcbiAqIFJlbmRlcmluZyBpcyBkb25lIGluIHRocmVlIHN0ZXBzOiBIVE1MIGdlbmVyYXRpb24sIERPTSBlbGVtZW50IGNyZWF0aW9uXHJcbiAqIGFuZCBpbnNlcnRpb24sIGFuZCBhbiBlbmhhbmNlIHN0ZXAgdG8gYmluZCBldmVudCBoYW5kbGVycy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gZWwgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIHJlbmRlcmVkLiBUaGVcclxuICogIG5vZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIHJpZ2h0IHBvc2l0aW9uIGJhc2VkIG9uIGl0cyBcImNoaWxkUG9zXCIgcHJvcGVydHkuXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgdmFyIGh0bWwgPSB0aGlzLmdlbmVyYXRlKCk7XHJcbiAgdGhpcy5zZXRDb250ZW50KGh0bWwsIGVsKTtcclxuICB0aGlzLmVuaGFuY2UoKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogSW5zZXJ0cy9VcGRhdGVzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG5vZGUgaW4gdGhlIERPTS5cclxuICpcclxuICogSWYgdGhlIEhUTUwgaXMgYW4gdXBkYXRlLCB0aGUgbmV3IEhUTUwgY29udGVudCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cclxuICogVGhlIG5ldyBIVE1MIGNvbnRlbnQgaXMgbm90IG1vdmVkIGFyb3VuZCBpbiB0aGUgRE9NIGluIHBhcnRpY3VsYXIuXHJcbiAqXHJcbiAqIFRoZSBIVE1MIGlzIGluc2VydGVkIGF0IHRoZSByaWdodCBwb3NpdGlvbiBpbiBpdHMgcGFyZW50J3MgRE9NIHN1YnRyZWVcclxuICogb3RoZXJ3aXNlICh3ZWxsLCBwcm92aWRlZCB0aGVyZSBhcmUgZW5vdWdoIGNoaWxkcmVuLCBidXQgdGhhdCBzaG91bGQgYWx3YXlzXHJcbiAqIGJlIHRoZSBjYXNlKS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIFRoZSBIVE1MIGNvbnRlbnQgdG8gcmVuZGVyXHJcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50RWwgVGhlIERPTSBlbGVtZW50IHRoYXQgaXMgdG8gY29udGFpbiB0aGUgRE9NIG5vZGUuXHJcbiAqICBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbCAodGhlIG5vZGUncyBwYXJlbnQgaXMgdXNlZCBvdGhlcndpc2UpIGFuZFxyXG4gKiAgaXMgaWdub3JlZCBpZiB0aGUgbm9kZSB0byByZW5kZXIgaXMgYWxyZWFkeSBpbiB0aGUgRE9NIHRyZWUuXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChodG1sLCBwYXJlbnRFbCkge1xyXG4gIHZhciBub2RlID0gJChodG1sKTtcclxuICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudEVsIHx8XHJcbiAgICAodGhpcy5wYXJlbnROb2RlID8gdGhpcy5wYXJlbnROb2RlLmVsIDogdGhpcy5vd25lclRyZWUuZG9tUm9vdCk7XHJcbiAgdmFyIG5leHRTaWJsaW5nID0gbnVsbDtcclxuXHJcbiAgaWYgKHRoaXMuZWwpIHtcclxuICAgIC8vIFJlcGxhY2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBET00gZWxlbWVudCBpZiB0aGUgbm9kZSBpcyBhbHJlYWR5IGluIHRoZSB0cmVlXHJcbiAgICAkKHRoaXMuZWwpLnJlcGxhY2VXaXRoKG5vZGUpO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBpbiB0aGUgRE9NIGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmVcclxuICAgIG5leHRTaWJsaW5nID0gJChwYXJlbnROb2RlKS5jaGlsZHJlbigpLmdldCh0aGlzLmNoaWxkUG9zKTtcclxuICAgIGlmIChuZXh0U2libGluZykge1xyXG4gICAgICAkKG5leHRTaWJsaW5nKS5iZWZvcmUobm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgJChwYXJlbnROb2RlKS5hcHBlbmQobm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTYXZlIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm0gbm9kZSBhbmQgdGhlIGdlbmVyYXRlZCBIVE1MXHJcbiAgdGhpcy5lbCA9IG5vZGU7XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgbm9kZSdzIHN1YnRyZWUsIGV4dHJhY3RpbmcgRE9NIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIG5vZGVzXHJcbiAgLy8gZnJvbSB0aGUgZ2VuZXJhdGVkIEhUTUxcclxuICB0aGlzLnVwZGF0ZUVsZW1lbnQodGhpcy5lbCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIERPTSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZS5cclxuICpcclxuICogT25seSBub2RlcyB0aGF0IGhhdmUgSUQgYXJlIGRpcmVjdGx5IGFzc29jaWF0ZWQgd2l0aCBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS51cGRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcclxuICBpZiAodGhpcy5pZCkge1xyXG4gICAgdGhpcy5lbCA9ICQoJyMnICsgZXNjYXBlU2VsZWN0b3IodGhpcy5pZCksIGRvbU5vZGUpLmdldCgwKTtcclxuICAgIGlmICh0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmdldEVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5lbCA9IHRoaXMudmlldy5nZXRFbGVtZW50KHRoaXMuZWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKCh0aGlzLmZpZWxkdGVtcGxhdGUgIT09IGZhbHNlKSAmJlxyXG4gICAgICB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmZpZWxkdGVtcGxhdGUpIHtcclxuICAgICAgLy8gVGhlIGZpZWxkIHRlbXBsYXRlIHdyYXBzIHRoZSBlbGVtZW50IHR3byBvciB0aHJlZSBsZXZlbCBkZWVwXHJcbiAgICAgIC8vIGluIHRoZSBET00gdHJlZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlcmUgaXMgYW55dGhpbmcgcHJlcGVuZGVkXHJcbiAgICAgIC8vIG9yIGFwcGVuZGVkIHRvIHRoZSBpbnB1dCBmaWVsZFxyXG4gICAgICB0aGlzLmVsID0gJCh0aGlzLmVsKS5wYXJlbnQoKS5wYXJlbnQoKTtcclxuICAgICAgaWYgKHRoaXMucHJlcGVuZCB8fCB0aGlzLnByZXBlbmQpIHtcclxuICAgICAgICB0aGlzLmVsID0gdGhpcy5lbC5wYXJlbnQoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVsID0gdGhpcy5lbC5nZXQoMCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS52aWV3ICYmXHJcbiAgICAgIHRoaXMucGFyZW50Tm9kZS52aWV3LmNoaWxkVGVtcGxhdGUpIHtcclxuICAgICAgLy8gVE9ETzogdGhlIGNoaWxkIHRlbXBsYXRlIG1heSBpbnRyb2R1Y2UgbW9yZSB0aGFuIG9uZSBsZXZlbCxcclxuICAgICAgLy8gc28gdGhlIG51bWJlciBvZiBsZXZlbHMgaW50cm9kdWNlZCBzaG91bGQgcmF0aGVyIGJlIGV4cG9zZWRcclxuICAgICAgLy8gc29tZWhvdyBpbiBqc29uZm9ybS5maWVsZHRlbXBsYXRlLlxyXG4gICAgICB0aGlzLmVsID0gJCh0aGlzLmVsKS5wYXJlbnQoKS5nZXQoMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfLmVhY2godGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICBjaGlsZC51cGRhdGVFbGVtZW50KHRoaXMuZWwgfHwgZG9tTm9kZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0aGUgdmlldydzIEhUTUwgY29udGVudCBmb3IgdGhlIHVuZGVybHlpbmcgbW9kZWwuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBkYXRhID0ge1xyXG4gICAgaWQ6IHRoaXMuaWQsXHJcbiAgICBrZXlkYXNoOiB0aGlzLmtleWRhc2gsXHJcbiAgICBlbHQ6IHRoaXMuZm9ybUVsZW1lbnQsXHJcbiAgICBzY2hlbWE6IHRoaXMuc2NoZW1hRWxlbWVudCxcclxuICAgIG5vZGU6IHRoaXMsXHJcbiAgICB2YWx1ZTogaXNTZXQodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlIDogJycsXHJcbiAgICBlc2NhcGU6IGVzY2FwZUhUTUxcclxuICB9O1xyXG4gIHZhciB0ZW1wbGF0ZSA9IG51bGw7XHJcbiAgdmFyIGh0bWwgPSAnJztcclxuXHJcbiAgLy8gQ29tcGxldGUgdGhlIGRhdGEgY29udGV4dCBpZiBuZWVkZWRcclxuICBpZiAodGhpcy5vd25lclRyZWUuZm9ybURlc2Mub25CZWZvcmVSZW5kZXIpIHtcclxuICAgIHRoaXMub3duZXJUcmVlLmZvcm1EZXNjLm9uQmVmb3JlUmVuZGVyKGRhdGEsIHRoaXMpO1xyXG4gIH1cclxuICBpZiAodGhpcy52aWV3Lm9uQmVmb3JlUmVuZGVyKSB7XHJcbiAgICB0aGlzLnZpZXcub25CZWZvcmVSZW5kZXIoZGF0YSwgdGhpcyk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2UgdGhlIHRlbXBsYXRlIHRoYXQgJ29uQmVmb3JlUmVuZGVyJyBtYXkgaGF2ZSBzZXQsXHJcbiAgLy8gZmFsbGluZyBiYWNrIHRvIHRoYXQgb2YgdGhlIGZvcm0gZWxlbWVudCBvdGhlcndpc2VcclxuICBpZiAodGhpcy50ZW1wbGF0ZSkge1xyXG4gICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xyXG4gIH1cclxuICBlbHNlIGlmICh0aGlzLmZvcm1FbGVtZW50ICYmIHRoaXMuZm9ybUVsZW1lbnQudGVtcGxhdGUpIHtcclxuICAgIHRlbXBsYXRlID0gdGhpcy5mb3JtRWxlbWVudC50ZW1wbGF0ZTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB0ZW1wbGF0ZSA9IHRoaXMudmlldy50ZW1wbGF0ZTtcclxuICB9XHJcblxyXG4gIC8vIFdyYXAgdGhlIHZpZXcgdGVtcGxhdGUgaW4gdGhlIGdlbmVyaWMgZmllbGQgdGVtcGxhdGVcclxuICAvLyAobm90ZSB0aGUgc3RyaWN0IGVxdWFsaXR5IHRvICdmYWxzZScsIG5lZWRlZCBhcyB3ZSBmYWxsYmFja1xyXG4gIC8vIHRvIHRoZSB2aWV3J3Mgc2V0dGluZyBvdGhlcndpc2UpXHJcbiAgaWYgKCh0aGlzLmZpZWxkdGVtcGxhdGUgIT09IGZhbHNlKSAmJlxyXG4gICAgKHRoaXMuZmllbGR0ZW1wbGF0ZSB8fCB0aGlzLnZpZXcuZmllbGR0ZW1wbGF0ZSkpIHtcclxuICAgIHRlbXBsYXRlID0ganNvbmZvcm0uZmllbGRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBXcmFwIHRoZSBjb250ZW50IGluIHRoZSBjaGlsZCB0ZW1wbGF0ZSBvZiBpdHMgcGFyZW50IGlmIG5lY2Vzc2FyeS5cclxuICBpZiAodGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS52aWV3ICYmXHJcbiAgICB0aGlzLnBhcmVudE5vZGUudmlldy5jaGlsZFRlbXBsYXRlKSB7XHJcbiAgICB0ZW1wbGF0ZSA9IHRoaXMucGFyZW50Tm9kZS52aWV3LmNoaWxkVGVtcGxhdGUodGVtcGxhdGUpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJlcGFyZSB0aGUgSFRNTCBvZiB0aGUgY2hpbGRyZW5cclxuICB2YXIgY2hpbGRyZW5odG1sID0gJyc7XHJcbiAgXy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgY2hpbGRyZW5odG1sICs9IGNoaWxkLmdlbmVyYXRlKCk7XHJcbiAgfSk7XHJcbiAgZGF0YS5jaGlsZHJlbiA9IGNoaWxkcmVuaHRtbDtcclxuXHJcbiAgZGF0YS5maWVsZEh0bWxDbGFzcyA9ICcnO1xyXG4gIGlmICh0aGlzLm93bmVyVHJlZSAmJlxyXG4gICAgICB0aGlzLm93bmVyVHJlZS5mb3JtRGVzYyAmJlxyXG4gICAgICB0aGlzLm93bmVyVHJlZS5mb3JtRGVzYy5wYXJhbXMgJiZcclxuICAgICAgdGhpcy5vd25lclRyZWUuZm9ybURlc2MucGFyYW1zLmZpZWxkSHRtbENsYXNzKSB7XHJcbiAgICBkYXRhLmZpZWxkSHRtbENsYXNzID0gdGhpcy5vd25lclRyZWUuZm9ybURlc2MucGFyYW1zLmZpZWxkSHRtbENsYXNzO1xyXG4gIH1cclxuICBpZiAodGhpcy5mb3JtRWxlbWVudCAmJlxyXG4gICAgICAodHlwZW9mIHRoaXMuZm9ybUVsZW1lbnQuZmllbGRIdG1sQ2xhc3MgIT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgZGF0YS5maWVsZEh0bWxDbGFzcyA9IHRoaXMuZm9ybUVsZW1lbnQuZmllbGRIdG1sQ2xhc3M7XHJcbiAgfVxyXG5cclxuICAvLyBBcHBseSB0aGUgSFRNTCB0ZW1wbGF0ZVxyXG4gIGh0bWwgPSBfLnRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhLCBmaWVsZFRlbXBsYXRlU2V0dGluZ3MpO1xyXG4gIHJldHVybiBodG1sO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBFbmhhbmNlcyB0aGUgdmlldyB3aXRoIGFkZGl0aW9uYWwgbG9naWMsIGJpbmRpbmcgZXZlbnQgaGFuZGxlcnNcclxuICogaW4gcGFydGljdWxhci5cclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGFsc28gcnVucyB0aGUgXCJpbnNlcnRcIiBldmVudCBoYW5kbGVyIG9mIHRoZSB2aWV3IGFuZFxyXG4gKiBmb3JtIGVsZW1lbnQgaWYgdGhleSBleGlzdCAoc3RhcnRpbmcgd2l0aCB0aGF0IG9mIHRoZSB2aWV3KVxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5lbmhhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBub2RlID0gdGhpcztcclxuICB2YXIgaGFuZGxlcnMgPSBudWxsO1xyXG4gIHZhciBoYW5kbGVyID0gbnVsbDtcclxuICB2YXIgZm9ybURhdGEgPSBfLmNsb25lKHRoaXMub3duZXJUcmVlLmZvcm1EZXNjLnRwbGRhdGEpIHx8IHt9O1xyXG5cclxuICBpZiAodGhpcy5mb3JtRWxlbWVudCkge1xyXG4gICAgLy8gQ2hlY2sgdGhlIHZpZXcgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlIGFzIGl0IG1heSBkZWZpbmUgYW4gXCJvbkluc2VydFwiXHJcbiAgICAvLyBldmVudCBoYW5kbGVyIHRvIGJlIHJ1biByaWdodCBhd2F5XHJcbiAgICBpZiAodGhpcy52aWV3Lm9uSW5zZXJ0KSB7XHJcbiAgICAgIHRoaXMudmlldy5vbkluc2VydCh7IHRhcmdldDogJCh0aGlzLmVsKSB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMgfHwgdGhpcy5mb3JtRWxlbWVudC5oYW5kbGVycztcclxuXHJcbiAgICAvLyBUcmlnZ2VyIHRoZSBcImluc2VydFwiIGV2ZW50IGhhbmRsZXJcclxuICAgIGhhbmRsZXIgPSB0aGlzLm9uSW5zZXJ0IHx8IHRoaXMuZm9ybUVsZW1lbnQub25JbnNlcnQ7XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICBoYW5kbGVyKHsgdGFyZ2V0OiAkKHRoaXMuZWwpIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICAgIF8uZWFjaChoYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIG9uZXZlbnQpIHtcclxuICAgICAgICBpZiAob25ldmVudCA9PT0gJ2luc2VydCcpIHtcclxuICAgICAgICAgIGhhbmRsZXIoeyB0YXJnZXQ6ICQodGhpcy5lbCkgfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyB3YXkgdG8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgaWYgdGhlIERPTSBlbGVtZW50IGlzIHVua25vd25cclxuICAgIC8vIFRPRE86IGZpbmQgc29tZSB3YXkgdG8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgZXZlbiB3aGVuIHRoaXMuZWwgaXMgbm90IHNldC5cclxuICAgIGlmICh0aGlzLmVsKSB7XHJcblxyXG4gICAgICAvLyBSZWdpc3RlciBzcGVjaWZpYyBldmVudCBoYW5kbGVyc1xyXG4gICAgICAvLyBUT0RPOiBBZGQgc3VwcG9ydCBmb3Igb3RoZXIgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgaWYgKHRoaXMub25DaGFuZ2UpXHJcbiAgICAgICAgJCh0aGlzLmVsKS5iaW5kKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHsgbm9kZS5vbkNoYW5nZShldnQsIG5vZGUpOyB9KTtcclxuICAgICAgaWYgKHRoaXMudmlldy5vbkNoYW5nZSlcclxuICAgICAgICAkKHRoaXMuZWwpLmJpbmQoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2dCkgeyBub2RlLnZpZXcub25DaGFuZ2UoZXZ0LCBub2RlKTsgfSk7XHJcbiAgICAgIGlmICh0aGlzLmZvcm1FbGVtZW50Lm9uQ2hhbmdlKVxyXG4gICAgICAgICQodGhpcy5lbCkuYmluZCgnY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7IG5vZGUuZm9ybUVsZW1lbnQub25DaGFuZ2UoZXZ0LCBub2RlKTsgfSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5vbkNsaWNrKVxyXG4gICAgICAgICQodGhpcy5lbCkuYmluZCgnY2xpY2snLCBmdW5jdGlvbihldnQpIHsgbm9kZS5vbkNsaWNrKGV2dCwgbm9kZSk7IH0pO1xyXG4gICAgICBpZiAodGhpcy52aWV3Lm9uQ2xpY2spXHJcbiAgICAgICAgJCh0aGlzLmVsKS5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkgeyBub2RlLnZpZXcub25DbGljayhldnQsIG5vZGUpOyB9KTtcclxuICAgICAgaWYgKHRoaXMuZm9ybUVsZW1lbnQub25DbGljaylcclxuICAgICAgICAkKHRoaXMuZWwpLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7IG5vZGUuZm9ybUVsZW1lbnQub25DbGljayhldnQsIG5vZGUpOyB9KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9uS2V5VXApXHJcbiAgICAgICAgJCh0aGlzLmVsKS5iaW5kKCdrZXl1cCcsIGZ1bmN0aW9uKGV2dCkgeyBub2RlLm9uS2V5VXAoZXZ0LCBub2RlKTsgfSk7XHJcbiAgICAgIGlmICh0aGlzLnZpZXcub25LZXlVcClcclxuICAgICAgICAkKHRoaXMuZWwpLmJpbmQoJ2tleXVwJywgZnVuY3Rpb24oZXZ0KSB7IG5vZGUudmlldy5vbktleVVwKGV2dCwgbm9kZSk7IH0pO1xyXG4gICAgICBpZiAodGhpcy5mb3JtRWxlbWVudC5vbktleVVwKVxyXG4gICAgICAgICQodGhpcy5lbCkuYmluZCgna2V5dXAnLCBmdW5jdGlvbihldnQpIHsgbm9kZS5mb3JtRWxlbWVudC5vbktleVVwKGV2dCwgbm9kZSk7IH0pO1xyXG5cclxuICAgICAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICAgICAgXy5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgb25ldmVudCkge1xyXG4gICAgICAgICAgaWYgKG9uZXZlbnQgIT09ICdpbnNlcnQnKSB7XHJcbiAgICAgICAgICAgICQodGhpcy5lbCkuYmluZChvbmV2ZW50LCBmdW5jdGlvbihldnQpIHsgaGFuZGxlcihldnQsIG5vZGUpOyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEF1dG8tdXBkYXRlIGxlZ2VuZCBiYXNlZCBvbiB0aGUgaW5wdXQgZmllbGQgdGhhdCdzIGFzc29jaWF0ZWQgd2l0aCBpdFxyXG4gICAgaWYgKHRoaXMubGVnZW5kQ2hpbGQgJiYgdGhpcy5sZWdlbmRDaGlsZC5mb3JtRWxlbWVudCkge1xyXG4gICAgICAkKHRoaXMubGVnZW5kQ2hpbGQuZWwpLmJpbmQoJ2tleXVwJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGlmIChub2RlLmZvcm1FbGVtZW50ICYmIG5vZGUuZm9ybUVsZW1lbnQubGVnZW5kICYmIG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgbm9kZS5sZWdlbmQgPSBhcHBseUFycmF5UGF0aChub2RlLmZvcm1FbGVtZW50LmxlZ2VuZCwgbm9kZS5hcnJheVBhdGgpO1xyXG4gICAgICAgICAgZm9ybURhdGEuaWR4ID0gKG5vZGUuYXJyYXlQYXRoLmxlbmd0aCA+IDApID9cclxuICAgICAgICAgICAgbm9kZS5hcnJheVBhdGhbbm9kZS5hcnJheVBhdGgubGVuZ3RoLTFdICsgMSA6XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGRQb3MgKyAxO1xyXG4gICAgICAgICAgZm9ybURhdGEudmFsdWUgPSAkKGV2dC50YXJnZXQpLnZhbCgpO1xyXG4gICAgICAgICAgbm9kZS5sZWdlbmQgPSBfLnRlbXBsYXRlKG5vZGUubGVnZW5kLCBmb3JtRGF0YSwgdmFsdWVUZW1wbGF0ZVNldHRpbmdzKTtcclxuICAgICAgICAgICQobm9kZS5wYXJlbnROb2RlLmVsKS50cmlnZ2VyKCdsZWdlbmRVcGRhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlY3Vyc2UgZG93biB0aGUgdHJlZSB0byBlbmhhbmNlIGNoaWxkcmVuXHJcbiAgXy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgY2hpbGQuZW5oYW5jZSgpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhbiBpdGVtIGluIHRoZSBhcnJheSBhdCB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uIGFuZCByZW5kZXJzIHRoZSBpdGVtLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBJbnNlcnRpb24gaW5kZXhcclxuICovXHJcbmZvcm1Ob2RlLnByb3RvdHlwZS5pbnNlcnRBcnJheUl0ZW0gPSBmdW5jdGlvbiAoaWR4LCBkb21FbGVtZW50KSB7XHJcbiAgdmFyIGkgPSAwO1xyXG5cclxuICAvLyBJbnNlcnQgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBpZiBpbmRleCBpcyBub3QgZ2l2ZW5cclxuICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlkeCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBhZGRpdGlvbmFsIGFycmF5IGl0ZW0gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCxcclxuICAvLyB1c2luZyB0aGUgaXRlbSB0ZW1wbGF0ZSBjcmVhdGVkIHdoZW4gdHJlZSB3YXMgaW5pdGlhbGl6ZWRcclxuICAvLyAodGhlIGNhbGwgdG8gcmVzZXRWYWx1ZXMgZW5zdXJlcyB0aGF0ICdhcnJheVBhdGgnIGlzIGNvcnJlY3RseSBzZXQpXHJcbiAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZFRlbXBsYXRlLmNsb25lKCk7XHJcbiAgdGhpcy5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbiAgY2hpbGQucmVzZXRWYWx1ZXMoKTtcclxuXHJcbiAgLy8gVG8gY3JlYXRlIGEgYmxhbmsgYXJyYXkgaXRlbSBhdCB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uLFxyXG4gIC8vIHNoaWZ0IHZhbHVlcyBkb3duIHN0YXJ0aW5nIGF0IHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cclxuICAvLyBvbmUgdG8gaW5zZXJ0IChub3RlIHdlIHN0YXJ0IHdpdGggdGhlIGVuZCBvZiB0aGUgYXJyYXkgb24gcHVycG9zZSlcclxuICBmb3IgKGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aC0yOyBpID49IGlkeDsgaS0tKSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuW2ldLm1vdmVWYWx1ZXNUbyh0aGlzLmNoaWxkcmVuW2krMV0pO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgYmxhbmsgbm9kZSB3ZSd2ZSBjcmVhdGVkIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICB0aGlzLmNoaWxkcmVuW2lkeF0ucmVzZXRWYWx1ZXMoKTtcclxuICB0aGlzLmNoaWxkcmVuW2lkeF0uY29tcHV0ZUluaXRpYWxWYWx1ZXMoKTtcclxuXHJcbiAgLy8gUmUtcmVuZGVyIGFsbCBjaGlsZHJlbiB0aGF0IGhhdmUgY2hhbmdlZFxyXG4gIGZvciAoaSA9IGlkeDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyKGRvbUVsZW1lbnQpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXggbnVtYmVyIG9mIHRoZSBpdGVtIHRvIHJlbW92ZVxyXG4gKi9cclxuZm9ybU5vZGUucHJvdG90eXBlLmRlbGV0ZUFycmF5SXRlbSA9IGZ1bmN0aW9uIChpZHgpIHtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGNoaWxkID0gbnVsbDtcclxuXHJcbiAgLy8gRGVsZXRlIGxhc3QgaXRlbSBpZiBubyBpbmRleCBpcyBnaXZlblxyXG4gIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWR4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxO1xyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSB2YWx1ZXMgdXAgaW4gdGhlIGFycmF5XHJcbiAgZm9yIChpID0gaWR4OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGgtMTsgaSsrKSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuW2krMV0ubW92ZVZhbHVlc1RvKHRoaXMuY2hpbGRyZW5baV0pO1xyXG4gICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIoKTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0aGUgbGFzdCBhcnJheSBpdGVtIGZyb20gdGhlIERPTSB0cmVlIGFuZCBmcm9tIHRoZSBmb3JtIHRyZWVcclxuICB0aGlzLnJlbW92ZUNoaWxkKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bS9tYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGFuIGFycmF5IGZpZWxkXHJcbiAqIGlzIGFsbG93ZWQgdG8gaGF2ZSBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSBkZWZpbml0aW9uIG9mIHRoZSBmaWVsZHNcclxuICogaXQgY29udGFpbnMuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBwYXJzZXMgdGhlIHNjaGVtYSBkZWZpbml0aW9ucyBvZiB0aGUgYXJyYXkgaXRlbXMgdGhhdFxyXG4gKiBjb21wb3NlIHRoZSBjdXJyZW50IFwiYXJyYXlcIiBub2RlIGFuZCByZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mXHJcbiAqIFwibWF4SXRlbXNcIiBpdCBlbmNvdW50ZXJzIGFzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcywgYW5kIHRoZVxyXG4gKiBtYXhpbXVtIHZhbHVlIG9mIFwibWluSXRlbXNcIiBhcyB0aGUgbWluaW11bSBudW1iZXIgb2YgaXRlbXMuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiByZXBvcnRzIGEgLTEgZm9yIGVpdGhlciBvZiB0aGUgYm91bmRhcmllcyBpZiB0aGUgc2NoZW1hXHJcbiAqIGRvZXMgbm90IHB1dCBhbnkgY29uc3RyYWludCBvbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoZSBjdXJyZW50XHJcbiAqIGFycmF5IG1heSBoYXZlIG9mIGlmIHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IGFuIGFycmF5LlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYXJyYXkgYm91bmRhcmllcyBzaG91bGQgYmUgZGVmaW5lZCBpbiB0aGUgSlNPTiBTY2hlbWEgdXNpbmdcclxuICogXCJtaW5JdGVtc1wiIGFuZCBcIm1heEl0ZW1zXCIuIFRoZSBjb2RlIGFsc28gc3VwcG9ydHMgXCJtaW5MZW5ndGhcIiBhbmRcclxuICogXCJtYXhMZW5ndGhcIiBhcyBhIGZhbGxiYWNrLCBtb3N0bHkgYmVjYXVzZSBpdCB1c2VkIHRvIGJ5IG1pc3Rha2UgKHNlZSAjMjIpXHJcbiAqIGFuZCBiZWNhdXNlIG90aGVyIHBlb3BsZSBjb3VsZCBtYWtlIHRoZSBzYW1lIG1pc3Rha2UuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgXCJtaW5JdGVtc1wiIGFuZCBcIm1heEl0ZW1zXCJcclxuICogIHRoYXQgcmVwb3J0cyB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIgb2YgaXRlbXMgdGhhdCB0aGUgYXJyYXkgbWF5XHJcbiAqICBoYXZlICh2YWx1ZSBpcyAtMSB3aGVuIHRoZXJlIGlzIG5vIGNvbnN0cmFpbnQgZm9yIHRoYXQgYm91bmRhcnkpXHJcbiAqL1xyXG5mb3JtTm9kZS5wcm90b3R5cGUuZ2V0QXJyYXlCb3VuZGFyaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBib3VuZGFyaWVzID0ge1xyXG4gICAgbWluSXRlbXM6IC0xLFxyXG4gICAgbWF4SXRlbXM6IC0xXHJcbiAgfTtcclxuICBpZiAoIXRoaXMudmlldyB8fCAhdGhpcy52aWV3LmFycmF5KSByZXR1cm4gYm91bmRhcmllcztcclxuXHJcbiAgdmFyIGdldE5vZGVCb3VuZGFyaWVzID0gZnVuY3Rpb24gKG5vZGUsIGluaXRpYWxOb2RlKSB7XHJcbiAgICB2YXIgc2NoZW1hS2V5ID0gbnVsbDtcclxuICAgIHZhciBhcnJheUtleSA9IG51bGw7XHJcbiAgICB2YXIgYm91bmRhcmllcyA9IHtcclxuICAgICAgbWluSXRlbXM6IC0xLFxyXG4gICAgICBtYXhJdGVtczogLTFcclxuICAgIH07XHJcbiAgICBpbml0aWFsTm9kZSA9IGluaXRpYWxOb2RlIHx8IG5vZGU7XHJcblxyXG4gICAgaWYgKG5vZGUudmlldyAmJiBub2RlLnZpZXcuYXJyYXkgJiYgKG5vZGUgIT09IGluaXRpYWxOb2RlKSkge1xyXG4gICAgICAvLyBOZXcgYXJyYXkgbGV2ZWwgbm90IGxpbmtlZCB0byBhbiBhcnJheSBpbiB0aGUgc2NoZW1hLFxyXG4gICAgICAvLyBzbyBubyBzaXplIGNvbnN0cmFpbnRzXHJcbiAgICAgIHJldHVybiBib3VuZGFyaWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlLmtleSkge1xyXG4gICAgICAvLyBOb3RlIHRoZSBjb252ZXJzaW9uIHRvIHRhcmdldCB0aGUgYWN0dWFsIGFycmF5IGRlZmluaXRpb24gaW4gdGhlXHJcbiAgICAgIC8vIHNjaGVtYSB3aGVyZSBtaW5JdGVtcy9tYXhJdGVtcyBtYXkgYmUgZGVmaW5lZC4gSWYgd2UncmUgc3RpbGwgbG9va2luZ1xyXG4gICAgICAvLyBhdCB0aGUgaW5pdGlhbCBub2RlLCB0aGUgZ29hbCBpcyB0byBjb252ZXJ0IGZyb206XHJcbiAgICAgIC8vICBmb29bMF0uYmFyWzNdLmJheiB0byBmb29bXS5iYXJbXS5iYXpcclxuICAgICAgLy8gSWYgd2UncmUgbm90IGxvb2tpbmcgYXQgdGhlIGluaXRpYWwgbm9kZSwgdGhlIGdvYWwgaXMgdG8gbG9vayBhdCB0aGVcclxuICAgICAgLy8gY2xvc2VzdCBhcnJheSBwYXJlbnQ6XHJcbiAgICAgIC8vICBmb29bMF0uYmFyWzNdLmJheiB0byBmb29bXS5iYXJcclxuICAgICAgYXJyYXlLZXkgPSBub2RlLmtleS5yZXBsYWNlKC9cXFtbMC05XStcXF0vZywgJ1tdJyk7XHJcbiAgICAgIGlmIChub2RlICE9PSBpbml0aWFsTm9kZSkge1xyXG4gICAgICAgIGFycmF5S2V5ID0gYXJyYXlLZXkucmVwbGFjZSgvXFxbXFxdW15cXFtcXF1dKiQvLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgc2NoZW1hS2V5ID0gZ2V0U2NoZW1hS2V5KFxyXG4gICAgICAgIG5vZGUub3duZXJUcmVlLmZvcm1EZXNjLnNjaGVtYS5wcm9wZXJ0aWVzLFxyXG4gICAgICAgIGFycmF5S2V5XHJcbiAgICAgICk7XHJcbiAgICAgIGlmICghc2NoZW1hS2V5KSByZXR1cm4gYm91bmRhcmllcztcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5JdGVtczogc2NoZW1hS2V5Lm1pbkl0ZW1zIHx8IHNjaGVtYUtleS5taW5MZW5ndGggfHwgLTEsXHJcbiAgICAgICAgbWF4SXRlbXM6IHNjaGVtYUtleS5tYXhJdGVtcyB8fCBzY2hlbWFLZXkubWF4TGVuZ3RoIHx8IC0xXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgXy5lYWNoKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBzdWJCb3VuZGFyaWVzID0gZ2V0Tm9kZUJvdW5kYXJpZXMoY2hpbGQsIGluaXRpYWxOb2RlKTtcclxuICAgICAgICBpZiAoc3ViQm91bmRhcmllcy5taW5JdGVtcyAhPT0gLTEpIHtcclxuICAgICAgICAgIGlmIChib3VuZGFyaWVzLm1pbkl0ZW1zICE9PSAtMSkge1xyXG4gICAgICAgICAgICBib3VuZGFyaWVzLm1pbkl0ZW1zID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgYm91bmRhcmllcy5taW5JdGVtcyxcclxuICAgICAgICAgICAgICBzdWJCb3VuZGFyaWVzLm1pbkl0ZW1zXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYm91bmRhcmllcy5taW5JdGVtcyA9IHN1YkJvdW5kYXJpZXMubWluSXRlbXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWJCb3VuZGFyaWVzLm1heEl0ZW1zICE9PSAtMSkge1xyXG4gICAgICAgICAgaWYgKGJvdW5kYXJpZXMubWF4SXRlbXMgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGJvdW5kYXJpZXMubWF4SXRlbXMgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICBib3VuZGFyaWVzLm1heEl0ZW1zLFxyXG4gICAgICAgICAgICAgIHN1YkJvdW5kYXJpZXMubWF4SXRlbXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZGFyaWVzLm1heEl0ZW1zID0gc3ViQm91bmRhcmllcy5tYXhJdGVtcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvdW5kYXJpZXM7XHJcbiAgfTtcclxuICByZXR1cm4gZ2V0Tm9kZUJvdW5kYXJpZXModGhpcyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZvcm0gdHJlZSBjbGFzcy5cclxuICpcclxuICogSG9sZHMgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmb3JtLlxyXG4gKiBUaGUgdHJlZSBpcyBhbHdheXMgaW4gc3luYyB3aXRoIHRoZSByZW5kZXJlZCBmb3JtLCB0aGlzIGFsbG93cyB0byBwYXJzZVxyXG4gKiBpdCBlYXNpbHkuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxudmFyIGZvcm1UcmVlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZXZlbnRoYW5kbGVycyA9IFtdO1xyXG4gIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgdGhpcy5mb3JtRGVzYyA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIGZvcm0gdHJlZSBzdHJ1Y3R1cmUgZnJvbSB0aGUgSlNPTkZvcm0gb2JqZWN0XHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgb2YgdGhlIEpTT05Gb3JtIGxpYnJhcnkuXHJcbiAqXHJcbiAqIEluaXRpYWxpemF0aW9uIHN0ZXBzOlxyXG4gKiAxLiB0aGUgaW50ZXJuYWwgdHJlZSBzdHJ1Y3R1cmUgdGhhdCBtYXRjaGVzIHRoZSBKU09ORm9ybSBvYmplY3RcclxuICogIGdldHMgY3JlYXRlZCAoY2FsbCB0byBidWlsZFRyZWUpXHJcbiAqIDIuIGluaXRpYWwgdmFsdWVzIGFyZSBjb21wdXRlZCBmcm9tIHByZXZpb3VzbHkgc3VibWl0dGVkIHZhbHVlc1xyXG4gKiAgb3IgZnJvbSB0aGUgZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgSlNPTiBzY2hlbWEuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMsIHRoZSB0cmVlIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkIHRocm91Z2hcclxuICogYSBjYWxsIHRvIFwicmVuZGVyXCIuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxuZm9ybVRyZWUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoZm9ybURlc2MpIHtcclxuICBmb3JtRGVzYyA9IGZvcm1EZXNjIHx8IHt9O1xyXG5cclxuICAvLyBLZWVwIGEgcG9pbnRlciB0byB0aGUgaW5pdGlhbCBKU09ORm9ybVxyXG4gIC8vIChub3RlIGNsb25lIHJldHVybnMgYSBzaGFsbG93IGNvcHksIG9ubHkgZmlyc3QtbGV2ZWwgaXMgY2xvbmVkKVxyXG4gIHRoaXMuZm9ybURlc2MgPSBfLmNsb25lKGZvcm1EZXNjKTtcclxuXHJcbiAgLy8gQ29tcHV0ZSBmb3JtIHByZWZpeCBpZiBubyBwcmVmaXggaXMgZ2l2ZW4uXHJcbiAgdGhpcy5mb3JtRGVzYy5wcmVmaXggPSB0aGlzLmZvcm1EZXNjLnByZWZpeCB8fFxyXG4gICAgJ2pzb25mb3JtLScgKyBfLnVuaXF1ZUlkKCk7XHJcblxyXG4gIC8vIEpTT04gc2NoZW1hIHNob3J0aGFuZFxyXG4gIGlmICh0aGlzLmZvcm1EZXNjLnNjaGVtYSAmJiAhdGhpcy5mb3JtRGVzYy5zY2hlbWEucHJvcGVydGllcykge1xyXG4gICAgdGhpcy5mb3JtRGVzYy5zY2hlbWEgPSB7XHJcbiAgICAgIHByb3BlcnRpZXM6IHRoaXMuZm9ybURlc2Muc2NoZW1hXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIGxheW91dCBpcyBzZXRcclxuICB0aGlzLmZvcm1EZXNjLmZvcm0gPSB0aGlzLmZvcm1EZXNjLmZvcm0gfHwgW1xyXG4gICAgJyonLFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWN0aW9ucycsXHJcbiAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXHJcbiAgICAgICAgICB2YWx1ZTogJ1N1Ym1pdCdcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH1cclxuICBdO1xyXG4gIHRoaXMuZm9ybURlc2MuZm9ybSA9IChfLmlzQXJyYXkodGhpcy5mb3JtRGVzYy5mb3JtKSA/XHJcbiAgICB0aGlzLmZvcm1EZXNjLmZvcm0gOlxyXG4gICAgW3RoaXMuZm9ybURlc2MuZm9ybV0pO1xyXG5cclxuICB0aGlzLmZvcm1EZXNjLnBhcmFtcyA9IHRoaXMuZm9ybURlc2MucGFyYW1zIHx8IHt9O1xyXG5cclxuICAvLyBDcmVhdGUgdGhlIHJvb3Qgb2YgdGhlIHRyZWVcclxuICB0aGlzLnJvb3QgPSBuZXcgZm9ybU5vZGUoKTtcclxuICB0aGlzLnJvb3Qub3duZXJUcmVlID0gdGhpcztcclxuICB0aGlzLnJvb3QudmlldyA9IGpzb25mb3JtLmVsZW1lbnRUeXBlc1sncm9vdCddO1xyXG5cclxuICAvLyBHZW5lcmF0ZSB0aGUgdHJlZSBmcm9tIHRoZSBmb3JtIGRlc2NyaXB0aW9uXHJcbiAgdGhpcy5idWlsZFRyZWUoKTtcclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIG5vZGVcclxuICAvLyAoZm9yIGFycmF5cywgdGhlIGNvbXB1dGF0aW9uIGFjdHVhbGx5IGNyZWF0ZXMgdGhlIGZvcm0gbm9kZXMpXHJcbiAgdGhpcy5jb21wdXRlSW5pdGlhbFZhbHVlcygpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIHRoZSB0cmVlIGZyb20gdGhlIGZvcm0gZGVzY3JpcHRpb24uXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIHRyZWUgaXMgZmlyc3QgY3JlYXRlZC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5mb3JtVHJlZS5wcm90b3R5cGUuYnVpbGRUcmVlID0gZnVuY3Rpb24gKCkge1xyXG4gIC8vIFBhcnNlIGFuZCBnZW5lcmF0ZSB0aGUgZm9ybSBzdHJ1Y3R1cmUgYmFzZWQgb24gdGhlIGVsZW1lbnRzIGVuY291bnRlcmVkOlxyXG4gIC8vIC0gJyonIG1lYW5zIFwiZ2VuZXJhdGUgYWxsIHBvc3NpYmxlIGZpZWxkcyB1c2luZyBkZWZhdWx0IGxheW91dFwiXHJcbiAgLy8gLSBhIGtleSByZWZlcmVuY2UgdG8gdGFyZ2V0IGEgc3BlY2lmaWMgZGF0YSBlbGVtZW50XHJcbiAgLy8gLSBhIG1vcmUgY29tcGxleCBvYmplY3QgdG8gZ2VuZXJhdGUgc3BlY2lmaWMgZm9ybSBzZWN0aW9uc1xyXG4gIF8uZWFjaCh0aGlzLmZvcm1EZXNjLmZvcm0sIGZ1bmN0aW9uIChmb3JtRWxlbWVudCkge1xyXG4gICAgaWYgKGZvcm1FbGVtZW50ID09PSAnKicpIHtcclxuICAgICAgXy5lYWNoKHRoaXMuZm9ybURlc2Muc2NoZW1hLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcclxuICAgICAgICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5idWlsZEZyb21MYXlvdXQoe1xyXG4gICAgICAgICAga2V5OiBrZXlcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChfLmlzU3RyaW5nKGZvcm1FbGVtZW50KSkge1xyXG4gICAgICAgIGZvcm1FbGVtZW50ID0ge1xyXG4gICAgICAgICAga2V5OiBmb3JtRWxlbWVudFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRGcm9tTGF5b3V0KGZvcm1FbGVtZW50KSk7XHJcbiAgICB9XHJcbiAgfSwgdGhpcyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgaW50ZXJuYWwgZm9ybSB0cmVlIHJlcHJlc2VudGF0aW9uIGZyb20gdGhlIHJlcXVlc3RlZCBsYXlvdXQuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBpcyByZWN1cnNpdmUsIGdlbmVyYXRpbmcgdGhlIG5vZGUgY2hpbGRyZW4gYXMgbmVjZXNzYXJ5LlxyXG4gKiBUaGUgZnVuY3Rpb24gZXh0cmFjdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBwcmV2aW91c2x5IHN1Ym1pdHRlZCB2YWx1ZXNcclxuICogKHRoaXMuZm9ybURlc2MudmFsdWUpIG9yIGZyb20gZGVmYXVsdCB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGZvcm1FbGVtZW50IEpTT05Gb3JtIGVsZW1lbnQgdG8gcmVuZGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQgKHRoZSBhcnJheSBkZXB0aCBpbiBwYXJ0aWN1bGFyKVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZWxlbWVudC5cclxuICovXHJcbmZvcm1UcmVlLnByb3RvdHlwZS5idWlsZEZyb21MYXlvdXQgPSBmdW5jdGlvbiAoZm9ybUVsZW1lbnQsIGNvbnRleHQpIHtcclxuICB2YXIgc2NoZW1hRWxlbWVudCA9IG51bGw7XHJcbiAgdmFyIG5vZGUgPSBuZXcgZm9ybU5vZGUoKTtcclxuICB2YXIgdmlldyA9IG51bGw7XHJcbiAgdmFyIGtleSA9IG51bGw7XHJcblxyXG4gIC8vIFRoZSBmb3JtIGVsZW1lbnQgcGFyYW1ldGVyIGRpcmVjdGx5IGNvbWVzIGZyb20gdGhlIGluaXRpYWxcclxuICAvLyBKU09ORm9ybSBvYmplY3QuIFdlJ2xsIG1ha2UgYSBzaGFsbG93IGNvcHkgb2YgaXQgYW5kIG9mIGl0cyBjaGlsZHJlblxyXG4gIC8vIG5vdCB0byBwb2xsdXRlIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgLy8gKG5vdGUgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSgpKSBjYW5ub3QgYmUgdXNlZCBzaW5jZSB0aGVyZSBtYXkgYmVcclxuICAvLyBldmVudCBoYW5kbGVycyBpbiB0aGVyZSEpXHJcbiAgZm9ybUVsZW1lbnQgPSBfLmNsb25lKGZvcm1FbGVtZW50KTtcclxuICBpZiAoZm9ybUVsZW1lbnQuaXRlbXMpIHtcclxuICAgIGlmIChfLmlzQXJyYXkoZm9ybUVsZW1lbnQuaXRlbXMpKSB7XHJcbiAgICAgIGZvcm1FbGVtZW50Lml0ZW1zID0gXy5tYXAoZm9ybUVsZW1lbnQuaXRlbXMsIF8uY2xvbmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGZvcm1FbGVtZW50Lml0ZW1zID0gWyBfLmNsb25lKGZvcm1FbGVtZW50Lml0ZW1zKSBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGZvcm1FbGVtZW50LmtleSkge1xyXG4gICAgLy8gVGhlIGZvcm0gZWxlbWVudCBpcyBkaXJlY3RseSBsaW5rZWQgdG8gYW4gZWxlbWVudCBpbiB0aGUgSlNPTlxyXG4gICAgLy8gc2NoZW1hLiBUaGUgcHJvcGVydGllcyBvZiB0aGUgZm9ybSBlbGVtZW50IG92ZXJyaWRlIHRob3NlIG9mIHRoZVxyXG4gICAgLy8gZWxlbWVudCBpbiB0aGUgSlNPTiBzY2hlbWEuIFByb3BlcnRpZXMgZnJvbSB0aGUgSlNPTiBzY2hlbWEgY29tcGxldGVcclxuICAgIC8vIHRob3NlIG9mIHRoZSBmb3JtIGVsZW1lbnQgb3RoZXJ3aXNlLlxyXG5cclxuICAgIC8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGZyb20gdGhlIEpTT04gc2NoZW1hXHJcbiAgICBzY2hlbWFFbGVtZW50ID0gZ2V0U2NoZW1hS2V5KFxyXG4gICAgICB0aGlzLmZvcm1EZXNjLnNjaGVtYS5wcm9wZXJ0aWVzLFxyXG4gICAgICBmb3JtRWxlbWVudC5rZXkpO1xyXG4gICAgaWYgKCFzY2hlbWFFbGVtZW50KSB7XHJcbiAgICAgIC8vIFRoZSBKU09OIEZvcm0gaXMgaW52YWxpZCFcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSlNPTkZvcm0gb2JqZWN0IHJlZmVyZW5jZXMgdGhlIHNjaGVtYSBrZXkgXCInICtcclxuICAgICAgICBmb3JtRWxlbWVudC5rZXkgKyAnXCIgYnV0IHRoYXQga2V5IGRvZXMgbm90IGV4aXN0IGluIHRoZSBKU09OIHNjaGVtYScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjaGVtYSBlbGVtZW50IGhhcyBqdXN0IGJlZW4gZm91bmQsIGxldCdzIHRyaWdnZXIgdGhlXHJcbiAgICAvLyBcIm9uRWxlbWVudFNjaGVtYVwiIGV2ZW50XHJcbiAgICAvLyAodGlkb3VzdDogbm90IHN1cmUgd2hhdCB0aGUgdXNlIGNhc2UgZm9yIHRoaXMgaXMsIGtlZXBpbmcgdGhlXHJcbiAgICAvLyBjb2RlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxyXG4gICAgaWYgKHRoaXMuZm9ybURlc2Mub25FbGVtZW50U2NoZW1hKSB7XHJcbiAgICAgIHRoaXMuZm9ybURlc2Mub25FbGVtZW50U2NoZW1hKGZvcm1FbGVtZW50LCBzY2hlbWFFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3JtRWxlbWVudC5uYW1lID1cclxuICAgICAgZm9ybUVsZW1lbnQubmFtZSB8fFxyXG4gICAgICBmb3JtRWxlbWVudC5rZXk7XHJcbiAgICBmb3JtRWxlbWVudC50aXRsZSA9XHJcbiAgICAgIGZvcm1FbGVtZW50LnRpdGxlIHx8XHJcbiAgICAgIHNjaGVtYUVsZW1lbnQudGl0bGU7XHJcbiAgICBmb3JtRWxlbWVudC5kZXNjcmlwdGlvbiA9XHJcbiAgICAgIGZvcm1FbGVtZW50LmRlc2NyaXB0aW9uIHx8XHJcbiAgICAgIHNjaGVtYUVsZW1lbnQuZGVzY3JpcHRpb247XHJcbiAgICBmb3JtRWxlbWVudC5yZWFkT25seSA9XHJcbiAgICAgIGZvcm1FbGVtZW50LnJlYWRPbmx5IHx8XHJcbiAgICAgIHNjaGVtYUVsZW1lbnQucmVhZE9ubHkgfHxcclxuICAgICAgZm9ybUVsZW1lbnQucmVhZG9ubHkgfHxcclxuICAgICAgc2NoZW1hRWxlbWVudC5yZWFkb25seTtcclxuXHJcbiAgICAvLyBDb21wdXRlIHRoZSBJRCBvZiB0aGUgaW5wdXQgZmllbGRcclxuICAgIGlmICghZm9ybUVsZW1lbnQuaWQpIHtcclxuICAgICAgZm9ybUVsZW1lbnQuaWQgPSBlc2NhcGVTZWxlY3Rvcih0aGlzLmZvcm1EZXNjLnByZWZpeCkgK1xyXG4gICAgICAgICctZWx0LScgKyBmb3JtRWxlbWVudC5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2hvdWxkIGVtcHR5IHN0cmluZ3MgYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHZhbHVlP1xyXG4gICAgLy8gVE9ETzogaXQncyByYXRoZXIgdW5jbGVhbiB0byBwYXNzIGl0IHRocm91Z2ggdGhlIHNjaGVtYS5cclxuICAgIGlmIChmb3JtRWxlbWVudC5hbGxvd0VtcHR5KSB7XHJcbiAgICAgIHNjaGVtYUVsZW1lbnQuX2pzb25mb3JtX2FsbG93RW1wdHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBmb3JtIGVsZW1lbnQgZG9lcyBub3QgZGVmaW5lIGl0cyB0eXBlLCB1c2UgdGhlIHR5cGUgb2ZcclxuICAgIC8vIHRoZSBzY2hlbWEgZWxlbWVudC5cclxuICAgIGlmICghZm9ybUVsZW1lbnQudHlwZSkge1xyXG4gICAgICBpZiAoKHNjaGVtYUVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpICYmXHJcbiAgICAgICAgKHNjaGVtYUVsZW1lbnQuZm9ybWF0ID09PSAnY29sb3InKSkge1xyXG4gICAgICAgIGZvcm1FbGVtZW50LnR5cGUgPSAnY29sb3InO1xyXG4gICAgICB9IGVsc2UgaWYgKChzY2hlbWFFbGVtZW50LnR5cGUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICBzY2hlbWFFbGVtZW50LnR5cGUgPT09ICdpbnRlZ2VyJyB8fFxyXG4gICAgICAgICAgc2NoZW1hRWxlbWVudC50eXBlID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgc2NoZW1hRWxlbWVudC50eXBlID09PSAnYW55JykgJiZcclxuICAgICAgICAhc2NoZW1hRWxlbWVudFsnZW51bSddKSB7XHJcbiAgICAgICAgZm9ybUVsZW1lbnQudHlwZSA9ICd0ZXh0JztcclxuICAgICAgfSBlbHNlIGlmIChzY2hlbWFFbGVtZW50LnR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIGZvcm1FbGVtZW50LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYUVsZW1lbnQudHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoc2NoZW1hRWxlbWVudC5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICBmb3JtRWxlbWVudC50eXBlID0gJ2ZpZWxkc2V0JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybUVsZW1lbnQudHlwZSA9ICd0ZXh0YXJlYSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKHNjaGVtYUVsZW1lbnRbJ2VudW0nXSkpIHtcclxuICAgICAgICBmb3JtRWxlbWVudC50eXBlID0gJ3NlbGVjdCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybUVsZW1lbnQudHlwZSA9IHNjaGVtYUVsZW1lbnQudHlwZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVubGVzcyBvdmVycmlkZGVuIGluIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBmb3JtIGVsZW1lbnQgKG9yIHVubGVzc1xyXG4gICAgLy8gdGhlcmUncyBhIHRpdGxlTWFwIGRlZmluZWQpLCB1c2UgdGhlIGVudW1lcmF0aW9uIGxpc3QgZGVmaW5lZCBpblxyXG4gICAgLy8gdGhlIHNjaGVtYVxyXG4gICAgaWYgKCFmb3JtRWxlbWVudC5vcHRpb25zICYmIHNjaGVtYUVsZW1lbnRbJ2VudW0nXSkge1xyXG4gICAgICBpZiAoZm9ybUVsZW1lbnQudGl0bGVNYXApIHtcclxuICAgICAgICBmb3JtRWxlbWVudC5vcHRpb25zID0gXy5tYXAoc2NoZW1hRWxlbWVudFsnZW51bSddLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgdGl0bGU6IGZvcm1FbGVtZW50LnRpdGxlTWFwW3ZhbHVlXSB8fCB2YWx1ZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBmb3JtRWxlbWVudC5vcHRpb25zID0gc2NoZW1hRWxlbWVudFsnZW51bSddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmxhZyBhIGxpc3Qgb2YgY2hlY2tib3hlcyB3aXRoIG11bHRpcGxlIGNob2ljZXNcclxuICAgIGlmICgoZm9ybUVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94ZXMnKSAmJiBzY2hlbWFFbGVtZW50Lml0ZW1zKSB7XHJcbiAgICAgIHZhciBpdGVtc0VudW0gPSBzY2hlbWFFbGVtZW50Lml0ZW1zWydlbnVtJ107XHJcbiAgICAgIGlmIChpdGVtc0VudW0pIHtcclxuICAgICAgICBzY2hlbWFFbGVtZW50Lml0ZW1zLl9qc29uZm9ybV9jaGVja2JveGVzX2FzX2FycmF5ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWl0ZW1zRW51bSAmJiBzY2hlbWFFbGVtZW50Lml0ZW1zWzBdKSB7XHJcbiAgICAgICAgaXRlbXNFbnVtID0gc2NoZW1hRWxlbWVudC5pdGVtc1swXVsnZW51bSddO1xyXG4gICAgICAgIGlmIChpdGVtc0VudW0pIHtcclxuICAgICAgICAgIHNjaGVtYUVsZW1lbnQuaXRlbXNbMF0uX2pzb25mb3JtX2NoZWNrYm94ZXNfYXNfYXJyYXkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBmb3JtIGVsZW1lbnQgdGFyZ2V0cyBhbiBcIm9iamVjdFwiIGluIHRoZSBKU09OIHNjaGVtYSxcclxuICAgIC8vIHdlIG5lZWQgdG8gcmVjdXJzZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGNoaWxkcmVuIHRvIGNyZWF0ZSBhblxyXG4gICAgLy8gaW5wdXQgZmllbGQgcGVyIGNoaWxkIHByb3BlcnR5IG9mIHRoZSBvYmplY3QgaW4gdGhlIEpTT04gc2NoZW1hXHJcbiAgICBpZiAoc2NoZW1hRWxlbWVudC50eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBfLmVhY2goc2NoZW1hRWxlbWVudC5wcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCwgcHJvcE5hbWUpIHtcclxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuYnVpbGRGcm9tTGF5b3V0KHtcclxuICAgICAgICAgIGtleTogZm9ybUVsZW1lbnQua2V5ICsgJy4nICsgcHJvcE5hbWVcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFmb3JtRWxlbWVudC50eXBlKSB7XHJcbiAgICBmb3JtRWxlbWVudC50eXBlID0gJ25vbmUnO1xyXG4gIH1cclxuICB2aWV3ID0ganNvbmZvcm0uZWxlbWVudFR5cGVzW2Zvcm1FbGVtZW50LnR5cGVdO1xyXG4gIGlmICghdmlldykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSlNPTkZvcm0gY29udGFpbnMgYW4gZWxlbWVudCB3aG9zZSB0eXBlIGlzIHVua25vd246IFwiJyArXHJcbiAgICAgIGZvcm1FbGVtZW50LnR5cGUgKyAnXCInKTtcclxuICB9XHJcbiAgXHJcblxyXG4gIGlmIChzY2hlbWFFbGVtZW50KSB7XHJcbiAgICAvLyBUaGUgZm9ybSBlbGVtZW50IGlzIGxpbmtlZCB0byBhbiBlbGVtZW50IGluIHRoZSBzY2hlbWEuXHJcbiAgICAvLyBMZXQncyBtYWtlIHN1cmUgdGhlIHR5cGVzIGFyZSBjb21wYXRpYmxlLlxyXG4gICAgLy8gSW4gcGFydGljdWxhciwgdGhlIGVsZW1lbnQgbXVzdCBub3QgYmUgYSBcImNvbnRhaW5lclwiXHJcbiAgICAvLyAob3IgbXVzdCBiZSBhbiBcIm9iamVjdFwiIG9yIFwiYXJyYXlcIiBjb250YWluZXIpXHJcbiAgICBpZiAoIXZpZXcuaW5wdXRmaWVsZCAmJiAhdmlldy5hcnJheSAmJlxyXG4gICAgICAoZm9ybUVsZW1lbnQudHlwZSAhPT0gJ3NlbGVjdGZpZWxkc2V0JykgJiZcclxuICAgICAgKHNjaGVtYUVsZW1lbnQudHlwZSAhPT0gJ29iamVjdCcpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIEpTT05Gb3JtIGNvbnRhaW5zIGFuIGVsZW1lbnQgdGhhdCBsaW5rcyB0byBhbiAnICtcclxuICAgICAgICAnZWxlbWVudCBpbiB0aGUgSlNPTiBzY2hlbWEgKGtleTogXCInICsgZm9ybUVsZW1lbnQua2V5ICsgJ1wiKSAnICtcclxuICAgICAgICAnYW5kIHRoYXQgc2hvdWxkIG5vdCBiYXNlZCBvbiBpdHMgdHlwZSAoXCInICsgZm9ybUVsZW1lbnQudHlwZSArICdcIiknKTtcclxuICAgIH1cclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBUaGUgZm9ybSBlbGVtZW50IGlzIG5vdCBsaW5rZWQgdG8gYW4gZWxlbWVudCBpbiB0aGUgc2NoZW1hLlxyXG4gICAgLy8gVGhpcyBtZWFucyB0aGUgZm9ybSBlbGVtZW50IG11c3QgYmUgYSBcImNvbnRhaW5lclwiIGVsZW1lbnQsXHJcbiAgICAvLyBhbmQgbXVzdCBub3QgZGVmaW5lIGFuIGlucHV0IGZpZWxkLlxyXG4gICAgaWYgKHZpZXcuaW5wdXRmaWVsZCAmJiAoZm9ybUVsZW1lbnQudHlwZSAhPT0gJ3NlbGVjdGZpZWxkc2V0JykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSlNPTkZvcm0gZGVmaW5lcyBhbiBlbGVtZW50IG9mIHR5cGUgJyArXHJcbiAgICAgICAgJ1wiJyArIGZvcm1FbGVtZW50LnR5cGUgKyAnXCIgJyArXHJcbiAgICAgICAgJ2J1dCBubyBcImtleVwiIHByb3BlcnR5IHRvIGxpbmsgdGhlIGlucHV0IGZpZWxkIHRvIHRoZSBKU09OIHNjaGVtYScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQSBmZXcgY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgdG8gdXNlIHRoZSBJRCBhcyBqUXVlcnkgc2VsZWN0b3JcclxuICBmb3JtRWxlbWVudC5pZGRvdCA9IGVzY2FwZVNlbGVjdG9yKGZvcm1FbGVtZW50LmlkIHx8ICcnKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgZm9ybSBub2RlIGZyb20gdGhlIGZvcm0gZWxlbWVudCBhbmQgc2NoZW1hIGVsZW1lbnRcclxuICBub2RlLmZvcm1FbGVtZW50ID0gZm9ybUVsZW1lbnQ7XHJcbiAgbm9kZS5zY2hlbWFFbGVtZW50ID0gc2NoZW1hRWxlbWVudDtcclxuICBub2RlLnZpZXcgPSB2aWV3O1xyXG4gIG5vZGUub3duZXJUcmVlID0gdGhpcztcclxuXHJcbiAgLy8gU2V0IGV2ZW50IGhhbmRsZXJzXHJcbiAgaWYgKCFmb3JtRWxlbWVudC5oYW5kbGVycykge1xyXG4gICAgZm9ybUVsZW1lbnQuaGFuZGxlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8vIFBhcnNlIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XHJcbiAgaWYgKG5vZGUudmlldy5hcnJheSkge1xyXG4gICAgLy8gVGhlIGZvcm0gZWxlbWVudCBpcyBhbiBhcnJheS4gVGhlIG51bWJlciBvZiBpdGVtcyBpbiBhbiBhcnJheVxyXG4gICAgLy8gaXMgYnkgZGVmaW5pdGlvbiBkeW5hbWljLCB1cCB0byB0aGUgZm9ybSB1c2VyICh0aHJvdWdoIFwiQWRkIG1vcmVcIixcclxuICAgIC8vIFwiRGVsZXRlXCIgY29tbWFuZHMpLiBUaGUgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgbWF5XHJcbiAgICAvLyBhbHNvIGNoYW5nZSBvdmVyIHRpbWUgKHRocm91Z2ggXCJNb3ZlIHVwXCIsIFwiTW92ZSBkb3duXCIgY29tbWFuZHMpLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBmb3JtIG5vZGUgc3RvcmVzIGEgXCJ0ZW1wbGF0ZVwiIG5vZGUgdGhhdCBzZXJ2ZXMgYXMgYmFzaXMgZm9yXHJcbiAgICAvLyB0aGUgY3JlYXRpb24gb2YgYW4gaXRlbSBpbiB0aGUgYXJyYXkuXHJcbiAgICAvL1xyXG4gICAgLy8gQXJyYXkgaXRlbXMgbWF5IGJlIGNvbXBsZXggZm9ybXMgdGhlbXNlbHZlcywgYWxsb3dpbmcgZm9yIG5lc3RpbmcuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIGluaXRpYWwgdmFsdWVzIHNldCB0aGUgaW5pdGlhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGFycmF5LlxyXG4gICAgLy8gTm90ZSBhIGZvcm0gZWxlbWVudCBjb250YWlucyBhdCBsZWFzdCBvbmUgaXRlbSB3aGVuIGl0IGlzIHJlbmRlcmVkLlxyXG4gICAgaWYgKGZvcm1FbGVtZW50Lml0ZW1zKSB7XHJcbiAgICAgIGtleSA9IGZvcm1FbGVtZW50Lml0ZW1zWzBdIHx8IGZvcm1FbGVtZW50Lml0ZW1zO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGtleSA9IGZvcm1FbGVtZW50LmtleSArICdbXSc7XHJcbiAgICB9XHJcbiAgICBpZiAoXy5pc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgIGtleSA9IHsga2V5OiBrZXkgfTtcclxuICAgIH1cclxuICAgIG5vZGUuc2V0Q2hpbGRUZW1wbGF0ZSh0aGlzLmJ1aWxkRnJvbUxheW91dChrZXkpKTtcclxuICB9XHJcbiAgZWxzZSBpZiAoZm9ybUVsZW1lbnQuaXRlbXMpIHtcclxuICAgIC8vIFRoZSBmb3JtIGVsZW1lbnQgZGVmaW5lcyBjaGlsZHJlbiBlbGVtZW50c1xyXG4gICAgXy5lYWNoKGZvcm1FbGVtZW50Lml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICBpZiAoXy5pc1N0cmluZyhpdGVtKSkge1xyXG4gICAgICAgIGl0ZW0gPSB7IGtleTogaXRlbSB9O1xyXG4gICAgICB9XHJcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5idWlsZEZyb21MYXlvdXQoaXRlbSkpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbm9kZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBpbnB1dCBmaWVsZCBpbiB0aGUgdHJlZSBiYXNlZFxyXG4gKiBvbiBwcmV2aW91c2x5IHN1Ym1pdHRlZCB2YWx1ZXMgb3IgZGVmYXVsdCB2YWx1ZXMgaW4gdGhlIEpTT04gc2NoZW1hLlxyXG4gKlxyXG4gKiBGb3IgYXJyYXlzLCB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgY3JlYXRlcyBhbmQgaW5zZXJ0cyBhZGRpdGlvbmFsXHJcbiAqIG5vZGVzIGluIHRoZSB0cmVlIGJhc2VkIG9uIHByZXZpb3VzbHkgc3VibWl0dGVkIHZhbHVlcyAoYWxzbyBlbnN1cmluZ1xyXG4gKiB0aGF0IHRoZSBhcnJheSBoYXMgYXQgbGVhc3Qgb25lIGl0ZW0pLlxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gc2V0cyB0aGUgYXJyYXkgcGF0aCBvbiBhbGwgbm9kZXMuXHJcbiAqIEl0IHNob3VsZCBiZSBjYWxsZWQgb25jZSBpbiB0aGUgbGlmZXRpbWUgb2YgYSBmb3JtIHRyZWUgcmlnaHQgYWZ0ZXJcclxuICogdGhlIHRyZWUgc3RydWN0dXJlIGhhcyBiZWVuIGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxuZm9ybVRyZWUucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucm9vdC5jb21wdXRlSW5pdGlhbFZhbHVlcyh0aGlzLmZvcm1EZXNjLnZhbHVlKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVuZGVycyB0aGUgZm9ybSB0cmVlXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGRvbVJvb3QgVGhlIFwiZm9ybVwiIGVsZW1lbnQgaW4gdGhlIERPTSB0cmVlIHRoYXQgc2VydmVzIGFzXHJcbiAqICByb290IGZvciB0aGUgZm9ybVxyXG4gKi9cclxuZm9ybVRyZWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkb21Sb290KSB7XHJcbiAgaWYgKCFkb21Sb290KSByZXR1cm47XHJcbiAgdGhpcy5kb21Sb290ID0gZG9tUm9vdDtcclxuICB0aGlzLnJvb3QucmVuZGVyKCk7XHJcblxyXG4gIC8vIElmIHRoZSBzY2hlbWEgZGVmaW5lcyByZXF1aXJlZCBmaWVsZHMsIGZsYWcgdGhlIGZvcm0gd2l0aCB0aGVcclxuICAvLyBcImpzb25mb3JtLWhhc3JlcXVpcmVkXCIgY2xhc3MgZm9yIHN0eWxpbmcgcHVycG9zZVxyXG4gIC8vICh0eXBpY2FsbHkgc28gdGhhdCB1c2VycyBtYXkgZGlzcGxheSBhIGxlZ2VuZClcclxuICBpZiAodGhpcy5oYXNSZXF1aXJlZEZpZWxkKCkpIHtcclxuICAgICQoZG9tUm9vdCkuYWRkQ2xhc3MoJ2pzb25mb3JtLWhhc3JlcXVpcmVkJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdhbGtzIGRvd24gdGhlIGVsZW1lbnQgdHJlZSB3aXRoIGEgY2FsbGJhY2tcclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIG9uIGVhY2ggZWxlbWVudFxyXG4gKi9cclxuZm9ybVRyZWUucHJvdG90eXBlLmZvckVhY2hFbGVtZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgXHJcbiAgdmFyIGYgPSBmdW5jdGlvbihyb290KSB7XHJcbiAgICBmb3IgKHZhciBpPTA7aTxyb290LmNoaWxkcmVuLmxlbmd0aDtpKyspIHtcclxuICAgICAgY2FsbGJhY2socm9vdC5jaGlsZHJlbltpXSk7XHJcbiAgICAgIGYocm9vdC5jaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmKHRoaXMucm9vdCk7XHJcblxyXG59O1xyXG5cclxuZm9ybVRyZWUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24obm9FcnJvckRpc3BsYXkpIHtcclxuXHJcbiAgdmFyIHZhbHVlcyA9IGpzb25mb3JtLmdldEZvcm1WYWx1ZSh0aGlzLmRvbVJvb3QpO1xyXG4gIHZhciBlcnJvcnMgPSBmYWxzZTtcclxuXHJcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmZvcm1EZXNjO1xyXG5cclxuICBpZiAob3B0aW9ucy52YWxpZGF0ZSE9PWZhbHNlKSB7XHJcbiAgICB2YXIgdmFsaWRhdG9yID0gZmFsc2U7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmFsaWRhdGUhPVwib2JqZWN0XCIpIHtcclxuICAgICAgaWYgKGdsb2JhbC5KU09ORm9ybVZhbGlkYXRvcikge1xyXG4gICAgICAgIHZhbGlkYXRvciA9IGdsb2JhbC5KU09ORm9ybVZhbGlkYXRvci5jcmVhdGVFbnZpcm9ubWVudChcImpzb24tc2NoZW1hLWRyYWZ0LTAzXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRvcikge1xyXG4gICAgICB2YXIgdiA9IHZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZXMsIHRoaXMuZm9ybURlc2Muc2NoZW1hKTtcclxuICAgICAgJCh0aGlzLmRvbVJvb3QpLmpzb25Gb3JtRXJyb3JzKGZhbHNlLG9wdGlvbnMpO1xyXG4gICAgICBpZiAodi5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFlcnJvcnMpIGVycm9ycyA9IFtdO1xyXG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodi5lcnJvcnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZXJyb3JzICYmICFub0Vycm9yRGlzcGxheSkge1xyXG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheUVycm9ycykge1xyXG4gICAgICBvcHRpb25zLmRpc3BsYXlFcnJvcnMoZXJyb3JzLHRoaXMuZG9tUm9vdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkKHRoaXMuZG9tUm9vdCkuanNvbkZvcm1FcnJvcnMoZXJyb3JzLG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcImVycm9yc1wiOmVycm9yc31cclxuXHJcbn1cclxuXHJcbmZvcm1UcmVlLnByb3RvdHlwZS5zdWJtaXQgPSBmdW5jdGlvbihldnQpIHtcclxuXHJcbiAgdmFyIHN0b3BFdmVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKGV2dCkge1xyXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcbiAgdmFyIHZhbHVlcyA9IGpzb25mb3JtLmdldEZvcm1WYWx1ZSh0aGlzLmRvbVJvb3QpO1xyXG4gIHZhciBvcHRpb25zID0gdGhpcy5mb3JtRGVzYztcclxuXHJcbiAgdmFyIGJyaz1mYWxzZTtcclxuICB0aGlzLmZvckVhY2hFbGVtZW50KGZ1bmN0aW9uKGVsdCkge1xyXG4gICAgaWYgKGJyaykgcmV0dXJuO1xyXG4gICAgaWYgKGVsdC52aWV3Lm9uU3VibWl0KSB7XHJcbiAgICAgIGJyayA9ICFlbHQudmlldy5vblN1Ym1pdChldnQsIGVsdCk7IC8vbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyEhXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChicmspIHJldHVybiBzdG9wRXZlbnQoKTtcclxuXHJcbiAgdmFyIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGUoKTtcclxuXHJcbiAgaWYgKG9wdGlvbnMub25TdWJtaXQgJiYgIW9wdGlvbnMub25TdWJtaXQodmFsaWRhdGVkLmVycm9ycyx2YWx1ZXMpKSB7XHJcbiAgICByZXR1cm4gc3RvcEV2ZW50KCk7XHJcbiAgfVxyXG5cclxuICBpZiAodmFsaWRhdGVkLmVycm9ycykgcmV0dXJuIHN0b3BFdmVudCgpO1xyXG5cclxuICBpZiAob3B0aW9ucy5vblN1Ym1pdFZhbGlkICYmICFvcHRpb25zLm9uU3VibWl0VmFsaWQodmFsdWVzKSkge1xyXG4gICAgcmV0dXJuIHN0b3BFdmVudCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG5cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmb3JtIGRpc3BsYXlzIGEgXCJyZXF1aXJlZFwiIGZpZWxkLlxyXG4gKlxyXG4gKiBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHRoZSBmdW5jdGlvbiBwYXJzZXMgdGhlIGZvcm0ncyBzY2hlbWEgYW5kIHJldHVybnNcclxuICogdHJ1ZSBhcyBzb29uIGFzIGl0IGZpbmRzIGEgXCJyZXF1aXJlZFwiIGZsYWcgZXZlbiB0aG91Z2gsIGluIHRoZW9yeSwgdGhhdFxyXG4gKiBzY2hlbWEga2V5IG1heSBub3QgYXBwZWFyIGluIHRoZSBmaW5hbCBmb3JtLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYSBcInJlcXVpcmVkXCIgY29uc3RyYWludCBvbiBhIGJvb2xlYW4gdHlwZSBpcyBhbHdheXMgZW5mb3JjZWQsXHJcbiAqIHRoZSBjb2RlIHNraXBzIHN1Y2ggZGVmaW5pdGlvbnMuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIHdoZW4gdGhlIGZvcm0gaGFzIHNvbWUgcmVxdWlyZWQgZmllbGQsXHJcbiAqICBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mb3JtVHJlZS5wcm90b3R5cGUuaGFzUmVxdWlyZWRGaWVsZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcGFyc2VFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoZWxlbWVudC5yZXF1aXJlZCAmJiAoZWxlbWVudC50eXBlICE9PSAnYm9vbGVhbicpKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm9wID0gXy5maW5kKGVsZW1lbnQucHJvcGVydGllcywgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgIHJldHVybiBwYXJzZUVsZW1lbnQocHJvcGVydHkpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAocHJvcCkge1xyXG4gICAgICByZXR1cm4gcHJvcDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudC5pdGVtcykge1xyXG4gICAgICBpZiAoXy5pc0FycmF5KGVsZW1lbnQuaXRlbXMpKSB7XHJcbiAgICAgICAgcHJvcCA9IF8uZmluZChlbGVtZW50Lml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlRWxlbWVudChpdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBwcm9wID0gcGFyc2VFbGVtZW50KGVsZW1lbnQuaXRlbXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gcGFyc2VFbGVtZW50KHRoaXMuZm9ybURlc2Muc2NoZW1hKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3RydWN0dXJlZCBvYmplY3QgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZm9ybSB2YWx1ZXMgZW50ZXJlZFxyXG4gKiBieSB0aGUgdXNlIGZvciB0aGUgZ2l2ZW4gZm9ybS5cclxuICpcclxuICogVGhlIGZvcm0gbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSByZW5kZXJlZCB0aHJvdWdoIGEgY2FsbCB0byBqc29uZm9ybS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gVGhlIDxmb3JtPiB0YWcgaW4gdGhlIERPTVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgdGhhdCBmb2xsb3dzIHRoZSBkYXRhIHNjaGVtYSBhbmQgbWF0Y2hlcyB0aGVcclxuICogIHZhbHVlcyBlbnRlcmVkIGJ5IHRoZSB1c2VyLlxyXG4gKi9cclxuanNvbmZvcm0uZ2V0Rm9ybVZhbHVlID0gZnVuY3Rpb24gKGZvcm1lbHQpIHtcclxuICB2YXIgZm9ybSA9ICQoZm9ybWVsdCkuZGF0YSgnanNvbmZvcm0tdHJlZScpO1xyXG4gIGlmICghZm9ybSkgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIGZvcm0ucm9vdC5nZXRGb3JtVmFsdWVzKCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEhpZ2hsaWdodHMgZXJyb3JzIHJlcG9ydGVkIGJ5IHRoZSBKU09OIHNjaGVtYSB2YWxpZGF0b3IgaW4gdGhlIGRvY3VtZW50LlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGVycm9ycyBMaXN0IG9mIGVycm9ycyByZXBvcnRlZCBieSB0aGUgSlNPTiBzY2hlbWEgdmFsaWRhdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBKU09OIEZvcm0gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBmb3JtXHJcbiAqICAodW51c2VkIGZvciB0aGUgdGltZSBiZWluZywgY291bGQgYmUgdXNlZnVsIHRvIHN0b3JlIGV4YW1wbGUgdmFsdWVzIG9yXHJcbiAqICAgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXMpXHJcbiAqL1xyXG4kLmZuLmpzb25Gb3JtRXJyb3JzID0gZnVuY3Rpb24oZXJyb3JzLCBvcHRpb25zKSB7XHJcbiAgJChcIi5lcnJvclwiLCB0aGlzKS5yZW1vdmVDbGFzcyhcImVycm9yXCIpO1xyXG4gICQoXCIud2FybmluZ1wiLCB0aGlzKS5yZW1vdmVDbGFzcyhcIndhcm5pbmdcIik7XHJcblxyXG4gICQoXCIuanNvbmZvcm0tZXJyb3J0ZXh0XCIsIHRoaXMpLmhpZGUoKTtcclxuICBpZiAoIWVycm9ycykgcmV0dXJuO1xyXG5cclxuICB2YXIgZXJyb3JTZWxlY3RvcnMgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgLy8gQ29tcHV0ZSB0aGUgYWRkcmVzcyBvZiB0aGUgaW5wdXQgZmllbGQgaW4gdGhlIGZvcm0gZnJvbSB0aGUgVVJJXHJcbiAgICAvLyByZXR1cm5lZCBieSB0aGUgSlNPTiBzY2hlbWEgdmFsaWRhdG9yLlxyXG4gICAgLy8gVGhlc2UgVVJJcyB0eXBpY2FsbHkgbG9vayBsaWtlOlxyXG4gICAgLy8gIHVybjp1dWlkOmNjY2MyNjVlLWZmZGQtNGU0MC04Yzk3LTk3N2Y3YTUxMjg1MyMvcGljdHVyZXMvMS90aHVtYm5haWxcclxuICAgIC8vIFdoYXQgd2UgbmVlZCBmcm9tIHRoYXQgaXMgdGhlIHBhdGggaW4gdGhlIHZhbHVlIG9iamVjdDpcclxuICAgIC8vICBwaWN0dXJlc1sxXS50aHVtYm5haWxcclxuICAgIC8vIC4uLiBhbmQgdGhlIGpRdWVyeS1mcmllbmRseSBjbGFzcyBzZWxlY3RvciBvZiB0aGUgaW5wdXQgZmllbGQ6XHJcbiAgICAvLyAgLmpzb25mb3JtLWVycm9yLXBpY3R1cmVzXFxbMVxcXS0tLXRodW1ibmFpbFxyXG4gICAgdmFyIGtleSA9IGVycm9yc1tpXS51cmlcclxuICAgICAgLnJlcGxhY2UoLy4qI1xcLy8sICcnKVxyXG4gICAgICAucmVwbGFjZSgvXFwvL2csICcuJylcclxuICAgICAgLnJlcGxhY2UoL1xcLihbMC05XSspKD89XFwufCQpL2csICdbJDFdJyk7XHJcbiAgICB2YXIgZXJyb3JtYXJrZXJjbGFzcyA9IFwiLmpzb25mb3JtLWVycm9yLVwiICtcclxuICAgICAgZXNjYXBlU2VsZWN0b3Ioa2V5LnJlcGxhY2UoL1xcLi9nLFwiLS0tXCIpKTtcclxuICAgIGVycm9yU2VsZWN0b3JzLnB1c2goZXJyb3JtYXJrZXJjbGFzcyk7XHJcblxyXG4gICAgdmFyIGVycm9yVHlwZSA9IGVycm9yc1tpXS50eXBlIHx8IFwiZXJyb3JcIjtcclxuICAgICQoZXJyb3JtYXJrZXJjbGFzcywgdGhpcykuYWRkQ2xhc3MoZXJyb3JUeXBlKTtcclxuICAgICQoZXJyb3JtYXJrZXJjbGFzcyArIFwiIC5qc29uZm9ybS1lcnJvcnRleHRcIiwgdGhpcykuaHRtbChlcnJvcnNbaV0ubWVzc2FnZSkuc2hvdygpO1xyXG4gIH1cclxuXHJcbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGVycm9yIGluIHRoZSBET00gYW5kIGVuc3VyZSB0aGUgZWxlbWVudFxyXG4gIC8vIGlzIHZpc2libGUgc28gdGhhdCB0aGUgdXNlciB1bmRlcnN0YW5kcyB0aGF0IHNvbWV0aGluZyB3ZW50IHdyb25nXHJcbiAgZXJyb3JTZWxlY3RvcnMgPSBlcnJvclNlbGVjdG9ycy5qb2luKCcsJyk7XHJcbiAgdmFyIGZpcnN0RXJyb3IgPSAkKGVycm9yU2VsZWN0b3JzKS5nZXQoMCk7XHJcbiAgaWYgKGZpcnN0RXJyb3IgJiYgZmlyc3RFcnJvci5zY3JvbGxJbnRvVmlldykge1xyXG4gICAgZmlyc3RFcnJvci5zY3JvbGxJbnRvVmlldyh0cnVlLCB7XHJcbiAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9ybSBmcm9tIHRoZSBnaXZlbiBKU09OIEZvcm0gb2JqZWN0IGFuZCByZW5kZXJzIHRoZSBmb3JtLlxyXG4gKlxyXG4gKiBNYWluIGVudHJ5IHBvaW50IG9mIHRoZSBsaWJyYXJ5LiBEZWZpbmVkIGFzIGEgalF1ZXJ5IGZ1bmN0aW9uIHRoYXQgdHlwaWNhbGx5XHJcbiAqIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gYSA8Zm9ybT4gZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBmb3IgdGhlIEpTT04gRm9ybSBvYmplY3QgaXRcclxuICogcmVjZWl2ZXMgYXMgcGFyYW1ldGVyOlxyXG4gKiAtIHNjaGVtYSAocmVxdWlyZWQpOiBUaGUgSlNPTiBTY2hlbWEgdGhhdCBkZXNjcmliZXMgdGhlIGZvcm0gdG8gcmVuZGVyXHJcbiAqIC0gZm9ybTogVGhlIG9wdGlvbnMgZm9ybSBsYXlvdXQgZGVzY3JpcHRpb24sIG92ZXJyaWRlcyBkZWZhdWx0IGxheW91dFxyXG4gKiAtIHByZWZpeDogU3RyaW5nIHRvIHVzZSB0byBwcmVmaXggY29tcHV0ZWQgSURzLiBEZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICogIFVzZSB0aGlzIG9wdGlvbiBpZiBKU09OIEZvcm0gaXMgdXNlZCBtdWx0aXBsZSB0aW1lcyBpbiBhbiBhcHBsaWNhdGlvbiB3aXRoXHJcbiAqICBzY2hlbWFzIHRoYXQgaGF2ZSBvdmVybGFwcGluZyBwYXJhbWV0ZXIgbmFtZXMgdG8gYXZvaWQgcnVubmluZyBpbnRvIG11bHRpcGxlXHJcbiAqICBJRHMgaXNzdWVzLiBEZWZhdWx0IHZhbHVlIGlzIFwianNvbmZvcm0tW2NvdW50ZXJdXCIuXHJcbiAqIC0gdHJhbnNsb2FkaXQ6IFRyYW5zbG9hZGl0IHBhcmFtZXRlcnMgd2hlbiB0cmFuc2xvYWRpdCBpcyB1c2VkXHJcbiAqIC0gdmFsaWRhdGU6IFZhbGlkYXRlcyBmb3JtIGFnYWluc3Qgc2NoZW1hIHVwb24gc3VibWlzc2lvbi4gVXNlcyB0aGUgdmFsdWVcclxuICogb2YgdGhlIFwidmFsaWRhdGVcIiBwcm9wZXJ0eSBhcyB2YWxpZGF0b3IgaWYgaXQgaXMgYW4gb2JqZWN0LlxyXG4gKiAtIGRpc3BsYXlFcnJvcnM6IEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlcnJvcnMgdXBvbiBmb3JtIHN1Ym1pc3Npb24uXHJcbiAqICBEZWZhdWx0IGlzIHRvIHJlbmRlciB0aGUgZXJyb3JzIG5leHQgdG8gdGhlIGlucHV0IGZpZWxkcy5cclxuICogLSBzdWJtaXRFdmVudDogTmFtZSBvZiB0aGUgZm9ybSBzdWJtaXNzaW9uIGV2ZW50IHRvIGJpbmQgdG8uXHJcbiAqICBEZWZhdWx0IGlzIFwic3VibWl0XCIuIFNldCB0aGlzIG9wdGlvbiB0byBmYWxzZSB0byBhdm9pZCBldmVudCBiaW5kaW5nLlxyXG4gKiAtIG9uU3VibWl0OiBDYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZm9ybSBpcyBzdWJtaXR0ZWRcclxuICogLSBvblN1Ym1pdFZhbGlkOiBDYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZm9ybSBpcyBzdWJtaXR0ZWQgd2l0aG91dFxyXG4gKiAgZXJyb3JzLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIEpTT04gRm9ybSBvYmplY3QgdG8gdXNlIGFzIGJhc2lzIGZvciB0aGUgZm9ybVxyXG4gKi9cclxuJC5mbi5qc29uRm9ybSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICB2YXIgZm9ybUVsdCA9IHRoaXM7XHJcblxyXG4gIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCB7c3VibWl0RXZlbnQ6ICdzdWJtaXQnfSk7XHJcblxyXG4gIHZhciBmb3JtID0gbmV3IGZvcm1UcmVlKCk7XHJcbiAgZm9ybS5pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gIGZvcm0ucmVuZGVyKGZvcm1FbHQuZ2V0KDApKTtcclxuXHJcbiAgLy8gVE9ETzogbW92ZSB0aGF0IHRvIGZvcm1UcmVlLnJlbmRlclxyXG4gIGlmIChvcHRpb25zLnRyYW5zbG9hZGl0KSB7XHJcbiAgICBmb3JtRWx0LmFwcGVuZCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwicGFyYW1zXCIgdmFsdWU9XFwnJyArXHJcbiAgICAgIGVzY2FwZUhUTUwoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy50cmFuc2xvYWRpdC5wYXJhbXMpKSArXHJcbiAgICAgICdcXCc+Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBLZWVwIGEgZGlyZWN0IHBvaW50ZXIgdG8gdGhlIEpTT04gc2NoZW1hIGZvciBmb3JtIHN1Ym1pc3Npb24gcHVycG9zZVxyXG4gIGZvcm1FbHQuZGF0YShcImpzb25mb3JtLXRyZWVcIiwgZm9ybSk7XHJcblxyXG4gIGlmIChvcHRpb25zLnN1Ym1pdEV2ZW50KSB7XHJcbiAgICBmb3JtRWx0LnVuYmluZCgob3B0aW9ucy5zdWJtaXRFdmVudCkrJy5qc29uZm9ybScpO1xyXG4gICAgZm9ybUVsdC5iaW5kKChvcHRpb25zLnN1Ym1pdEV2ZW50KSsnLmpzb25mb3JtJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgIGZvcm0uc3VibWl0KGV2dCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpemUgdGFicyBzZWN0aW9ucywgaWYgYW55XHJcbiAgaW5pdGlhbGl6ZVRhYnMoZm9ybUVsdCk7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgZXhwYW5kYWJsZSBzZWN0aW9ucywgaWYgYW55XHJcbiAgJCgnLmV4cGFuZGFibGUgPiBkaXYsIC5leHBhbmRhYmxlID4gZmllbGRzZXQnLCBmb3JtRWx0KS5oaWRlKCk7XHJcbiAgJCgnLmV4cGFuZGFibGUgPiBsZWdlbmQnLCBmb3JtRWx0KS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gJCh0aGlzKS5wYXJlbnQoKTtcclxuICAgIHBhcmVudC50b2dnbGVDbGFzcygnZXhwYW5kZWQnKTtcclxuICAgICQoJz4gZGl2JywgcGFyZW50KS5zbGlkZVRvZ2dsZSgxMDApO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZm9ybTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0cmlldmVzIHRoZSBzdHJ1Y3R1cmVkIHZhbHVlcyBvYmplY3QgZ2VuZXJhdGVkIGZyb20gdGhlIHZhbHVlc1xyXG4gKiBlbnRlcmVkIGJ5IHRoZSB1c2VyIGFuZCB0aGUgZGF0YSBzY2hlbWEgdGhhdCBnYXZlIGJpcnRoIHRvIHRoZSBmb3JtLlxyXG4gKlxyXG4gKiBEZWZpbmVkIGFzIGEgalF1ZXJ5IGZ1bmN0aW9uIHRoYXQgdHlwaWNhbGx5IG5lZWRzIHRvIGJlIGFwcGxpZWQgdG9cclxuICogYSA8Zm9ybT4gZWxlbWVudCB3aG9zZSBjb250ZW50IGhhcyBwcmV2aW91c2x5IGJlZW4gZ2VuZXJhdGVkIGJ5IGFcclxuICogY2FsbCB0byBcImpzb25Gb3JtXCIuXHJcbiAqXHJcbiAqIFVubGVzcyBleHBsaWNpdGx5IGRpc2FibGVkLCB0aGUgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHZhbGlkYXRlZFxyXG4gKiBhZ2FpbnN0IHRoZSBjb25zdHJhaW50cyBleHByZXNzZWQgaW4gdGhlIHNjaGVtYS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm4ge09iamVjdH0gU3RydWN0dXJlZCB2YWx1ZXMgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgdXNlciBpbnB1dHNcclxuICogIGFuZCB0aGUgZGF0YSBzY2hlbWEuXHJcbiAqL1xyXG4kLmZuLmpzb25Gb3JtVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ganNvbmZvcm0uZ2V0Rm9ybVZhbHVlKHRoaXMpO1xyXG59O1xyXG5cclxuLy8gRXhwb3NlIHRoZSBnZXRGb3JtVmFsdWUgbWV0aG9kIHRvIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIChvdGhlciBtZXRob2RzIGV4cG9zZWQgYXMgalF1ZXJ5IGZ1bmN0aW9ucylcclxuZ2xvYmFsLkpTT05Gb3JtID0gZ2xvYmFsLkpTT05Gb3JtIHx8IHt1dGlsOnt9fTtcclxuZ2xvYmFsLkpTT05Gb3JtLmdldEZvcm1WYWx1ZSA9IGpzb25mb3JtLmdldEZvcm1WYWx1ZTtcclxuZ2xvYmFsLkpTT05Gb3JtLmZpZWxkVGVtcGxhdGUgPSBqc29uZm9ybS5maWVsZFRlbXBsYXRlO1xyXG5nbG9iYWwuSlNPTkZvcm0uZmllbGRUeXBlcyA9IGpzb25mb3JtLmVsZW1lbnRUeXBlcztcclxuZ2xvYmFsLkpTT05Gb3JtLmdldEluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZTtcclxuZ2xvYmFsLkpTT05Gb3JtLnV0aWwuZ2V0T2JqS2V5ID0ganNvbmZvcm0udXRpbC5nZXRPYmpLZXk7XHJcbmdsb2JhbC5KU09ORm9ybS51dGlsLnNldE9iaktleSA9IGpzb25mb3JtLnV0aWwuc2V0T2JqS2V5O1xyXG5cclxufSkoKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyksXHJcbiAgKCh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpID8gZXhwb3J0cyA6IHdpbmRvdyksXHJcbiAgKCh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJykgPyBqUXVlcnkgOiB7IGZuOiB7fSB9KSxcclxuICAoKHR5cGVvZiBfICE9PSAndW5kZWZpbmVkJykgPyBfIDogbnVsbCksXHJcbiAgSlNPTik7XHJcblxufSkoKSIsIi8vIG5vdGhpbmcgdG8gc2VlIGhlcmUuLi4gbm8gZmlsZSBtZXRob2RzIGZvciB0aGUgYnJvd3NlclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgY2hvc2VuID0gcmVxdWlyZSgnY2hvc2VuLWpxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgQnJhbmNoVmlldyA9IHJlcXVpcmUoJy4vYnJhbmNoJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5zaWRlYmFyLmJyYW5jaGVzLFxyXG5cclxuICBzdWJ2aWV3czoge30sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuXHJcbiAgICB2YXIgYXBwID0gb3B0aW9ucy5hcHA7XHJcbiAgICBhcHAubG9hZGVyLnN0YXJ0KCk7XHJcblxyXG4gICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcclxuICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbztcclxuICAgIHRoaXMuYnJhbmNoID0gb3B0aW9ucy5icmFuY2ggfHwgdGhpcy5yZXBvLmdldCgnZGVmYXVsdF9icmFuY2gnKTtcclxuICAgIHRoaXMucm91dGVyID0gb3B0aW9ucy5yb3V0ZXI7XHJcbiAgICB0aGlzLnNpZGViYXIgPSBvcHRpb25zLnNpZGViYXI7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5mZXRjaCh7XHJcbiAgICAgIHN1Y2Nlc3M6IHRoaXMucmVuZGVyLFxyXG4gICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnJvdXRlci5lcnJvcih4aHIpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBjb21wbGV0ZTogdGhpcy5hcHAubG9hZGVyLmRvbmVcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBvbmx5IHJlbmRlciBicmFuY2hlcyBzZWxlY3RvciBpZiB0d28gb3IgbW9yZSBicmFuY2hlc1xyXG4gICAgaWYgKHRoaXMubW9kZWwubGVuZ3RoIDwgMikgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuYXBwLmxvYWRlci5zdGFydCgpO1xyXG5cclxuICAgIHRoaXMuJGVsLmVtcHR5KCkuYXBwZW5kKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSkpO1xyXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5lYWNoKChmdW5jdGlvbihicmFuY2gsIGluZGV4KSB7XHJcbiAgICAgIHZhciB2aWV3ID0gbmV3IEJyYW5jaFZpZXcoe1xyXG4gICAgICAgIG1vZGVsOiBicmFuY2gsXHJcbiAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxyXG4gICAgICAgIGJyYW5jaDogdGhpcy5icmFuY2hcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHZpZXcucmVuZGVyKCkuZWwpO1xyXG4gICAgICB0aGlzLnN1YnZpZXdzW2JyYW5jaC5nZXQoJ25hbWUnKV0gPSB2aWV3O1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdGhpcy4kZWwuZmluZCgnc2VsZWN0JykuaHRtbChmcmFnKTtcclxuXHJcbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcuY2h6bi1zZWxlY3QnKS5jaG9zZW4oKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSgkKHRoaXMpLnZhbCgpLCB0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc2lkZWJhci5vcGVuKCk7XHJcblxyXG4gICAgdGhpcy5hcHAubG9hZGVyLmRvbmUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgXy5pbnZva2UodGhpcy5zdWJ2aWV3cywgJ3JlbW92ZScpO1xyXG4gICAgdGhpcy5zdWJ2aWV3cyA9IHt9O1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBDb21taXRWaWV3ID0gcmVxdWlyZSgnLi9saS9jb21taXQnKTtcclxuXHJcbnZhciBxdWV1ZSA9IHJlcXVpcmUoJ3F1ZXVlLWFzeW5jJyk7XHJcblxyXG52YXIgY29va2llID0gcmVxdWlyZSgnLi4vLi4vY29va2llJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICBzdWJ2aWV3czoge30sXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMuc2lkZWJhci5sYWJlbCxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHZhciBhcHAgPSBvcHRpb25zLmFwcDtcclxuICAgIGFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgIHRoaXMuYnJhbmNoID0gb3B0aW9ucy5icmFuY2g7XHJcbiAgICB0aGlzLmNvbW1pdHMgPSBvcHRpb25zLmNvbW1pdHM7XHJcbiAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG87XHJcbiAgICB0aGlzLnJvdXRlciA9IG9wdGlvbnMucm91dGVyO1xyXG4gICAgdGhpcy5zaWRlYmFyID0gb3B0aW9ucy5zaWRlYmFyO1xyXG4gICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xyXG4gICAgdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3O1xyXG5cclxuICAgIHRoaXMuY29tbWl0cy5zZXRCcmFuY2godGhpcy5icmFuY2gsIHtcclxuICAgICAgc3VjY2VzczogdGhpcy5yZW5kZXIsXHJcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucm91dGVyLmVycm9yKHhocik7XHJcbiAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgIGNvbXBsZXRlOiB0aGlzLmFwcC5sb2FkZXIuZG9uZVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyRmlsZXM6IGZ1bmN0aW9uKGNvbW1pdHMsIGxhYmVsKSB7XHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuc3RhcnQoKTtcclxuXHJcbiAgICAvLyBTaGFsbG93IGZsYXR0ZW4gbWFwcGVkIGFycmF5IG9mIGFsbCBjb21taXQgZmlsZXNcclxuICAgIHZhciBmaWxlcyA9IF8uZmxhdHRlbihfLm1hcChjb21taXRzLCBmdW5jdGlvbihjb21taXQpIHtcclxuICAgICAgcmV0dXJuIGNvbW1pdC5nZXQoJ2ZpbGVzJyk7XHJcbiAgICB9KSwgdHJ1ZSk7XHJcblxyXG4gICAgLypcclxuICAgIC8vIFRPRE86IGphaWwgZmlsZXMgdG8gcm9vdHVybCAjNTQxXHJcbiAgICAvLyBUaGlzIGlzIGRpZmZpY3VsdCwgYXMgcm9vdHVybCBpcyBzZXQgaW4gRmlsZXMgY29sbGVjdGlvblxyXG4gICAgLy8gb24gYSBzdWNjZXNzZnVsIGZldGNoXHJcblxyXG4gICAgaWYgKHJvb3R1cmwpIHtcclxuICAgICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmaWxlLmZpbGVuYW1lLmluZGV4T2Yocm9vdHVybCkgPT09IDA7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgKi9cclxuXHJcbiAgICB2YXIgbWFwID0gXy5ncm91cEJ5KGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgIHJldHVybiBmaWxlLmZpbGVuYW1lO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGxpc3QgPSBfLnVuaXEoXy5tYXAoZmlsZXMsIGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgcmV0dXJuIGZpbGUuZmlsZW5hbWU7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgaWYgKGxpc3QubGVuZ3RoKSB7XHJcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBmaWxlcyBhbmQgYnVpbGQgZnJhZ21lbnQgdG8gYXBwZW5kXHJcbiAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICB2YXIgdWwgPSBmcmFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJykpO1xyXG4gICAgICB1bC5jbGFzc05hbWUgPSAnbGlzdGluZyc7XHJcblxyXG4gICAgICBsaXN0LnNsaWNlKDAsNSkuZWFjaCgoZnVuY3Rpb24oZmlsZSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgY29tbWl0cyA9IG1hcFtmaWxlXTtcclxuICAgICAgICB2YXIgY29tbWl0ID0gY29tbWl0c1swXTtcclxuXHJcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgQ29tbWl0Vmlldyh7XHJcbiAgICAgICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICAgICAgZmlsZTogY29tbWl0LFxyXG4gICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxyXG4gICAgICAgICAgdmlldzogdGhpcy52aWV3XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVsLmFwcGVuZENoaWxkKHZpZXcucmVuZGVyKCkuZWwpO1xyXG5cclxuICAgICAgICB0aGlzLnN1YnZpZXdzW2NvbW1pdC5zaGFdID0gdmlldztcclxuICAgICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICB2YXIgdG1wbCA9IF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgbGFiZWwsIHsgdmFyaWFibGU6ICdsYWJlbCcgfSk7XHJcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0bXBsLCBmcmFnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFwcC5sb2FkZXIuZG9uZSgpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5hcHAubG9hZGVyLnN0YXJ0KCk7XHJcblxyXG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcclxuXHJcbiAgICAvLyBGaWx0ZXIgb24gY29tbWl0LmdldCgnYXV0aG9yJykuaWQgPT09IHRoaXMudXNlci5nZXQoJ2lkJylcclxuICAgIHZhciBpZCA9IGNvb2tpZS5nZXQoJ2lkJykgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gR3JvdXAgYW5kIGRlZHVwbGljYXRlIGNvbW1pdHMgYnkgYXV0aGVudGljYXRlZCB1c2VyXHJcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29tbWl0cy5ncm91cEJ5KGZ1bmN0aW9uKGNvbW1pdCkge1xyXG4gICAgICAvLyBIYW5kbGUgbWFsZm9ybWVkIGNvbW1pdCBkYXRhXHJcbiAgICAgIHZhciBhdXRob3IgPSBjb21taXQuZ2V0KCdhdXRob3InKSB8fCBjb21taXQuZ2V0KCdjb21taXQnKS5hdXRob3I7XHJcbiAgICAgIHJldHVybiBhdXRob3IgJiYgYXV0aG9yLmlkID09PSBpZCA/ICdhdXRob3InIDogJ2FsbCc7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUT0RPOiBob3cgbWFueSBjb21taXRzIHNob3VsZCBiZSBmZXRjaGVkIGluaXRpYWxseT9cclxuICAgIC8vIFRPRE86IG9wdGlvbiB0byBsb2FkIG1vcmU/XHJcblxyXG4gICAgLy8gTGlzdCBvZiByZWNlbnQgdXBkYXRlcyBieSBhbGwgb3RoZXIgdXNlcnNcclxuICAgIHRoaXMuaGlzdG9yeSA9IChoaXN0b3J5LmFsbCB8fCBbXSkuc2xpY2UoMCwgMTUpO1xyXG5cclxuICAgIC8vIFJlY2VudCBjb21taXRzIGJ5IGF1dGhlbnRpY2F0ZWQgdXNlclxyXG4gICAgdGhpcy5yZWNlbnQgPSAoaGlzdG9yeS5hdXRob3IgfHwgW10pLnNsaWNlKDAsIDE1KTtcclxuXHJcbiAgICB2YXIgcSA9IHF1ZXVlKCk7XHJcblxyXG4gICAgXy51bmlvbih0aGlzLmhpc3RvcnksIHRoaXMucmVjZW50KS5lYWNoKGZ1bmN0aW9uKGNvbW1pdCkge1xyXG4gICAgICBxLmRlZmVyKGZ1bmN0aW9uKGNiKSB7XHJcbiAgICAgICAgY29tbWl0LmZldGNoKHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW5zdGVhZCBvZiBzdWNjZXNzOiBjYiBmb3Igc29tZSByZWFzb25cclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlcnJvcjogKGZ1bmN0aW9uKG1vZGVsLCB4aHIsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIuZXJyb3IoeGhyKTtcclxuICAgICAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcS5hd2FpdEFsbCgoZnVuY3Rpb24oZXJyLCByZXMpIHtcclxuICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyRmlsZXModGhpcy5oaXN0b3J5LCAnSGlzdG9yeScpO1xyXG4gICAgICB0aGlzLnJlbmRlckZpbGVzKHRoaXMucmVjZW50LCB0KCdzaWRlYmFyLnJlcG8uaGlzdG9yeS5sYWJlbCcpKTtcclxuXHJcbiAgICAgIHRoaXMuc2lkZWJhci5vcGVuKCk7XHJcblxyXG4gICAgICB0aGlzLmFwcC5sb2FkZXIuZG9uZSgpO1xyXG4gICAgfSkuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIF8uaW52b2tlKHRoaXMuc3Vidmlld3MsICdyZW1vdmUnKTtcclxuICAgIHRoaXMuc3Vidmlld3MgPSB7fTtcclxuXHJcbiAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIGNsYXNzTmFtZTogJ2lubmVyJyxcclxuXHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5zaWRlYmFyLmRyYWZ0cyxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgXy5iaW5kQWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubGluayA9IG9wdGlvbnMubGluaztcclxuICAgIHRoaXMuc2lkZWJhciA9IG9wdGlvbnMuc2lkZWJhcjtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy4kZWwuaHRtbChfLnRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIHRoaXMubGluaywge1xyXG4gICAgICB2YXJpYWJsZTogJ2xpbmsnXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdGhpcy5zaWRlYmFyLm9wZW4oKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgTmF2VmlldyA9IHJlcXVpcmUoJy4uL25hdicpO1xyXG52YXIgdGVtcGxhdGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGlzdC90ZW1wbGF0ZXMnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0ZW1wbGF0ZTogdGVtcGxhdGVzLnNpZGViYXIuc2F2ZSxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnY2hhbmdlIC5jb21taXQtbWVzc2FnZSc6ICdzZXRNZXNzYWdlJyxcclxuICAgICdjbGljayBhLmNhbmNlbCc6ICdlbWl0JyxcclxuICAgICdjbGljayBhLmNvbmZpcm0nOiAnZW1pdCdcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBfLmJpbmRBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zaWRlYmFyID0gb3B0aW9ucy5zaWRlYmFyO1xyXG4gICAgdGhpcy5maWxlID0gb3B0aW9ucy5maWxlO1xyXG5cclxuICAgIC8vIFJlLXJlbmRlciB1cGRhdGVkIHBhdGggaW4gY29tbWl0IG1lc3NhZ2VcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5maWxlLCAnY2hhbmdlOnBhdGgnLCB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyKTtcclxuICB9LFxyXG5cclxuICBlbWl0OiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYWN0aW9uID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2FjdGlvbicpO1xyXG4gICAgdGhpcy5zaWRlYmFyLnRyaWdnZXIoYWN0aW9uLCBlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBzZXRNZXNzYWdlOiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XHJcbiAgICB0aGlzLmZpbGUuc2V0KCdtZXNzYWdlJywgdmFsdWUpO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbihtb2RlbCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBuYW1lID0gdXRpbC5leHRyYWN0RmlsZW5hbWUodmFsdWUpWzFdO1xyXG5cclxuICAgIHZhciBwbGFjZWhvbGRlciA9IHRoaXMuZmlsZS5pc05ldygpID9cclxuICAgICAgdCgnYWN0aW9ucy5jb21taXRzLmNyZWF0ZWQnLCB7IGZpbGVuYW1lOiBuYW1lIH0pIDpcclxuICAgICAgdCgnYWN0aW9ucy5jb21taXRzLnVwZGF0ZWQnLCB7IGZpbGVuYW1lOiBuYW1lIH0pO1xyXG5cclxuICAgIHRoaXMuZmlsZS5zZXQoJ3BsYWNlaG9sZGVyJywgcGxhY2Vob2xkZXIpO1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLmNvbW1pdC1tZXNzYWdlJykuYXR0cigncGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlcik7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB3cml0YWJsZSA9IHRoaXMuZmlsZS5nZXQoJ3dyaXRhYmxlJykgP1xyXG4gICAgICB0KCdzaWRlYmFyLnNhdmUuc2F2ZScpIDpcclxuICAgICAgdCgnc2lkZWJhci5zYXZlLnN1Ym1pdCcpXHJcblxyXG4gICAgdGhpcy4kZWwuaHRtbChfLnRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIHdyaXRhYmxlLCB7XHJcbiAgICAgIHZhcmlhYmxlOiAnd3JpdGFibGUnXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVQbGFjZWhvbGRlcih0aGlzLmZpbGUsIHRoaXMuZmlsZS5nZXQoJ3BhdGgnKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59KTtcclxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIE5hdlZpZXcgPSByZXF1aXJlKCcuLi9uYXYnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5zaWRlYmFyLnNldHRpbmdzLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjbGljayBhLmRlbGV0ZSc6ICdlbWl0JyxcclxuICAgICdjbGljayBhLnRyYW5zbGF0ZSc6ICdlbWl0JyxcclxuICAgICdjbGljayBhLmRyYWZ0JzogJ2VtaXQnLFxyXG4gICAgJ2NoYW5nZSBpbnB1dC5maWxlcGF0aCc6ICdzZXRQYXRoJ1xyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuc2lkZWJhciA9IG9wdGlvbnMuc2lkZWJhcjtcclxuICAgIHRoaXMuY29uZmlnID0gb3B0aW9ucy5jb25maWc7XHJcbiAgICB0aGlzLmZpbGUgPSBvcHRpb25zLmZpbGU7XHJcblxyXG4gICAgLy8gZmlsZUlucHV0IGlzIHBhc3NlZCBpZiBhIHRpdGxlIHJlcGxhY2VzIHdoZXJlIGl0XHJcbiAgICAvLyBub3JtYWxseSBpcyBzaG93biBpbiB0aGUgaGVhZGluZyBvZiB0aGUgZmlsZS5cclxuICAgIHRoaXMuZmlsZUlucHV0ID0gb3B0aW9ucy5maWxlSW5wdXQ7XHJcblxyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmZpbGUsICdjaGFuZ2U6cGF0aCcsIHRoaXMudXBkYXRlUGF0aCk7XHJcbiAgfSxcclxuXHJcbiAgZW1pdDogZnVuY3Rpb24oZSkge1xyXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICB2YXIgYWN0aW9uID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2FjdGlvbicpO1xyXG4gICAgdGhpcy5zaWRlYmFyLnRyaWdnZXIoYWN0aW9uLCBlKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVQYXRoOiBmdW5jdGlvbihtb2RlbCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIC8vIFNldCBwYXRoIHZhbHVlIGZyb20gcGF0aCBhdHRyIGluIGZpbGUgbW9kZWxcclxuICAgIHRoaXMuJGVsLmZpbmQoJ2lucHV0LmZpbGVwYXRoJykuYXR0cigndmFsdWUnLCB2YWx1ZSk7XHJcbiAgfSxcclxuXHJcbiAgc2V0UGF0aDogZnVuY3Rpb24oZSkge1xyXG4gICAgdGhpcy5maWxlLnNldCgncGF0aCcsIGUuY3VycmVudFRhcmdldC52YWx1ZSk7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ21ha2VEaXJ0eScpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyB0aGlzLmZpbGUuZ2V0KCdsYW5nJykgaXMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VcclxuICAgIC8vIHRoaXMuZmlsZS5nZXQoJ21ldGFkYXRhJykubGFuZyBpcyBJU08gNjM5LTEgbGFuZ3VhZ2UgY29kZVxyXG4gICAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgICBsYW5ndWFnZXM6IHRoaXMuY29uZmlnID8gdGhpcy5jb25maWcubGFuZ3VhZ2VzIDogW10sXHJcbiAgICAgIGxhbmc6IHRoaXMuZmlsZS5nZXQoJ2xhbmcnKSxcclxuICAgICAgbWV0YWRhdGE6IHRoaXMuZmlsZS5nZXQoJ21ldGFkYXRhJyksXHJcbiAgICAgIGZpbGVJbnB1dDogdGhpcy5maWxlSW5wdXQsXHJcbiAgICAgIHBhdGg6IHRoaXMuZmlsZS5nZXQoJ3BhdGgnKVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLiRlbC5odG1sKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgc2V0dGluZ3MsIHtcclxuICAgICAgdmFyaWFibGU6ICdzZXR0aW5ncydcclxuICAgIH0pKTtcclxuXHJcbiAgICB1dGlsLmF1dG9TZWxlY3QodGhpcy4kZWwuZmluZCgnaW5wdXQuZmlsZXBhdGgnKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeS1icm93c2VyaWZ5Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgQ29tbWl0VmlldyA9IHJlcXVpcmUoJy4uL3NpZGViYXIvbGkvY29tbWl0Jyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubGkuZmlsZSxcclxuXHJcbiAgdGFnTmFtZTogJ2xpJyxcclxuXHJcbiAgY2xhc3NOYW1lOiAnaXRlbSBjbGVhcmZpeCcsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIGEuZGVsZXRlJzogJ2Rlc3Ryb3knXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5icmFuY2ggPSBvcHRpb25zLmJyYW5jaDtcclxuICAgIHRoaXMuaGlzdG9yeSA9IG9wdGlvbnMuaGlzdG9yeTtcclxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgdGhpcy5yZXBvID0gb3B0aW9ucy5yZXBvO1xyXG4gICAgdGhpcy5yb3V0ZXIgPSBvcHRpb25zLnJvdXRlcjtcclxuXHJcbiAgICB0aGlzLiRlbC5hdHRyKCdkYXRhLWluZGV4Jywgb3B0aW9ucy5pbmRleCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldCgnYmluYXJ5JykpIHtcclxuICAgICAgdGhpcy4kZWwuYXR0cignZGF0YS1uYXZpZ2F0ZScsICcjJyArIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4gKyAnLycgK1xyXG4gICAgICAgIHRoaXMucmVwby5nZXQoJ25hbWUnKSArICcvZWRpdC8nICsgdGhpcy5icmFuY2ggKyAnLycgK1xyXG4gICAgICAgIHRoaXMubW9kZWwuZ2V0KCdwYXRoJykpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHRoaXMubW9kZWwuYXR0cmlidXRlcywge1xyXG4gICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICByZXBvOiB0aGlzLnJlcG8uYXR0cmlidXRlc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJvb3R1cmwgPSB0aGlzLm1vZGVsLmNvbGxlY3Rpb24uY29uZmlnICYmXHJcbiAgICAgIHRoaXMubW9kZWwuY29sbGVjdGlvbi5jb25maWcucm9vdHVybDtcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgcm9vdHVybCArICcoLiopJyk7XHJcbiAgICB2YXIgamFpbHBhdGggPSByb290dXJsID8gZGF0YS5wYXRoLm1hdGNoKHJlZ2V4KSA6IGZhbHNlO1xyXG5cclxuICAgIGRhdGEuamFpbHBhdGggPSBqYWlscGF0aCA/IGphaWxwYXRoWzFdIDogZGF0YS5wYXRoO1xyXG5cclxuICAgIHRoaXMuJGVsLmh0bWwoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBkYXRhLCB7XHJcbiAgICAgIHZhcmlhYmxlOiAnZmlsZSdcclxuICAgIH0pKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBkZXN0cm95OiBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoY29uZmlybSh0KCdhY3Rpb25zLmRlbGV0ZS53YXJuJykpKSB7XHJcbiAgICAgIHRoaXMubW9kZWwuZGVzdHJveSh7XHJcbiAgICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgIHZhciBjb21taXQgPSByZXMuY29tbWl0O1xyXG5cclxuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IENvbW1pdFZpZXcoe1xyXG4gICAgICAgICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICAgICAgICBmaWxlOiBfLmV4dGVuZChjb21taXQsIHtcclxuICAgICAgICAgICAgICBjb250ZW50c191cmw6IG1vZGVsLmdldCgnY29udGVudF91cmwnKSxcclxuICAgICAgICAgICAgICBmaWxlbmFtZTogbW9kZWwuZ2V0KCdwYXRoJyksXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAncmVtb3ZlZCdcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcclxuICAgICAgICAgICAgdmlldzogdGhpcy52aWV3XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICB0aGlzLmhpc3RvcnkuJGVsLmZpbmQoJyNjb21taXRzJykucHJlcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcclxuICAgICAgICAgIHRoaXMuaGlzdG9yeS5zdWJ2aWV3c1tjb21taXQuc2hhXSA9IHZpZXc7XHJcblxyXG4gICAgICAgICAgdGhpcy4kZWwuZmFkZU91dCgnZmFzdCcpO1xyXG4gICAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgICAgZXJyb3I6IChmdW5jdGlvbihtb2RlbCwgeGhyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICB0aGlzLnJvdXRlci5lcnJvcih4aHIpO1xyXG4gICAgICAgIH0pLmJpbmQodGhpcylcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSk7XHJcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3RlbXBsYXRlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGFnTmFtZTogJ2xpJyxcclxuXHJcbiAgY2xhc3NOYW1lOiAnaXRlbSBjbGVhcmZpeCcsXHJcblxyXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZXMubGkuZm9sZGVyLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcclxuICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbztcclxuICAgIHRoaXMuYnJhbmNoID0gb3B0aW9ucy5icmFuY2g7XHJcblxyXG4gICAgdGhpcy4kZWwuYXR0cignZGF0YS1pbmRleCcsIG9wdGlvbnMuaW5kZXgpO1xyXG4gICAgdGhpcy4kZWwuYXR0cignZGF0YS1uYXZpZ2F0ZScsICcjJyArIHRoaXMucmVwby5nZXQoJ293bmVyJykubG9naW4gKyAnLycgK1xyXG4gICAgICB0aGlzLnJlcG8uZ2V0KCduYW1lJykgKyAnL3RyZWUvJyArIHRoaXMuYnJhbmNoICsgJy8nICtcclxuICAgICAgdGhpcy5tb2RlbC5nZXQoJ3BhdGgnKSk7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBkYXRhID0gXy5leHRlbmQodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLCB7XHJcbiAgICAgIGJyYW5jaDogdGhpcy5icmFuY2gsXHJcbiAgICAgIHJlcG86IHRoaXMucmVwby5hdHRyaWJ1dGVzXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcm9vdHVybCA9IHRoaXMubW9kZWwuY29sbGVjdGlvbi5jb25maWcgJiZcclxuICAgICAgdGhpcy5tb2RlbC5jb2xsZWN0aW9uLmNvbmZpZy5yb290dXJsO1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyByb290dXJsICsgJyguKiknKTtcclxuICAgIHZhciBqYWlscGF0aCA9IHJvb3R1cmwgPyBkYXRhLnBhdGgubWF0Y2gocmVnZXgpIDogZmFsc2U7XHJcblxyXG4gICAgZGF0YS5qYWlscGF0aCA9IGphaWxwYXRoID8gamFpbHBhdGhbMV0gOiBkYXRhLnBhdGg7XHJcblxyXG4gICAgdGhpcy4kZWwuZW1wdHkoKS5hcHBlbmQoXy50ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCBkYXRhLCB7XHJcbiAgICAgIHZhcmlhYmxlOiAnZm9sZGVyJ1xyXG4gICAgfSkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcclxudmFyIFR5cGUgICAgICAgICAgPSByZXF1aXJlKCcuL3R5cGUnKTtcclxuXHJcblxyXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xyXG4gIHZhciBleGNsdWRlID0gW107XHJcblxyXG4gIHNjaGVtYS5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24gKGluY2x1ZGVkU2NoZW1hKSB7XHJcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcclxuICB9KTtcclxuXHJcbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XHJcbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocHJldmlvdXNUeXBlLCBwcmV2aW91c0luZGV4KSB7XHJcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcpIHtcclxuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRUeXBlKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gLTEgPT09IGV4Y2x1ZGUuaW5kZXhPZihpbmRleCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XHJcbiAgdmFyIHJlc3VsdCA9IHt9LCBpbmRleCwgbGVuZ3RoO1xyXG5cclxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XHJcbiAgICByZXN1bHRbdHlwZS50YWddID0gdHlwZTtcclxuICB9XHJcblxyXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xyXG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xyXG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xyXG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xyXG5cclxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgIGlmIChudWxsICE9PSB0eXBlLmxvYWRlciAmJiAnc3RyaW5nJyAhPT0gdHlwZS5sb2FkZXIua2luZCkge1xyXG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcclxuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XHJcbiAgdGhpcy5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XHJcbn1cclxuXHJcblxyXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XHJcblxyXG5cclxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcclxuICB2YXIgc2NoZW1hcywgdHlwZXM7XHJcblxyXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gIGNhc2UgMTpcclxuICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcclxuICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xyXG4gICAgYnJlYWs7XHJcblxyXG4gIGNhc2UgMjpcclxuICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XHJcbiAgICB0eXBlcyA9IGFyZ3VtZW50c1sxXTtcclxuICAgIGJyZWFrO1xyXG5cclxuICBkZWZhdWx0OlxyXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFNjaGVtYS5jcmVhdGUgZnVuY3Rpb24nKTtcclxuICB9XHJcblxyXG4gIHNjaGVtYXMgPSBjb21tb24udG9BcnJheShzY2hlbWFzKTtcclxuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcclxuXHJcbiAgaWYgKCFzY2hlbWFzLmV2ZXJ5KGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTsgfSkpIHtcclxuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XHJcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xyXG4gICAgaW5jbHVkZTogc2NoZW1hcyxcclxuICAgIGV4cGxpY2l0OiB0eXBlc1xyXG4gIH0pO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xyXG5cclxuXHJcbi8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxyXG5mdW5jdGlvbiBUeXBlKHRhZywgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB0aGlzLnRhZyAgICA9IHRhZztcclxuICB0aGlzLmxvYWRlciA9IG9wdGlvbnNbJ2xvYWRlciddIHx8IG51bGw7XHJcbiAgdGhpcy5kdW1wZXIgPSBvcHRpb25zWydkdW1wZXInXSB8fCBudWxsO1xyXG5cclxuICBpZiAobnVsbCA9PT0gdGhpcy5sb2FkZXIgJiYgbnVsbCA9PT0gdGhpcy5kdW1wZXIpIHtcclxuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdJbmNvbXBsZXRlIFlBTUwgdHlwZSBkZWZpbml0aW9uLiBcImxvYWRlclwiIG9yIFwiZHVtcGVyXCIgc2V0dGluZyBtdXN0IGJlIHNwZWNpZmllZC4nKTtcclxuICB9XHJcblxyXG4gIGlmIChudWxsICE9PSB0aGlzLmxvYWRlcikge1xyXG4gICAgdGhpcy5sb2FkZXIgPSBuZXcgVHlwZS5Mb2FkZXIodGhpcy5sb2FkZXIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG51bGwgIT09IHRoaXMuZHVtcGVyKSB7XHJcbiAgICB0aGlzLmR1bXBlciA9IG5ldyBUeXBlLkR1bXBlcih0aGlzLmR1bXBlcik7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuVHlwZS5Mb2FkZXIgPSBmdW5jdGlvbiBUeXBlTG9hZGVyKG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdGhpcy5raW5kICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgfHwgbnVsbDtcclxuICB0aGlzLnJlc29sdmVyID0gb3B0aW9uc1sncmVzb2x2ZXInXSB8fCBudWxsO1xyXG5cclxuICBpZiAoJ3N0cmluZycgIT09IHRoaXMua2luZCAmJlxyXG4gICAgICAnYXJyYXknICAhPT0gdGhpcy5raW5kICYmXHJcbiAgICAgICdvYmplY3QnICE9PSB0aGlzLmtpbmQpIHtcclxuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmFjY2VwdGFibGUgXCJraW5kXCIgc2V0dGluZyBvZiBhIHR5cGUgbG9hZGVyLicpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBjb21waWxlQWxpYXNlcyhtYXApIHtcclxuICB2YXIgcmVzdWx0ID0ge307XHJcblxyXG4gIGlmIChudWxsICE9PSBtYXApIHtcclxuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xyXG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcblR5cGUuRHVtcGVyID0gZnVuY3Rpb24gVHlwZUR1bXBlcihvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcclxuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XHJcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xyXG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcclxuICB0aGlzLnJlcHJlc2VudGVyICA9IG9wdGlvbnNbJ3JlcHJlc2VudGVyJ10gIHx8IG51bGw7XHJcbiAgdGhpcy5zdHlsZUFsaWFzZXMgPSBjb21waWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcclxuXHJcbiAgaWYgKCd1bmRlZmluZWQnICE9PSB0aGlzLmtpbmQgJiZcclxuICAgICAgJ251bGwnICAgICAgIT09IHRoaXMua2luZCAmJlxyXG4gICAgICAnYm9vbGVhbicgICAhPT0gdGhpcy5raW5kICYmXHJcbiAgICAgICdpbnRlZ2VyJyAgICE9PSB0aGlzLmtpbmQgJiZcclxuICAgICAgJ2Zsb2F0JyAgICAgIT09IHRoaXMua2luZCAmJlxyXG4gICAgICAnc3RyaW5nJyAgICAhPT0gdGhpcy5raW5kICYmXHJcbiAgICAgICdhcnJheScgICAgICE9PSB0aGlzLmtpbmQgJiZcclxuICAgICAgJ29iamVjdCcgICAgIT09IHRoaXMua2luZCAmJlxyXG4gICAgICAnZnVuY3Rpb24nICAhPT0gdGhpcy5raW5kKSB7XHJcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5hY2NlcHRhYmxlIFwia2luZFwiIHNldHRpbmcgb2YgYSB0eXBlIGR1bXBlci4nKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGZzICAgICA9IHJlcXVpcmUoJ2ZzJyk7XHJcbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHlhbWxSZXF1aXJlSGFuZGxlcihtb2R1bGUsIGZpbGVuYW1lKSB7XHJcbiAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XHJcblxyXG4gIC8vIGZpbGwgaW4gZG9jdW1lbnRzXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBsb2FkZXIuc2FmZUxvYWQoY29udGVudCwgeyBmaWxlbmFtZTogZmlsZW5hbWUgfSk7XHJcbn1cclxuXHJcbi8vIHJlZ2lzdGVyIHJlcXVpcmUgZXh0ZW5zaW9ucyBvbmx5IGlmIHdlJ3JlIG9uIG5vZGUuanNcclxuLy8gaGFjayBmb3IgYnJvd3NlcmlmeVxyXG5pZiAodW5kZWZpbmVkICE9PSByZXF1aXJlLmV4dGVuc2lvbnMpIHtcclxuICByZXF1aXJlLmV4dGVuc2lvbnNbJy55bWwnXSAgPSB5YW1sUmVxdWlyZUhhbmRsZXI7XHJcbiAgcmVxdWlyZS5leHRlbnNpb25zWycueWFtbCddID0geWFtbFJlcXVpcmVIYW5kbGVyO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XHJcbnZhciBNYXJrICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9tYXJrJyk7XHJcbnZhciBOSUwgICAgICAgICAgICAgICAgID0gY29tbW9uLk5JTDtcclxudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcclxudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcclxuXHJcblxyXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcblxyXG52YXIgS0lORF9TVFJJTkcgPSAnc3RyaW5nJztcclxudmFyIEtJTkRfQVJSQVkgID0gJ2FycmF5JztcclxudmFyIEtJTkRfT0JKRUNUID0gJ29iamVjdCc7XHJcblxyXG5cclxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcclxudmFyIENPTlRFWFRfRkxPV19PVVQgID0gMjtcclxudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcclxudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcclxuXHJcblxyXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xyXG52YXIgQ0hPTVBJTkdfU1RSSVAgPSAyO1xyXG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xyXG5cclxuXHJcbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgICAvKiBUYWIgKi9cclxudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAgIC8qIExGICovXHJcbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgICAvKiBDUiAqL1xyXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7ICAgLyogU3BhY2UgKi9cclxudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAgIC8qICEgKi9cclxudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAgIC8qIFwiICovXHJcbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgICAvKiAjICovXHJcbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgICAvKiAlICovXHJcbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgICAvKiAmICovXHJcbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgICAvKiAnICovXHJcbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgICAvKiAqICovXHJcbnZhciBDSEFSX1BMVVMgICAgICAgICAgICAgICAgID0gMHgyQjsgICAvKiArICovXHJcbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgICAvKiAsICovXHJcbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgICAvKiAtICovXHJcbnZhciBDSEFSX0RPVCAgICAgICAgICAgICAgICAgID0gMHgyRTsgICAvKiAuICovXHJcbnZhciBDSEFSX1NMQVNIICAgICAgICAgICAgICAgID0gMHgyRjsgICAvKiAvICovXHJcbnZhciBDSEFSX0RJR0lUX1pFUk8gICAgICAgICAgID0gMHgzMDsgICAvKiAwICovXHJcbnZhciBDSEFSX0RJR0lUX09ORSAgICAgICAgICAgID0gMHgzMTsgICAvKiAxICovXHJcbnZhciBDSEFSX0RJR0lUX05JTkUgICAgICAgICAgID0gMHgzOTsgICAvKiA5ICovXHJcbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgICAvKiA6ICovXHJcbnZhciBDSEFSX0xFU1NfVEhBTiAgICAgICAgICAgID0gMHgzQzsgICAvKiA8ICovXHJcbnZhciBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID0gMHgzRTsgICAvKiA+ICovXHJcbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgICAvKiA/ICovXHJcbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgICAvKiBAICovXHJcbnZhciBDSEFSX0NBUElUQUxfQSAgICAgICAgICAgID0gMHg0MTsgICAvKiBBICovXHJcbnZhciBDSEFSX0NBUElUQUxfRiAgICAgICAgICAgID0gMHg0NjsgICAvKiBGICovXHJcbnZhciBDSEFSX0NBUElUQUxfTCAgICAgICAgICAgID0gMHg0QzsgICAvKiBMICovXHJcbnZhciBDSEFSX0NBUElUQUxfTiAgICAgICAgICAgID0gMHg0RTsgICAvKiBOICovXHJcbnZhciBDSEFSX0NBUElUQUxfUCAgICAgICAgICAgID0gMHg1MDsgICAvKiBQICovXHJcbnZhciBDSEFSX0NBUElUQUxfVSAgICAgICAgICAgID0gMHg1NTsgICAvKiBVICovXHJcbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID0gMHg1QjsgICAvKiBbICovXHJcbnZhciBDSEFSX0JBQ0tTTEFTSCAgICAgICAgICAgID0gMHg1QzsgICAvKiBcXCAqL1xyXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7ICAgLyogXSAqL1xyXG52YXIgQ0hBUl9VTkRFUlNDT1JFICAgICAgICAgICA9IDB4NUY7ICAgLyogXyAqL1xyXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7ICAgLyogYCAqL1xyXG52YXIgQ0hBUl9TTUFMTF9BICAgICAgICAgICAgICA9IDB4NjE7ICAgLyogYSAqL1xyXG52YXIgQ0hBUl9TTUFMTF9CICAgICAgICAgICAgICA9IDB4NjI7ICAgLyogYiAqL1xyXG52YXIgQ0hBUl9TTUFMTF9FICAgICAgICAgICAgICA9IDB4NjU7ICAgLyogZSAqL1xyXG52YXIgQ0hBUl9TTUFMTF9GICAgICAgICAgICAgICA9IDB4NjY7ICAgLyogZiAqL1xyXG52YXIgQ0hBUl9TTUFMTF9OICAgICAgICAgICAgICA9IDB4NkU7ICAgLyogbiAqL1xyXG52YXIgQ0hBUl9TTUFMTF9SICAgICAgICAgICAgICA9IDB4NzI7ICAgLyogciAqL1xyXG52YXIgQ0hBUl9TTUFMTF9UICAgICAgICAgICAgICA9IDB4NzQ7ICAgLyogdCAqL1xyXG52YXIgQ0hBUl9TTUFMTF9VICAgICAgICAgICAgICA9IDB4NzU7ICAgLyogdSAqL1xyXG52YXIgQ0hBUl9TTUFMTF9WICAgICAgICAgICAgICA9IDB4NzY7ICAgLyogdiAqL1xyXG52YXIgQ0hBUl9TTUFMTF9YICAgICAgICAgICAgICA9IDB4Nzg7ICAgLyogeCAqL1xyXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7ICAgLyogeyAqL1xyXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7ICAgLyogfCAqL1xyXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7ICAgLyogfSAqL1xyXG5cclxuXHJcbnZhciBTSU1QTEVfRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xyXG5cclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9ESUdJVF9aRVJPXSAgID0gJ1xceDAwJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9BXSAgICAgID0gJ1xceDA3JztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9CXSAgICAgID0gJ1xceDA4JztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9UXSAgICAgID0gJ1xceDA5JztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9UQUJdICAgICAgICAgID0gJ1xceDA5JztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9OXSAgICAgID0gJ1xceDBBJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9WXSAgICAgID0gJ1xceDBCJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9GXSAgICAgID0gJ1xceDBDJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9SXSAgICAgID0gJ1xceDBEJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9FXSAgICAgID0gJ1xceDFCJztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TUEFDRV0gICAgICAgID0gJyAnO1xyXG5TSU1QTEVfRVNDQVBFX1NFUVVFTkNFU1tDSEFSX0RPVUJMRV9RVU9URV0gPSAnXFx4MjInO1xyXG5TSU1QTEVfRVNDQVBFX1NFUVVFTkNFU1tDSEFSX1NMQVNIXSAgICAgICAgPSAnLyc7XHJcblNJTVBMRV9FU0NBUEVfU0VRVUVOQ0VTW0NIQVJfQkFDS1NMQVNIXSAgICA9ICdcXHg1Qyc7XHJcblNJTVBMRV9FU0NBUEVfU0VRVUVOQ0VTW0NIQVJfQ0FQSVRBTF9OXSAgICA9ICdcXHg4NSc7XHJcblNJTVBMRV9FU0NBUEVfU0VRVUVOQ0VTW0NIQVJfVU5ERVJTQ09SRV0gICA9ICdcXHhBMCc7XHJcblNJTVBMRV9FU0NBUEVfU0VRVUVOQ0VTW0NIQVJfQ0FQSVRBTF9MXSAgICA9ICdcXHUyMDI4JztcclxuU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9DQVBJVEFMX1BdICAgID0gJ1xcdTIwMjknO1xyXG5cclxuXHJcbnZhciBIRVhBREVDSU1BTF9FU0NBUEVfU0VRVUVOQ0VTID0ge307XHJcblxyXG5IRVhBREVDSU1BTF9FU0NBUEVfU0VRVUVOQ0VTW0NIQVJfU01BTExfWF0gICA9IDI7XHJcbkhFWEFERUNJTUFMX0VTQ0FQRV9TRVFVRU5DRVNbQ0hBUl9TTUFMTF9VXSAgID0gNDtcclxuSEVYQURFQ0lNQUxfRVNDQVBFX1NFUVVFTkNFU1tDSEFSX0NBUElUQUxfVV0gPSA4O1xyXG5cclxuXHJcbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RDgwMC1cXHVERkZGXFx1RkZGRVxcdUZGRkZdLztcclxudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XHJcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyAgICAgICA9IC9bLFxcW1xcXVxce1xcfV0vO1xyXG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xyXG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xyXG5cclxuXHJcbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIG91dHB1dCwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB2YXIgZmlsZW5hbWUgPSBvcHRpb25zWydmaWxlbmFtZSddIHx8IG51bGwsXHJcbiAgICAgIHNjaGVtYSAgID0gb3B0aW9uc1snc2NoZW1hJ10gICB8fCBERUZBVUxUX0ZVTExfU0NIRU1BLFxyXG4gICAgICByZXNvbHZlICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgfHwgdHJ1ZSxcclxuICAgICAgdmFsaWRhdGUgPSBvcHRpb25zWyd2YWxpZGF0ZSddIHx8IHRydWUsXHJcbiAgICAgIHN0cmljdCAgID0gb3B0aW9uc1snc3RyaWN0J10gICB8fCBmYWxzZSxcclxuICAgICAgbGVnYWN5ICAgPSBvcHRpb25zWydsZWdhY3knXSAgIHx8IGZhbHNlLFxyXG5cclxuICAgICAgZGlyZWN0aXZlSGFuZGxlcnMgPSB7fSxcclxuICAgICAgaW1wbGljaXRUeXBlcyAgICAgPSBzY2hlbWEuY29tcGlsZWRJbXBsaWNpdCxcclxuICAgICAgdHlwZU1hcCAgICAgICAgICAgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwLFxyXG5cclxuICAgICAgbGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aCxcclxuICAgICAgcG9zaXRpb24gICA9IDAsXHJcbiAgICAgIGxpbmUgICAgICAgPSAwLFxyXG4gICAgICBsaW5lU3RhcnQgID0gMCxcclxuICAgICAgbGluZUluZGVudCA9IDAsXHJcbiAgICAgIGNoYXJhY3RlciAgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKSxcclxuXHJcbiAgICAgIHZlcnNpb24sXHJcbiAgICAgIGNoZWNrTGluZUJyZWFrcyxcclxuICAgICAgdGFnTWFwLFxyXG4gICAgICBhbmNob3JNYXAsXHJcbiAgICAgIHRhZyxcclxuICAgICAgYW5jaG9yLFxyXG4gICAgICBraW5kLFxyXG4gICAgICByZXN1bHQ7XHJcblxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBZQU1MRXhjZXB0aW9uKFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBuZXcgTWFyayhmaWxlbmFtZSwgaW5wdXQsIHBvc2l0aW9uLCBsaW5lLCAocG9zaXRpb24gLSBsaW5lU3RhcnQpKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UpIHtcclxuICAgIHRocm93IGdlbmVyYXRlRXJyb3IobWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0aHJvd1dhcm5pbmcobWVzc2FnZSkge1xyXG4gICAgdmFyIGVycm9yID0gZ2VuZXJhdGVFcnJvcihtZXNzYWdlKTtcclxuXHJcbiAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS53YXJuKGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlyZWN0aXZlSGFuZGxlcnNbJ1lBTUwnXSA9IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUobmFtZSwgYXJncykge1xyXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XHJcblxyXG4gICAgaWYgKG51bGwgIT09IHZlcnNpb24pIHtcclxuICAgICAgdGhyb3dFcnJvcignZHVwbGljYXRpb24gb2YgJVlBTUwgZGlyZWN0aXZlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKDEgIT09IGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XHJcblxyXG4gICAgaWYgKG51bGwgPT09IG1hdGNoKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFqb3IgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xyXG5cclxuICAgIGlmICgxICE9PSBtYWpvcikge1xyXG4gICAgICB0aHJvd0Vycm9yKCd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHZlcnNpb24gPSBhcmdzWzBdO1xyXG4gICAgY2hlY2tMaW5lQnJlYWtzID0gKG1pbm9yIDwgMik7XHJcblxyXG4gICAgaWYgKDEgIT09IG1pbm9yICYmIDIgIT09IG1pbm9yKSB7XHJcbiAgICAgIHRocm93V2FybmluZygndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGRpcmVjdGl2ZUhhbmRsZXJzWydUQUcnXSA9IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShuYW1lLCBhcmdzKSB7XHJcbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XHJcblxyXG4gICAgaWYgKDIgIT09IGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGUgPSBhcmdzWzBdO1xyXG4gICAgcHJlZml4ID0gYXJnc1sxXTtcclxuXHJcbiAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KGhhbmRsZSkpIHtcclxuICAgICAgdGhyb3dFcnJvcignaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodGFnTWFwLCBoYW5kbGUpKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNhcHR1cmVTZWdtZW50KHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xyXG4gICAgdmFyIF9wb3NpdGlvbiwgX2xlbmd0aCwgX2NoYXJhY3RlciwgX3Jlc3VsdDtcclxuXHJcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgX3Jlc3VsdCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgaWYgKGNoZWNrSnNvbiAmJiB2YWxpZGF0ZSkge1xyXG4gICAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgX3Bvc2l0aW9uIDwgX2xlbmd0aDtcclxuICAgICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XHJcbiAgICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XHJcbiAgICAgICAgICBpZiAoISgweDA5ID09PSBfY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcignZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdCArPSBfcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhkZXN0aW5hdGlvbiwgc291cmNlKSB7XHJcbiAgICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XHJcblxyXG4gICAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICB0aHJvd0Vycm9yKCdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG5cclxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XHJcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xyXG5cclxuICAgICAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkge1xyXG4gICAgdmFyIGluZGV4LCBxdWFudGl0eTtcclxuXHJcbiAgICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xyXG5cclxuICAgIGlmIChudWxsID09PSBfcmVzdWx0KSB7XHJcbiAgICAgIF9yZXN1bHQgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJyA9PT0ga2V5VGFnKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICBtZXJnZU1hcHBpbmdzKF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZXJnZU1hcHBpbmdzKF9yZXN1bHQsIHZhbHVlTm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9yZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkTGluZUJyZWFrKCkge1xyXG4gICAgaWYgKENIQVJfTElORV9GRUVEID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgcG9zaXRpb24gKz0gMTtcclxuICAgIH0gZWxzZSBpZiAoQ0hBUl9DQVJSSUFHRV9SRVRVUk4gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICBpZiAoQ0hBUl9MSU5FX0ZFRUQgPT09IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkge1xyXG4gICAgICAgIHBvc2l0aW9uICs9IDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcG9zaXRpb24gKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3dFcnJvcignYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGluZSArPSAxO1xyXG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb247XHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2UoYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcclxuICAgIHZhciBsaW5lQnJlYWtzID0gMDtcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgd2hpbGUgKENIQVJfU1BBQ0UgPT09IGNoYXJhY3RlciB8fCBDSEFSX1RBQiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFsbG93Q29tbWVudHMgJiYgQ0hBUl9TSEFSUCA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgZG8geyBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pOyB9XHJcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgIENIQVJfTElORV9GRUVEICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gIT09IGNoYXJhY3Rlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChDSEFSX0xJTkVfRkVFRCA9PT0gY2hhcmFjdGVyIHx8IENIQVJfQ0FSUklBR0VfUkVUVVJOID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICByZWFkTGluZUJyZWFrKCk7XHJcbiAgICAgICAgbGluZUJyZWFrcyArPSAxO1xyXG4gICAgICAgIGxpbmVJbmRlbnQgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoQ0hBUl9TUEFDRSA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICBsaW5lSW5kZW50ICs9IDE7XHJcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xyXG4gICAgICAgICAgdGhyb3dXYXJuaW5nKCdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGluZUJyZWFrcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcigpIHtcclxuICAgIHZhciBfcG9zaXRpb24sIF9jaGFyYWN0ZXI7XHJcblxyXG4gICAgaWYgKHBvc2l0aW9uID09PSBsaW5lU3RhcnQgJiZcclxuICAgICAgICAoQ0hBUl9NSU5VUyA9PT0gY2hhcmFjdGVyIHx8IENIQVJfRE9UID09PSBjaGFyYWN0ZXIpICYmXHJcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IGNoYXJhY3Rlcikge1xyXG5cclxuICAgICAgX3Bvc2l0aW9uID0gcG9zaXRpb24gKyAzO1xyXG4gICAgICBfY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xyXG5cclxuICAgICAgaWYgKF9wb3NpdGlvbiA+PSBsZW5ndGggfHxcclxuICAgICAgICAgIENIQVJfU1BBQ0UgICAgICAgICAgID09PSBfY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICA9PT0gX2NoYXJhY3RlciB8fFxyXG4gICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgICAgICAgPT09IF9jaGFyYWN0ZXIgfHxcclxuICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOID09PSBfY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKGNvdW50KSB7XHJcbiAgICBpZiAoMSA9PT0gY291bnQpIHtcclxuICAgICAgcmVzdWx0ICs9ICcgJztcclxuICAgIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XHJcbiAgICB2YXIgcHJlY2VkaW5nLFxyXG4gICAgICAgIGZvbGxvd2luZyxcclxuICAgICAgICBjYXB0dXJlU3RhcnQsXHJcbiAgICAgICAgY2FwdHVyZUVuZCxcclxuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCxcclxuICAgICAgICBfbGluZSxcclxuICAgICAgICBfbGluZVN0YXJ0LFxyXG4gICAgICAgIF9saW5lSW5kZW50LFxyXG4gICAgICAgIF9raW5kID0ga2luZCxcclxuICAgICAgICBfcmVzdWx0ID0gcmVzdWx0O1xyXG5cclxuICAgIGlmIChDSEFSX1NQQUNFICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDSEFSX1FVRVNUSU9OID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICBDSEFSX01JTlVTID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgZm9sbG93aW5nID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xyXG5cclxuICAgICAgaWYgKENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgIENIQVJfVEFCICAgICAgICAgICAgICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgICAoQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9PT0gZm9sbG93aW5nKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGtpbmQgPSBLSU5EX1NUUklORztcclxuICAgIHJlc3VsdCA9ICcnO1xyXG4gICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG4gICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKENIQVJfQ09MT04gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIGZvbGxvd2luZyA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKTtcclxuXHJcbiAgICAgICAgaWYgKENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgICAgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICAgPT09IGZvbGxvd2luZyB8fFxyXG4gICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiZcclxuICAgICAgICAgICAgKENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPT09IGZvbGxvd2luZyB8fFxyXG4gICAgICAgICAgICAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgICAgIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPT09IGZvbGxvd2luZyB8fFxyXG4gICAgICAgICAgICAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9PT0gZm9sbG93aW5nKSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChDSEFSX1NIQVJQID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBwcmVjZWRpbmcgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uIC0gMSk7XHJcblxyXG4gICAgICAgIGlmIChDSEFSX1NQQUNFICAgICAgICAgICA9PT0gcHJlY2VkaW5nIHx8XHJcbiAgICAgICAgICAgIENIQVJfVEFCICAgICAgICAgICAgID09PSBwcmVjZWRpbmcgfHxcclxuICAgICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgICAgICAgPT09IHByZWNlZGluZyB8fFxyXG4gICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gcHJlY2VkaW5nKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKChwb3NpdGlvbiA9PT0gbGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcigpKSB8fFxyXG4gICAgICAgICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgKENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICAgICAgICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgICAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgICAgICAgIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICAgICAgICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID09PSBjaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKENIQVJfTElORV9GRUVEID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgX2xpbmUgPSBsaW5lO1xyXG4gICAgICAgIF9saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XHJcbiAgICAgICAgX2xpbmVJbmRlbnQgPSBsaW5lSW5kZW50O1xyXG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2UoZmFsc2UsIC0xKTtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xyXG4gICAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBvc2l0aW9uID0gY2FwdHVyZUVuZDtcclxuICAgICAgICAgIGxpbmUgPSBfbGluZTtcclxuICAgICAgICAgIGxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XHJcbiAgICAgICAgICBsaW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XHJcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XHJcbiAgICAgICAgY2FwdHVyZVNlZ21lbnQoY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgd3JpdGVGb2xkZWRMaW5lcyhsaW5lIC0gX2xpbmUpO1xyXG4gICAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBwb3NpdGlvbjtcclxuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoQ0hBUl9TUEFDRSAhPT0gY2hhcmFjdGVyICYmIENIQVJfVEFCICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBjYXB0dXJlRW5kID0gcG9zaXRpb24gKyAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGNhcHR1cmVTZWdtZW50KGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xyXG5cclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBraW5kID0gX2tpbmQ7XHJcbiAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIobm9kZUluZGVudCkge1xyXG4gICAgdmFyIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcclxuXHJcbiAgICBpZiAoQ0hBUl9TSU5HTEVfUVVPVEUgIT09IGNoYXJhY3Rlcikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAga2luZCA9IEtJTkRfU1RSSU5HO1xyXG4gICAgcmVzdWx0ID0gJyc7XHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG5cclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAoQ0hBUl9TSU5HTEVfUVVPVEUgPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIGNhcHR1cmVTZWdtZW50KGNhcHR1cmVTdGFydCwgcG9zaXRpb24sIHRydWUpO1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChDSEFSX1NJTkdMRV9RVU9URSA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gcG9zaXRpb247XHJcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKENIQVJfTElORV9GRUVEID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgY2FwdHVyZVNlZ21lbnQoY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcclxuICAgICAgICB3cml0ZUZvbGRlZExpbmVzKHNraXBTZXBhcmF0aW9uU3BhY2UoZmFsc2UsIG5vZGVJbmRlbnQpKTtcclxuICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gcG9zaXRpb247XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbik7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBsaW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKCkpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgICBjYXB0dXJlRW5kID0gcG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aHJvd0Vycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKG5vZGVJbmRlbnQpIHtcclxuICAgIHZhciBjYXB0dXJlU3RhcnQsXHJcbiAgICAgICAgY2FwdHVyZUVuZCxcclxuICAgICAgICBoZXhMZW5ndGgsXHJcbiAgICAgICAgaGV4SW5kZXgsXHJcbiAgICAgICAgaGV4T2Zmc2V0LFxyXG4gICAgICAgIGhleFJlc3VsdDtcclxuXHJcbiAgICBpZiAoQ0hBUl9ET1VCTEVfUVVPVEUgIT09IGNoYXJhY3Rlcikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAga2luZCA9IEtJTkRfU1RSSU5HO1xyXG4gICAgcmVzdWx0ID0gJyc7XHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG5cclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAoQ0hBUl9ET1VCTEVfUVVPVEUgPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIGNhcHR1cmVTZWdtZW50KGNhcHR1cmVTdGFydCwgcG9zaXRpb24sIHRydWUpO1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKENIQVJfQkFDS1NMQVNIID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBjYXB0dXJlU2VnbWVudChjYXB0dXJlU3RhcnQsIHBvc2l0aW9uLCB0cnVlKTtcclxuICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoQ0hBUl9MSU5FX0ZFRUQgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKGZhbHNlLCBub2RlSW5kZW50KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChTSU1QTEVfRVNDQVBFX1NFUVVFTkNFU1tjaGFyYWN0ZXJdKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gU0lNUExFX0VTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXTtcclxuICAgICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoSEVYQURFQ0lNQUxfRVNDQVBFX1NFUVVFTkNFU1tjaGFyYWN0ZXJdKSB7XHJcbiAgICAgICAgICBoZXhMZW5ndGggPSBIRVhBREVDSU1BTF9FU0NBUEVfU0VRVUVOQ0VTW2NoYXJhY3Rlcl07XHJcbiAgICAgICAgICBoZXhSZXN1bHQgPSAwO1xyXG5cclxuICAgICAgICAgIGZvciAoaGV4SW5kZXggPSAxOyBoZXhJbmRleCA8PSBoZXhMZW5ndGg7IGhleEluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgaGV4T2Zmc2V0ID0gKGhleExlbmd0aCAtIGhleEluZGV4KSAqIDQ7XHJcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBpZiAoQ0hBUl9ESUdJVF9aRVJPIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gQ0hBUl9ESUdJVF9OSU5FKSB7XHJcbiAgICAgICAgICAgICAgaGV4UmVzdWx0IHw9IChjaGFyYWN0ZXIgLSBDSEFSX0RJR0lUX1pFUk8pIDw8IGhleE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ0hBUl9DQVBJVEFMX0EgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSBDSEFSX0NBUElUQUxfRikge1xyXG4gICAgICAgICAgICAgIGhleFJlc3VsdCB8PSAoY2hhcmFjdGVyIC0gQ0hBUl9DQVBJVEFMX0EgKyAxMCkgPDwgaGV4T2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChDSEFSX1NNQUxMX0EgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSBDSEFSX1NNQUxMX0YpIHtcclxuICAgICAgICAgICAgICBoZXhSZXN1bHQgfD0gKGNoYXJhY3RlciAtIENIQVJfU01BTExfQSArIDEwKSA8PCBoZXhPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93RXJyb3IoJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4UmVzdWx0KTtcclxuICAgICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvd0Vycm9yKCd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChDSEFSX0xJTkVfRkVFRCA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgICAgICAgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIGNhcHR1cmVTZWdtZW50KGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XHJcbiAgICAgICAgd3JpdGVGb2xkZWRMaW5lcyhza2lwU2VwYXJhdGlvblNwYWNlKGZhbHNlLCBub2RlSW5kZW50KSk7XHJcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gbGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcigpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgICAgY2FwdHVyZUVuZCA9IHBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3dFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKG5vZGVJbmRlbnQpIHtcclxuICAgIHZhciByZWFkTmV4dCA9IHRydWUsXHJcbiAgICAgICAgX2xpbmUsXHJcbiAgICAgICAgX3RhZyAgICAgPSB0YWcsXHJcbiAgICAgICAgX3Jlc3VsdCxcclxuICAgICAgICBmb2xsb3dpbmcsXHJcbiAgICAgICAgdGVybWluYXRvcixcclxuICAgICAgICBpc1BhaXIsXHJcbiAgICAgICAgaXNFeHBsaWNpdFBhaXIsXHJcbiAgICAgICAgaXNNYXBwaW5nLFxyXG4gICAgICAgIGtleU5vZGUsXHJcbiAgICAgICAga2V5VGFnLFxyXG4gICAgICAgIHZhbHVlTm9kZTtcclxuXHJcbiAgICBzd2l0Y2ggKGNoYXJhY3Rlcikge1xyXG4gICAgY2FzZSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6XHJcbiAgICAgIHRlcm1pbmF0b3IgPSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUO1xyXG4gICAgICBpc01hcHBpbmcgPSBmYWxzZTtcclxuICAgICAgX3Jlc3VsdCA9IFtdO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUOlxyXG4gICAgICB0ZXJtaW5hdG9yID0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUO1xyXG4gICAgICBpc01hcHBpbmcgPSB0cnVlO1xyXG4gICAgICBfcmVzdWx0ID0ge307XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobnVsbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgIGFuY2hvck1hcFthbmNob3JdID0gX3Jlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHRydWUsIG5vZGVJbmRlbnQpO1xyXG5cclxuICAgICAgaWYgKGNoYXJhY3RlciA9PT0gdGVybWluYXRvcikge1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgICAgdGFnID0gX3RhZztcclxuICAgICAgICBraW5kID0gaXNNYXBwaW5nID8gS0lORF9PQkpFQ1QgOiBLSU5EX0FSUkFZO1xyXG4gICAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcignbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XHJcbiAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoQ0hBUl9RVUVTVElPTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgZm9sbG93aW5nID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xyXG5cclxuICAgICAgICBpZiAoQ0hBUl9TUEFDRSA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgIENIQVJfVEFCID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgPT09IGZvbGxvd2luZyB8fFxyXG4gICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gZm9sbG93aW5nKSB7XHJcbiAgICAgICAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IHRydWU7XHJcbiAgICAgICAgICBwb3NpdGlvbiArPSAxO1xyXG4gICAgICAgICAgY2hhcmFjdGVyID0gZm9sbG93aW5nO1xyXG4gICAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCBub2RlSW5kZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9saW5lID0gbGluZTtcclxuICAgICAgY29tcG9zZU5vZGUobm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgIGtleVRhZyA9IHRhZztcclxuICAgICAga2V5Tm9kZSA9IHJlc3VsdDtcclxuXHJcbiAgICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgbGluZSA9PT0gX2xpbmUpICYmIENIQVJfQ09MT04gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIGlzUGFpciA9IHRydWU7XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHRydWUsIG5vZGVJbmRlbnQpO1xyXG4gICAgICAgIGNvbXBvc2VOb2RlKG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHZhbHVlTm9kZSA9IHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTWFwcGluZykge1xyXG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xyXG4gICAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKG51bGwsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHRydWUsIG5vZGVJbmRlbnQpO1xyXG5cclxuICAgICAgaWYgKENIQVJfQ09NTUEgPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcclxuICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlYWROZXh0ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aHJvd0Vycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKG5vZGVJbmRlbnQpIHtcclxuICAgIHZhciBjYXB0dXJlU3RhcnQsXHJcbiAgICAgICAgZm9sZGluZyxcclxuICAgICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXHJcbiAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcclxuICAgICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXHJcbiAgICAgICAgZW1wdHlMaW5lcyAgICAgPSAtMTtcclxuXHJcbiAgICBzd2l0Y2ggKGNoYXJhY3Rlcikge1xyXG4gICAgY2FzZSBDSEFSX1ZFUlRJQ0FMX0xJTkU6XHJcbiAgICAgIGZvbGRpbmcgPSBmYWxzZTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSBDSEFSX0dSRUFURVJfVEhBTjpcclxuICAgICAgZm9sZGluZyA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBraW5kID0gS0lORF9TVFJJTkc7XHJcbiAgICByZXN1bHQgPSAnJztcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChDSEFSX1BMVVMgPT09IGNoYXJhY3RlciB8fCBDSEFSX01JTlVTID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcclxuICAgICAgICAgIGNob21waW5nID0gKENIQVJfUExVUyA9PT0gY2hhcmFjdGVyKSA/IENIT01QSU5HX0tFRVAgOiBDSE9NUElOR19TVFJJUDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3dFcnJvcigncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChDSEFSX0RJR0lUX1pFUk8gPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSBDSEFSX0RJR0lUX05JTkUpIHtcclxuICAgICAgICBpZiAoQ0hBUl9ESUdJVF9aRVJPID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgIHRocm93RXJyb3IoJ2JhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xyXG4gICAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyAoY2hhcmFjdGVyIC0gQ0hBUl9ESUdJVF9PTkUpO1xyXG4gICAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvd0Vycm9yKCdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ0hBUl9TUEFDRSA9PT0gY2hhcmFjdGVyIHx8IENIQVJfVEFCID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgZG8geyBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pOyB9XHJcbiAgICAgIHdoaWxlIChDSEFSX1NQQUNFID09PSBjaGFyYWN0ZXIgfHwgQ0hBUl9UQUIgPT09IGNoYXJhY3Rlcik7XHJcblxyXG4gICAgICBpZiAoQ0hBUl9TSEFSUCA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgZG8geyBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pOyB9XHJcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgIENIQVJfTElORV9GRUVEICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gIT09IGNoYXJhY3Rlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgcmVhZExpbmVCcmVhaygpO1xyXG4gICAgICBsaW5lSW5kZW50ID0gMDtcclxuXHJcbiAgICAgIHdoaWxlICgoIWRldGVjdGVkSW5kZW50IHx8IGxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSAmJlxyXG4gICAgICAgICAgICAgKENIQVJfU1BBQ0UgPT09IGNoYXJhY3RlcikpIHtcclxuICAgICAgICBsaW5lSW5kZW50ICs9IDE7XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBsaW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xyXG4gICAgICAgIHRleHRJbmRlbnQgPSBsaW5lSW5kZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoQ0hBUl9MSU5FX0ZFRUQgPT09IGNoYXJhY3RlciB8fCBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgZW1wdHlMaW5lcyArPSAxO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci4gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXHJcbiAgICAgIGlmIChsaW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xyXG4gICAgICAgIGlmIChDSE9NUElOR19LRUVQID09PSBjaG9tcGluZykge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcclxuICAgICAgICB9IGVsc2UgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoZm9sZGluZykge1xyXG4gICAgICAgIGlmIChDSEFSX1NQQUNFID09PSBjaGFyYWN0ZXIgfHwgQ0hBUl9UQUIgPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcclxuICAgICAgICAgIGVtcHR5TGluZXMgPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gZW1wdHlMaW5lcykge1xyXG4gICAgICAgICAgcmVzdWx0ICs9ICcgJztcclxuICAgICAgICAgIGVtcHR5TGluZXMgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XHJcbiAgICAgICAgICBlbXB0eUxpbmVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcclxuICAgICAgICBlbXB0eUxpbmVzID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FwdHVyZVN0YXJ0ID0gcG9zaXRpb247XHJcblxyXG4gICAgICBkbyB7IGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7IH1cclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAhPT0gY2hhcmFjdGVyKTtcclxuXHJcbiAgICAgIGNhcHR1cmVTZWdtZW50KGNhcHR1cmVTdGFydCwgcG9zaXRpb24sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKG5vZGVJbmRlbnQpIHtcclxuICAgIHZhciBfbGluZSxcclxuICAgICAgICBfdGFnICAgICAgPSB0YWcsXHJcbiAgICAgICAgX3Jlc3VsdCAgID0gW10sXHJcbiAgICAgICAgZm9sbG93aW5nLFxyXG4gICAgICAgIGRldGVjdGVkICA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChudWxsICE9PSBhbmNob3IpIHtcclxuICAgICAgYW5jaG9yTWFwW2FuY2hvcl0gPSBfcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAoQ0hBUl9NSU5VUyAhPT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvbGxvd2luZyA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKTtcclxuXHJcbiAgICAgIGlmIChDSEFSX1NQQUNFICAgICAgICAgICAhPT0gZm9sbG93aW5nICYmXHJcbiAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAhPT0gZm9sbG93aW5nICYmXHJcbiAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAhPT0gZm9sbG93aW5nICYmXHJcbiAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAhPT0gZm9sbG93aW5nKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRldGVjdGVkID0gdHJ1ZTtcclxuICAgICAgcG9zaXRpb24gKz0gMTtcclxuICAgICAgY2hhcmFjdGVyID0gZm9sbG93aW5nO1xyXG5cclxuICAgICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2UodHJ1ZSwgLTEpKSB7XHJcbiAgICAgICAgaWYgKGxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xyXG4gICAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfbGluZSA9IGxpbmU7XHJcbiAgICAgIGNvbXBvc2VOb2RlKG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcclxuICAgICAgX3Jlc3VsdC5wdXNoKHJlc3VsdCk7XHJcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2UodHJ1ZSwgLTEpO1xyXG5cclxuICAgICAgaWYgKChsaW5lID09PSBfbGluZSB8fCBsaW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgcG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgICB0aHJvd0Vycm9yKCdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xyXG4gICAgICB9IGVsc2UgaWYgKGxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGV0ZWN0ZWQpIHtcclxuICAgICAgdGFnID0gX3RhZztcclxuICAgICAga2luZCA9IEtJTkRfQVJSQVk7XHJcbiAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhub2RlSW5kZW50KSB7XHJcbiAgICB2YXIgZm9sbG93aW5nLFxyXG4gICAgICAgIGFsbG93Q29tcGFjdCxcclxuICAgICAgICBfbGluZSxcclxuICAgICAgICBfdGFnICAgICAgICAgID0gdGFnLFxyXG4gICAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcclxuICAgICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcclxuICAgICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcclxuICAgICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcclxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXHJcbiAgICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChudWxsICE9PSBhbmNob3IpIHtcclxuICAgICAgYW5jaG9yTWFwW2FuY2hvcl0gPSBfcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICBmb2xsb3dpbmcgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSk7XHJcbiAgICAgIF9saW5lID0gbGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxyXG5cclxuICAgICAgaWYgKChDSEFSX1FVRVNUSU9OICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgQ0hBUl9DT0xPTiAgICAgICAgICAgPT09IGNoYXJhY3RlcikgJiZcclxuICAgICAgICAgIChDSEFSX1NQQUNFICAgICAgICAgICA9PT0gZm9sbG93aW5nIHx8XHJcbiAgICAgICAgICAgQ0hBUl9UQUIgICAgICAgICAgICAgPT09IGZvbGxvd2luZyB8fFxyXG4gICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgID09PSBmb2xsb3dpbmcgfHxcclxuICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gZm9sbG93aW5nKSkge1xyXG5cclxuICAgICAgICBpZiAoQ0hBUl9RVUVTVElPTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xyXG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xyXG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XHJcbiAgICAgICAgICAvLyBpLmUuIENIQVJfQ09MT04gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxyXG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xyXG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93RXJyb3IoJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9zaXRpb24gKz0gMTtcclxuICAgICAgICBjaGFyYWN0ZXIgPSBmb2xsb3dpbmc7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKGNvbXBvc2VOb2RlKG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xyXG4gICAgICAgIGlmIChsaW5lID09PSBfbGluZSkge1xyXG4gICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgY3ljbGUgd2hlbiB0aGUgZmxvdyByZWFkZXJzIHdpbGwgY29uc3VtZVxyXG4gICAgICAgICAgLy8gdHJhaWxpbmcgd2hpdGVzcGFjZXMgbGlrZSB0aGUgYmxvY2sgcmVhZGVycy5cclxuICAgICAgICAgIHdoaWxlIChDSEFSX1NQQUNFID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgICAgICBDSEFSX1RBQiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKENIQVJfQ09MT04gPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKENIQVJfU1BBQ0UgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgIENIQVJfVEFCICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcclxuICAgICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAga2V5VGFnID0gdGFnO1xyXG4gICAgICAgICAgICBrZXlOb2RlID0gcmVzdWx0O1xyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcignY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YWcgPSBfdGFnO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcclxuICAgICAgICAgIHRocm93RXJyb3IoJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFnID0gX3RhZztcclxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobGluZSA9PT0gX2xpbmUgfHwgbGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcclxuICAgICAgICBpZiAoY29tcG9zZU5vZGUobm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcclxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XHJcbiAgICAgICAgICAgIGtleU5vZGUgPSByZXN1bHQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZU5vZGUgPSByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcclxuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xyXG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBJdCBpcyBuZWVkZWQgb25seSBmb3IgZmxvdyBub2RlIHJlYWRlcnMuIEl0IHNob3VsZCBiZSByZW1vdmVkXHJcbiAgICAgICAgLy8gd2hlbiB0aGUgZmxvdyByZWFkZXJzIHdpbGwgY29uc3VtZSB0cmFpbGluZyB3aGl0ZXNwYWNlcyBhcyB3ZWxsIGFzXHJcbiAgICAgICAgLy8gdGhlIGJsb2NrIHJlYWRlcnMuXHJcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCAtMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChsaW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiBwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICAgIHRocm93RXJyb3IoJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcclxuICAgICAgfSBlbHNlIGlmIChsaW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcclxuICAgICAgc3RvcmVNYXBwaW5nUGFpcihfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZXRlY3RlZCkge1xyXG4gICAgICB0YWcgPSBfdGFnO1xyXG4gICAgICBraW5kID0gS0lORF9PQkpFQ1Q7XHJcbiAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRldGVjdGVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KCkge1xyXG4gICAgdmFyIF9wb3NpdGlvbixcclxuICAgICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXHJcbiAgICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxyXG4gICAgICAgIHRhZ0hhbmRsZSxcclxuICAgICAgICB0YWdOYW1lO1xyXG5cclxuICAgIGlmIChDSEFSX0VYQ0xBTUFUSU9OICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChudWxsICE9PSB0YWcpIHtcclxuICAgICAgdGhyb3dFcnJvcignZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgIGlmIChDSEFSX0xFU1NfVEhBTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgIGlzVmVyYmF0aW0gPSB0cnVlO1xyXG4gICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoQ0hBUl9FWENMQU1BVElPTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgIGlzTmFtZWQgPSB0cnVlO1xyXG4gICAgICB0YWdIYW5kbGUgPSAnISEnO1xyXG4gICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRhZ0hhbmRsZSA9ICchJztcclxuICAgIH1cclxuXHJcbiAgICBfcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICBpZiAoaXNWZXJiYXRpbSkge1xyXG4gICAgICBkbyB7IGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7IH1cclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmIENIQVJfR1JFQVRFUl9USEFOICE9PSBjaGFyYWN0ZXIpO1xyXG5cclxuICAgICAgaWYgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdGFnTmFtZSA9IGlucHV0LnNsaWNlKF9wb3NpdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICBDSEFSX1NQQUNFICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAhPT0gY2hhcmFjdGVyKSB7XHJcblxyXG4gICAgICAgIGlmIChDSEFSX0VYQ0xBTUFUSU9OID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgIGlmICghaXNOYW1lZCkge1xyXG4gICAgICAgICAgICB0YWdIYW5kbGUgPSBpbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBwb3NpdGlvbiArIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcignbmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnMnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaXNOYW1lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIF9wb3NpdGlvbiA9IHBvc2l0aW9uICsgMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRhZ05hbWUgPSBpbnB1dC5zbGljZShfcG9zaXRpb24sIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmICh2YWxpZGF0ZSAmJiBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcigndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsaWRhdGUgJiYgdGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcclxuICAgICAgdGhyb3dFcnJvcigndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzVmVyYmF0aW0pIHtcclxuICAgICAgdGFnID0gdGFnTmFtZTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhZ01hcCwgdGFnSGFuZGxlKSkge1xyXG4gICAgICB0YWcgPSB0YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XHJcblxyXG4gICAgfSBlbHNlIGlmICgnIScgPT09IHRhZ0hhbmRsZSkge1xyXG4gICAgICB0YWcgPSAnIScgKyB0YWdOYW1lO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoJyEhJyA9PT0gdGFnSGFuZGxlKSB7XHJcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvd0Vycm9yKCd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoKSB7XHJcbiAgICB2YXIgX3Bvc2l0aW9uO1xyXG5cclxuICAgIGlmIChDSEFSX0FNUEVSU0FORCAhPT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobnVsbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgIHRocm93RXJyb3IoJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICBfcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGggJiZcclxuICAgICAgICAgICBDSEFSX1NQQUNFICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0NPTU1BICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xyXG4gICAgICB0aHJvd0Vycm9yKCduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgYW5jaG9yID0gaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBwb3NpdGlvbik7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRBbGlhcygpIHtcclxuICAgIHZhciBfcG9zaXRpb24sIGFsaWFzO1xyXG5cclxuICAgIGlmIChDSEFSX0FTVEVSSVNLICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICBfcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGggJiZcclxuICAgICAgICAgICBDSEFSX1NQQUNFICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0NPTU1BICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xyXG4gICAgICB0aHJvd0Vycm9yKCduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBhbGlhcyA9IGlucHV0LnNsaWNlKF9wb3NpdGlvbiwgcG9zaXRpb24pO1xyXG5cclxuICAgIGlmICghYW5jaG9yTWFwLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xyXG4gICAgICB0aHJvd0Vycm9yKCd1bmlkZW50aWZpZWQgYWxpYXMgXCInICsgYWxpYXMgKyAnXCInKTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgPSBhbmNob3JNYXBbYWxpYXNdO1xyXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCAtMSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBvc2VOb2RlKHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcclxuICAgIHZhciBhbGxvd0Jsb2NrU3R5bGVzLFxyXG4gICAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxyXG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcclxuICAgICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXHJcbiAgICAgICAgaXNJbmRlbnRlZCA9IHRydWUsXHJcbiAgICAgICAgaGFzQ29udGVudCA9IGZhbHNlLFxyXG4gICAgICAgIHR5cGVJbmRleCxcclxuICAgICAgICB0eXBlUXVhbnRpdHksXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0eXBlTG9hZGVyLFxyXG4gICAgICAgIGZsb3dJbmRlbnQsXHJcbiAgICAgICAgYmxvY2tJbmRlbnQsXHJcbiAgICAgICAgX3Jlc3VsdDtcclxuXHJcbiAgICB0YWcgICAgPSBudWxsO1xyXG4gICAgYW5jaG9yID0gbnVsbDtcclxuICAgIGtpbmQgICA9IG51bGw7XHJcbiAgICByZXN1bHQgPSBudWxsO1xyXG5cclxuICAgIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XHJcbiAgICAgIENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCB8fFxyXG4gICAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XHJcblxyXG4gICAgaWYgKGFsbG93VG9TZWVrKSB7XHJcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHRydWUsIC0xKSkge1xyXG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChsaW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcclxuICAgICAgICAgIGlzSW5kZW50ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XHJcbiAgICAgICAgICBpc0luZGVudGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNJbmRlbnRlZCkge1xyXG4gICAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KCkgfHwgcmVhZEFuY2hvclByb3BlcnR5KCkpIHtcclxuICAgICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCAtMSkpIHtcclxuICAgICAgICAgIGF0TmV3TGluZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgaWYgKGxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcclxuICAgICAgICAgICAgaXNJbmRlbnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcclxuICAgICAgICAgICAgaXNJbmRlbnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhbGxvd0Jsb2NrU3R5bGVzO1xyXG5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XHJcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGF0TmV3TGluZSB8fCBhbGxvd0NvbXBhY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSW5kZW50ZWQgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XHJcbiAgICAgIGlmIChDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfRkxPV19PVVQgPT09IG5vZGVDb250ZXh0KSB7XHJcbiAgICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50ICsgMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYmxvY2tJbmRlbnQgPSBwb3NpdGlvbiAtIGxpbmVTdGFydDtcclxuXHJcbiAgICAgIGlmIChpc0luZGVudGVkKSB7XHJcbiAgICAgICAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJlxyXG4gICAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2UoYmxvY2tJbmRlbnQpIHx8XHJcbiAgICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKGJsb2NrSW5kZW50KSkgfHxcclxuICAgICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKGZsb3dJbmRlbnQpKSB7XHJcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKChhbGxvd0Jsb2NrU2NhbGFycyAmJiByZWFkQmxvY2tTY2FsYXIoZmxvd0luZGVudCkpIHx8XHJcbiAgICAgICAgICAgICAgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihmbG93SW5kZW50KSB8fFxyXG4gICAgICAgICAgICAgIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoZmxvd0luZGVudCkpIHtcclxuICAgICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoKSkge1xyXG4gICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB0YWcgfHwgbnVsbCAhPT0gYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcignYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAocmVhZFBsYWluU2NhbGFyKGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRhZykge1xyXG4gICAgICAgICAgICAgIHRhZyA9ICc/JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChudWxsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgYW5jaG9yTWFwW2FuY2hvcl0gPSByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2UoYmxvY2tJbmRlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG51bGwgIT09IHRhZyAmJiAnIScgIT09IHRhZykge1xyXG4gICAgICBpZiAoJz8nID09PSB0YWcpIHtcclxuICAgICAgICBpZiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBpbXBsaWNpdFR5cGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5O1xyXG4gICAgICAgICAgICAgICB0eXBlSW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICB0eXBlID0gaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXHJcbiAgICAgICAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLiBTbywgaXQgaXNuJ3RcclxuICAgICAgICAgICAgLy8gbmVlZGVkIHRvIGNoZWNrIGZvciAna2luZCcgY29uZm9ybWl0eS5cclxuICAgICAgICAgICAgX3Jlc3VsdCA9IHR5cGUubG9hZGVyLnJlc29sdmVyKHJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKE5JTCAhPT0gX3Jlc3VsdCkge1xyXG4gICAgICAgICAgICAgIHRhZyA9IHR5cGUudGFnO1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZU1hcCwgdGFnKSkge1xyXG4gICAgICAgIHR5cGVMb2FkZXIgPSB0eXBlTWFwW3RhZ10ubG9hZGVyO1xyXG5cclxuICAgICAgICBpZiAobnVsbCAhPT0gcmVzdWx0ICYmIHR5cGVMb2FkZXIua2luZCAhPT0ga2luZCkge1xyXG4gICAgICAgICAgdGhyb3dFcnJvcigndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgdGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZUxvYWRlci5raW5kICsgJ1wiLCBub3QgXCInICsga2luZCArICdcIicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVMb2FkZXIucmVzb2x2ZXIpIHtcclxuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlTG9hZGVyLnJlc29sdmVyKHJlc3VsdCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgaWYgKE5JTCAhPT0gX3Jlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBfcmVzdWx0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcignY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgdGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93V2FybmluZygndW5rbm93biB0YWcgITwnICsgdGFnICsgJz4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsICE9PSB0YWcgfHwgbnVsbCAhPT0gYW5jaG9yIHx8IGhhc0NvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkRG9jdW1lbnQoKSB7XHJcbiAgICB2YXIgZG9jdW1lbnRTdGFydCA9IHBvc2l0aW9uLFxyXG4gICAgICAgIF9wb3NpdGlvbixcclxuICAgICAgICBkaXJlY3RpdmVOYW1lLFxyXG4gICAgICAgIGRpcmVjdGl2ZUFyZ3MsXHJcbiAgICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlO1xyXG5cclxuICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgY2hlY2tMaW5lQnJlYWtzID0gbGVnYWN5O1xyXG4gICAgdGFnTWFwID0ge307XHJcbiAgICBhbmNob3JNYXAgPSB7fTtcclxuXHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCAtMSk7XHJcblxyXG4gICAgICBpZiAobGluZUluZGVudCA+IDAgfHwgQ0hBUl9QRVJDRU5UICE9PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XHJcbiAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XHJcbiAgICAgIF9wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICBDSEFSX1NQQUNFICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAhPT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlyZWN0aXZlTmFtZSA9IGlucHV0LnNsaWNlKF9wb3NpdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICBkaXJlY3RpdmVBcmdzID0gW107XHJcblxyXG4gICAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcignZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICAgIHdoaWxlIChDSEFSX1NQQUNFID09PSBjaGFyYWN0ZXIgfHwgQ0hBUl9UQUIgPT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChDSEFSX1NIQVJQID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgIGRvIHsgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTsgfVxyXG4gICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgIT09IGNoYXJhY3RlciAmJlxyXG4gICAgICAgICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICE9PSBjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQ0hBUl9MSU5FX0ZFRUQgPT09IGNoYXJhY3RlciB8fCBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGggJiZcclxuICAgICAgICAgICAgICAgQ0hBUl9TUEFDRSAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxyXG4gICAgICAgICAgICAgICBDSEFSX1RBQiAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXHJcbiAgICAgICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICAgICAgICAgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gIT09IGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChpbnB1dC5zbGljZShfcG9zaXRpb24sIHBvc2l0aW9uKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwb3NpdGlvbiA8IGxlbmd0aCkge1xyXG4gICAgICAgIHJlYWRMaW5lQnJlYWsoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xyXG4gICAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93V2FybmluZygndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZSh0cnVlLCAtMSk7XHJcblxyXG4gICAgaWYgKDAgPT09IGxpbmVJbmRlbnQgJiZcclxuICAgICAgICBDSEFSX01JTlVTID09PSBjaGFyYWN0ZXIgJiZcclxuICAgICAgICBDSEFSX01JTlVTID09PSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgJiZcclxuICAgICAgICBDSEFSX01JTlVTID09PSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikpIHtcclxuICAgICAgcG9zaXRpb24gKz0gMztcclxuICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbik7XHJcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2UodHJ1ZSwgLTEpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xyXG4gICAgICB0aHJvd0Vycm9yKCdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9zZU5vZGUobGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHRydWUsIC0xKTtcclxuXHJcbiAgICBpZiAodmFsaWRhdGUgJiYgY2hlY2tMaW5lQnJlYWtzICYmXHJcbiAgICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChpbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBwb3NpdGlvbikpKSB7XHJcbiAgICAgIHRocm93V2FybmluZygnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0KHJlc3VsdCk7XHJcblxyXG4gICAgaWYgKHBvc2l0aW9uID09PSBsaW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKCkpIHtcclxuICAgICAgaWYgKENIQVJfRE9UID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICBwb3NpdGlvbiArPSAzO1xyXG4gICAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xyXG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2UodHJ1ZSwgLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24gPCBsZW5ndGgpIHtcclxuICAgICAgdGhyb3dFcnJvcignZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh2YWxpZGF0ZSAmJiBQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChpbnB1dCkpIHtcclxuICAgIHRocm93RXJyb3IoJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XHJcbiAgfVxyXG5cclxuICB3aGlsZSAoQ0hBUl9TUEFDRSA9PT0gY2hhcmFjdGVyKSB7XHJcbiAgICBsaW5lSW5kZW50ICs9IDE7XHJcbiAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XHJcbiAgICByZWFkRG9jdW1lbnQoKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgdmFyIHJlc3VsdCA9IG51bGwsIHJlY2VpdmVkID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGxiYWNrKGRhdGEpIHtcclxuICAgIGlmICghcmVjZWl2ZWQpIHtcclxuICAgICAgcmVzdWx0ID0gZGF0YTtcclxuICAgICAgcmVjZWl2ZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkQWxsKGlucHV0LCBjYWxsYmFjaywgb3B0aW9ucyk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzYWZlTG9hZEFsbChpbnB1dCwgb3V0cHV0LCBvcHRpb25zKSB7XHJcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIGxvYWQoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xyXG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICA9IGxvYWQ7XHJcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsID0gc2FmZUxvYWRBbGw7XHJcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XHJcbiIsIihmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbnZhciBOSUwgICAgICAgICAgICAgICAgID0gY29tbW9uLk5JTDtcclxudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xyXG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xyXG52YXIgREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xyXG5cclxuXHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuXHJcbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXHJcbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cclxudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xyXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXHJcbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xyXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXHJcbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xyXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cclxudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXHJcbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xyXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cclxudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXHJcbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xyXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cclxudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXHJcbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xyXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUICAgICAgICA9IDB4NDA7IC8qIEAgKi9cclxudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXHJcbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xyXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7IC8qIGAgKi9cclxudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXHJcbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xyXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7IC8qIH0gKi9cclxuXHJcblxyXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xyXG5cclxuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSAgID0gJ1xcXFwwJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSAgID0gJ1xcXFx0JztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSAgID0gJ1xcXFxmJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcclxuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSAgID0gJ1xcXFxcIic7XHJcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XHJcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XHJcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gICA9ICdcXFxcXyc7XHJcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XHJcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XHJcblxyXG5cclxuZnVuY3Rpb24ga2luZE9mKG9iamVjdCkge1xyXG4gIHZhciBraW5kID0gdHlwZW9mIG9iamVjdDtcclxuXHJcbiAgaWYgKG51bGwgPT09IG9iamVjdCkge1xyXG4gICAgcmV0dXJuICdudWxsJztcclxuICB9IGVsc2UgaWYgKCdudW1iZXInID09PSBraW5kKSB7XHJcbiAgICByZXR1cm4gMCA9PT0gb2JqZWN0ICUgMSA/ICdpbnRlZ2VyJyA6ICdmbG9hdCc7XHJcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0ga2luZCAmJiBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgIHJldHVybiAnYXJyYXknO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4ga2luZDtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcclxuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xyXG5cclxuICBpZiAobnVsbCA9PT0gbWFwKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICByZXN1bHQgPSB7fTtcclxuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcclxuXHJcbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgdGFnID0ga2V5c1tpbmRleF07XHJcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XHJcblxyXG4gICAgaWYgKCchIScgPT09IHRhZy5zbGljZSgwLCAyKSkge1xyXG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcclxuICAgIH1cclxuXHJcbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFt0YWddO1xyXG5cclxuICAgIGlmICh0eXBlICYmIHR5cGUuZHVtcGVyKSB7XHJcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLmR1bXBlci5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xyXG4gICAgICAgIHN0eWxlID0gdHlwZS5kdW1wZXIuc3R5bGVBbGlhc2VzW3N0eWxlXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xyXG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xyXG5cclxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xyXG4gICAgaGFuZGxlID0gJ3gnO1xyXG4gICAgbGVuZ3RoID0gMjtcclxuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcclxuICAgIGhhbmRsZSA9ICd1JztcclxuICAgIGxlbmd0aCA9IDQ7XHJcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xyXG4gICAgaGFuZGxlID0gJ1UnO1xyXG4gICAgbGVuZ3RoID0gODtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcclxuICB9XHJcblxyXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBzY2hlbWEgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUEsXHJcbiAgICAgIGluZGVudCAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKSxcclxuICAgICAgc2tpcEludmFsaWQgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlLFxyXG4gICAgICBmbG93TGV2ZWwgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pLFxyXG4gICAgICBzdHlsZU1hcCAgICA9IGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpLFxyXG5cclxuICAgICAgaW1wbGljaXRUeXBlcyA9IHNjaGVtYS5jb21waWxlZEltcGxpY2l0LFxyXG4gICAgICBleHBsaWNpdFR5cGVzID0gc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQsXHJcblxyXG4gICAgICBraW5kLFxyXG4gICAgICB0YWcsXHJcbiAgICAgIHJlc3VsdDtcclxuXHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShsZXZlbCkge1xyXG4gICAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCAqIGxldmVsKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhvYmplY3QpIHtcclxuICAgIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xyXG5cclxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBpbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgdHlwZSA9IGltcGxpY2l0VHlwZXNbaW5kZXhdO1xyXG5cclxuICAgICAgaWYgKG51bGwgIT09IHR5cGUubG9hZGVyICYmXHJcbiAgICAgICAgICBOSUwgIT09IHR5cGUubG9hZGVyLnJlc29sdmVyKG9iamVjdCwgZmFsc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cml0ZVNjYWxhcihvYmplY3QpIHtcclxuICAgIHZhciBpc1F1b3RlZCwgY2hlY2twb2ludCwgcG9zaXRpb24sIGxlbmd0aCwgY2hhcmFjdGVyLCBib29sZWFucztcclxuXHJcbiAgICByZXN1bHQgPSAnJztcclxuICAgIGlzUXVvdGVkID0gZmFsc2U7XHJcbiAgICBjaGVja3BvaW50ID0gMDtcclxuICAgIGJvb2xlYW5zID0gL14oeXxZfHllc3xZZXN8WUVTfG58Tnxub3xOb3xOT3x0cnVlfFRydWV8VFJVRXxmYWxzZXxGYWxzZXxGQUxTRXxvbnxPbnxPTnxvZmZ8T2ZmfE9GRikkLztcclxuXHJcbiAgICBpZiAoMCAgICAgICAgICA9PT0gb2JqZWN0Lmxlbmd0aCB8fFxyXG4gICAgICAgIENIQVJfU1BBQ0UgPT09IG9iamVjdC5jaGFyQ29kZUF0KDApIHx8XHJcbiAgICAgICAgQ0hBUl9TUEFDRSA9PT0gb2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgIGlzUXVvdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgcG9zaXRpb24gPCBsZW5ndGg7IHBvc2l0aW9uICs9IDEpIHtcclxuICAgICAgY2hhcmFjdGVyID0gb2JqZWN0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xyXG5cclxuICAgICAgaWYgKCFpc1F1b3RlZCkge1xyXG4gICAgICAgIGlmIChDSEFSX1RBQiAgICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID09PSBjaGFyYWN0ZXIgfHxcclxuICAgICAgICAgICAgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9PT0gY2hhcmFjdGVyIHx8XHJcbiAgICAgICAgICAgIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxyXG4gICAgICAgICAgICBDSEFSX01JTlVTICAgICAgICAgICAgICAgID09PSBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgIGlzUXVvdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChFU0NBUEVfU0VRVUVOQ0VTW2NoYXJhY3Rlcl0gfHxcclxuICAgICAgICAgICEoKDB4MDAwMjAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwMDA3RSkgfHxcclxuICAgICAgICAgICAgKDB4MDAwODUgPT09IGNoYXJhY3RlcikgICAgICAgICAgICAgICAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgKDB4MDAwQTAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwRDdGRikgfHxcclxuICAgICAgICAgICAgKDB4MEUwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDAwRkZGRCkgfHxcclxuICAgICAgICAgICAgKDB4MTAwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IG9iamVjdC5zbGljZShjaGVja3BvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgcmVzdWx0ICs9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fCBlbmNvZGVIZXgoY2hhcmFjdGVyKTtcclxuICAgICAgICBjaGVja3BvaW50ID0gcG9zaXRpb24gKyAxO1xyXG4gICAgICAgIGlzUXVvdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGVja3BvaW50IDwgcG9zaXRpb24pIHtcclxuICAgICAgcmVzdWx0ICs9IG9iamVjdC5zbGljZShjaGVja3BvaW50LCBwb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1F1b3RlZCAmJiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcocmVzdWx0KSkge1xyXG4gICAgICBpc1F1b3RlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1F1b3RlZCAmJiBib29sZWFucy50ZXN0KG9iamVjdCkpIHtcclxuICAgICAgaXNRdW90ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1F1b3RlZCkge1xyXG4gICAgICByZXN1bHQgPSAnXCInICsgcmVzdWx0ICsgJ1wiJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKGxldmVsLCBvYmplY3QpIHtcclxuICAgIHZhciBfcmVzdWx0ID0gJycsXHJcbiAgICAgICAgX3RhZyAgICA9IHRhZyxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICBsZW5ndGg7XHJcblxyXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXHJcbiAgICAgIGlmICh3cml0ZU5vZGUobGV2ZWwsIG9iamVjdFtpbmRleF0sIGZhbHNlLCBmYWxzZSkpIHtcclxuICAgICAgICBpZiAoMCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgIF9yZXN1bHQgKz0gJywgJztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Jlc3VsdCArPSByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0YWcgPSBfdGFnO1xyXG4gICAgcmVzdWx0ID0gJ1snICsgX3Jlc3VsdCArICddJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XHJcbiAgICB2YXIgX3Jlc3VsdCA9ICcnLFxyXG4gICAgICAgIF90YWcgICAgPSB0YWcsXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgbGVuZ3RoO1xyXG5cclxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxyXG4gICAgICBpZiAod3JpdGVOb2RlKGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcclxuICAgICAgICBpZiAoIWNvbXBhY3QgfHwgMCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShsZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJyArIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRhZyA9IF90YWc7XHJcbiAgICByZXN1bHQgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcobGV2ZWwsIG9iamVjdCkge1xyXG4gICAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcclxuICAgICAgICBfdGFnICAgICAgICAgID0gdGFnLFxyXG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICAgIGxlbmd0aCxcclxuICAgICAgICBvYmplY3RLZXksXHJcbiAgICAgICAgb2JqZWN0VmFsdWUsXHJcbiAgICAgICAgcGFpckJ1ZmZlcjtcclxuXHJcbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgIHBhaXJCdWZmZXIgPSAnJztcclxuXHJcbiAgICAgIGlmICgwICE9PSBpbmRleCkge1xyXG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJywgJztcclxuICAgICAgfVxyXG5cclxuICAgICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XHJcbiAgICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XHJcblxyXG4gICAgICBpZiAoIXdyaXRlTm9kZShsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XHJcbiAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMTAyNCkge1xyXG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFpckJ1ZmZlciArPSByZXN1bHQgKyAnOiAnO1xyXG5cclxuICAgICAgaWYgKCF3cml0ZU5vZGUobGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XHJcbiAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cclxuICAgICAgfVxyXG5cclxuICAgICAgcGFpckJ1ZmZlciArPSByZXN1bHQ7XHJcblxyXG4gICAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxyXG4gICAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnID0gX3RhZztcclxuICAgIHJlc3VsdCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XHJcbiAgICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxyXG4gICAgICAgIF90YWcgICAgICAgICAgPSB0YWcsXHJcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgIG9iamVjdEtleSxcclxuICAgICAgICBvYmplY3RWYWx1ZSxcclxuICAgICAgICBleHBsaWNpdFBhaXIsXHJcbiAgICAgICAgcGFpckJ1ZmZlcjtcclxuXHJcbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgIHBhaXJCdWZmZXIgPSAnJztcclxuXHJcbiAgICAgIGlmICghY29tcGFjdCB8fCAwICE9PSBpbmRleCkge1xyXG4gICAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShsZXZlbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xyXG4gICAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xyXG5cclxuICAgICAgaWYgKCF3cml0ZU5vZGUobGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUpKSB7XHJcbiAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV4cGxpY2l0UGFpciA9IChudWxsICE9PSB0YWcgJiYgJz8nICE9PSB0YWcgJiYgcmVzdWx0Lmxlbmd0aCA8PSAxMDI0KTtcclxuXHJcbiAgICAgIGlmIChleHBsaWNpdFBhaXIpIHtcclxuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhaXJCdWZmZXIgKz0gcmVzdWx0O1xyXG5cclxuICAgICAgaWYgKGV4cGxpY2l0UGFpcikge1xyXG4gICAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShsZXZlbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghd3JpdGVOb2RlKGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcclxuICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICcgKyByZXN1bHQ7XHJcblxyXG4gICAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxyXG4gICAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnID0gX3RhZztcclxuICAgIHJlc3VsdCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRldGVjdFR5cGUob2JqZWN0LCBleHBsaWNpdCkge1xyXG4gICAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcclxuXHJcbiAgICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gZXhwbGljaXRUeXBlcyA6IGltcGxpY2l0VHlwZXM7XHJcbiAgICBraW5kID0ga2luZE9mKG9iamVjdCk7XHJcblxyXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcclxuXHJcbiAgICAgIGlmICgobnVsbCAhPT0gdHlwZS5kdW1wZXIpICYmXHJcbiAgICAgICAgICAobnVsbCA9PT0gdHlwZS5kdW1wZXIua2luZCAgICAgICB8fCBraW5kID09PSB0eXBlLmR1bXBlci5raW5kKSAmJlxyXG4gICAgICAgICAgKG51bGwgPT09IHR5cGUuZHVtcGVyLmluc3RhbmNlT2YgfHwgb2JqZWN0IGluc3RhbmNlb2YgdHlwZS5kdW1wZXIuaW5zdGFuY2VPZikgJiZcclxuICAgICAgICAgIChudWxsID09PSB0eXBlLmR1bXBlci5wcmVkaWNhdGUgIHx8IHR5cGUuZHVtcGVyLnByZWRpY2F0ZShvYmplY3QpKSkge1xyXG4gICAgICAgIHRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XHJcblxyXG4gICAgICAgIGlmIChudWxsICE9PSB0eXBlLmR1bXBlci5yZXByZXNlbnRlcikge1xyXG4gICAgICAgICAgc3R5bGUgPSBzdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kdW1wZXIuZGVmYXVsdFN0eWxlO1xyXG5cclxuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdHlwZS5kdW1wZXIucmVwcmVzZW50ZXIpIHtcclxuICAgICAgICAgICAgX3Jlc3VsdCA9IHR5cGUuZHVtcGVyLnJlcHJlc2VudGVyKG9iamVjdCwgc3R5bGUpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLmR1bXBlci5yZXByZXNlbnRlciwgc3R5bGUpKSB7XHJcbiAgICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLmR1bXBlci5yZXByZXNlbnRlcltzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoTklMICE9PSBfcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGtpbmQgPSBraW5kT2YoX3Jlc3VsdCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXhwbGljaXQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignY2Fubm90IHJlcHJlc2VudCBhbiBvYmplY3Qgb2YgITwnICsgdHlwZS50YWcgKyAnPiB0eXBlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cclxuICAvLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXHJcbiAgLy9cclxuICBmdW5jdGlvbiB3cml0ZU5vZGUobGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QpIHtcclxuICAgIHRhZyA9IG51bGw7XHJcbiAgICByZXN1bHQgPSBvYmplY3Q7XHJcblxyXG4gICAgaWYgKCFkZXRlY3RUeXBlKG9iamVjdCwgZmFsc2UpKSB7XHJcbiAgICAgIGRldGVjdFR5cGUob2JqZWN0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmxvY2spIHtcclxuICAgICAgYmxvY2sgPSAoMCA+IGZsb3dMZXZlbCB8fCBmbG93TGV2ZWwgPiBsZXZlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKChudWxsICE9PSB0YWcgJiYgJz8nICE9PSB0YWcpIHx8ICgyICE9PSBpbmRlbnQgJiYgbGV2ZWwgPiAwKSkge1xyXG4gICAgICBjb21wYWN0ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdvYmplY3QnID09PSBraW5kKSB7XHJcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGgpKSB7XHJcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcobGV2ZWwsIHJlc3VsdCwgY29tcGFjdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhsZXZlbCwgcmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICgnYXJyYXknID09PSBraW5kKSB7XHJcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gcmVzdWx0Lmxlbmd0aCkpIHtcclxuICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2UobGV2ZWwsIHJlc3VsdCwgY29tcGFjdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2UobGV2ZWwsIHJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IGtpbmQpIHtcclxuICAgICAgaWYgKCc/JyAhPT0gdGFnKSB7XHJcbiAgICAgICAgd3JpdGVTY2FsYXIocmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChza2lwSW52YWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAoJyArIGtpbmQgKyAnKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChudWxsICE9PSB0YWcgJiYgJz8nICE9PSB0YWcpIHtcclxuICAgICAgcmVzdWx0ID0gJyE8JyArIHRhZyArICc+ICcgKyByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICh3cml0ZU5vZGUoMCwgaW5wdXQsIHRydWUsIHRydWUpKSB7XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgJ1xcbic7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzYWZlRHVtcChpbnB1dCwgb3B0aW9ucykge1xyXG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgID0gZHVtcDtcclxubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcclxuXG59KSgpIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxyXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcclxuLy9cclxuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXHJcbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxyXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxyXG5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcclxuICBpbmNsdWRlOiBbXHJcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcclxuICBdLFxyXG4gIGltcGxpY2l0OiBbXHJcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcclxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcclxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxyXG4gIF1cclxufSk7XHJcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXHJcbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxyXG5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcclxuICBleHBsaWNpdDogW1xyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcclxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXHJcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXHJcbiAgXVxyXG59KTtcclxuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxyXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXHJcbi8vXHJcbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxyXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcclxuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XHJcbiAgaW5jbHVkZTogW1xyXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcclxuICBdLFxyXG4gIGltcGxpY2l0OiBbXHJcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXHJcbiAgXSxcclxuICBleHBsaWNpdDogW1xyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcclxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxyXG4gIF1cclxufSk7XHJcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxyXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXHJcbi8vXHJcbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xyXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXHJcbi8vXHJcbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cclxuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcclxuICBpbmNsdWRlOiBbXHJcbiAgICByZXF1aXJlKCcuL2RlZmF1bHRfc2FmZScpXHJcbiAgXSxcclxuICBleHBsaWNpdDogW1xyXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy91bmRlZmluZWQnKSxcclxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXHJcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcclxuICBdXHJcbn0pO1xyXG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXHJcbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xyXG4vL1xyXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cclxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxyXG5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcclxuICBpbmNsdWRlOiBbXHJcbiAgICByZXF1aXJlKCcuL2pzb24nKVxyXG4gIF1cclxufSk7XHJcbiIsIihmdW5jdGlvbihnbG9iYWwpeyhmdW5jdGlvbigpIHtcbiAgdmFyICQsIEFic3RyYWN0Q2hvc2VuLCBDaG9zZW4sIFNlbGVjdFBhcnNlciwgZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgQWJzdHJhY3RDaG9zZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDaG9zZW4oZm9ybV9maWVsZCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkID0gZm9ybV9maWVsZDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgIHRoaXMuaXNfbXVsdGlwbGUgPSB0aGlzLmZvcm1fZmllbGQubXVsdGlwbGU7XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3RleHQoKTtcbiAgICAgIHRoaXMuc2V0X2RlZmF1bHRfdmFsdWVzKCk7XG4gICAgICB0aGlzLnNldHVwKCk7XG4gICAgICB0aGlzLnNldF91cF9odG1sKCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyX29ic2VydmVycygpO1xuICAgICAgdGhpcy5maW5pc2hfc2V0dXAoKTtcbiAgICB9XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50ZXN0X2FjdGl2ZV9jbGljayhldnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZhdGVfYWN0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hY3RpdmF0ZV9maWVsZChldnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXN1bHRzX3Nob3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCA9IG51bGw7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA9ICh0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0ICE9IG51bGwpICYmICh0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXSAhPSBudWxsKSAmJiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS50ZXh0ID09PSBcIlwiID8gdGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA6IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkIHx8IDA7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmRpc2FibGVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoIDogdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5zID0gdGhpcy5vcHRpb25zLnNlYXJjaF9jb250YWlucyB8fCBmYWxzZTtcbiAgICAgIHRoaXMuY2hvaWNlcyA9IDA7XG4gICAgICB0aGlzLnNpbmdsZV9iYWNrc3Ryb2tlX2RlbGV0ZSA9IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgfHwgZmFsc2U7XG4gICAgICB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zID0gdGhpcy5vcHRpb25zLm1heF9zZWxlY3RlZF9vcHRpb25zIHx8IEluZmluaXR5O1xuICAgICAgcmV0dXJuIHRoaXMuaW5oZXJpdF9zZWxlY3RfY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtcGxhY2Vob2xkZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dF9tdWx0aXBsZSB8fCB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dCB8fCBcIlNlbGVjdCBTb21lIE9wdGlvbnNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHRfc2luZ2xlIHx8IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0IHx8IFwiU2VsZWN0IGFuIE9wdGlvblwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19ub25lX2ZvdW5kID0gdGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtbm9fcmVzdWx0c190ZXh0XCIpIHx8IHRoaXMub3B0aW9ucy5ub19yZXN1bHRzX3RleHQgfHwgXCJObyByZXN1bHRzIG1hdGNoXCI7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5tb3VzZV9lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2xlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2ZvY3VzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oKTtcbiAgICAgICAgICB9KSwgNTApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVfZmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5wdXRfYmx1ciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm1vdXNlX29uX2NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmJsdXJfdGVzdCgpO1xuICAgICAgICB9KSwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICB2YXIgY2xhc3Nlcywgc3R5bGU7XG5cbiAgICAgIGlmICghb3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgIG9wdGlvbi5kb21faWQgPSB0aGlzLmNvbnRhaW5lcl9pZCArIFwiX29fXCIgKyBvcHRpb24uYXJyYXlfaW5kZXg7XG4gICAgICAgIGNsYXNzZXMgPSBvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSA/IFtdIDogW1wiYWN0aXZlLXJlc3VsdFwiXTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goXCJncm91cC1vcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbi5jbGFzc2VzICE9PSBcIlwiKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKG9wdGlvbi5jbGFzc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZSA9IG9wdGlvbi5zdHlsZS5jc3NUZXh0ICE9PSBcIlwiID8gXCIgc3R5bGU9XFxcIlwiICsgb3B0aW9uLnN0eWxlICsgXCJcXFwiXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gJzxsaSBpZD1cIicgKyBvcHRpb24uZG9tX2lkICsgJ1wiIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArIHN0eWxlICsgJz4nICsgb3B0aW9uLmh0bWwgKyAnPC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3VwZGF0ZV9maWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX2J1aWxkKCk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3RvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3NlYXJjaCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmtleXVwX2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBzdHJva2UsIF9yZWY7XG5cbiAgICAgIHN0cm9rZSA9IChfcmVmID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZiA6IGV2dC5rZXlDb2RlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHN3aXRjaCAoc3Ryb2tlKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmJhY2tzdHJva2VfbGVuZ3RoIDwgMSAmJiB0aGlzLmNob2ljZXMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9zZWxlY3QoZXZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDkxOlxuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2VhcmNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5nZW5lcmF0ZV9maWVsZF9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld19pZDtcblxuICAgICAgbmV3X2lkID0gdGhpcy5nZW5lcmF0ZV9yYW5kb21faWQoKTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZC5pZCA9IG5ld19pZDtcbiAgICAgIHJldHVybiBuZXdfaWQ7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5nZW5lcmF0ZV9yYW5kb21fY2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXJzLCBuZXdjaGFyLCByYW5kO1xuXG4gICAgICBjaGFycyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG4gICAgICByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdjaGFyID0gY2hhcnMuc3Vic3RyaW5nKHJhbmQsIHJhbmQgKyAxKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0Q2hvc2VuO1xuXG4gIH0pKCk7XG5cbiAgJCA9IGdsb2JhbC4kO1xuXG4gICQgfHwgKCQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpKTtcblxuICBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyA9IGZ1bmN0aW9uKGVsbXQpIHtcbiAgICB2YXIgc2lkZV9ib3JkZXJfcGFkZGluZztcblxuICAgIHJldHVybiBzaWRlX2JvcmRlcl9wYWRkaW5nID0gZWxtdC5vdXRlcldpZHRoKCkgLSBlbG10LndpZHRoKCk7XG4gIH07XG5cbiAgJC5mbi5leHRlbmQoe1xuICAgIGNob3NlbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGJyb3dzZXIsIG1hdGNoLCB1YTtcblxuICAgICAgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgbWF0Y2ggPSAvKG1zaWUpIChbXFx3Ll0rKS8uZXhlYyh1YSkgfHwgW107XG4gICAgICBicm93c2VyID0ge1xuICAgICAgICBuYW1lOiBtYXRjaFsxXSB8fCBcIlwiLFxuICAgICAgICB2ZXJzaW9uOiBtYXRjaFsyXSB8fCBcIjBcIlxuICAgICAgfTtcbiAgICAgIGlmIChicm93c2VyLm5hbWUgPT09IFwibXNpZVwiICYmIChicm93c2VyLnZlcnNpb24gPT09IFwiNi4wXCIgfHwgKGJyb3dzZXIudmVyc2lvbiA9PT0gXCI3LjBcIiAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IDcpKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5wdXRfZmllbGQpIHtcbiAgICAgICAgdmFyICR0aGlzO1xuXG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgaWYgKCEkdGhpcy5oYXNDbGFzcyhcImNoem4tZG9uZVwiKSkge1xuICAgICAgICAgIHJldHVybiAkdGhpcy5kYXRhKCdjaG9zZW4nLCBuZXcgQ2hvc2VuKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBDaG9zZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENob3NlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENob3NlbigpIHtcbiAgICAgIF9yZWYgPSBDaG9zZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEgPSAkKHRoaXMuZm9ybV9maWVsZCk7XG4gICAgICB0aGlzLmN1cnJlbnRfdmFsdWUgPSB0aGlzLmZvcm1fZmllbGRfanEudmFsKCk7XG4gICAgICByZXR1cm4gdGhpcy5pc19ydGwgPSB0aGlzLmZvcm1fZmllbGRfanEuaGFzQ2xhc3MoXCJjaHpuLXJ0bFwiKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5maW5pc2hfc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1fZmllbGRfanEuYWRkQ2xhc3MoXCJjaHpuLWRvbmVcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3VwX2h0bWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250YWluZXJfY2xhc3NlcywgY29udGFpbmVyX2RpdiwgY29udGFpbmVyX3Byb3BzLCBkZF90b3AsIGRkX3dpZHRoLCBzZl93aWR0aDtcblxuICAgICAgdGhpcy5jb250YWluZXJfaWQgPSB0aGlzLmZvcm1fZmllbGQuaWQubGVuZ3RoID8gdGhpcy5mb3JtX2ZpZWxkLmlkLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpIDogdGhpcy5nZW5lcmF0ZV9maWVsZF9pZCgpO1xuICAgICAgdGhpcy5jb250YWluZXJfaWQgKz0gXCJfY2h6blwiO1xuICAgICAgY29udGFpbmVyX2NsYXNzZXMgPSBbXCJjaHpuLWNvbnRhaW5lclwiXTtcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzLnB1c2goXCJjaHpuLWNvbnRhaW5lci1cIiArICh0aGlzLmlzX211bHRpcGxlID8gXCJtdWx0aVwiIDogXCJzaW5nbGVcIikpO1xuICAgICAgaWYgKHRoaXMuaW5oZXJpdF9zZWxlY3RfY2xhc3NlcyAmJiB0aGlzLmZvcm1fZmllbGQuY2xhc3NOYW1lKSB7XG4gICAgICAgIGNvbnRhaW5lcl9jbGFzc2VzLnB1c2godGhpcy5mb3JtX2ZpZWxkLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc19ydGwpIHtcbiAgICAgICAgY29udGFpbmVyX2NsYXNzZXMucHVzaChcImNoem4tcnRsXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5mX3dpZHRoID0gdGhpcy5mb3JtX2ZpZWxkX2pxLm91dGVyV2lkdGgoKTtcbiAgICAgIGNvbnRhaW5lcl9wcm9wcyA9IHtcbiAgICAgICAgaWQ6IHRoaXMuY29udGFpbmVyX2lkLFxuICAgICAgICBcImNsYXNzXCI6IGNvbnRhaW5lcl9jbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgc3R5bGU6ICd3aWR0aDogJyArIHRoaXMuZl93aWR0aCArICdweDsnLFxuICAgICAgICB0aXRsZTogdGhpcy5mb3JtX2ZpZWxkLnRpdGxlXG4gICAgICB9O1xuICAgICAgY29udGFpbmVyX2RpdiA9ICQoXCI8ZGl2IC8+XCIsIGNvbnRhaW5lcl9wcm9wcyk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBjb250YWluZXJfZGl2Lmh0bWwoJzx1bCBjbGFzcz1cImNoem4tY2hvaWNlc1wiPjxsaSBjbGFzcz1cInNlYXJjaC1maWVsZFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPVwiJyArIHRoaXMuZGVmYXVsdF90ZXh0ICsgJ1wiIGNsYXNzPVwiZGVmYXVsdFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIHN0eWxlPVwid2lkdGg6MjVweDtcIiAvPjwvbGk+PC91bD48ZGl2IGNsYXNzPVwiY2h6bi1kcm9wXCIgc3R5bGU9XCJsZWZ0Oi05MDAwcHg7XCI+PHVsIGNsYXNzPVwiY2h6bi1yZXN1bHRzXCI+PC91bD48L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lcl9kaXYuaHRtbCgnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiY2h6bi1zaW5nbGUgY2h6bi1kZWZhdWx0XCIgdGFiaW5kZXg9XCItMVwiPjxzcGFuPicgKyB0aGlzLmRlZmF1bHRfdGV4dCArICc8L3NwYW4+PGRpdj48Yj48L2I+PC9kaXY+PC9hPjxkaXYgY2xhc3M9XCJjaHpuLWRyb3BcIiBzdHlsZT1cImxlZnQ6LTkwMDBweDtcIj48ZGl2IGNsYXNzPVwiY2h6bi1zZWFyY2hcIj48aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiAvPjwvZGl2Pjx1bCBjbGFzcz1cImNoem4tcmVzdWx0c1wiPjwvdWw+PC9kaXY+Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuaGlkZSgpLmFmdGVyKGNvbnRhaW5lcl9kaXYpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSAkKCcjJyArIHRoaXMuY29udGFpbmVyX2lkKTtcbiAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2h6bi1kcm9wJykuZmlyc3QoKTtcbiAgICAgIGRkX3RvcCA9IHRoaXMuY29udGFpbmVyLmhlaWdodCgpO1xuICAgICAgZGRfd2lkdGggPSB0aGlzLmZfd2lkdGggLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLmRyb3Bkb3duKTtcbiAgICAgIHRoaXMuZHJvcGRvd24uY3NzKHtcbiAgICAgICAgXCJ3aWR0aFwiOiBkZF93aWR0aCArIFwicHhcIixcbiAgICAgICAgXCJ0b3BcIjogZGRfdG9wICsgXCJweFwiXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkID0gdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXQnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cyA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ3VsLmNoem4tcmVzdWx0cycpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgdGhpcy5zZWFyY2hfbm9fcmVzdWx0cyA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2xpLm5vLXJlc3VsdHMnKS5maXJzdCgpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcyA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ3VsLmNoem4tY2hvaWNlcycpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2xpLnNlYXJjaC1maWVsZCcpLmZpcnN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2h6bi1zZWFyY2gnKS5maXJzdCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0gPSB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2h6bi1zaW5nbGUnKS5maXJzdCgpO1xuICAgICAgICBzZl93aWR0aCA9IGRkX3dpZHRoIC0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcodGhpcy5zZWFyY2hfY29udGFpbmVyKSAtIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nKHRoaXMuc2VhcmNoX2ZpZWxkKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQuY3NzKHtcbiAgICAgICAgICBcIndpZHRoXCI6IHNmX3dpZHRoICsgXCJweFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRzX2J1aWxkKCk7XG4gICAgICB0aGlzLnNldF90YWJfaW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImxpc3p0OnJlYWR5XCIsIHtcbiAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZWdpc3Rlcl9vYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNlZG93bihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIubW91c2V1cChmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNlZW50ZXIoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tb3VzZV9lbnRlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5tb3VzZWxlYXZlKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubW91c2VfbGVhdmUoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5tb3VzZXVwKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLm1vdXNlb3ZlcihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLm1vdXNlb3V0KGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJsaXN6dDp1cGRhdGVkXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVzdWx0c191cGRhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJsaXN6dDphY3RpdmF0ZVwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRlX2ZpZWxkKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwibGlzenQ6b3BlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmx1cihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmlucHV0X2JsdXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQua2V5dXAoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5rZXl1cF9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmtleWRvd24oZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5rZXlkb3duX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5pbnB1dF9mb2N1cyhldnQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfY2hvaWNlcy5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlc19jbGljayhldnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9maWVsZF9kaXNhYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc19kaXNhYmxlZCA9IHRoaXMuZm9ybV9maWVsZF9qcVswXS5kaXNhYmxlZDtcbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdjaHpuLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLnVuYmluZChcImZvY3VzXCIsIHRoaXMuYWN0aXZhdGVfYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZV9maWVsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2Noem4tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5iaW5kKFwiZm9jdXNcIiwgdGhpcy5hY3RpdmF0ZV9hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY29udGFpbmVyX21vdXNlZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldF9jbG9zZWxpbms7XG5cbiAgICAgIGlmICghdGhpcy5pc19kaXNhYmxlZCkge1xuICAgICAgICB0YXJnZXRfY2xvc2VsaW5rID0gZXZ0ICE9IG51bGwgPyAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwic2VhcmNoLWNob2ljZS1jbG9zZVwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoKGV2dCAhPSBudWxsID8gZXZ0LnR5cGUgOiB2b2lkIDApID09PSBcIm1vdXNlZG93blwiICYmICF0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nX2Rlc3Ryb3lfY2xpY2sgJiYgIXRhcmdldF9jbG9zZWxpbmspIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKGRvY3VtZW50KS5jbGljayh0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19tdWx0aXBsZSAmJiBldnQgJiYgKCgkKGV2dC50YXJnZXQpWzBdID09PSB0aGlzLnNlbGVjdGVkX2l0ZW1bMF0pIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcImEuY2h6bi1zaW5nbGVcIikubGVuZ3RoKSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfdG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19kZXN0cm95X2NsaWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jb250YWluZXJfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKGV2dC50YXJnZXQubm9kZU5hbWUgPT09IFwiQUJCUlwiICYmICF0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfcmVzZXQoZXZ0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5ibHVyX3Rlc3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICghdGhpcy5hY3RpdmVfZmllbGQgJiYgdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VfZmllbGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbG9zZV9maWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgJChkb2N1bWVudCkudW5iaW5kKFwiY2xpY2tcIiwgdGhpcy5jbGlja190ZXN0X2FjdGlvbik7XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiY2h6bi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy53aW5ub3dfcmVzdWx0c19jbGVhcigpO1xuICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmFjdGl2YXRlX2ZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNoem4tY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLnNlYXJjaF9maWVsZC52YWwoKSk7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS50ZXN0X2FjdGl2ZV9jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCQoZXZ0LnRhcmdldCkucGFyZW50cygnIycgKyB0aGlzLmNvbnRhaW5lcl9pZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZV9maWVsZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZV9maWVsZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZW50LCBkYXRhLCBfaSwgX2xlbiwgX3JlZjE7XG5cbiAgICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgICB0aGlzLnJlc3VsdHNfZGF0YSA9IFNlbGVjdFBhcnNlci5zZWxlY3RfdG9fYXJyYXkodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlcyA+IDApIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcy5maW5kKFwibGkuc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jaG9pY2VzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2h6bi1kZWZhdWx0XCIpLmZpbmQoXCJzcGFuXCIpLnRleHQodGhpcy5kZWZhdWx0X3RleHQpO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlX3NlYXJjaCB8fCB0aGlzLmZvcm1fZmllbGQub3B0aW9ucy5sZW5ndGggPD0gdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNoem4tY29udGFpbmVyLXNpbmdsZS1ub3NlYXJjaFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNoem4tY29udGFpbmVyLXNpbmdsZS1ub3NlYXJjaFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGVudCA9ICcnO1xuICAgICAgX3JlZjEgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZGF0YSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKGRhdGEuZ3JvdXApIHtcbiAgICAgICAgICBjb250ZW50ICs9IHRoaXMucmVzdWx0X2FkZF9ncm91cChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YS5lbXB0eSkge1xuICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5yZXN1bHRfYWRkX29wdGlvbihkYXRhKTtcbiAgICAgICAgICBpZiAoZGF0YS5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNoem4tZGVmYXVsdFwiKS5maW5kKFwic3BhblwiKS50ZXh0KGRhdGEudGV4dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaW5nbGVfZGVzZWxlY3RfY29udHJvbF9idWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfZGlzYWJsZWQoKTtcbiAgICAgIHRoaXMuc2hvd19zZWFyY2hfZmllbGRfZGVmYXVsdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuaHRtbChjb250ZW50KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfYWRkX2dyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIGlmICghZ3JvdXAuZGlzYWJsZWQpIHtcbiAgICAgICAgZ3JvdXAuZG9tX2lkID0gdGhpcy5jb250YWluZXJfaWQgKyBcIl9nX1wiICsgZ3JvdXAuYXJyYXlfaW5kZXg7XG4gICAgICAgIHJldHVybiAnPGxpIGlkPVwiJyArIGdyb3VwLmRvbV9pZCArICdcIiBjbGFzcz1cImdyb3VwLXJlc3VsdFwiPicgKyAkKFwiPGRpdiAvPlwiKS50ZXh0KGdyb3VwLmxhYmVsKS5odG1sKCkgKyAnPC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2RvX2hpZ2hsaWdodCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgaGlnaF9ib3R0b20sIGhpZ2hfdG9wLCBtYXhIZWlnaHQsIHZpc2libGVfYm90dG9tLCB2aXNpYmxlX3RvcDtcblxuICAgICAgaWYgKGVsLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0ID0gZWw7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5hZGRDbGFzcyhcImhpZ2hsaWdodGVkXCIpO1xuICAgICAgICBtYXhIZWlnaHQgPSBwYXJzZUludCh0aGlzLnNlYXJjaF9yZXN1bHRzLmNzcyhcIm1heEhlaWdodFwiKSwgMTApO1xuICAgICAgICB2aXNpYmxlX3RvcCA9IHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKCk7XG4gICAgICAgIHZpc2libGVfYm90dG9tID0gbWF4SGVpZ2h0ICsgdmlzaWJsZV90b3A7XG4gICAgICAgIGhpZ2hfdG9wID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LnBvc2l0aW9uKCkudG9wICsgdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKTtcbiAgICAgICAgaGlnaF9ib3R0b20gPSBoaWdoX3RvcCArIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5vdXRlckhlaWdodCgpO1xuICAgICAgICBpZiAoaGlnaF9ib3R0b20gPj0gdmlzaWJsZV9ib3R0b20pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKGhpZ2hfYm90dG9tIC0gbWF4SGVpZ2h0KSA+IDAgPyBoaWdoX2JvdHRvbSAtIG1heEhlaWdodCA6IDApO1xuICAgICAgICB9IGVsc2UgaWYgKGhpZ2hfdG9wIDwgdmlzaWJsZV90b3ApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoaGlnaF90b3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQucmVtb3ZlQ2xhc3MoXCJoaWdobGlnaHRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSBudWxsO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRkX3RvcDtcblxuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5hZGRDbGFzcyhcImNoem4tc2luZ2xlLXdpdGgtZHJvcFwiKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodCh0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF4X3NlbGVjdGVkX29wdGlvbnMgPD0gdGhpcy5jaG9pY2VzKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwibGlzenQ6bWF4c2VsZWN0ZWRcIiwge1xuICAgICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgZmFsc2U7XG4gICAgICB9XG4gICAgICBkZF90b3AgPSB0aGlzLmlzX211bHRpcGxlID8gdGhpcy5jb250YWluZXIuaGVpZ2h0KCkgOiB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKSAtIDE7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImxpc3p0OnNob3dpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcm9wZG93bi5jc3Moe1xuICAgICAgICBcInRvcFwiOiBkZF90b3AgKyBcInB4XCIsXG4gICAgICAgIFwibGVmdFwiOiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgcmV0dXJuIHRoaXMud2lubm93X3Jlc3VsdHMoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX2hpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0ucmVtb3ZlQ2xhc3MoXCJjaHpuLXNpbmdsZS13aXRoLWRyb3BcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwibGlzenQ6aGlkaW5nX2Ryb3Bkb3duXCIsIHtcbiAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHJvcGRvd24uY3NzKHtcbiAgICAgICAgbGVmdDogXCItOTAwMHB4XCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3RhYl9pbmRleCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgdGk7XG5cbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGRfanEuYXR0cihcInRhYmluZGV4XCIpKSB7XG4gICAgICAgIHRpID0gdGhpcy5mb3JtX2ZpZWxkX2pxLmF0dHIoXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmF0dHIoXCJ0YWJpbmRleFwiLCAtMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hdHRyKFwidGFiaW5kZXhcIiwgdGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlcyA8IDEgJiYgIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hZGRDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5yZW1vdmVDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgdGFyZ2V0ID0gJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIikgPyAkKGV2dC50YXJnZXQpIDogJChldnQudGFyZ2V0KS5wYXJlbnRzKFwiLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgIGlmICh0YXJnZXQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgdGFyZ2V0ID0gJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIikgPyAkKGV2dC50YXJnZXQpIDogJChldnQudGFyZ2V0KS5wYXJlbnRzKFwiLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIiB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoJy5hY3RpdmUtcmVzdWx0JykuZmlyc3QoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNob2ljZXNfY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlX2ZpZWxkICYmICEoJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2VcIiB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoJy5zZWFyY2gtY2hvaWNlJykuZmlyc3QpKSAmJiAhdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2J1aWxkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGNob2ljZV9pZCwgaHRtbCwgbGluayxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zIDw9IHRoaXMuY2hvaWNlcykge1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImxpc3p0Om1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hvaWNlX2lkID0gdGhpcy5jb250YWluZXJfaWQgKyBcIl9jX1wiICsgaXRlbS5hcnJheV9pbmRleDtcbiAgICAgIHRoaXMuY2hvaWNlcyArPSAxO1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgaHRtbCA9ICc8bGkgY2xhc3M9XCJzZWFyY2gtY2hvaWNlIHNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIiBpZD1cIicgKyBjaG9pY2VfaWQgKyAnXCI+PHNwYW4+JyArIGl0ZW0uaHRtbCArICc8L3NwYW4+PC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICc8bGkgY2xhc3M9XCJzZWFyY2gtY2hvaWNlXCIgaWQ9XCInICsgY2hvaWNlX2lkICsgJ1wiPjxzcGFuPicgKyBpdGVtLmh0bWwgKyAnPC9zcGFuPjxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cInNlYXJjaC1jaG9pY2UtY2xvc2VcIiByZWw9XCInICsgaXRlbS5hcnJheV9pbmRleCArICdcIj48L2E+PC9saT4nO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWFyY2hfY29udGFpbmVyLmJlZm9yZShodG1sKTtcbiAgICAgIGxpbmsgPSAkKCcjJyArIGNob2ljZV9pZCkuZmluZChcImFcIikuZmlyc3QoKTtcbiAgICAgIHJldHVybiBsaW5rLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayhldnQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2Rlc3Ryb3lfY2xpY2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jaG9pY2VfZGVzdHJveSgkKGV2dC50YXJnZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNob2ljZV9kZXN0cm95ID0gZnVuY3Rpb24obGluaykge1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2Rlc2VsZWN0KGxpbmsuYXR0cihcInJlbFwiKSkpIHtcbiAgICAgICAgdGhpcy5jaG9pY2VzIC09IDE7XG4gICAgICAgIHRoaXMuc2hvd19zZWFyY2hfZmllbGRfZGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXMgPiAwICYmIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsucGFyZW50cygnbGknKS5maXJzdCgpLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcInNwYW5cIikudGV4dCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2h6bi1kZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnJlc3VsdHNfcmVzZXRfY2xlYW51cCgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICBpZiAodGhpcy5hY3RpdmVfZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19yZXNldF9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnJlbnRfdmFsdWUgPSB0aGlzLmZvcm1fZmllbGRfanEudmFsKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9zZWxlY3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBoaWdoLCBoaWdoX2lkLCBpdGVtLCBwb3NpdGlvbjtcblxuICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBoaWdoID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0O1xuICAgICAgICBoaWdoX2lkID0gaGlnaC5hdHRyKFwiaWRcIik7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RlYWN0aXZhdGUoaGlnaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLnJlc3VsdC1zZWxlY3RlZFwiKS5yZW1vdmVDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQgPSBoaWdoO1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNoem4tZGVmYXVsdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBoaWdoLmFkZENsYXNzKFwicmVzdWx0LXNlbGVjdGVkXCIpO1xuICAgICAgICBwb3NpdGlvbiA9IGhpZ2hfaWQuc3Vic3RyKGhpZ2hfaWQubGFzdEluZGV4T2YoXCJfXCIpICsgMSk7XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NpdGlvbl07XG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tpdGVtLm9wdGlvbnNfaW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcInNwYW5cIikuZmlyc3QoKS50ZXh0KGl0ZW0udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKChldnQubWV0YUtleSB8fCBldnQuY3RybEtleSkgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbChcIlwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUgfHwgdGhpcy5mb3JtX2ZpZWxkX2pxLnZhbCgpICE9PSB0aGlzLmN1cnJlbnRfdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiLCB7XG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tpdGVtLm9wdGlvbnNfaW5kZXhdLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50X3ZhbHVlID0gdGhpcy5mb3JtX2ZpZWxkX2pxLnZhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfYWN0aXZhdGUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLmFkZENsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwucmVtb3ZlQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kZXNlbGVjdCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIHJlc3VsdCwgcmVzdWx0X2RhdGE7XG5cbiAgICAgIHJlc3VsdF9kYXRhID0gdGhpcy5yZXN1bHRzX2RhdGFbcG9zXTtcbiAgICAgIGlmICghdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgcmVzdWx0X2RhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0ID0gJChcIiNcIiArIHRoaXMuY29udGFpbmVyX2lkICsgXCJfb19cIiArIHBvcyk7XG4gICAgICAgIHJlc3VsdC5yZW1vdmVDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKS5hZGRDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIikuc2hvdygpO1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiLCB7XG4gICAgICAgICAgZGVzZWxlY3RlZDogdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QgJiYgdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5maXJzdCgpLmFmdGVyKFwiPGFiYnIgY2xhc3M9XFxcInNlYXJjaC1jaG9pY2UtY2xvc2VcXFwiPjwvYWJicj5cIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmb3VuZCwgb3B0aW9uLCBwYXJ0LCBwYXJ0cywgcmVnZXgsIHJlZ2V4QW5jaG9yLCByZXN1bHQsIHJlc3VsdF9pZCwgcmVzdWx0cywgc2VhcmNoVGV4dCwgc3RhcnRwb3MsIHRleHQsIHpyZWdleCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjE7XG5cbiAgICAgIHRoaXMubm9fcmVzdWx0c19jbGVhcigpO1xuICAgICAgcmVzdWx0cyA9IDA7XG4gICAgICBzZWFyY2hUZXh0ID0gdGhpcy5zZWFyY2hfZmllbGQudmFsKCkgPT09IHRoaXMuZGVmYXVsdF90ZXh0ID8gXCJcIiA6ICQoJzxkaXYvPicpLnRleHQoJC50cmltKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKSkuaHRtbCgpO1xuICAgICAgcmVnZXhBbmNob3IgPSB0aGlzLnNlYXJjaF9jb250YWlucyA/IFwiXCIgOiBcIl5cIjtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleEFuY2hvciArIHNlYXJjaFRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpLCAnaScpO1xuICAgICAgenJlZ2V4ID0gbmV3IFJlZ0V4cChzZWFyY2hUZXh0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKSwgJ2knKTtcbiAgICAgIF9yZWYxID0gdGhpcy5yZXN1bHRzX2RhdGE7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQgJiYgIW9wdGlvbi5lbXB0eSkge1xuICAgICAgICAgIGlmIChvcHRpb24uZ3JvdXApIHtcbiAgICAgICAgICAgICQoJyMnICsgb3B0aW9uLmRvbV9pZCkuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEodGhpcy5pc19tdWx0aXBsZSAmJiBvcHRpb24uc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0X2lkID0gb3B0aW9uLmRvbV9pZDtcbiAgICAgICAgICAgIHJlc3VsdCA9ICQoXCIjXCIgKyByZXN1bHRfaWQpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3Qob3B0aW9uLmh0bWwpKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzdWx0cyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZV9zcGxpdF93b3JkX3NlYXJjaCAmJiAob3B0aW9uLmh0bWwuaW5kZXhPZihcIiBcIikgPj0gMCB8fCBvcHRpb24uaHRtbC5pbmRleE9mKFwiW1wiKSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgcGFydHMgPSBvcHRpb24uaHRtbC5yZXBsYWNlKC9cXFt8XFxdL2csIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHBhcnRzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW19qXTtcbiAgICAgICAgICAgICAgICAgIGlmICghKHJlZ2V4LnRlc3QocGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIGlmIChzZWFyY2hUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0cG9zID0gb3B0aW9uLmh0bWwuc2VhcmNoKHpyZWdleCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9wdGlvbi5odG1sLnN1YnN0cigwLCBzdGFydHBvcyArIHNlYXJjaFRleHQubGVuZ3RoKSArICc8L2VtPicgKyBvcHRpb24uaHRtbC5zdWJzdHIoc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIHN0YXJ0cG9zKSArICc8ZW0+JyArIHRleHQuc3Vic3RyKHN0YXJ0cG9zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3B0aW9uLmh0bWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0Lmh0bWwodGV4dCk7XG4gICAgICAgICAgICAgIHRoaXMucmVzdWx0X2FjdGl2YXRlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICQoXCIjXCIgKyB0aGlzLnJlc3VsdHNfZGF0YVtvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXhdLmRvbV9pZCkuY3NzKCdkaXNwbGF5JywgJ2xpc3QtaXRlbScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0ICYmIHJlc3VsdF9pZCA9PT0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmF0dHIoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnJlc3VsdF9kZWFjdGl2YXRlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0cyA8IDEgJiYgc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9fcmVzdWx0cyhzZWFyY2hUZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS53aW5ub3dfcmVzdWx0c19jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpLCBsaXMsIF9pLCBfbGVuLCBfcmVzdWx0cztcblxuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgbGlzID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwibGlcIik7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBsaXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbGkgPSBsaXNbX2ldO1xuICAgICAgICBsaSA9ICQobGkpO1xuICAgICAgICBpZiAobGkuaGFzQ2xhc3MoXCJncm91cC1yZXN1bHRcIikpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGxpLmNzcygnZGlzcGxheScsICdhdXRvJykpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzX211bHRpcGxlIHx8ICFsaS5oYXNDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5yZXN1bHRfYWN0aXZhdGUobGkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS53aW5ub3dfcmVzdWx0c19zZXRfaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9faGlnaCwgc2VsZWN0ZWRfcmVzdWx0cztcblxuICAgICAgaWYgKCF0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgc2VsZWN0ZWRfcmVzdWx0cyA9ICF0aGlzLmlzX211bHRpcGxlID8gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLnJlc3VsdC1zZWxlY3RlZC5hY3RpdmUtcmVzdWx0XCIpIDogW107XG4gICAgICAgIGRvX2hpZ2ggPSBzZWxlY3RlZF9yZXN1bHRzLmxlbmd0aCA/IHNlbGVjdGVkX3Jlc3VsdHMuZmlyc3QoKSA6IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChkb19oaWdoICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KGRvX2hpZ2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUubm9fcmVzdWx0cyA9IGZ1bmN0aW9uKHRlcm1zKSB7XG4gICAgICB2YXIgbm9fcmVzdWx0c19odG1sO1xuXG4gICAgICBub19yZXN1bHRzX2h0bWwgPSAkKCc8bGkgY2xhc3M9XCJuby1yZXN1bHRzXCI+JyArIHRoaXMucmVzdWx0c19ub25lX2ZvdW5kICsgJyBcIjxzcGFuPjwvc3Bhbj5cIjwvbGk+Jyk7XG4gICAgICBub19yZXN1bHRzX2h0bWwuZmluZChcInNwYW5cIikuZmlyc3QoKS5odG1sKHRlcm1zKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmFwcGVuZChub19yZXN1bHRzX2h0bWwpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIubm8tcmVzdWx0c1wiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3RfYWN0aXZlLCBuZXh0X3NpYjtcblxuICAgICAgaWYgKCF0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgZmlyc3RfYWN0aXZlID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwibGkuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgICBpZiAoZmlyc3RfYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KCQoZmlyc3RfYWN0aXZlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgbmV4dF9zaWIgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQubmV4dEFsbChcImxpLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgICAgaWYgKG5leHRfc2liKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KG5leHRfc2liKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXl1cF9hcnJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXZfc2licztcblxuICAgICAgaWYgKCF0aGlzLnJlc3VsdHNfc2hvd2luZyAmJiAhdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHByZXZfc2licyA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodC5wcmV2QWxsKFwibGkuYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgICAgaWYgKHByZXZfc2licy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHByZXZfc2licy5maXJzdCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5jaG9pY2VzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY2hvaWNlX2Rlc3Ryb3kodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UuZmluZChcImFcIikuZmlyc3QoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyX2JhY2tzdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3kgPSB0aGlzLnNlYXJjaF9jb250YWluZXIuc2libGluZ3MoXCJsaS5zZWFyY2gtY2hvaWNlXCIpLmxhc3QoKTtcbiAgICAgICAgaWYgKG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3kubGVuZ3RoICYmICFuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmhhc0NsYXNzKFwic2VhcmNoLWNob2ljZS1kaXNhYmxlZFwiKSkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgICAgICBpZiAodGhpcy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleWRvd25fYmFja3N0cm9rZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UuYWRkQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNsZWFyX2JhY2tzdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZS5yZW1vdmVDbGFzcyhcInNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmtleWRvd25fY2hlY2tlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHN0cm9rZSwgX3JlZjE7XG5cbiAgICAgIHN0cm9rZSA9IChfcmVmMSA9IGV2dC53aGljaCkgIT0gbnVsbCA/IF9yZWYxIDogZXZ0LmtleUNvZGU7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgaWYgKHN0cm9rZSAhPT0gOCAmJiB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLmNsZWFyX2JhY2tzdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3Ryb2tlKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrc3Ryb2tlX2xlbmd0aCA9IHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpLmxlbmd0aDtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZyAmJiAhdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5rZXl1cF9hcnJvdygpO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIHJldHVybiB0aGlzLmtleWRvd25fYXJyb3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfZmllbGRfc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZF90b3AsIGRpdiwgaCwgc3R5bGUsIHN0eWxlX2Jsb2NrLCBzdHlsZXMsIHcsIF9pLCBfbGVuO1xuXG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBoID0gMDtcbiAgICAgICAgdyA9IDA7XG4gICAgICAgIHN0eWxlX2Jsb2NrID0gXCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDogLTEwMDBweDsgdG9wOiAtMTAwMHB4OyBkaXNwbGF5Om5vbmU7XCI7XG4gICAgICAgIHN0eWxlcyA9IFsnZm9udC1zaXplJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC13ZWlnaHQnLCAnZm9udC1mYW1pbHknLCAnbGluZS1oZWlnaHQnLCAndGV4dC10cmFuc2Zvcm0nLCAnbGV0dGVyLXNwYWNpbmcnXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzdHlsZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tfaV07XG4gICAgICAgICAgc3R5bGVfYmxvY2sgKz0gc3R5bGUgKyBcIjpcIiArIHRoaXMuc2VhcmNoX2ZpZWxkLmNzcyhzdHlsZSkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBkaXYgPSAkKCc8ZGl2IC8+Jywge1xuICAgICAgICAgICdzdHlsZSc6IHN0eWxlX2Jsb2NrXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYudGV4dCh0aGlzLnNlYXJjaF9maWVsZC52YWwoKSk7XG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQoZGl2KTtcbiAgICAgICAgdyA9IGRpdi53aWR0aCgpICsgMjU7XG4gICAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHcgPiB0aGlzLmZfd2lkdGggLSAxMCkge1xuICAgICAgICAgIHcgPSB0aGlzLmZfd2lkdGggLSAxMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IHcgKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgICBkZF90b3AgPSB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uY3NzKHtcbiAgICAgICAgICBcInRvcFwiOiBkZF90b3AgKyBcInB4XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuZ2VuZXJhdGVfcmFuZG9tX2lkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5nO1xuXG4gICAgICBzdHJpbmcgPSBcInNlbFwiICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpO1xuICAgICAgd2hpbGUgKCQoXCIjXCIgKyBzdHJpbmcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5nICs9IHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2NoYXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIHJldHVybiBDaG9zZW47XG5cbiAgfSkoQWJzdHJhY3RDaG9zZW4pO1xuXG4gIGV4cG9ydHMuQ2hvc2VuID0gQ2hvc2VuO1xuXG4gIFNlbGVjdFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RQYXJzZXIoKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfaW5kZXggPSAwO1xuICAgICAgdGhpcy5wYXJzZWQgPSBbXTtcbiAgICB9XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ub2RlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2dyb3VwKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9vcHRpb24oY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ncm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICB2YXIgZ3JvdXBfcG9zaXRpb24sIG9wdGlvbiwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcblxuICAgICAgZ3JvdXBfcG9zaXRpb24gPSB0aGlzLnBhcnNlZC5sZW5ndGg7XG4gICAgICB0aGlzLnBhcnNlZC5wdXNoKHtcbiAgICAgICAgYXJyYXlfaW5kZXg6IGdyb3VwX3Bvc2l0aW9uLFxuICAgICAgICBncm91cDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IGdyb3VwLmxhYmVsLFxuICAgICAgICBjaGlsZHJlbjogMCxcbiAgICAgICAgZGlzYWJsZWQ6IGdyb3VwLmRpc2FibGVkXG4gICAgICB9KTtcbiAgICAgIF9yZWYxID0gZ3JvdXAuY2hpbGROb2RlcztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWYxW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFkZF9vcHRpb24ob3B0aW9uLCBncm91cF9wb3NpdGlvbiwgZ3JvdXAuZGlzYWJsZWQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uLCBncm91cF9wb3NpdGlvbiwgZ3JvdXBfZGlzYWJsZWQpIHtcbiAgICAgIGlmIChvcHRpb24ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgICBpZiAob3B0aW9uLnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoZ3JvdXBfcG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRbZ3JvdXBfcG9zaXRpb25dLmNoaWxkcmVuICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgYXJyYXlfaW5kZXg6IHRoaXMucGFyc2VkLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnNfaW5kZXg6IHRoaXMub3B0aW9uc19pbmRleCxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgICAgICB0ZXh0OiBvcHRpb24udGV4dCxcbiAgICAgICAgICAgIGh0bWw6IG9wdGlvbi5pbm5lckhUTUwsXG4gICAgICAgICAgICBzZWxlY3RlZDogb3B0aW9uLnNlbGVjdGVkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGdyb3VwX2Rpc2FibGVkID09PSB0cnVlID8gZ3JvdXBfZGlzYWJsZWQgOiBvcHRpb24uZGlzYWJsZWQsXG4gICAgICAgICAgICBncm91cF9hcnJheV9pbmRleDogZ3JvdXBfcG9zaXRpb24sXG4gICAgICAgICAgICBjbGFzc2VzOiBvcHRpb24uY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbi5zdHlsZS5jc3NUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgZW1wdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zX2luZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3RQYXJzZXI7XG5cbiAgfSkoKTtcblxuICBTZWxlY3RQYXJzZXIuc2VsZWN0X3RvX2FycmF5ID0gZnVuY3Rpb24oc2VsZWN0KSB7XG4gICAgdmFyIGNoaWxkLCBwYXJzZXIsIF9pLCBfbGVuLCBfcmVmMTtcblxuICAgIHBhcnNlciA9IG5ldyBTZWxlY3RQYXJzZXIoKTtcbiAgICBfcmVmMSA9IHNlbGVjdC5jaGlsZE5vZGVzO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGNoaWxkID0gX3JlZjFbX2ldO1xuICAgICAgcGFyc2VyLmFkZF9ub2RlKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZWQ7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pKHdpbmRvdykiLCIoZnVuY3Rpb24oKXt2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIGpzeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKTtcclxudmFyIHF1ZXVlID0gcmVxdWlyZSgncXVldWUtYXN5bmMnKTtcclxuXHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL2ZpbGUnKTtcclxudmFyIEZvbGRlciA9IHJlcXVpcmUoJy4uL21vZGVscy9mb2xkZXInKTtcclxuXHJcbnZhciBjb29raWUgPSByZXF1aXJlKCcuLi9jb29raWUnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbnZhciBpZ25vcmUgPSByZXF1aXJlKCdpZ25vcmUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xyXG4gIG1vZGVsOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XHJcbiAgICAvLyBUT0RPOiBoYW5kbGUgJ3N5bWxpbmsnIGFuZCAnc3VibW9kdWxlJyB0eXBlXHJcbiAgICAvLyBUT0RPOiBjb2VyY2UgdHJlZS9mb2xkZXIgdG8gYSBzaW5nbGUgdHlwZVxyXG4gICAgc3dpdGNoKGF0dHJpYnV0ZXMudHlwZSkge1xyXG4gICAgICBjYXNlICd0cmVlJzpcclxuICAgICAgICByZXR1cm4gbmV3IEZvbGRlcihhdHRyaWJ1dGVzLCBvcHRpb25zKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYmxvYic6XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBuZXcgRmlsZShhdHRyaWJ1dGVzLCBvcHRpb25zKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcclxuICAgIF8uYmluZEFsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG87XHJcbiAgICB0aGlzLmJyYW5jaCA9IG9wdGlvbnMuYnJhbmNoO1xyXG4gICAgdGhpcy5zaGEgPSBvcHRpb25zLnNoYTtcclxuXHJcbiAgICAvLyBTb3J0IGZpbGVzIHJldmVyc2UgYWxwaGFiZXRpY2FsbHkgaWYgcGF0aCBiZWdpbnMgd2l0aCAnX3Bvc3RzLydcclxuICAgIHRoaXMuY29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgdmFyIHR5cGVBID0gYS5nZXQoJ3R5cGUnKTtcclxuICAgICAgdmFyIHR5cGVCID0gYi5nZXQoJ3R5cGUnKTtcclxuXHJcbiAgICAgIHZhciBwYXRoQSA9IGEuZ2V0KCdwYXRoJyk7XHJcbiAgICAgIHZhciBwYXRoQiA9IGIuZ2V0KCdwYXRoJyk7XHJcblxyXG4gICAgICB2YXIgcmVnZXggPSAvXl9wb3N0c1xcLy4qJC9cclxuXHJcbiAgICAgIGlmICh0eXBlQSA9PT0gdHlwZUIgJiYgdHlwZUEgPT09ICdmaWxlJyAmJiByZWdleC50ZXN0KHBhdGhBKSAmJiByZWdleC50ZXN0KHBhdGhCKSkge1xyXG4gICAgICAgIC8vIFJldmVyc2UgYWxwaGFiZXRpY2FsXHJcbiAgICAgICAgcmV0dXJuIHBhdGhBIDwgcGF0aEIgPyAxIDogLTE7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZUEgPT09IHR5cGVCKSB7XHJcbiAgICAgICAgLy8gQWxwaGFiZXRpY2FsXHJcbiAgICAgICAgcmV0dXJuIHBhdGhBIDwgcGF0aEIgPyAtMSA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoKHR5cGVBKSB7XHJcbiAgICAgICAgICBjYXNlICd0cmVlJzpcclxuICAgICAgICAgIGNhc2UgJ2ZvbGRlcic6XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVCID09PSAnZm9sZGVyJyB8fCB0eXBlQiA9PT0gJ3RyZWUnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfLm1hcChyZXNwLnRyZWUsIChmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgIHJldHVybiAgXy5leHRlbmQoZmlsZSwge1xyXG4gICAgICAgIGJyYW5jaDogdGhpcy5icmFuY2gsXHJcbiAgICAgICAgY29sbGVjdGlvbjogdGhpcyxcclxuICAgICAgICByZXBvOiB0aGlzLnJlcG9cclxuICAgICAgfSlcclxuICAgIH0pLmJpbmQodGhpcykpO1xyXG4gIH0sXHJcblxyXG4gIHBhcnNlQ29uZmlnOiBmdW5jdGlvbihjb25maWcsIG9wdGlvbnMpIHtcclxuICAgIHZhciBjb250ZW50ID0gY29uZmlnLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgWUFNTFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uZmlnID0ganN5YW1sLnNhZmVMb2FkKGNvbnRlbnQpO1xyXG4gICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBwYXJzaW5nIFlBTUxcIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcucHJvc2UpIHtcclxuICAgICAgLy8gTG9hZCBfY29uZmlnLnltbCwgc2V0IHBhcnNlZCB2YWx1ZSBvbiBjb2xsZWN0aW9uXHJcbiAgICAgIC8vIEV4dGVuZCB0byBjYXB0dXJlIHNldHRpbmdzIGZyb20gb3V0c2lkZSBjb25maWcucHJvc2VcclxuICAgICAgLy8gd2hpbGUgYWxsb3dpbmcgb3ZlcnJpZGVcclxuICAgICAgdGhpcy5jb25maWcgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgYmFzZXVybDogY29uZmlnLmJhc2V1cmwsXHJcbiAgICAgICAgbGFuZ3VhZ2VzOiBjb25maWcubGFuZ3VhZ2VzXHJcbiAgICAgIH0sIGNvbmZpZy5wcm9zZSk7XHJcblxyXG4gICAgICBpZiAoY29uZmlnLnByb3NlLmlnbm9yZSkge1xyXG4gICAgICAgIHRoaXMucGFyc2VJZ25vcmUoY29uZmlnLnByb3NlLmlnbm9yZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb25maWcucHJvc2UubWV0YWRhdGEpIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjb25maWcucHJvc2UubWV0YWRhdGE7XHJcblxyXG4gICAgICAgIC8vIFNlcmlhbCBxdWV1ZSB0byBub3QgYnJlYWsgZ2xvYmFsIHNjb3BlIEpTT05QIGNhbGxiYWNrc1xyXG4gICAgICAgIHZhciBxID0gcXVldWUoMSk7XHJcblxyXG4gICAgICAgIF8uZWFjaChtZXRhZGF0YSwgZnVuY3Rpb24ocmF3LCBrZXkpIHtcclxuICAgICAgICAgIHEuZGVmZXIoZnVuY3Rpb24oY2IpIHtcclxuICAgICAgICAgICAgdmFyIHN1YnEgPSBxdWV1ZSgpO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHM7XHJcblxyXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdHMgPSByYXc7XHJcblxyXG4gICAgICAgICAgICAgIF8uZWFjaChkZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL15odHRwcz86XFwvXFwvLztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBKU09OIFVSTCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5maWVsZCAmJiB2YWx1ZS5maWVsZC5vcHRpb25zICYmXHJcbiAgICAgICAgICAgICAgICAgICAgXy5pc1N0cmluZyh2YWx1ZS5maWVsZC5vcHRpb25zKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4LnRlc3QodmFsdWUuZmllbGQub3B0aW9ucykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnEuZGVmZXIoZnVuY3Rpb24oY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJyxcclxuICAgICAgICAgICAgICAgICAgICAgIGpzb25wOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIGpzb25wQ2FsbGJhY2s6IHZhbHVlLmZpZWxkLm9wdGlvbnMuc3BsaXQoJz9jYWxsYmFjaz0nKVsxXSB8fCAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgIHVybDogdmFsdWUuZmllbGQub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpZWxkLm9wdGlvbnMgPSBfLmNvbXBhY3QoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcocmF3KSkge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0cyA9IGpzeWFtbC5zYWZlTG9hZChyYXcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cy5kYXRlID09PSBcIkNVUlJFTlRfREFURVRJTUVcIikge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IChuZXcgRGF0ZSgpKS5mb3JtYXQoJ1ktbS1kIEg6aScpO1xyXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0cy5kYXRlID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnJlcGxhY2UoXCJDVVJSRU5UX0RBVEVUSU1FXCIsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHBhcnNpbmcgZGVmYXVsdCB2YWx1ZXMuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN1YnEuYXdhaXRBbGwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgbWV0YWRhdGFba2V5XSA9IGRlZmF1bHRzO1xyXG4gICAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHEuYXdhaXRBbGwoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgLy8gU2F2ZSBwYXJzZWQgY29uZmlnIHRvIHRoZSBjb2xsZWN0aW9uIGFzIGl0J3MgdXNlZCBhY2Nyb3NzXHJcbiAgICAgICAgICAvLyBmaWxlcyBvZiB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBzaG91bGRuJ3QgYmUgcmUtcGFyc2VkIGVhY2ggdGltZVxyXG4gICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IG1ldGFkYXRhO1xyXG5cclxuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy5zdWNjZXNzKSkgb3B0aW9ucy5zdWNjZXNzLmFwcGx5KHRoaXMsIG9wdGlvbnMuYXJncyk7XHJcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLnN1Y2Nlc3MpKSBvcHRpb25zLnN1Y2Nlc3MuYXBwbHkodGhpcywgb3B0aW9ucy5hcmdzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLnN1Y2Nlc3MpKSBvcHRpb25zLnN1Y2Nlc3MuYXBwbHkodGhpcywgb3B0aW9ucy5hcmdzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwYXJzZUlnbm9yZTogZnVuY3Rpb24oaWdub3JlUGF0dGVybnMpIHtcclxuICAgIHZhciBpZ25vcmVGaWx0ZXIgPSBpZ25vcmUoKS5hZGRQYXR0ZXJuKGlnbm9yZVBhdHRlcm5zKS5jcmVhdGVGaWx0ZXIoKTtcclxuICAgIHRoaXMuZmlsdGVyZWRNb2RlbCA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgcmV0dXJuIGlnbm9yZUZpbHRlcihmaWxlLmlkKTtcclxuICAgIH0pKTtcclxuICB9LFxyXG5cclxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XHJcblxyXG4gICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcbiAgICB2YXIgYXJncyA9IG9wdGlvbnMuYXJncztcclxuXHJcbiAgICBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsIF8uZXh0ZW5kKG9wdGlvbnMsIHtcclxuICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5maW5kV2hlcmUoeyBwYXRoOiAnX3Byb3NlLnltbCcgfSkgfHxcclxuICAgICAgICAgIHRoaXMuZmluZFdoZXJlKHsgcGF0aDogJ19jb25maWcueW1sJyB9KTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgY29uZmlnLmZldGNoKHtcclxuICAgICAgICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHRoaXMucGFyc2VDb25maWcoY29uZmlnLCB7IHN1Y2Nlc3M6IHN1Y2Nlc3MsIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgICAgIH0pLmJpbmQodGhpcylcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHN1Y2Nlc3MpKSBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pLmJpbmQodGhpcylcclxuICAgIH0pKTtcclxuICB9LFxyXG5cclxuICByZXN0b3JlOiBmdW5jdGlvbihmaWxlLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcclxuXHJcbiAgICB2YXIgcGF0aCA9IGZpbGUuZmlsZW5hbWU7XHJcbiAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuXHJcbiAgICAkLmFqYXgoe1xyXG4gICAgICB0eXBlOiAnR0VUJyxcclxuICAgICAgdXJsOiBmaWxlLmNvbnRlbnRzX3VybCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMucmF3J1xyXG4gICAgICB9LFxyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24ocmVzKSB7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBuZXcgRmlsZSBtb2RlbCB3aXRoIGNvbnRlbnRcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgRmlsZSh7XHJcbiAgICAgICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICAgICAgY29sbGVjdGlvbjogdGhpcyxcclxuICAgICAgICAgIGNvbnRlbnQ6IHJlcyxcclxuICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICByZXBvOiB0aGlzLnJlcG9cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmV4dHJhY3RGaWxlbmFtZShwYXRoKVsxXTtcclxuICAgICAgICBtb2RlbC5zZXQoJ3BsYWNlaG9sZGVyJywgdCgnYWN0aW9ucy5jb21taXRzLmNyZWF0ZWQnLCB7IGZpbGVuYW1lOiBuYW1lIH0pKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIGNvbGxlY3Rpb24gb24gc2F2ZVxyXG4gICAgICAgIG1vZGVsLnNhdmUoe1xyXG4gICAgICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKG1vZGVsLCByZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGF0dHJpYnV0ZXMgYW5kIGFkZCB0byBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgIG1vZGVsLnNldChyZXMuY29udGVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKG1vZGVsKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oc3VjY2VzcykpIHN1Y2Nlc3MobW9kZWwsIHJlcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcclxuICAgICAgICB9KTtcclxuICAgICAgfSkuYmluZCh0aGlzKSxcclxuICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIHVwbG9hZDogZnVuY3Rpb24oZmlsZSwgY29udGVudCwgcGF0aCwgb3B0aW9ucykge1xyXG4gICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcblxyXG4gICAgdmFyIGV4dGVuc2lvbiA9IGZpbGUudHlwZS5zcGxpdCgnLycpLnBvcCgpO1xyXG4gICAgdmFyIHVpZDtcclxuXHJcbiAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgdWlkID0gZmlsZS5uYW1lO1xyXG5cclxuICAgICAgaWYgKHRoaXMuYXNzZXRzRGlyZWN0b3J5KSB7XHJcbiAgICAgICAgcGF0aCA9IHRoaXMuYXNzZXRzRGlyZWN0b3J5ICsgJy8nICsgdWlkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhdGggPSB0aGlzLm1vZGVsLnBhdGggPyB0aGlzLm1vZGVsLnBhdGggKyAnLycgKyB1aWQgOiB1aWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBwYXRoIG1hdGNoZXMgYW4gZXhpc3RpbmcgZmlsZSwgY29uZmlybSB0aGUgb3ZlcndyaXRlIGlzIGludGVudGlvbmFsXHJcbiAgICAvLyB0aGVuIHNldCBuZXcgY29udGVudCBhbmQgdXBkYXRlIHRoZSBleGlzdGluZyBmaWxlXHJcbiAgICB2YXIgbW9kZWwgPSB0aGlzLmZpbmRXaGVyZSh7IHBhdGg6IHBhdGggfSk7XHJcblxyXG4gICAgaWYgKG1vZGVsKSB7XHJcbiAgICAgIC8vIFRPRE86IGNvbmZpcm0gb3ZlcndyaXRlIHdpdGggVUkgcHJvbXB0XHJcbiAgICAgIG1vZGVsLnNldCgnY29udGVudCcsIGNvbnRlbnQpO1xyXG4gICAgICBtb2RlbC5zZXQoJ3BsYWNlaG9sZGVyJywgdCgnYWN0aW9ucy5jb21taXRzLnVwZGF0ZWQnLCB7IGZpbGVuYW1lOiBmaWxlLm5hbWUgfSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaW5pdGlhbGl6ZSBuZXcgRmlsZSBtb2RlbCB3aXRoIGNvbnRlbnRcclxuICAgICAgbW9kZWwgPSBuZXcgRmlsZSh7XHJcbiAgICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaCxcclxuICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLFxyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICByZXBvOiB0aGlzLnJlcG9cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBtb2RlbC5zZXQoJ3BsYWNlaG9sZGVyJywgdCgnYWN0aW9ucy5jb21taXRzLmNyZWF0ZWQnLCB7IGZpbGVuYW1lOiBmaWxlLm5hbWUgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCB0byBjb2xsZWN0aW9uIG9uIHNhdmVcclxuICAgIG1vZGVsLnNhdmUoe1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtb2RlbCBhdHRyaWJ1dGVzIGFuZCBhZGQgdG8gY29sbGVjdGlvblxyXG4gICAgICAgIG1vZGVsLnNldChyZXMuY29udGVudCk7XHJcbiAgICAgICAgdGhpcy5hZGQobW9kZWwpO1xyXG5cclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHN1Y2Nlc3MpKSBzdWNjZXNzKG1vZGVsLCByZXMsIG9wdGlvbnMpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpLFxyXG4gICAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgdXJsOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcG8udXJsKCkgKyAnL2dpdC90cmVlcy8nICsgdGhpcy5zaGEgKyAnP3JlY3Vyc2l2ZT0xJztcclxuICB9XHJcbn0pO1xyXG5cbn0pKCkiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaWdub3JlO1xuaWdub3JlLklnbm9yZSA9IElnbm9yZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIG5vZGVfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBub2RlX2ZzID0gcmVxdWlyZSgnZnMnKTtcblxuZnVuY3Rpb24gaWdub3JlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBJZ25vcmUob3B0aW9ucyk7XG59XG5cbnZhciBleGlzdHMgPSBub2RlX2ZzLmV4aXN0c1N5bmMgP1xuICAgIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIHJldHVybiBub2RlX2ZzLmV4aXN0c1N5bmMoZmlsZSk7XG4gIH0gOlxuXG4gIC8vIGlmIG5vZGUgPD0gMC42LCB0aGVyZSdzIG5vIGZzLmV4aXN0c1N5bmMgbWV0aG9kLlxuICBmdW5jdGlvbihmaWxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5vZGVfZnMuc3RhdFN5bmMoZmlsZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4vLyBTZWxlY3QgdGhlIGZpcnN0IGV4aXN0aW5nIGZpbGUgb2YgdGhlIGZpbGUgbGlzdFxuaWdub3JlLnNlbGVjdCA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gIHZhciBzZWxlY3RlZDtcblxuICBmaWxlcy5zb21lKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICBpZiAoZXhpc3RzKGZpbGUpKSB7XG4gICAgICBzZWxlY3RlZCA9IGZpbGU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWxlY3RlZDtcbn07XG5cblxuLy8gQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbi8vIC0gaWdub3JlOiB7QXJyYXl9XG4vLyAtIHR3b0dsb2JzdGFyczoge2Jvb2xlYW49ZmFsc2V9IGVuYWJsZSBwYXR0ZXJuIGAnKionYCAodHdvIGNvbnNlY3V0aXZlIGFzdGVyaXNrcyksIGRlZmF1bHQgdG8gYGZhbHNlYC5cbi8vICAgICAgSWYgZmFsc2UsIGlnbm9yZSBwYXR0ZXJucyB3aXRoIHR3byBnbG9ic3RhcnMgd2lsbCBiZSBvbWl0dGVkXG4vLyAtIG1hdGNoQ2FzZToge2Jvb2xlYW49fSBjYXNlIHNlbnNpdGl2ZS5cbi8vICAgICAgQnkgZGVmYXVsdCwgZ2l0IGlzIGNhc2UtaW5zZW5zaXRpdmVcbmZ1bmN0aW9uIElnbm9yZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX3BhdHRlcm5zID0gW107XG4gIHRoaXMuX3J1bGVzID0gW107XG4gIHRoaXMuX2lnbm9yZUZpbGVzID0gW107XG5cbiAgb3B0aW9ucy5pZ25vcmUgPSBvcHRpb25zLmlnbm9yZSB8fCBbXG4gICAgLy8gU29tZSBmaWxlcyBvciBkaXJlY3RvcmllcyB3aGljaCB3ZSBzaG91bGQgaWdub3JlIGZvciBtb3N0IGNhc2VzLlxuICAgICcuZ2l0JyxcbiAgICAnLnN2bicsXG4gICAgJy5EU19TdG9yZSdcbiAgXTtcblxuICB0aGlzLmFkZFBhdHRlcm4ob3B0aW9ucy5pZ25vcmUpO1xufVxuXG4vLyBFdmVudHM6XG4vLyAnd2Fybic6ICwgXG4vLyAgICAgIHdpbGwgd2FybiB3aGVuIGVuY291bnRlciAnYCoqYCcgKHR3byBjb25zZWN1dGl2ZSBhc3Rlcmlza3MpXG4vLyAgICAgIHdoaWNoIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYWxsIHBsYXRmb3JtcyAobm90IHdvcmtzIG9uIE1hYyBPUyBmb3IgZXhhbXBsZSlcbm5vZGVfdXRpbC5pbmhlcml0cyhJZ25vcmUsIEVFKTtcblxuZnVuY3Rpb24gbWFrZUFycmF5KHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgP1xuICAgIHN1YmplY3QgOlxuICAgIHN1YmplY3QgPT09IHVuZGVmaW5lZCB8fCBzdWJqZWN0ID09PSBudWxsID9cbiAgICBbXSA6XG4gICAgW3N1YmplY3RdO1xufVxuXG5cbi8vIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBwYXR0ZXJuXG5JZ25vcmUucHJvdG90eXBlLmFkZFBhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIG1ha2VBcnJheShwYXR0ZXJuKS5mb3JFYWNoKHRoaXMuX2FkZFBhdHRlcm4sIHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuSWdub3JlLnByb3RvdHlwZS5fYWRkUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgaWYgKHRoaXMuX3NpbXBsZVRlc3QocGF0dGVybikpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMuX2NyZWF0ZVJ1bGUocGF0dGVybik7XG4gICAgdGhpcy5fcnVsZXMucHVzaChydWxlKTtcbiAgfVxufTtcblxuXG5JZ25vcmUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gIHJldHVybiBwYXRocy5maWx0ZXIodGhpcy5fZmlsdGVyLCB0aGlzKTtcbn07XG5cblxuSWdub3JlLnByb3RvdHlwZS5fc2ltcGxlVGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHBhc3MgPVxuICAvLyBXaGl0ZXNwYWNlIGRpcnMgYXJlIGFsbG93ZWQsIHNvIG9ubHkgZmlsdGVyIGJsYW5rIHBhdHRlcm4uXG4gIHBhdHRlcm4gJiZcbiAgLy8gQW5kIG5vdCBzdGFydCB3aXRoIGEgJyMnXG4gIHBhdHRlcm4uaW5kZXhPZignIycpICE9PSAwICYmXG5cbiAgIX50aGlzLl9wYXR0ZXJucy5pbmRleE9mKHBhdHRlcm4pO1xuXG4gIHRoaXMuX3BhdHRlcm5zLnB1c2gocGF0dGVybik7XG5cbiAgaWYgKH5wYXR0ZXJuLmluZGV4T2YoJyoqJykpIHtcbiAgICB0aGlzLmVtaXQoJ3dhcm4nLCB7XG4gICAgICBjb2RlOiAnV0dMT0JTVEFSUycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG9yaWdpbjogcGF0dGVyblxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6ICdgKipgIGZvdW5kLCB3aGljaCBpcyBub3QgY29tcGF0aWJsZSBjcm9zcyBhbGwgcGxhdGZvcm1zLidcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnR3b0dsb2JzdGFycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXNzO1xufTtcblxudmFyIFJFR0VYX0xFQURJTkdfRVhDTEFNQVRJT04gPSAvXlxcXFxcXCEvO1xudmFyIFJFR0VYX0xFQURJTkdfSEFTSCA9IC9eXFxcXCMvO1xuXG5JZ25vcmUucHJvdG90eXBlLl9jcmVhdGVSdWxlID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcnVsZV9vYmplY3QgPSB7XG4gICAgb3JpZ2luOiBwYXR0ZXJuXG4gIH07XG5cbiAgdmFyIG1hdGNoX3N0YXJ0O1xuXG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgIHJ1bGVfb2JqZWN0Lm5lZ2F0aXZlID0gdHJ1ZTtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMSk7XG4gIH1cblxuICBwYXR0ZXJuID0gcGF0dGVyblxuICAgIC5yZXBsYWNlKFJFR0VYX0xFQURJTkdfRVhDTEFNQVRJT04sICchJylcbiAgICAucmVwbGFjZShSRUdFWF9MRUFESU5HX0hBU0gsICcjJyk7XG5cbiAgcnVsZV9vYmplY3QucGF0dGVybiA9IHBhdHRlcm47XG5cbiAgcnVsZV9vYmplY3QucmVnZXggPSB0aGlzLm1ha2VSZWdleChwYXR0ZXJuKTtcblxuICByZXR1cm4gcnVsZV9vYmplY3Q7XG59O1xuXG4vLyA+IElmIHRoZSBwYXR0ZXJuIGVuZHMgd2l0aCBhIHNsYXNoLCBpdCBpcyByZW1vdmVkIGZvciB0aGUgcHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIGRlc2NyaXB0aW9uLCBidXQgaXQgd291bGQgb25seSBmaW5kIGEgbWF0Y2ggd2l0aCBhIGRpcmVjdG9yeS4gSW4gb3RoZXIgd29yZHMsIGZvby8gd2lsbCBtYXRjaCBhIGRpcmVjdG9yeSBmb28gYW5kIHBhdGhzIHVuZGVybmVhdGggaXQsIGJ1dCB3aWxsIG5vdCBtYXRjaCBhIHJlZ3VsYXIgZmlsZSBvciBhIHN5bWJvbGljIGxpbmsgZm9vICh0aGlzIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgd2F5IGhvdyBwYXRoc3BlYyB3b3JrcyBpbiBnZW5lcmFsIGluIEdpdCkuXG4vLyAnYGZvby9gJyB3aWxsIG5vdCBtYXRjaCByZWd1bGFyIGZpbGUgJ2Bmb29gJyBvciBzeW1ib2xpYyBsaW5rICdgZm9vYCdcbi8vIC0+IGlnbm9yZS1ydWxlcyB3aWxsIG5vdCBkZWFsIHdpdGggaXQsIGJlY2F1c2UgaXQgY29zdHMgZXh0cmEgYGZzLnN0YXRgIGNhbGxcbi8vICAgICAgeW91IGNvdWxkIHVzZSBvcHRpb24gYG1hcms6IHRydWVgIHdpdGggYGdsb2JgXG5cbi8vICdgZm9vL2AnIHNob3VsZCBub3QgY29udGludWUgd2l0aCB0aGUgJ2AuLmAnXG52YXIgUkVQTEFDRVJTID0gW1xuXG4gIC8vIEVzY2FwZSBtZXRhY2hhcmFjdGVycyBcbiAgLy8gd2hpY2ggaXMgd3JpdHRlbiBkb3duIGJ5IHVzZXJzIGJ1dCBtZWFucyBzcGVjaWFsIGZvciByZWd1bGFyIGV4cHJlc3Npb25zLlxuXG4gIC8vID4gVGhlcmUgYXJlIDEyIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmdzOiBcbiAgLy8gPiAtIHRoZSBiYWNrc2xhc2ggXFwsIFxuICAvLyA+IC0gdGhlIGNhcmV0IF4sIFxuICAvLyA+IC0gdGhlIGRvbGxhciBzaWduICQsIFxuICAvLyA+IC0gdGhlIHBlcmlvZCBvciBkb3QgLiwgXG4gIC8vID4gLSB0aGUgdmVydGljYWwgYmFyIG9yIHBpcGUgc3ltYm9sIHwsIFxuICAvLyA+IC0gdGhlIHF1ZXN0aW9uIG1hcmsgPywgXG4gIC8vID4gLSB0aGUgYXN0ZXJpc2sgb3Igc3RhciAqLCBcbiAgLy8gPiAtIHRoZSBwbHVzIHNpZ24gKywgXG4gIC8vID4gLSB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyAoLCBcbiAgLy8gPiAtIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzICksIFxuICAvLyA+IC0gYW5kIHRoZSBvcGVuaW5nIHNxdWFyZSBicmFja2V0IFssIFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgY3VybHkgYnJhY2UgeywgXG4gIC8vID4gVGhlc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBvZnRlbiBjYWxsZWQgXCJtZXRhY2hhcmFjdGVyc1wiLlxuICBbXG4gICAgL1tcXFxcXFxeJC58PyorKClcXFt7XS9nLFxuICAgIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gICAgfVxuICBdLFxuXG4gIC8vIGxlYWRpbmcgc2xhc2hcbiAgW1xuXG4gICAgLy8gPiBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZS4gRm9yIGV4YW1wbGUsIFwiLyouY1wiIG1hdGNoZXMgXCJjYXQtZmlsZS5jXCIgYnV0IG5vdCBcIm1vemlsbGEtc2hhMS9zaGExLmNcIi5cbiAgICAvLyBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZSBcbiAgICAvXlxcLy8sXG4gICAgJ14nXG4gIF0sXG5cbiAgW1xuICAgIC9cXC8vZyxcbiAgICAnXFxcXC8nXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gQSBsZWFkaW5nIFwiKipcIiBmb2xsb3dlZCBieSBhIHNsYXNoIG1lYW5zIG1hdGNoIGluIGFsbCBkaXJlY3Rvcmllcy4gRm9yIGV4YW1wbGUsIFwiKiovZm9vXCIgbWF0Y2hlcyBmaWxlIG9yIGRpcmVjdG9yeSBcImZvb1wiIGFueXdoZXJlLCB0aGUgc2FtZSBhcyBwYXR0ZXJuIFwiZm9vXCIuIFwiKiovZm9vL2JhclwiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJiYXJcIiBhbnl3aGVyZSB0aGF0IGlzIGRpcmVjdGx5IHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuICAgIC8vIE5vdGljZSB0aGF0IHRoZSAnKidzIGhhdmUgYmVlbiByZXBsYWNlZCBhcyAnXFxcXConXG4gICAgL1xcXFxcXCpcXFxcXFwqXFxcXFxcLy8sXG5cbiAgICAvLyAnKiovZm9vJyA8LT4gJ2ZvbydcbiAgICAvLyBqdXN0IHJlbW92ZSBpdFxuICAgICcnXG4gIF0sXG5cbiAgLy8gJ2YnXG4gIC8vIG1hdGNoZXNcbiAgLy8gLSAvZihlbmQpXG4gIC8vIC0gL2YvXG4gIC8vIC0gKHN0YXJ0KWYoZW5kKVxuICAvLyAtIChzdGFydClmL1xuICAvLyBkb2Vzbid0IG1hdGNoXG4gIC8vIC0gb29mXG4gIC8vIC0gZm9vXG4gIC8vIHBzZXVkbzpcbiAgLy8gLT4gKF58LylmKC98JClcblxuICAvLyBlbmRpbmdcbiAgW1xuICAgIC8vICdqcycgd2lsbCBub3QgbWF0Y2ggJ2pzLidcbiAgICAvKD86W14qXFwvXSkkLyxcbiAgICBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgLy8gJ2pzKicgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4gICAgICAvLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAgIC8vICdqcycgd2lsbCBtYXRjaCAnYS5qcycgYW5kICdhLmpzLydcbiAgICAgIHJldHVybiBtYXRjaCArICcoPz0kfFxcXFwvKSc7XG4gICAgfVxuICBdLFxuXG4gIC8vIHN0YXJ0aW5nXG4gIFtcbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGxlYWRpbmcgJy8nICh3aGljaCBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgc2Vjb25kIHJlcGxhY2VyKVxuICAgIC8vIElmIHN0YXJ0cyB3aXRoICcqKicsIGFkZGluZyBhICdeJyB0byB0aGUgcmVndWxhciBleHByZXNzaW9uIGFsc28gd29ya3NcbiAgICAvXig/PVteXFxeXSkvLFxuICAgICcoPzpefFxcXFwvKSdcbiAgXSxcblxuICAvLyB0d28gZ2xvYnN0YXJzXG4gIFtcbiAgICAvLyA+IEEgc2xhc2ggZm9sbG93ZWQgYnkgdHdvIGNvbnNlY3V0aXZlIGFzdGVyaXNrcyB0aGVuIGEgc2xhc2ggbWF0Y2hlcyB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuIEZvciBleGFtcGxlLCBcImEvKiovYlwiIG1hdGNoZXMgXCJhL2JcIiwgXCJhL3gvYlwiLCBcImEveC95L2JcIiBhbmQgc28gb24uXG4gICAgLy8gJy8qKi8nXG4gICAgL1xcL1xcXFxcXCpcXFxcXFwqXFwvL2csXG5cbiAgICAvLyBaZXJvLCBvbmUgb3Igc2V2ZXJhbCBkaXJlY3Rvcmllc1xuICAgIC8vIHNob3VsZCBub3QgdXNlICcqJywgb3IgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgbmV4dCByZXBsYWNlclxuICAgICcoPzpcXFxcL1teXFxcXC9dKykqXFxcXC8nXG4gIF0sXG5cbiAgLy8gaW50ZXJtZWRpYXRlIHdpbGRjYXJkc1xuICBbXG4gICAgLy8gTmV2ZXIgcmVwbGFjZSBlc2NhcGVkICcqJ1xuICAgIC8vIGlnbm9yZSBydWxlICdcXConIHdpbGwgbWF0Y2ggdGhlIHBhdGggJyonXG5cbiAgICAvLyAnYWJjLiovJyAtPiBnb1xuICAgIC8vICdhYmMuKicgIC0+IHNraXBcbiAgICAvKF58W15cXFxcXSspXFxcXFxcKig/PS4rKS9nLFxuICAgIGZ1bmN0aW9uKG1hdGNoLCBwMSkge1xuICAgICAgLy8gJyouanMnIG1hdGNoZXMgJy5qcydcbiAgICAgIC8vICcqLmpzJyBkb2Vzbid0IG1hdGNoICdhYmMnXG4gICAgICByZXR1cm4gcDEgKyAnW15cXFxcL10qJztcbiAgICB9XG4gIF0sXG5cbiAgLy8gZW5kaW5nIHdpbGRjYXJkXG4gIFtcbiAgICAvXFxcXFxcKiQvLFxuICAgIC8vIHNpbXBseSByZW1vdmUgaXRcbiAgICAnJ1xuICBdLFxuXG4gIFtcbiAgICAvXFxcXFxcXFxcXFxcL2csXG4gICAgJ1xcXFwnXG4gIF1cbl07XG5cblxuLy8gQHBhcmFtIHtwYXR0ZXJufVxuSWdub3JlLnByb3RvdHlwZS5tYWtlUmVnZXggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzb3VyY2UgPSBSRVBMQUNFUlMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnJlbnQpIHtcbiAgICByZXR1cm4gcHJldi5yZXBsYWNlKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0pO1xuXG4gIH0sIHBhdHRlcm4pO1xuXG4gIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgdGhpcy5vcHRpb25zLm1hdGNoQ2FzZSA/ICcnIDogJ2knKTtcbn07XG5cblxuSWdub3JlLnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcnVsZXMgPSB0aGlzLl9ydWxlcztcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xuICB2YXIgbWF0Y2hlZDtcbiAgdmFyIHJ1bGU7XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJ1bGUgPSBydWxlc1tpXTtcblxuICAgIC8vIGlmIG1hdGNoZWQgPSB0cnVlLCB0aGVuIHdlIG9ubHkgdGVzdCBuZWdhdGl2ZSBydWxlc1xuICAgIC8vIGlmIG1hdGNoZWQgPSBmYWxzZSwgdGhlbiB3ZSB0ZXN0IG5vbi1uZWdhdGl2ZSBydWxlc1xuICAgIGlmICghKG1hdGNoZWQgXiBydWxlLm5lZ2F0aXZlKSkge1xuICAgICAgbWF0Y2hlZCA9IHJ1bGUubmVnYXRpdmUgXiBydWxlLnJlZ2V4LnRlc3QocGF0aCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICFtYXRjaGVkO1xufTtcblxuXG5JZ25vcmUucHJvdG90eXBlLmNyZWF0ZUZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gc2VsZi5fZmlsdGVyKHBhdGgpO1xuICB9O1xufTtcblxuXG4vLyBAcGFyYW0ge0FycmF5LjxwYXRoPnxwYXRofSBhXG5JZ25vcmUucHJvdG90eXBlLmFkZElnbm9yZUZpbGUgPSBmdW5jdGlvbihmaWxlcykge1xuICBtYWtlQXJyYXkoZmlsZXMpLmZvckVhY2godGhpcy5fYWRkSWdub3JlRmlsZSwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5JZ25vcmUucHJvdG90eXBlLl9hZGRJZ25vcmVGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xuICBpZiAodGhpcy5fY2hlY2tSdWxlRmlsZShmaWxlKSkge1xuICAgIHRoaXMuX2lnbm9yZUZpbGVzLnB1c2goZmlsZSk7XG5cbiAgICB2YXIgY29udGVudDtcblxuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gbm9kZV9mcy5yZWFkRmlsZVN5bmMoZmlsZSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkZFBhdHRlcm4oY29udGVudC50b1N0cmluZygpLnNwbGl0KC9cXHI/XFxuLykpO1xuICAgIH1cbiAgfVxufTtcblxuXG5JZ25vcmUucHJvdG90eXBlLl9jaGVja1J1bGVGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xuICByZXR1cm4gZmlsZSAhPT0gJy4nICYmXG4gICAgZmlsZSAhPT0gJy4uJyAmJiAhfnRoaXMuX2lnbm9yZUZpbGVzLmluZGV4T2YoZmlsZSk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5LWJyb3dzZXJpZnknKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICB0YWdOYW1lOiAnb3B0aW9uJyxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG87XHJcbiAgICB0aGlzLmJyYW5jaCA9IG9wdGlvbnMuYnJhbmNoO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiRlbC52YWwoJyMnICsgWyB0aGlzLnJlcG8uZ2V0KCdvd25lcicpLmxvZ2luLCB0aGlzLnJlcG8uZ2V0KCduYW1lJyksICd0cmVlJywgdGhpcy5tb2RlbC5nZXQoJ25hbWUnKSBdLmpvaW4oJy8nKSk7XHJcbiAgICB0aGlzLmVsLnNlbGVjdGVkID0gdGhpcy5icmFuY2ggJiYgdGhpcy5icmFuY2ggPT09IHRoaXMubW9kZWwuZ2V0KCduYW1lJyk7XHJcblxyXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLm1vZGVsLmdldCgnbmFtZScpKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcclxuICB0aGlzLm5hbWUgICAgID0gbmFtZTtcclxuICB0aGlzLmJ1ZmZlciAgID0gYnVmZmVyO1xyXG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICB0aGlzLmxpbmUgICAgID0gbGluZTtcclxuICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xyXG59XHJcblxyXG5cclxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcclxuICB2YXIgaGVhZCwgc3RhcnQsIHRhaWwsIGVuZCwgc25pcHBldDtcclxuXHJcbiAgaWYgKCF0aGlzLmJ1ZmZlcikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcclxuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNzU7XHJcblxyXG4gIGhlYWQgPSAnJztcclxuICBzdGFydCA9IHRoaXMucG9zaXRpb247XHJcblxyXG4gIHdoaWxlIChzdGFydCA+IDAgJiYgLTEgPT09ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpKSB7XHJcbiAgICBzdGFydCAtPSAxO1xyXG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcclxuICAgICAgaGVhZCA9ICcgLi4uICc7XHJcbiAgICAgIHN0YXJ0ICs9IDU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGFpbCA9ICcnO1xyXG4gIGVuZCA9IHRoaXMucG9zaXRpb247XHJcblxyXG4gIHdoaWxlIChlbmQgPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgLTEgPT09ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpKSB7XHJcbiAgICBlbmQgKz0gMTtcclxuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xyXG4gICAgICB0YWlsID0gJyAuLi4gJztcclxuICAgICAgZW5kIC09IDU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc25pcHBldCA9IHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cclxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXHJcbiAgICAgICAgIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQgKyB0aGlzLnBvc2l0aW9uIC0gc3RhcnQgKyBoZWFkLmxlbmd0aCkgKyAnXic7XHJcbn07XHJcblxyXG5cclxuTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XHJcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XHJcblxyXG4gIGlmICh0aGlzLm5hbWUpIHtcclxuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcclxuICB9XHJcblxyXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xyXG5cclxuICBpZiAoIWNvbXBhY3QpIHtcclxuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcclxuXHJcbiAgICBpZiAoc25pcHBldCkge1xyXG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHdoZXJlO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFyaztcclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2lmICghcHJvY2Vzcy5FdmVudEVtaXR0ZXIpIHByb2Nlc3MuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHByb2Nlc3MuRXZlbnRFbWl0dGVyO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gQXJyYXkuaXNBcnJheVxuICAgIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgfVxuO1xuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbi8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4vL1xuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcbn07XG5cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gZmFsc2U7XG4gIHZhciBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2Ncbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCgpIGlzIGFsc28gZGVmaW5lZCB0aGVyZS5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGlmICh0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24odHlwZSwgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICB2YXIgaSA9IGluZGV4T2YobGlzdCwgbGlzdGVuZXIpO1xuICAgIGlmIChpIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDApXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAodHlwZSAmJiB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJ307XG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nfTtcblxuXG5leHBvcnRzLnByaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnB1dHMgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmluc3BlY3QgPSBmdW5jdGlvbihvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIHNlZW4gPSBbXTtcblxuICB2YXIgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gICAgdmFyIHN0eWxlcyA9XG4gICAgICAgIHsgJ2JvbGQnIDogWzEsIDIyXSxcbiAgICAgICAgICAnaXRhbGljJyA6IFszLCAyM10sXG4gICAgICAgICAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAgICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICAgJ3doaXRlJyA6IFszNywgMzldLFxuICAgICAgICAgICdncmV5JyA6IFs5MCwgMzldLFxuICAgICAgICAgICdibGFjaycgOiBbMzAsIDM5XSxcbiAgICAgICAgICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgICAgICAgICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgICAgICAgICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICAgICAgICAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICAgICAgICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAgICAgICAneWVsbG93JyA6IFszMywgMzldIH07XG5cbiAgICB2YXIgc3R5bGUgPVxuICAgICAgICB7ICdzcGVjaWFsJzogJ2N5YW4nLFxuICAgICAgICAgICdudW1iZXInOiAnYmx1ZScsXG4gICAgICAgICAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgICAgICAgICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAgICAgICAgICdudWxsJzogJ2JvbGQnLFxuICAgICAgICAgICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAgICAgICAgICdkYXRlJzogJ21hZ2VudGEnLFxuICAgICAgICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgICAgICAgJ3JlZ2V4cCc6ICdyZWQnIH1bc3R5bGVUeXBlXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICAgJ1xcMDMzWycgKyBzdHlsZXNbc3R5bGVdWzFdICsgJ20nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEgY29sb3JzKSB7XG4gICAgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7IHJldHVybiBzdHI7IH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlICE9PSBleHBvcnRzICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciB2aXNpYmxlX2tleXMgPSBPYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSBzaG93SGlkZGVuID8gT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXModmFsdWUpIDogdmlzaWJsZV9rZXlzO1xuXG4gICAgLy8gRnVuY3Rpb25zIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGF0ZXMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZFxuICAgIGlmIChpc0RhdGUodmFsdWUpICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSh2YWx1ZS50b1VUQ1N0cmluZygpLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCB0eXBlLCBicmFjZXM7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdBcnJheSc7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ09iamVjdCc7XG4gICAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gKGlzUmVnRXhwKHZhbHVlKSkgPyAnICcgKyB2YWx1ZSA6ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIHZhbHVlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICB2YXIgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbmFtZSwgc3RyO1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVfa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gICAgfSk7XG5cbiAgICBzZWVuLnBvcCgpO1xuXG4gICAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgIG51bUxpbmVzRXN0Kys7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGxlbmd0aCA+IDUwKSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBicmFjZXNbMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAoYXIgJiYgYXIgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgaXNBcnJheShhci5fX3Byb3RvX18pKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gcmUgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAodHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmUpID09PSAnW29iamVjdCBSZWdFeHBdJyk7XG59XG5cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBkICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvcGVydGllcyA9IERhdGUucHJvdG90eXBlICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKERhdGUucHJvdG90eXBlKTtcbiAgdmFyIHByb3RvID0gZC5fX3Byb3RvX18gJiYgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMoZC5fX3Byb3RvX18pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvdG8pID09PSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge307XG5cbmV4cG9ydHMucHVtcCA9IG51bGw7XG5cbnZhciBPYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgT2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIC8vIGZyb20gZXM1LXNoaW1cbiAgICB2YXIgb2JqZWN0O1xuICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0ID0geyAnX19wcm90b19fJyA6IG51bGwgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAndHlwZW9mIHByb3RvdHlwZVsnICsgKHR5cGVvZiBwcm90b3R5cGUpICsgJ10gIT0gXFwnb2JqZWN0XFwnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3RfY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goZXhwb3J0cy5pbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzogcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKXtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgZXhwb3J0cy5pbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcbiIsIihmdW5jdGlvbigpey8vIFVUSUxJVFlcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbn07XG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgIHJldHVybiBbdGhpcy5uYW1lICsgJzonLCB0aGlzLm1lc3NhZ2VdLmpvaW4oJyAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5uYW1lICsgJzonLFxuICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkodGhpcy5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSxcbiAgICAgIHRoaXMub3BlcmF0b3IsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmV4cGVjdGVkLCByZXBsYWNlciksIDEyOClcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsIGd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoISEhdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGFjdHVhbCkgJiYgQnVmZmVyLmlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9IGV4cGVjdGVkLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3R1YWxbaV0gIT09IGV4cGVjdGVkW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgICAga2V5LCBpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYWN0dWFsID0gZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKCFzaG91bGRUaHJvdyAmJiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbn0pKCkiLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbnZhciBZQU1MX05VTExfTUFQID0ge1xyXG4gICd+JyAgICA6IHRydWUsXHJcbiAgJ251bGwnIDogdHJ1ZSxcclxuICAnTnVsbCcgOiB0cnVlLFxyXG4gICdOVUxMJyA6IHRydWVcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwob2JqZWN0IC8qLCBleHBsaWNpdCovKSB7XHJcbiAgcmV0dXJuIFlBTUxfTlVMTF9NQVBbb2JqZWN0XSA/IG51bGwgOiBOSUw7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ3N0cmluZycsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZVlhbWxOdWxsXHJcbiAgfSxcclxuICBkdW1wZXI6IHtcclxuICAgIGtpbmQ6ICdudWxsJyxcclxuICAgIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZScsXHJcbiAgICByZXByZXNlbnRlcjoge1xyXG4gICAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcclxuICAgICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXHJcbiAgICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxyXG4gICAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfSxcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbnZhciBZQU1MX0lNUExJQ0lUX0JPT0xFQU5fTUFQID0ge1xyXG4gICd0cnVlJyAgOiB0cnVlLFxyXG4gICdUcnVlJyAgOiB0cnVlLFxyXG4gICdUUlVFJyAgOiB0cnVlLFxyXG4gICdmYWxzZScgOiBmYWxzZSxcclxuICAnRmFsc2UnIDogZmFsc2UsXHJcbiAgJ0ZBTFNFJyA6IGZhbHNlXHJcbn07XHJcblxyXG52YXIgWUFNTF9FWFBMSUNJVF9CT09MRUFOX01BUCA9IHtcclxuICAndHJ1ZScgIDogdHJ1ZSxcclxuICAnVHJ1ZScgIDogdHJ1ZSxcclxuICAnVFJVRScgIDogdHJ1ZSxcclxuICAnZmFsc2UnIDogZmFsc2UsXHJcbiAgJ0ZhbHNlJyA6IGZhbHNlLFxyXG4gICdGQUxTRScgOiBmYWxzZSxcclxuICAneScgICAgIDogdHJ1ZSxcclxuICAnWScgICAgIDogdHJ1ZSxcclxuICAneWVzJyAgIDogdHJ1ZSxcclxuICAnWWVzJyAgIDogdHJ1ZSxcclxuICAnWUVTJyAgIDogdHJ1ZSxcclxuICAnbicgICAgIDogZmFsc2UsXHJcbiAgJ04nICAgICA6IGZhbHNlLFxyXG4gICdubycgICAgOiBmYWxzZSxcclxuICAnTm8nICAgIDogZmFsc2UsXHJcbiAgJ05PJyAgICA6IGZhbHNlLFxyXG4gICdvbicgICAgOiB0cnVlLFxyXG4gICdPbicgICAgOiB0cnVlLFxyXG4gICdPTicgICAgOiB0cnVlLFxyXG4gICdvZmYnICAgOiBmYWxzZSxcclxuICAnT2ZmJyAgIDogZmFsc2UsXHJcbiAgJ09GRicgICA6IGZhbHNlXHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKG9iamVjdCwgZXhwbGljaXQpIHtcclxuICBpZiAoZXhwbGljaXQpIHtcclxuICAgIGlmIChZQU1MX0VYUExJQ0lUX0JPT0xFQU5fTUFQLmhhc093blByb3BlcnR5KG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIFlBTUxfRVhQTElDSVRfQk9PTEVBTl9NQVBbb2JqZWN0XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBOSUw7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChZQU1MX0lNUExJQ0lUX0JPT0xFQU5fTUFQLmhhc093blByb3BlcnR5KG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIFlBTUxfSU1QTElDSVRfQk9PTEVBTl9NQVBbb2JqZWN0XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBOSUw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcclxuICBsb2FkZXI6IHtcclxuICAgIGtpbmQ6ICdzdHJpbmcnLFxyXG4gICAgcmVzb2x2ZXI6IHJlc29sdmVZYW1sQm9vbGVhblxyXG4gIH0sXHJcbiAgZHVtcGVyOiB7XHJcbiAgICBraW5kOiAnYm9vbGVhbicsXHJcbiAgICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnLFxyXG4gICAgcmVwcmVzZW50ZXI6IHtcclxuICAgICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxyXG4gICAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXHJcbiAgICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgTklMICA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLk5JTDtcclxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XHJcblxyXG5cclxudmFyIFlBTUxfSU5URUdFUl9QQVRURVJOID0gbmV3IFJlZ0V4cChcclxuICAnXig/OlstK10/MGJbMC0xX10rJyArXHJcbiAgJ3xbLStdPzBbMC03X10rJyArXHJcbiAgJ3xbLStdPyg/OjB8WzEtOV1bMC05X10qKScgK1xyXG4gICd8Wy0rXT8weFswLTlhLWZBLUZfXSsnICtcclxuICAnfFstK10/WzEtOV1bMC05X10qKD86OlswLTVdP1swLTldKSspJCcpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihvYmplY3QgLyosIGV4cGxpY2l0Ki8pIHtcclxuICB2YXIgdmFsdWUsIHNpZ24sIGJhc2UsIGRpZ2l0cztcclxuXHJcbiAgaWYgKCFZQU1MX0lOVEVHRVJfUEFUVEVSTi50ZXN0KG9iamVjdCkpIHtcclxuICAgIHJldHVybiBOSUw7XHJcbiAgfVxyXG5cclxuICB2YWx1ZSAgPSBvYmplY3QucmVwbGFjZSgvXy9nLCAnJyk7XHJcbiAgc2lnbiAgID0gJy0nID09PSB2YWx1ZVswXSA/IC0xIDogMTtcclxuICBkaWdpdHMgPSBbXTtcclxuXHJcbiAgaWYgKDAgPD0gJystJy5pbmRleE9mKHZhbHVlWzBdKSkge1xyXG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIGlmICgnMCcgPT09IHZhbHVlKSB7XHJcbiAgICByZXR1cm4gMDtcclxuXHJcbiAgfSBlbHNlIGlmICgvXjBiLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XHJcblxyXG4gIH0gZWxzZSBpZiAoL14weC8udGVzdCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcclxuXHJcbiAgfSBlbHNlIGlmICgnMCcgPT09IHZhbHVlWzBdKSB7XHJcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcclxuXHJcbiAgfSBlbHNlIGlmICgwIDw9IHZhbHVlLmluZGV4T2YoJzonKSkge1xyXG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlSW50KHYsIDEwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YWx1ZSA9IDA7XHJcbiAgICBiYXNlID0gMTtcclxuXHJcbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xyXG4gICAgICBiYXNlICo9IDYwO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnc3RyaW5nJyxcclxuICAgIHJlc29sdmVyOiByZXNvbHZlWWFtbEludGVnZXJcclxuICB9LFxyXG4gIGR1bXBlcjoge1xyXG4gICAga2luZDogJ2ludGVnZXInLFxyXG4gICAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXHJcbiAgICByZXByZXNlbnRlcjoge1xyXG4gICAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzBiJyArIG9iamVjdC50b1N0cmluZygyKTsgfSxcclxuICAgICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwJyAgKyBvYmplY3QudG9TdHJpbmcoOCk7IH0sXHJcbiAgICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcclxuICAgICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcweCcgKyBvYmplY3QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cclxuICAgIH0sXHJcbiAgICBzdHlsZUFsaWFzZXM6IHtcclxuICAgICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXHJcbiAgICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxyXG4gICAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcclxuICAgICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxyXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xyXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK11bMC05XSspPycgK1xyXG4gICd8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgK1xyXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xyXG4gICd8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQob2JqZWN0IC8qLCBleHBsaWNpdCovKSB7XHJcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XHJcblxyXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3Qob2JqZWN0KSkge1xyXG4gICAgcmV0dXJuIE5JTDtcclxuICB9XHJcblxyXG4gIHZhbHVlICA9IG9iamVjdC5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gIHNpZ24gICA9ICctJyA9PT0gdmFsdWVbMF0gPyAtMSA6IDE7XHJcbiAgZGlnaXRzID0gW107XHJcblxyXG4gIGlmICgwIDw9ICcrLScuaW5kZXhPZih2YWx1ZVswXSkpIHtcclxuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XHJcbiAgfVxyXG5cclxuICBpZiAoJy5pbmYnID09PSB2YWx1ZSkge1xyXG4gICAgcmV0dXJuICgxID09PSBzaWduKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHJcbiAgfSBlbHNlIGlmICgnLm5hbicgPT09IHZhbHVlKSB7XHJcbiAgICByZXR1cm4gTmFOO1xyXG5cclxuICB9IGVsc2UgaWYgKDAgPD0gdmFsdWUuaW5kZXhPZignOicpKSB7XHJcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VGbG9hdCh2LCAxMCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFsdWUgPSAwLjA7XHJcbiAgICBiYXNlID0gMTtcclxuXHJcbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcclxuICAgICAgYmFzZSAqPSA2MDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzaWduICogdmFsdWU7XHJcblxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xyXG4gIGlmIChpc05hTihvYmplY3QpKSB7XHJcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XHJcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxyXG4gICAgICByZXR1cm4gJy5uYW4nO1xyXG4gICAgY2FzZSAndXBwZXJjYXNlJzpcclxuICAgICAgcmV0dXJuICcuTkFOJztcclxuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XHJcbiAgICAgIHJldHVybiAnLk5hTic7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xyXG4gICAgc3dpdGNoIChzdHlsZSkge1xyXG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcclxuICAgICAgcmV0dXJuICcuaW5mJztcclxuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XHJcbiAgICAgIHJldHVybiAnLklORic7XHJcbiAgICBjYXNlICdjYW1lbGNhc2UnOlxyXG4gICAgICByZXR1cm4gJy5JbmYnO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcclxuICAgIHN3aXRjaCAoc3R5bGUpIHtcclxuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XHJcbiAgICAgIHJldHVybiAnLS5pbmYnO1xyXG4gICAgY2FzZSAndXBwZXJjYXNlJzpcclxuICAgICAgcmV0dXJuICctLklORic7XHJcbiAgICBjYXNlICdjYW1lbGNhc2UnOlxyXG4gICAgICByZXR1cm4gJy0uSW5mJztcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygxMCk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnc3RyaW5nJyxcclxuICAgIHJlc29sdmVyOiByZXNvbHZlWWFtbEZsb2F0XHJcbiAgfSxcclxuICBkdW1wZXI6IHtcclxuICAgIGtpbmQ6ICdmbG9hdCcsXHJcbiAgICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnLFxyXG4gICAgcmVwcmVzZW50ZXI6IHJlcHJlc2VudFlhbWxGbG9hdFxyXG4gIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnc3RyaW5nJ1xyXG4gIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnYXJyYXknXHJcbiAgfVxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcclxuICBsb2FkZXI6IHtcclxuICAgIGtpbmQ6ICdvYmplY3QnXHJcbiAgfVxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBOSUwgID0gcmVxdWlyZSgnLi4vY29tbW9uJykuTklMO1xyXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcclxuXHJcblxyXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcclxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXHJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcclxuICAnKD86KD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgKyAvLyAuLi5cclxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcclxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXHJcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXHJcbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8pPyQnKTsgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgZXhwbGljaXQqLykge1xyXG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcclxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGE7XHJcblxyXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMob2JqZWN0KTtcclxuXHJcbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XHJcbiAgICByZXR1cm4gTklMO1xyXG4gIH1cclxuXHJcbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XHJcblxyXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcclxuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxyXG4gIGRheSA9ICsobWF0Y2hbM10pO1xyXG5cclxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcclxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XHJcbiAgfVxyXG5cclxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxyXG5cclxuICBob3VyID0gKyhtYXRjaFs0XSk7XHJcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XHJcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XHJcblxyXG4gIGlmIChtYXRjaFs3XSkge1xyXG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcclxuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcclxuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xyXG4gICAgfVxyXG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XHJcbiAgfVxyXG5cclxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxyXG5cclxuICBpZiAobWF0Y2hbOV0pIHtcclxuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XHJcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcclxuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXHJcbiAgICBpZiAoJy0nID09PSBtYXRjaFs5XSkge1xyXG4gICAgICBkZWx0YSA9IC1kZWx0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRhdGEgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcclxuXHJcbiAgaWYgKGRlbHRhKSB7XHJcbiAgICBkYXRhLnNldFRpbWUoZGF0YS5nZXRUaW1lKCkgLSBkZWx0YSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XHJcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ3N0cmluZycsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZVlhbWxUaW1lc3RhbXBcclxuICB9LFxyXG4gIGR1bXBlcjoge1xyXG4gICAga2luZDogJ29iamVjdCcsXHJcbiAgICBpbnN0YW5jZU9mOiBEYXRlLFxyXG4gICAgcmVwcmVzZW50ZXI6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2Uob2JqZWN0IC8qLCBleHBsaWNpdCovKSB7XHJcbiAgcmV0dXJuICc8PCcgPT09IG9iamVjdCA/IG9iamVjdCA6IE5JTDtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ3N0cmluZycsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZVlhbWxNZXJnZVxyXG4gIH1cclxufSk7XHJcbiIsIihmdW5jdGlvbigpey8vIE1vZGlmaWVkIGZyb206XHJcbi8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20va2FuYWthL25vVk5DL2Q4OTBlODY0MGYyMGZiYTMyMTViYTdiZThlMGZmMTQ1YWViOGMxN2MvaW5jbHVkZS9iYXNlNjQuanNcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgTm9kZUJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjsgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24uXHJcbnZhciBjb21tb24gICAgID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XHJcbnZhciBOSUwgICAgICAgID0gY29tbW9uLk5JTDtcclxudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XHJcblxyXG5cclxuXHJcbnZhciBCQVNFNjRfUEFERElORyA9ICc9JztcclxuXHJcbnZhciBCQVNFNjRfQklOVEFCTEUgPSBbXHJcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCA2MiwgLTEsIC0xLCAtMSwgNjMsXHJcbiAgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsIC0xLCAtMSwgLTEsICAwLCAtMSwgLTEsXHJcbiAgLTEsICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsXHJcbiAgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbiAgLTEsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsXHJcbiAgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxLCAtMSwgLTEsIC0xLCAtMSwgLTFcclxuXTtcclxuXHJcbnZhciBCQVNFNjRfQ0hBUlRBQkxFID1cclxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KG9iamVjdCAvKiwgZXhwbGljaXQqLykge1xyXG4gIHZhciB2YWx1ZSwgY29kZSwgaWR4ID0gMCwgcmVzdWx0ID0gW10sIGxlZnRiaXRzLCBsZWZ0ZGF0YTtcclxuXHJcbiAgbGVmdGJpdHMgPSAwOyAvLyBudW1iZXIgb2YgYml0cyBkZWNvZGVkLCBidXQgeWV0IHRvIGJlIGFwcGVuZGVkXHJcbiAgbGVmdGRhdGEgPSAwOyAvLyBiaXRzIGRlY29kZWQsIGJ1dCB5ZXQgdG8gYmUgYXBwZW5kZWRcclxuXHJcbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxyXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgb2JqZWN0Lmxlbmd0aDsgaWR4ICs9IDEpIHtcclxuICAgIGNvZGUgPSBvYmplY3QuY2hhckNvZGVBdChpZHgpO1xyXG4gICAgdmFsdWUgPSBCQVNFNjRfQklOVEFCTEVbY29kZSAmIDB4N0ZdO1xyXG5cclxuICAgIC8vIFNraXAgTEYoTkwpIHx8IENSXHJcbiAgICBpZiAoMHgwQSAhPT0gY29kZSAmJiAweDBEICE9PSBjb2RlKSB7XHJcbiAgICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXHJcbiAgICAgIGlmICgtMSA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gTklMO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb2xsZWN0IGRhdGEgaW50byBsZWZ0ZGF0YSwgdXBkYXRlIGJpdGNvdW50XHJcbiAgICAgIGxlZnRkYXRhID0gKGxlZnRkYXRhIDw8IDYpIHwgdmFsdWU7XHJcbiAgICAgIGxlZnRiaXRzICs9IDY7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBoYXZlIDggb3IgbW9yZSBiaXRzLCBhcHBlbmQgOCBiaXRzIHRvIHRoZSByZXN1bHRcclxuICAgICAgaWYgKGxlZnRiaXRzID49IDgpIHtcclxuICAgICAgICBsZWZ0Yml0cyAtPSA4O1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgaWYgbm90IHBhZGRpbmcuXHJcbiAgICAgICAgaWYgKEJBU0U2NF9QQURESU5HICE9PSBvYmplY3QuY2hhckF0KGlkeCkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKChsZWZ0ZGF0YSA+PiBsZWZ0Yml0cykgJiAweEZGKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlZnRkYXRhICY9ICgxIDw8IGxlZnRiaXRzKSAtIDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCB0aGUgYmFzZTY0IHN0cmluZyB3YXMgY29ycnVwdGVkXHJcbiAgaWYgKGxlZnRiaXRzKSB7XHJcbiAgICByZXR1cm4gTklMO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdCAvKiwgc3R5bGUqLykge1xyXG4gIHZhciByZXN1bHQgPSAnJywgaW5kZXgsIGxlbmd0aCwgcmVzdDtcclxuXHJcbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXHJcbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGggLSAyOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMykge1xyXG4gICAgcmVzdWx0ICs9IEJBU0U2NF9DSEFSVEFCTEVbb2JqZWN0W2luZGV4ICsgMF0gPj4gMl07XHJcbiAgICByZXN1bHQgKz0gQkFTRTY0X0NIQVJUQUJMRVsoKG9iamVjdFtpbmRleCArIDBdICYgMHgwMykgPDwgNCkgKyAob2JqZWN0W2luZGV4ICsgMV0gPj4gNCldO1xyXG4gICAgcmVzdWx0ICs9IEJBU0U2NF9DSEFSVEFCTEVbKChvYmplY3RbaW5kZXggKyAxXSAmIDB4MEYpIDw8IDIpICsgKG9iamVjdFtpbmRleCArIDJdID4+IDYpXTtcclxuICAgIHJlc3VsdCArPSBCQVNFNjRfQ0hBUlRBQkxFW29iamVjdFtpbmRleCArIDJdICYgMHgzRl07XHJcbiAgfVxyXG5cclxuICByZXN0ID0gb2JqZWN0Lmxlbmd0aCAlIDM7XHJcblxyXG4gIC8vIENvbnZlcnQgdGhlIHJlbWFpbmluZyAxIG9yIDIgYnl0ZXMsIHBhZGRpbmcgb3V0IHRvIDQgY2hhcmFjdGVycy5cclxuICBpZiAoMCAhPT0gcmVzdCkge1xyXG4gICAgaW5kZXggPSBvYmplY3QubGVuZ3RoIC0gcmVzdDtcclxuICAgIHJlc3VsdCArPSBCQVNFNjRfQ0hBUlRBQkxFW29iamVjdFtpbmRleCArIDBdID4+IDJdO1xyXG5cclxuICAgIGlmICgyID09PSByZXN0KSB7XHJcbiAgICAgIHJlc3VsdCArPSBCQVNFNjRfQ0hBUlRBQkxFWygob2JqZWN0W2luZGV4ICsgMF0gJiAweDAzKSA8PCA0KSArIChvYmplY3RbaW5kZXggKyAxXSA+PiA0KV07XHJcbiAgICAgIHJlc3VsdCArPSBCQVNFNjRfQ0hBUlRBQkxFWyhvYmplY3RbaW5kZXggKyAxXSAmIDB4MEYpIDw8IDJdO1xyXG4gICAgICByZXN1bHQgKz0gQkFTRTY0X1BBRERJTkc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgKz0gQkFTRTY0X0NIQVJUQUJMRVsob2JqZWN0W2luZGV4ICsgMF0gJiAweDAzKSA8PCA0XTtcclxuICAgICAgcmVzdWx0ICs9IEJBU0U2NF9QQURESU5HICsgQkFTRTY0X1BBRERJTkc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ3N0cmluZycsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZVlhbWxCaW5hcnlcclxuICB9LFxyXG4gIGR1bXBlcjoge1xyXG4gICAga2luZDogJ29iamVjdCcsXHJcbiAgICBpbnN0YW5jZU9mOiBOb2RlQnVmZmVyLFxyXG4gICAgcmVwcmVzZW50ZXI6IHJlcHJlc2VudFlhbWxCaW5hcnlcclxuICB9XHJcbn0pO1xyXG5cbn0pKCkiLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAob2JqZWN0IC8qLCBleHBsaWNpdCovKSB7XHJcbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleTtcclxuXHJcbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcclxuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgIT09IF90b1N0cmluZy5jYWxsKHBhaXIpKSB7XHJcbiAgICAgIHJldHVybiBOSUw7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcclxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XHJcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSB7XHJcbiAgICAgICAgICBwYWlySGFzS2V5ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIE5JTDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBhaXJIYXNLZXkpIHtcclxuICAgICAgcmV0dXJuIE5JTDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoLTEgPT09IG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSkge1xyXG4gICAgICBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gTklMO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnYXJyYXknLFxyXG4gICAgcmVzb2x2ZXI6IHJlc29sdmVZYW1sT21hcFxyXG4gIH1cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgTklMICA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLk5JTDtcclxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XHJcblxyXG5cclxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhvYmplY3QgLyosIGV4cGxpY2l0Ki8pIHtcclxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0O1xyXG5cclxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XHJcblxyXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XHJcblxyXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xyXG4gICAgICByZXR1cm4gTklMO1xyXG4gICAgfVxyXG5cclxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcclxuXHJcbiAgICBpZiAoMSAhPT0ga2V5cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIE5JTDtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnYXJyYXknLFxyXG4gICAgcmVzb2x2ZXI6IHJlc29sdmVZYW1sUGFpcnNcclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIE5JTCAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5OSUw7XHJcbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xyXG5cclxuXHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KG9iamVjdCAvKiwgZXhwbGljaXQqLykge1xyXG4gIHZhciBrZXk7XHJcblxyXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xyXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICBpZiAobnVsbCAhPT0gb2JqZWN0W2tleV0pIHtcclxuICAgICAgICByZXR1cm4gTklMO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ29iamVjdCcsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZVlhbWxTZXRcclxuICB9XHJcbn0pO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQoLypvYmplY3QsIGV4cGxpY2l0Ki8pIHtcclxuICB2YXIgdW5kZWY7XHJcblxyXG4gIHJldHVybiB1bmRlZjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWQoLypvYmplY3QsIGV4cGxpY2l0Ki8pIHtcclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnc3RyaW5nJyxcclxuICAgIHJlc29sdmVyOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZFxyXG4gIH0sXHJcbiAgZHVtcGVyOiB7XHJcbiAgICBraW5kOiAndW5kZWZpbmVkJyxcclxuICAgIHJlcHJlc2VudGVyOiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkXHJcbiAgfVxyXG59KTtcclxuIiwiKGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBOSUwgID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJykuTklMO1xyXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcclxuXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIGV4cGxpY2l0Ki8pIHtcclxuICB2YXIgcmVnZXhwID0gb2JqZWN0LFxyXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKG9iamVjdCksXHJcbiAgICAgIG1vZGlmaWVycztcclxuXHJcbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xyXG4gIGlmICgnLycgPT09IHJlZ2V4cFswXSAmJiB0YWlsICYmIDQgPj0gdGFpbFswXS5sZW5ndGgpIHtcclxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gdGFpbFswXS5sZW5ndGgpO1xyXG4gICAgbW9kaWZpZXJzID0gdGFpbFsxXTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG1vZGlmaWVycyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBOSUw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIHN0eWxlKi8pIHtcclxuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcclxuXHJcbiAgaWYgKG9iamVjdC5nbG9iYWwpIHtcclxuICAgIHJlc3VsdCArPSAnZyc7XHJcbiAgfVxyXG5cclxuICBpZiAob2JqZWN0Lm11bHRpbGluZSkge1xyXG4gICAgcmVzdWx0ICs9ICdtJztcclxuICB9XHJcblxyXG4gIGlmIChvYmplY3QuaWdub3JlQ2FzZSkge1xyXG4gICAgcmVzdWx0ICs9ICdpJztcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9yZWdleHAnLCB7XHJcbiAgbG9hZGVyOiB7XHJcbiAgICBraW5kOiAnc3RyaW5nJyxcclxuICAgIHJlc29sdmVyOiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cFxyXG4gIH0sXHJcbiAgZHVtcGVyOiB7XHJcbiAgICBraW5kOiAnb2JqZWN0JyxcclxuICAgIGluc3RhbmNlT2Y6IFJlZ0V4cCxcclxuICAgIHJlcHJlc2VudGVyOiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwXHJcbiAgfVxyXG59KTtcclxuXG59KSgpIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnktYnJvd3NlcmlmeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIHRlbXBsYXRlcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Rpc3QvdGVtcGxhdGVzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlcy5zaWRlYmFyLmxpLmNvbW1pdCxcclxuXHJcbiAgdGFnTmFtZTogJ2xpJyxcclxuXHJcbiAgY2xhc3NOYW1lOiAnaXRlbScsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ21vdXNlZW50ZXIgLnJlbW92ZWQnOiAnZXZlbnRNZXNzYWdlJyxcclxuICAgICdtb3VzZWxlYXZlIC5yZW1vdmVkJzogJ2V2ZW50TWVzc2FnZScsXHJcbiAgICAnY2xpY2sgLnJlbW92ZWQnOiAncmVzdG9yZSdcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuZmlsZTtcclxuXHJcbiAgICB0aGlzLmJyYW5jaCA9IG9wdGlvbnMuYnJhbmNoO1xyXG4gICAgdGhpcy5maWxlID0gZmlsZTtcclxuICAgIHRoaXMuZmlsZXMgPSBvcHRpb25zLnJlcG8uYnJhbmNoZXMuZmluZFdoZXJlKHsgbmFtZTogb3B0aW9ucy5icmFuY2ggfSkuZmlsZXM7XHJcbiAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG87XHJcbiAgICB0aGlzLnZpZXcgID0gb3B0aW9ucy52aWV3O1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZTtcclxuICAgIHZhciBiaW5hcnkgPSB1dGlsLmlzQmluYXJ5KGZpbGUuZmlsZW5hbWUpO1xyXG5cclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICBicmFuY2g6IHRoaXMuYnJhbmNoLFxyXG4gICAgICBmaWxlOiBmaWxlLFxyXG4gICAgICBtb2RlOiBiaW5hcnkgPyAndHJlZScgOiAnZWRpdCcsXHJcbiAgICAgIHBhdGg6IGJpbmFyeSA/XHJcbiAgICAgICAgdXRpbC5leHRyYWN0RmlsZW5hbWUoZmlsZS5maWxlbmFtZSlbMF0gOiBmaWxlLmZpbGVuYW1lLFxyXG4gICAgICByZXBvOiB0aGlzLnJlcG8udG9KU09OKCksXHJcbiAgICAgIHN0YXR1czogZmlsZS5zdGF0dXNcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRpdGxlID0gZmlsZS5zdGF0dXMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmaWxlLnN0YXR1cy5zbGljZSgxKSArXHJcbiAgICAgICc6ICcgKyBmaWxlLmZpbGVuYW1lO1xyXG5cclxuICAgIHRoaXMuJGVsLmF0dHIoJ3RpdGxlJywgdGl0bGUpXHJcbiAgICAgIC5odG1sKF8udGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgZGF0YSwgeyB2YXJpYWJsZTogJ2RhdGEnIH0pKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBtZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcubWVzc2FnZScpLmh0bWwobWVzc2FnZSk7XHJcbiAgfSxcclxuXHJcbiAgZXZlbnRNZXNzYWdlOiBmdW5jdGlvbihlKSB7XHJcbiAgICBzd2l0Y2goZS50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxyXG4gICAgICAgIHRoaXMubWVzc2FnZSh0KCdzaWRlYmFyLnJlcG8uaGlzdG9yeS5hY3Rpb25zLnJlc3RvcmUnKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxyXG4gICAgICAgIHRoaXMubWVzc2FnZSh0aGlzLmZpbGUuZmlsZW5hbWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBzdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgIC8vIFRPRE86IFNldCBkYXRhLXN0YXRlIGF0dHJpYnV0ZSB0byB0b2dnbGUgaWNvbiBpbiBDU1M/XHJcbiAgICAvLyB0aGlzLiRlbC5hdHRyKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xyXG5cclxuICAgIHZhciAkaWNvbiA9IHRoaXMuJGVsLmZpbmQoJy5pY28nKTtcclxuICAgICRpY29uLnJlbW92ZUNsYXNzKCdhZGRlZCBtb2RpZmllZCByZW5hbWVkIHJlbW92ZWQgc2F2aW5nIGNoZWNrbWFyayBlcnJvcicpXHJcbiAgICAgIC5hZGRDbGFzcyhzdGF0ZSk7XHJcbiAgfSxcclxuXHJcbiAgcmVzdG9yZTogZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHBhdGggPSB0aGlzLmZpbGUuZmlsZW5hbWU7XHJcblxyXG4gICAgLy8gU3Bpbm5pbmcgaWNvblxyXG4gICAgdGhpcy5tZXNzYWdlKHQoJ2FjdGlvbnMucmVzdG9yZS5yZXN0b3JpbmcnKSArICcgJyArIHBhdGgpO1xyXG4gICAgdGhpcy5zdGF0ZSgnc2F2aW5nJyk7XHJcblxyXG4gICAgdGhpcy5maWxlcy5yZXN0b3JlKHRoaXMuZmlsZSwge1xyXG4gICAgICBzdWNjZXNzOiAoZnVuY3Rpb24obW9kZWwsIHJlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSh0KCdhY3Rpb25zLnJlc3RvcmUucmVzdG9yZWQnKSArICc6ICcgKyBwYXRoKTtcclxuICAgICAgICB0aGlzLnN0YXRlKCdjaGVja21hcmsnKTtcclxuXHJcbiAgICAgICAgdGhpcy4kZWxcclxuICAgICAgICAgIC5hdHRyKCd0aXRsZScsIHQoJ2FjdGlvbnMucmVzdG9yZS5yZXN0b3JlZCcpICsgJzogJyArIHRoaXMuZmlsZS5maWxlbmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJ2EnKS5yZW1vdmVDbGFzcygncmVtb3ZlZCcpO1xyXG5cclxuICAgICAgICAvLyBSZS1yZW5kZXIgRmlsZXMgdmlldyBvbmNlIGNvbGxlY3Rpb24gaGFzIHVwZGF0ZWRcclxuICAgICAgICB0aGlzLnZpZXcuZmlsZXMucmVuZGVyKCk7XHJcbiAgICAgIH0pLmJpbmQodGhpcyksXHJcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24obW9kZWwsIHhociwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIExvZyBhY3R1YWwgZXJyb3IgbWVzc2FnZVxyXG4gICAgICAgIHRoaXMubWVzc2FnZShbJ0Vycm9yJywgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHRdLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSgnZXJyb3InKTtcclxuICAgICAgfSkuYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSk7XHJcbiIsImV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCIoZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGg7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICgoaStvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVhaztcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmFzZTY0V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLmZyb21CeXRlQXJyYXkoYnl0ZXMpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB2YXIgdG1wID0gXCJcIjtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmIChieXRlc1tpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgdG1wID0gXCJcIjtcbiAgICB9IGVsc2VcbiAgICAgIHRtcCArPSBcIiVcIiArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJldCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IFNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2U7XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoO1xufVxuXG5cbi8vIEJ1ZmZlclxuXG5mdW5jdGlvbiBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG5cbiAgdmFyIHR5cGU7XG5cbiAgLy8gQXJlIHdlIHNsaWNpbmc/XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKGVuY29kaW5nKTtcbiAgICB0aGlzLnBhcmVudCA9IHN1YmplY3Q7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gICAgc3dpdGNoICh0eXBlID0gdHlwZW9mIHN1YmplY3QpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5IG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBCdWZmZXIucG9vbFNpemUpIHtcbiAgICAgIC8vIEJpZyBidWZmZXIsIGp1c3QgYWxsb2Mgb25lLlxuICAgICAgdGhpcy5wYXJlbnQgPSBuZXcgU2xvd0J1ZmZlcih0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU21hbGwgYnVmZmVyLlxuICAgICAgaWYgKCFwb29sIHx8IHBvb2wubGVuZ3RoIC0gcG9vbC51c2VkIDwgdGhpcy5sZW5ndGgpIGFsbG9jUG9vbCgpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwb29sO1xuICAgICAgdGhpcy5vZmZzZXQgPSBwb29sLnVzZWQ7XG4gICAgICBwb29sLnVzZWQgKz0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5LlxuICAgIGlmIChpc0FycmF5SXNoKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdC5yZWFkVUludDgoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSA9IHN1YmplY3RbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCA4O1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiAwO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAyIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCA4O1xuICAgIGlmIChvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdIDw8IDI0ID4+PiAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBTaWduZWQgaW50ZWdlciB0eXBlcywgeWF5IHRlYW0hIEEgcmVtaW5kZXIgb24gaG93IHR3bydzIGNvbXBsZW1lbnQgYWN0dWFsbHlcbiAqIHdvcmtzLiBUaGUgZmlyc3QgYml0IGlzIHRoZSBzaWduZWQgYml0LCBpLmUuIHRlbGxzIHVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICogbnVtYmVyIHNob3VsZCBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS4gSWYgdGhlIHR3bydzIGNvbXBsZW1lbnQgdmFsdWUgaXNcbiAqIHBvc2l0aXZlLCB0aGVuIHdlJ3JlIGRvbmUsIGFzIGl0J3MgZXF1aXZhbGVudCB0byB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogTm93IGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHlvdSdyZSBwcmV0dHkgbXVjaCBkb25lLCB5b3UgY2FuIGp1c3QgbGV2ZXJhZ2VcbiAqIHRoZSB1bnNpZ25lZCB0cmFuc2xhdGlvbnMgYW5kIHJldHVybiB0aG9zZS4gVW5mb3J0dW5hdGVseSwgbmVnYXRpdmUgbnVtYmVyc1xuICogYXJlbid0IHF1aXRlIHRoYXQgc3RyYWlnaHRmb3J3YXJkLlxuICpcbiAqIEF0IGZpcnN0IGdsYW5jZSwgb25lIG1pZ2h0IGJlIGluY2xpbmVkIHRvIHVzZSB0aGUgdHJhZGl0aW9uYWwgZm9ybXVsYSB0b1xuICogdHJhbnNsYXRlIGJpbmFyeSBudW1iZXJzIGJldHdlZW4gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgaW4gdHdvJ3NcbiAqIGNvbXBsZW1lbnQuIChUaG91Z2ggaXQgZG9lc24ndCBxdWl0ZSB3b3JrIGZvciB0aGUgbW9zdCBuZWdhdGl2ZSB2YWx1ZSlcbiAqIE1haW5seTpcbiAqICAtIGludmVydCBhbGwgdGhlIGJpdHNcbiAqICAtIGFkZCBvbmUgdG8gdGhlIHJlc3VsdFxuICpcbiAqIE9mIGNvdXJzZSwgdGhpcyBkb2Vzbid0IHF1aXRlIHdvcmsgaW4gSmF2YXNjcmlwdC4gVGFrZSBmb3IgZXhhbXBsZSB0aGUgdmFsdWVcbiAqIG9mIC0xMjguIFRoaXMgY291bGQgYmUgcmVwcmVzZW50ZWQgaW4gMTYgYml0cyAoYmlnLWVuZGlhbikgYXMgMHhmZjgwLiBCdXQgb2ZcbiAqIGNvdXJzZSwgSmF2YXNjcmlwdCB3aWxsIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogPiB+MHhmZjgwXG4gKiAtNjU0MDlcbiAqXG4gKiBXaG9oIHRoZXJlLCBKYXZhc2NyaXB0LCB0aGF0J3Mgbm90IHF1aXRlIHJpZ2h0LiBCdXQgd2FpdCwgYWNjb3JkaW5nIHRvXG4gKiBKYXZhc2NyaXB0IHRoYXQncyBwZXJmZWN0bHkgY29ycmVjdC4gV2hlbiBKYXZhc2NyaXB0IGVuZHMgdXAgc2VlaW5nIHRoZVxuICogY29uc3RhbnQgMHhmZjgwLCBpdCBoYXMgbm8gbm90aW9uIHRoYXQgaXQgaXMgYWN0dWFsbHkgYSBzaWduZWQgbnVtYmVyLiBJdFxuICogYXNzdW1lcyB0aGF0IHdlJ3ZlIGlucHV0IHRoZSB1bnNpZ25lZCB2YWx1ZSAweGZmODAuIFRodXMsIHdoZW4gaXQgZG9lcyB0aGVcbiAqIGJpbmFyeSBuZWdhdGlvbiwgaXQgY2FzdHMgaXQgaW50byBhIHNpZ25lZCB2YWx1ZSwgKHBvc2l0aXZlIDB4ZmY4MCkuIFRoZW5cbiAqIHdoZW4geW91IHBlcmZvcm0gYmluYXJ5IG5lZ2F0aW9uIG9uIHRoYXQsIGl0IHR1cm5zIGl0IGludG8gYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB1c2UgdGhlIGZvbGxvd2luZyBnZW5lcmFsIGZvcm11bGEsIHRoYXQgd29ya3NcbiAqIGluIGEgcmF0aGVyIEphdmFzY3JpcHQgZnJpZW5kbHkgd2F5LiBJJ20gZ2xhZCB3ZSBkb24ndCBzdXBwb3J0IHRoaXMga2luZCBvZlxuICogd2VpcmQgbnVtYmVyaW5nIHNjaGVtZSBpbiB0aGUga2VybmVsLlxuICpcbiAqIChCSVQtTUFYIC0gKHVuc2lnbmVkKXZhbCArIDEpICogLTFcbiAqXG4gKiBUaGUgYXN0dXRlIG9ic2VydmVyLCBtYXkgdGhpbmsgdGhhdCB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgOC1iaXQgbnVtYmVyc1xuICogKHJlYWxseSBpdCBpc24ndCBuZWNlc3NhcnkgZm9yIHRoZW0pLiBIb3dldmVyLCB3aGVuIHlvdSBnZXQgMTYtYml0IG51bWJlcnMsXG4gKiB5b3UgZG8uIExldCdzIGdvIGJhY2sgdG8gb3VyIHByaW9yIGV4YW1wbGUgYW5kIHNlZSBob3cgdGhpcyB3aWxsIGxvb2s6XG4gKlxuICogKDB4ZmZmZiAtIDB4ZmY4MCArIDEpICogLTFcbiAqICgweDAwN2YgKyAxKSAqIC0xXG4gKiAoMHgwMDgwKSAqIC0xXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuICB2YXIgbmVnO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIG5lZyA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gJiAweDgwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSk7XG4gIH1cblxuICByZXR1cm4gKCgweGZmIC0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSArIDEpICogLTEpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwMDAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gKHZhbCk7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRmxvYXQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdCBpc1xuICogbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3QgZXhjZWVkIHRoZVxuICogbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICpcbiAqICAgICAgdmFsdWUgICAgICAgICAgIFRoZSBudW1iZXIgdG8gY2hlY2sgZm9yIHZhbGlkaXR5XG4gKlxuICogICAgICBtYXggICAgICAgICAgICAgVGhlIG1heGltdW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50KHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gMCxcbiAgICAgICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZik7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSsrKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkpKSkgPj4+XG4gICAgICAgICAgICAoaXNCaWdFbmRpYW4gPyAxIC0gaSA6IGkpICogODtcbiAgfVxuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSsrKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChpc0JpZ0VuZGlhbiA/IDMgLSBpIDogaSkgKiA4KSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKCkiLCIoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdFxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jztcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0cGxhY2VIb2xkZXJzID0gYjY0LmluZGV4T2YoJz0nKTtcblx0XHRwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIHBsYWNlSG9sZGVycyA6IDA7XG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBbXTsvL25ldyBVaW50OEFycmF5KGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxOCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgMTIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pIDw8IDYpIHwgbG9va3VwLmluZGV4T2YoYjY0W2kgKyAzXSk7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDApID4+IDgpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPj4gNCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTApIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDQpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pID4+IDIpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCA+PiA4KSAmIDB4RkYpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDJdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPT0nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSk7XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAxMF07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPj4gNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCAyKSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz0nO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheTtcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjQ7XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYScpO1xyXG5cclxuXHJcbnZhciBOSUwgID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJykuTklMO1xyXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcclxuXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdCAvKiwgZXhwbGljaXQqLykge1xyXG4gIC8qanNsaW50IGV2aWw6dHJ1ZSovXHJcblxyXG4gIHRyeSB7XHJcbiAgICB2YXIgc291cmNlID0gJygnICsgb2JqZWN0ICsgJyknLFxyXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxyXG4gICAgICAgIHBhcmFtcyA9IFtdLFxyXG4gICAgICAgIGJvZHk7XHJcblxyXG4gICAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxyXG4gICAgICAgIDEgICAgICAgICAgICAgICAgICAgICAhPT0gYXN0LmJvZHkubGVuZ3RoICB8fFxyXG4gICAgICAgICdFeHByZXNzaW9uU3RhdGVtZW50JyAhPT0gYXN0LmJvZHlbMF0udHlwZSB8fFxyXG4gICAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlKSB7XHJcbiAgICAgIHJldHVybiBOSUw7XHJcbiAgICB9XHJcblxyXG4gICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBib2R5ID0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5ib2R5LnJhbmdlO1xyXG5cclxuICAgIC8vIEVzcHJpbWEncyByYW5nZXMgaW5jbHVkZSB0aGUgZmlyc3QgJ3snIGFuZCB0aGUgbGFzdCAnfScgY2hhcmFjdGVycyBvblxyXG4gICAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cclxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSsxLCBib2R5WzFdLTEpKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiBOSUw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdCAvKiwgc3R5bGUqLykge1xyXG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xyXG4gIGxvYWRlcjoge1xyXG4gICAga2luZDogJ3N0cmluZycsXHJcbiAgICByZXNvbHZlcjogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvblxyXG4gIH0sXHJcbiAgZHVtcGVyOiB7XHJcbiAgICBraW5kOiAnZnVuY3Rpb24nLFxyXG4gICAgcmVwcmVzZW50ZXI6IHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbixcclxuICB9XHJcbn0pO1xyXG4iLCIoZnVuY3Rpb24oKXsvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLypqc2xpbnQgYml0d2lzZTp0cnVlIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIGVzcHJpbWE6dHJ1ZSwgZGVmaW5lOnRydWUsIGV4cG9ydHM6dHJ1ZSwgd2luZG93OiB0cnVlLFxudGhyb3dFcnJvcjogdHJ1ZSwgY3JlYXRlTGl0ZXJhbDogdHJ1ZSwgZ2VuZXJhdGVTdGF0ZW1lbnQ6IHRydWUsXG5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uOiB0cnVlLCBwYXJzZUJsb2NrOiB0cnVlLCBwYXJzZUV4cHJlc3Npb246IHRydWUsXG5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb246IHRydWUsIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uOiB0cnVlLFxucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzOiB0cnVlLCBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcjogdHJ1ZSxcbnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbjogdHJ1ZSxcbnBhcnNlU3RhdGVtZW50OiB0cnVlLCBwYXJzZVNvdXJjZUVsZW1lbnQ6IHRydWUgKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoKHJvb3QuZXNwcmltYSA9IHt9KSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBUb2tlbixcbiAgICAgICAgVG9rZW5OYW1lLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgICAgTWVzc2FnZXMsXG4gICAgICAgIFJlZ2V4LFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBleHRyYTtcblxuICAgIFRva2VuID0ge1xuICAgICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgICAgRU9GOiAyLFxuICAgICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgICBLZXl3b3JkOiA0LFxuICAgICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICAgIFN0cmluZ0xpdGVyYWw6IDhcbiAgICB9O1xuXG4gICAgVG9rZW5OYW1lID0ge307XG4gICAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICAgIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICAgIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnXG4gICAgfTtcblxuICAgIFByb3BlcnR5S2luZCA9IHtcbiAgICAgICAgRGF0YTogMSxcbiAgICAgICAgR2V0OiAyLFxuICAgICAgICBTZXQ6IDRcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cbiAgICBNZXNzYWdlcyA9IHtcbiAgICAgICAgVW5leHBlY3RlZFRva2VuOiAgJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAgJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAgJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICAgIEludmFsaWRMSFNJbkZvckluOiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdE1vZGVXaXRoOiAgJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAgJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtTmFtZTogICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcbiAgICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RGVsZXRlOiAgJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXG4gICAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIGRhdGEgYW5kIGFjY2Vzc29yIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICAgIEFjY2Vzc29yR2V0U2V0OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBtdWx0aXBsZSBnZXQvc2V0IGFjY2Vzc29ycyB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAgJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1ByZWZpeDogICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gICAgfTtcblxuICAgIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXgucHkuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNdJyksXG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NjlcXHUwNjZlLVxcdTA2ZDNcXHUwNmQ1LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZThcXHUwNmVhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMC1cXHUwNzRhXFx1MDc0ZC1cXHUwN2IxXFx1MDdjMC1cXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgyZFxcdTA4NDAtXFx1MDg1YlxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTgxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJjLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZVxcdTA5ZDdcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllM1xcdTA5ZTYtXFx1MDlmMVxcdTBhMDEtXFx1MGEwM1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTY2LVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmMtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzYy1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODJcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDBcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZC1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzU4XFx1MGM1OVxcdTBjNjAtXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiYy1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2RlXFx1MGNlMC1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmMVxcdTBjZjJcXHUwZDAyXFx1MGQwM1xcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2QtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZVxcdTBkNTdcXHUwZDYwLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDgyXFx1MGQ4M1xcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUwMS1cXHUwZTNhXFx1MGU0MC1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjlcXHUwZWJiLVxcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZS1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5ZFxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzVkLVxcdTEzNWZcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdkM1xcdTE3ZDdcXHUxN2RjXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExYlxcdTFhMjAtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYTdcXHUxYjAwLVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiZjNcXHUxYzAwLVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzRkLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZjZcXHUxZDAwLVxcdTFkZTZcXHUxZGZjLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ3Zi1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmRlMC1cXHUyZGZmXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyZlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlhXFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY3Zi1cXHVhNjk3XFx1YTY5Zi1cXHVhNmYxXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODI3XFx1YTg0MC1cXHVhODczXFx1YTg4MC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGY3XFx1YThmYlxcdWE5MDAtXFx1YTkyZFxcdWE5MzAtXFx1YTk1M1xcdWE5NjAtXFx1YTk3Y1xcdWE5ODAtXFx1YTljMFxcdWE5Y2YtXFx1YTlkOVxcdWFhMDAtXFx1YWEzNlxcdWFhNDAtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdiXFx1YWE4MC1cXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVmXFx1YWFmMi1cXHVhYWY2XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYxMC1cXHVmZjE5XFx1ZmYyMS1cXHVmZjNhXFx1ZmYzZlxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY10nKVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gICAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gICAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGljZVNvdXJjZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gc291cmNlLnNsaWNlKGZyb20sIHRvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mICdlc3ByaW1hJ1swXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2xpY2VTb3VyY2UgPSBmdW5jdGlvbiBzbGljZUFycmF5U291cmNlKGZyb20sIHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnNsaWNlKGZyb20sIHRvKS5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODknLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnICcpIHx8IChjaCA9PT0gJ1xcdTAwMDknKSB8fCAoY2ggPT09ICdcXHUwMDBCJykgfHxcbiAgICAgICAgICAgIChjaCA9PT0gJ1xcdTAwMEMnKSB8fCAoY2ggPT09ICdcXHUwMEEwJykgfHxcbiAgICAgICAgICAgIChjaC5jaGFyQ29kZUF0KDApID49IDB4MTY4MCAmJlxuICAgICAgICAgICAgICdcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1RkVGRicuaW5kZXhPZihjaCkgPj0gMCk7XG4gICAgfVxuXG4gICAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFx1MjAyOCcgfHwgY2ggPT09ICdcXHUyMDI5Jyk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnJCcpIHx8IChjaCA9PT0gJ18nKSB8fCAoY2ggPT09ICdcXFxcJykgfHxcbiAgICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHxcbiAgICAgICAgICAgICgoY2guY2hhckNvZGVBdCgwKSA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnJCcpIHx8IChjaCA9PT0gJ18nKSB8fCAoY2ggPT09ICdcXFxcJykgfHxcbiAgICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHxcbiAgICAgICAgICAgICgoY2ggPj0gJzAnKSAmJiAoY2ggPD0gJzknKSkgfHxcbiAgICAgICAgICAgICgoY2guY2hhckNvZGVBdCgwKSA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoY2gpKTtcbiAgICB9XG5cbiAgICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuXG4gICAgICAgIC8vIEZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG5cbiAgICAgICAgLy8gU3RyaWN0IE1vZGUgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjEgS2V5d29yZHNcblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZChpZCkge1xuICAgICAgICB2YXIga2V5d29yZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8IChpZCA9PT0gJ3RyeScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fCAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fCAoaWQgPT09ICd0aHJvdycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fCAoaWQgPT09ICdzd2l0Y2gnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgLy8gRnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuICAgICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIEZvciBjb21wYXRpYmxpdHkgdG8gU3BpZGVyTW9ua2V5IGFuZCBFUy5uZXh0XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCk7XG4gICAgfVxuXG4gICAgLy8gNy40IENvbW1lbnRzXG5cbiAgICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNoLCBibG9ja0NvbW1lbnQsIGxpbmVDb21tZW50O1xuXG4gICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobGluZUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydCwgaWQsIHJlc3RvcmU7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSAhPT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkID0gY2g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICBpZCA9ICd1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gIT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlkICs9ICd1JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uS2V5d29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyA3LjguMSBOdWxsIExpdGVyYWxzXG5cbiAgICAgICAgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVsbExpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNy44LjIgQm9vbGVhbiBMaXRlcmFsc1xuXG4gICAgICAgIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLkJvb2xlYW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5JZGVudGlmaWVyLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICAgICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgICAgICAgY2gyLFxuICAgICAgICAgICAgY2gzLFxuICAgICAgICAgICAgY2g0O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuXG4gICAgICAgIGlmIChjaDEgPT09ICc7JyB8fCBjaDEgPT09ICd7JyB8fCBjaDEgPT09ICd9Jykge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJywnIHx8IGNoMSA9PT0gJygnIHx8IGNoMSA9PT0gJyknKSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb3QgKC4pIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG5cbiAgICAgICAgY2gyID0gc291cmNlW2luZGV4ICsgMV07XG4gICAgICAgIGlmIChjaDEgPT09ICcuJyAmJiAhaXNEZWNpbWFsRGlnaXQoY2gyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2VbaW5kZXgrK10sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZWVrIG1vcmUgY2hhcmFjdGVycy5cblxuICAgICAgICBjaDMgPSBzb3VyY2VbaW5kZXggKyAyXTtcbiAgICAgICAgY2g0ID0gc291cmNlW2luZGV4ICsgM107XG5cbiAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKGNoNCA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz0nICYmIGNoMiA9PT0gJz0nICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPT09JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICchJyAmJiBjaDIgPT09ICc9JyAmJiBjaDMgPT09ICc9Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJyE9PScsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnPicgJiYgY2gyID09PSAnPicgJiYgY2gzID09PSAnPicpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc+Pj4nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJzwnICYmIGNoMiA9PT0gJzwnICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPDw9JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc9Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz4+PScsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPD0gPj0gPT0gIT0gKysgLS0gPDwgPj4gJiYgfHxcbiAgICAgICAgLy8gKz0gLT0gKj0gJT0gJj0gfD0gXj0gLz1cblxuICAgICAgICBpZiAoY2gyID09PSAnPScpIHtcbiAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoMSArIGNoMixcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSBjaDIgJiYgKCcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwKSkge1xuICAgICAgICAgICAgaWYgKCcrLTw+JnwnLmluZGV4T2YoY2gyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2gxICsgY2gyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZW1haW5pbmcgMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG5cbiAgICAgICAgaWYgKCdbXTw+Ky0qJSZ8XiF+Pzo9LycuaW5kZXhPZihjaDEpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlW2luZGV4KytdLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBudW1iZXIgPSAnJztcbiAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSAweFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2ggPSAnY2hhcmFjdGVyICcgKyBjaDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gJzxlbmQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlO1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgICB2YXIgc3RyLCBjaCwgc3RhcnQsIHBhdHRlcm4sIGZsYWdzLCB2YWx1ZSwgY2xhc3NNYXJrZXIgPSBmYWxzZSwgcmVzdG9yZSwgdGVybWluYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICBwYXR0ZXJuID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG5cbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0cixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY2gsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW2luZGV4LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgaWYgKGNoID09PSAnXFwnJyB8fCBjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcuJyB8fCBpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpbmRleCA9IGJ1ZmZlci5yYW5nZVsxXTtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBidWZmZXIubGluZU51bWJlcjtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGJ1ZmZlci5saW5lU3RhcnQ7XG4gICAgICAgICAgICB0b2tlbiA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gYWR2YW5jZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2thaGVhZCgpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGJ1ZmZlciA9IGFkdmFuY2UoKTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XSB8fCAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyB0b2tlbi5saW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnJhbmdlWzBdO1xuICAgICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICBlcnJvci5jb2x1bW4gPSB0b2tlbi5yYW5nZVswXSAtIGxpbmVTdGFydCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvclRvbGVyYW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cbiAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuICAgIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiB0b2tlbi52YWx1ZSA9PT0ga2V5d29yZDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBtYXRjaEFzc2lnbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICBvcCA9IHRva2VuLnZhbHVlO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsaW5lO1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0LlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJzsnKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuXG4gICAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fCBleHByLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQXJyYXlFeHByZXNzaW9uLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtLCBmaXJzdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtWzBdLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3QsIE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW0sXG4gICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIGtleSwgaWQsIHBhcmFtO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcblxuICAgICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IEFzc2lnbm1lbnQ6IEdldHRlciBhbmQgU2V0dGVyLlxuXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmICFtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiAnZ2V0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiAhbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzZXQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSBbIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCkgXTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0sIHRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzZXQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGtleTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgcHJvcGVydHksIG5hbWUsIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZztcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtuYW1lXSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBbbmFtZV0gJiBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBbbmFtZV0gfD0ga2luZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwW25hbWVdID0ga2luZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdEV4cHJlc3Npb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBsZXgoKS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwobGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaGlzRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgIH1cblxuICAgIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG5cbiAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICdhcmd1bWVudHMnOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBleHByWydhcmd1bWVudHMnXSA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykgfHwgbWF0Y2goJ1snKSB8fCBtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogcGFyc2VBcmd1bWVudHMoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VDb21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSwgdG9rZW47XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAvLyAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogcGFyc2VVbmFyeUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHBhcnNlVW5hcnlFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnKicpIHx8IG1hdGNoKCcvJykgfHwgbWF0Y2goJyUnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VVbmFyeUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNoaWZ0RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnPDwnKSB8fCBtYXRjaCgnPj4nKSB8fCBtYXRjaCgnPj4+JykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcblxuICAgICAgICBleHByID0gcGFyc2VTaGlmdEV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJzwnKSB8fCBtYXRjaCgnPicpIHx8IG1hdGNoKCc8PScpIHx8IG1hdGNoKCc+PScpIHx8IChwcmV2aW91c0FsbG93SW4gJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB8fCBtYXRjaEtleXdvcmQoJ2luc3RhbmNlb2YnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VTaGlmdEV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCc9PScpIHx8IG1hdGNoKCchPScpIHx8IG1hdGNoKCc9PT0nKSB8fCBtYXRjaCgnIT09JykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnJicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcmJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCdeJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ14nLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCd8JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ3wnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjExIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJyYmJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTG9naWNhbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcmJicsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByID0gcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnfHwnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ3x8JyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQ7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB0ZXN0OiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xMyBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaEFzc2lnbigpKSB7XG4gICAgICAgICAgICAvLyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMTEuMTMuMVxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbIGV4cHIgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2s7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZVN0YXRlbWVudExpc3QoKTtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogYmxvY2tcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4yIFZhcmlhYmxlIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpLFxuICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpbml0OiBpbml0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihraW5kKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IHdoaWxlIChpbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAga2luZDogJ3ZhcidcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBraW5kIG1heSBiZSBgY29uc3RgIG9yIGBsZXRgXG4gICAgLy8gQm90aCBhcmUgZXhwZXJpbWVudGFsIGFuZCBub3QgaW4gdGhlIHNwZWNpZmljYXRpb24geWV0LlxuICAgIC8vIHNlZSBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmNvbnN0XG4gICAgLy8gYW5kIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6bGV0XG4gICAgZnVuY3Rpb24gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKGtpbmQpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKGtpbmQpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Qoa2luZCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAga2luZDoga2luZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KCkge1xuICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkVtcHR5U3RhdGVtZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuNSBJZiBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZWxzZScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZlN0YXRlbWVudCxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgYWx0ZXJuYXRlOiBhbHRlcm5hdGVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi42IEl0ZXJhdGlvbiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBib2R5LCB0ZXN0LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkbycpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguV2hpbGVTdGF0ZW1lbnQsXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCksXG4gICAgICAgICAgICBraW5kOiB0b2tlbi52YWx1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgaW5pdCwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwgYm9keSwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xlZnRIYW5kU2lkZShpbml0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZvckluU3RhdGVtZW50LFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBlYWNoOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjcgVGhlIGNvbnRpbnVlIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsYWJlbCA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gZm9ybTogJ2NvbnRpbnVlOycuXG4gICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAnOycpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Db250aW51ZVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBsYWJlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdicmVhazsnLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJzsnKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQnJlYWtTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlW2luZGV4ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlJldHVyblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG9iamVjdCwgYm9keTtcblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBvYmplY3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LldpdGhTdGF0ZW1lbnQsXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LFxuICAgICAgICAgICAgY29uc2VxdWVudCA9IFtdLFxuICAgICAgICAgICAgc3RhdGVtZW50O1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IG1hdGNoS2V5d29yZCgnY2FzZScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zZXF1ZW50LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoQ2FzZSxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnQsXG4gICAgICAgICAgICAgICAgY2FzZXM6IGNhc2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSB0cnVlO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICAgICBkaXNjcmltaW5hbnQ6IGRpc2NyaW1pbmFudCxcbiAgICAgICAgICAgIGNhc2VzOiBjYXNlc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjEzIFRoZSB0aHJvdyBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaHJvd1N0YXRlbWVudCxcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjE0IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW07XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIC8vIDEyLjE0LjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYXRjaENsYXVzZSxcbiAgICAgICAgICAgIHBhcmFtOiBwYXJhbSxcbiAgICAgICAgICAgIGJvZHk6IHBhcnNlQmxvY2soKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgYmxvY2ssIGhhbmRsZXJzID0gW10sIGZpbmFsaXplciA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChwYXJzZUNhdGNoQ2xhdXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDAgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlRyeVN0YXRlbWVudCxcbiAgICAgICAgICAgIGJsb2NrOiBibG9jayxcbiAgICAgICAgICAgIGd1YXJkZWRIYW5kbGVyczogW10sXG4gICAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnMsXG4gICAgICAgICAgICBmaW5hbGl6ZXI6IGZpbmFsaXplclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjE1IFRoZSBkZWJ1Z2dlciBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgbGFiZWxlZEJvZHk7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFbXB0eVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2soKTtcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29udGludWVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZG8nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAndHJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAvLyAxMi4xMiBMYWJlbGxlZCBTdGF0ZW1lbnRzXG4gICAgICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBleHByLm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYWJlbFNldFtleHByLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5sYWJlbFNldFtleHByLm5hbWVdO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MYWJlbGVkU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBleHByLFxuICAgICAgICAgICAgICAgIGJvZHk6IGxhYmVsZWRCb2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMyBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0gKyAxLCB0b2tlbi5yYW5nZVsxXSAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbGRMYWJlbFNldCA9IHN0YXRlLmxhYmVsU2V0O1xuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBvbGRJbkZ1bmN0aW9uQm9keSA9IHN0YXRlLmluRnVuY3Rpb25Cb2R5O1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0ge307XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSBvbGRMYWJlbFNldDtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSBvbGRJbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogc291cmNlRWxlbWVudHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpZCwgcGFyYW0sIHBhcmFtcyA9IFtdLCBib2R5LCB0b2tlbiwgc3RyaWN0ZWQsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgcHJldmlvdXNTdHJpY3QsIHBhcmFtU2V0O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtU2V0LCB0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1TZXRbcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBwYXJhbSwgcGFyYW1zID0gW10sIGJvZHksIHByZXZpb3VzU3RyaWN0LCBwYXJhbVNldDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtU2V0LCB0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1TZXRbcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxNCBQcm9ncmFtXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24odG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNsaWNlU291cmNlKHRva2VuLnJhbmdlWzBdICsgMSwgdG9rZW4ucmFuZ2VbMV0gLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICAgIHZhciBwcm9ncmFtO1xuICAgICAgICBzdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9ncmFtLFxuICAgICAgICAgICAgYm9keTogcGFyc2VTb3VyY2VFbGVtZW50cygpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBuZWVkZWQgb25seSB3aGVuIHRoZSBvcHRpb24gdG8gcHJlc2VydmVcbiAgICAvLyB0aGUgY29tbWVudHMgaXMgYWN0aXZlLlxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudCh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbG9jKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcblxuICAgICAgICAvLyBCZWNhdXNlIHRoZSB3YXkgdGhlIGFjdHVhbCB0b2tlbiBpcyBzY2FubmVkLCBvZnRlbiB0aGUgY29tbWVudHNcbiAgICAgICAgLy8gKGlmIGFueSkgYXJlIHNraXBwZWQgdHdpY2UgZHVyaW5nIHRoZSBsZXhpY2FsIGFuYWx5c2lzLlxuICAgICAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIHNraXAgYWRkaW5nIGEgY29tbWVudCBpZiB0aGUgY29tbWVudCBhcnJheSBhbHJlYWR5XG4gICAgICAgIC8vIGhhbmRsZWQgaXQuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHNbZXh0cmEuY29tbWVudHMubGVuZ3RoIC0gMV0ucmFuZ2VbMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGVuZF0sXG4gICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQsIGNoLCBsb2MsIHN0YXJ0LCBibG9ja0NvbW1lbnQsIGxpbmVDb21tZW50O1xuXG4gICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgYmxvY2tDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChsaW5lQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXggLSAxLCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbGVuZ3RoIC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgbGVuZ3RoLCBsb2MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9ja0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9ICdcXHJcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnN1YnN0cigwLCBjb21tZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnQmxvY2snLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyQ29tbWVudExvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIGNvbW1lbnQsIGNvbW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLmNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLmNvbW1lbnRzW2ldO1xuICAgICAgICAgICAgY29tbWVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS5jb21tZW50cyA9IGNvbW1lbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIHRva2VuLCByYW5nZSwgdmFsdWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0b2tlbiA9IGV4dHJhLmFkdmFuY2UoKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgcmFuZ2UgPSBbdG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIHZhbHVlID0gc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2V4ID0gZXh0cmEuc2NhblJlZ0V4cCgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGl0ZXJhbCh0b2tlbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYXdMaXRlcmFsKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgIHJhdzogc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uTWFya2VyKCkge1xuICAgICAgICB2YXIgbWFya2VyID0ge307XG5cbiAgICAgICAgbWFya2VyLnJhbmdlID0gW2luZGV4LCBpbmRleF07XG4gICAgICAgIG1hcmtlci5sb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1hcmtlci5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlWzFdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLmxvYy5lbmQubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmxvYy5lbmQuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgbWFya2VyLmFwcGx5R3JvdXAgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ncm91cFJhbmdlID0gW3RoaXMucmFuZ2VbMF0sIHRoaXMucmFuZ2VbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JvdXBMb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5lbmQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sb2MuZW5kLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtYXJrZXIuYXBwbHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFt0aGlzLnJhbmdlWzBdLCB0aGlzLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubG9jLmVuZC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxvYy5lbmQuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIGV4cHI7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgbWFya2VyLmFwcGx5R3JvdXAoZXhwcik7XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBleHByO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VDb21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkoZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFja0xlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIGV4cHI7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLicpIHx8IG1hdGNoKCdbJykgfHwgbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZTogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IHBhcnNlQXJndW1lbnRzKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkoZXhwcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShleHByKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyR3JvdXAobm9kZSkge1xuICAgICAgICB2YXIgbiwgaSwgZW50cnk7XG5cbiAgICAgICAgbiA9IChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG5vZGUpID09PSAnW29iamVjdCBBcnJheV0nKSA/IFtdIDoge307XG4gICAgICAgIGZvciAoaSBpbiBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAnZ3JvdXBSYW5nZScgJiYgaSAhPT0gJ2dyb3VwTG9jJykge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbm9kZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgPT09IG51bGwgfHwgdHlwZW9mIGVudHJ5ICE9PSAnb2JqZWN0JyB8fCBlbnRyeSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBuW2ldID0gZW50cnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbltpXSA9IGZpbHRlckdyb3VwKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcFRyYWNraW5nRnVuY3Rpb24ocmFuZ2UsIGxvYykge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0JpbmFyeShub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQsIGVuZDtcblxuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeShub2RlLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KG5vZGUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeShub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdChub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5ncm91cFJhbmdlIHx8IG5vZGUucmlnaHQuZ3JvdXBSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBub2RlLmxlZnQuZ3JvdXBSYW5nZSA/IG5vZGUubGVmdC5ncm91cFJhbmdlWzBdIDogbm9kZS5sZWZ0LnJhbmdlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbm9kZS5yaWdodC5ncm91cFJhbmdlID8gbm9kZS5yaWdodC5ncm91cFJhbmdlWzFdIDogbm9kZS5yaWdodC5yYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbc3RhcnQsIGVuZF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUucmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGUubGVmdC5yYW5nZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IG5vZGUucmlnaHQucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5ncm91cExvYyB8fCBub2RlLnJpZ2h0Lmdyb3VwTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGUubGVmdC5ncm91cExvYyA/IG5vZGUubGVmdC5ncm91cExvYy5zdGFydCA6IG5vZGUubGVmdC5sb2Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBub2RlLnJpZ2h0Lmdyb3VwTG9jID8gbm9kZS5yaWdodC5ncm91cExvYy5lbmQgOiBub2RlLnJpZ2h0LmxvYy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUubG9jID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUubGVmdC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLnJpZ2h0LmxvYy5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlciwgbm9kZTtcblxuICAgICAgICAgICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIHR5cGVvZiBub2RlLnJhbmdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvYyAmJiB0eXBlb2Ygbm9kZS5sb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoKCkge1xuXG4gICAgICAgIHZhciB3cmFwVHJhY2tpbmc7XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBleHRyYS5za2lwQ29tbWVudCA9IHNraXBDb21tZW50O1xuICAgICAgICAgICAgc2tpcENvbW1lbnQgPSBzY2FuQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5yYXcpIHtcbiAgICAgICAgICAgIGV4dHJhLmNyZWF0ZUxpdGVyYWwgPSBjcmVhdGVMaXRlcmFsO1xuICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbCA9IGNyZWF0ZVJhd0xpdGVyYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmFuZ2UgfHwgZXh0cmEubG9jKSB7XG5cbiAgICAgICAgICAgIGV4dHJhLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gcGFyc2VHcm91cEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGw7XG4gICAgICAgICAgICBwYXJzZUdyb3VwRXhwcmVzc2lvbiA9IHRyYWNrR3JvdXBFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsO1xuXG4gICAgICAgICAgICB3cmFwVHJhY2tpbmcgPSB3cmFwVHJhY2tpbmdGdW5jdGlvbihleHRyYS5yYW5nZSwgZXh0cmEubG9jKTtcblxuICAgICAgICAgICAgZXh0cmEucGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24gPSBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbiA9IHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24gPSBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uID0gcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQmxvY2sgPSBwYXJzZUJsb2NrO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VDYXRjaENsYXVzZSA9IHBhcnNlQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICBleHRyYS5wYXJzZUNvbXB1dGVkTWVtYmVyID0gcGFyc2VDb21wdXRlZE1lbWJlcjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24gPSBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbiA9IHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VFeHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uID0gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24gPSBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uID0gcGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gPSBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTmV3RXhwcmVzc2lvbiA9IHBhcnNlTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5O1xuICAgICAgICAgICAgZXh0cmEucGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXk7XG4gICAgICAgICAgICBleHRyYS5wYXJzZVBvc3RmaXhFeHByZXNzaW9uID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VQcm9ncmFtID0gcGFyc2VQcm9ncmFtO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VQcm9wZXJ0eUZ1bmN0aW9uID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbiA9IHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50O1xuICAgICAgICAgICAgZXh0cmEucGFyc2VTaGlmdEV4cHJlc3Npb24gPSBwYXJzZVNoaWZ0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlU3dpdGNoQ2FzZSA9IHBhcnNlU3dpdGNoQ2FzZTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlVW5hcnlFeHByZXNzaW9uID0gcGFyc2VVbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyO1xuXG4gICAgICAgICAgICBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUFkZGl0aXZlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQmxvY2sgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VCbG9jayk7XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcbiAgICAgICAgICAgIHBhcnNlQ2F0Y2hDbGF1c2UgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VDYXRjaENsYXVzZSk7XG4gICAgICAgICAgICBwYXJzZUNvbXB1dGVkTWVtYmVyID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ29tcHV0ZWRNZW1iZXIpO1xuICAgICAgICAgICAgcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VDb25zdExldERlY2xhcmF0aW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTmV3RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU5ld0V4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VOb25Db21wdXRlZFByb3BlcnR5ID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSk7XG4gICAgICAgICAgICBwYXJzZU9iamVjdFByb3BlcnR5ID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHkpO1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU9iamVjdFByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VQb3N0Zml4RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVByaW1hcnlFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VQcm9ncmFtID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUHJvZ3JhbSk7XG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5RnVuY3Rpb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVN0YXRlbWVudCA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVN0YXRlbWVudCk7XG4gICAgICAgICAgICBwYXJzZVNoaWZ0RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVNoaWZ0RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVN3aXRjaENhc2UgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VTd2l0Y2hDYXNlKTtcbiAgICAgICAgICAgIHBhcnNlVW5hcnlFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5hZHZhbmNlID0gYWR2YW5jZTtcbiAgICAgICAgICAgIGV4dHJhLnNjYW5SZWdFeHAgPSBzY2FuUmVnRXhwO1xuXG4gICAgICAgICAgICBhZHZhbmNlID0gY29sbGVjdFRva2VuO1xuICAgICAgICAgICAgc2NhblJlZ0V4cCA9IGNvbGxlY3RSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucGF0Y2goKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEuc2tpcENvbW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNraXBDb21tZW50ID0gZXh0cmEuc2tpcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmF3KSB7XG4gICAgICAgICAgICBjcmVhdGVMaXRlcmFsID0gZXh0cmEuY3JlYXRlTGl0ZXJhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5yYW5nZSB8fCBleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uID0gZXh0cmEucGFyc2VBZGRpdGl2ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gZXh0cmEucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uID0gZXh0cmEucGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUJsb2NrID0gZXh0cmEucGFyc2VCbG9jaztcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGV4dHJhLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cztcbiAgICAgICAgICAgIHBhcnNlQ2F0Y2hDbGF1c2UgPSBleHRyYS5wYXJzZUNhdGNoQ2xhdXNlO1xuICAgICAgICAgICAgcGFyc2VDb21wdXRlZE1lbWJlciA9IGV4dHJhLnBhcnNlQ29tcHV0ZWRNZW1iZXI7XG4gICAgICAgICAgICBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VDb25zdExldERlY2xhcmF0aW9uID0gZXh0cmEucGFyc2VDb25zdExldERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgcGFyc2VFcXVhbGl0eUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZXh0cmEucGFyc2VGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUdyb3VwRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlR3JvdXBFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsO1xuICAgICAgICAgICAgcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTG9naWNhbEFOREV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VOZXdFeHByZXNzaW9uID0gZXh0cmEucGFyc2VOZXdFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VOb25Db21wdXRlZFByb3BlcnR5ID0gZXh0cmEucGFyc2VOb25Db21wdXRlZFByb3BlcnR5O1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eSA9IGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHk7XG4gICAgICAgICAgICBwYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZXh0cmEucGFyc2VPYmplY3RQcm9wZXJ0eUtleTtcbiAgICAgICAgICAgIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVByaW1hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VQb3N0Zml4RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlUG9zdGZpeEV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZVByb2dyYW0gPSBleHRyYS5wYXJzZVByb2dyYW07XG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5RnVuY3Rpb24gPSBleHRyYS5wYXJzZVByb3BlcnR5RnVuY3Rpb247XG4gICAgICAgICAgICBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uID0gZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlU3RhdGVtZW50ID0gZXh0cmEucGFyc2VTdGF0ZW1lbnQ7XG4gICAgICAgICAgICBwYXJzZVNoaWZ0RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlU2hpZnRFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VTd2l0Y2hDYXNlID0gZXh0cmEucGFyc2VTd2l0Y2hDYXNlO1xuICAgICAgICAgICAgcGFyc2VVbmFyeUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZXh0cmEucGFyc2VWYXJpYWJsZUlkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnNjYW5SZWdFeHAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFkdmFuY2UgPSBleHRyYS5hZHZhbmNlO1xuICAgICAgICAgICAgc2NhblJlZ0V4cCA9IGV4dHJhLnNjYW5SZWdFeHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpblN3aXRjaDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcbiAgICAgICAgICAgIGV4dHJhLnJhdyA9ICh0eXBlb2Ygb3B0aW9ucy5yYXcgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYXc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmlyc3QgdG8gY29udmVydCB0byBhIHN0cmluZy4gVGhpcyBpcyBnb29kIGFzIGZhc3QgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGZvciBvbGQgSUUgd2hpY2ggdW5kZXJzdGFuZHMgc3RyaW5nIGluZGV4aW5nIGZvciBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscyBvbmx5IGFuZCBub3QgZm9yIHN0cmluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gY29kZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgYWNjZXNzaW5nIHRoZSBjaGFyYWN0ZXJzIHZpYSBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc3RyaW5nVG9BcnJheShjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXRjaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5jb21tZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb21tZW50TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS50b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSB8fCBleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmJvZHkgPSBmaWx0ZXJHcm91cChwcm9ncmFtLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdW5wYXRjaCgpO1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCBwYWNrYWdlLmpzb24uXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gJzEuMC40JztcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuXG59KSgpIl19
;